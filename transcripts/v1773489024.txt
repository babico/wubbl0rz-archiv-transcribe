Ich bin froh.
Ich bin froh, ich bin froh, ich bin froh.
Ich bin froh, ich bin froh.
Ich bin froh, ich bin froh.
Ich bin froh, ich bin froh.
Ich bin froh, ich bin froh.
Ich bin froh.
Ich bin froh, ich bin froh.
Ich bin froh.
Ich bin froh, ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh, ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Ich bin froh.
Alter!
Ich will keine fucking Class Library, man!
Ach, kann man das nicht machen, oder wie?
Ah, das ist ja doof.
Warum kann ich in die Dornett-Version nicht runtergehen?
Warum geht das nicht? Ich mein, ich kann sagen, Unload.
Wo ist denn der Unload-Knopf überhaupt jetzt?
Unload-Project.
So, ich kann da in Dornett 7 reinschreiben. So, easy.
Oh, es funktioniert jetzt auch.
Äh, Ligada kann ich hier gleich was zu sagen.
Eigentlich bin ich hundertprozentig sicher, bin.
So. Guck mal, wie groß das ist.
Okay, das ist schon ein Unterschied, guck mal.
Mit der alten Dornett-Version ist es 5,6 MB für ein publisches Hello World Kurs.
Und mit der neuen ist es 1,9.
Das ist tatsächlich echt eine gute Verbesserung.
Da kann man nichts sagen.
So, also, ich bin nicht so schlapp.
Ich sehe unsere Pipeline, die mir fehlt.
Dornett Restore, aber auch Dornett Bild.
Mit Restore nicht in Bild verwenden.
Doch, die Sache ist plus die.
Ich habe keine Ahnung, warum die Leute überhaupt noch Bild und Restore verwenden.
Die können einfach Publish verwenden.
Das macht beides in einem.
Also, keine Ahnung, warum das über...
Ich weiß, sogar das offizielle Dornett-Docker-File-Example macht das mit Restore.
Vielleicht fürs Caching von den Containern.
Das kann natürlich sein, dass wenn sich der Source-Code ändern tut es nicht.
Jedes Mal...
Also, du kannst ja, wenn du ein Docker-File hast,
dann merkt das sicher, an welchem Step du was geändert hast
und macht dann ab da weiter.
So, wenn du quasi Publish, also quasi den Restore
für die Dependencies und die Nougat-Packages und alles,
wenn du das in einem Befehl hast mit Publish und in Bild
und du änderst dein Bildbefehl was,
dann muss er das alles wieder machen.
Also, vielleicht ist das aufzusplitten in Restore
und dann in Publish hinterher oder in Bild,
ist vielleicht, dass das Docker-Caching das besser hinbekommt.
Aber ansonsten kannst du einfach .NET Publish verwenden.
Das macht alles in einem.
Also, eigentlich braucht man das gar nicht.
Eigentlich overrated, outdated, jebaited.
So, alles klar.
Dann können wir jetzt hier anfangen.
Ich habe die .NET-Version wieder hochgestellt.
Gucken wir mal, ob das wieder funktioniert.
.NET Publish.
Okay, funktioniert.
So, und jetzt passt mal auf, was wir heute probieren werden.
Ich bin mir nicht sicher,
ob wir das überhaupt auf die Reihe bekommen.
Ich muss gerade erst mal schnell KVM installieren.
Und zwar, man kann ja auf der Lidungskiste,
ja, ja, ich weiß, es läuft gerade nichts,
man kann ja auf der Lidungskiste lokal VMs benutzen.
So, und ich wollte schon immer mal gucken,
wie man VMs erstellt über die Linux VM-Erstellungs-API.
Das hat nicht wirklich so viel Sinn.
Ich habe mir letztens so ein Tool zusammengescriptet,
aber wir können das ja mal über die API machen.
Und das Gute ist, das eignet sich dementsprechend auch wunderbar
als Compiler-Testprojekt,
weil ich muss Low-Level-Kram verwenden
plus ein paar etwas advancedere Libraries.
Ich muss mir jetzt aber erst mal LibWirt und QEMO
und den ganzen Shit erstellen.
Gucken wir mal, ob das überhaupt funktioniert,
damit ich da drauf zugreifen kann.
Okay.
LibWirt gibt es nicht.
Na gut, nein, deswegen muss ich das noch starten.
System CTL, enable, LibWirt.
Not exist, okay.
Start.
Sag mal, warum ist denn das so?
So lahm eine Tastatur?
Ah, viel besser.
Okay, haben wir es jetzt laufen?
Haben wir KVM laufen?
Nee, wir haben kein KVM.
Oh fuck, ich habe schon lange kein KVM mehr installiert.
KVM?
Okay, KVM ist da.
Ach du Kacke.
Arch KVM install.
Das müssen wir jetzt mal auf die Schnelle gucken.
Check support.
Okay, kann meine CPU in der VM los?
Nein.
Das heißt, ich muss meine VM erst mal wieder ausschalten
und in den Settings Nested Virtualisierung einschalten.
Sonst wird das nämlich nicht funktionieren.
Nested Virtualisierung, okay.
Also, wenn ich eine VM in einer VM starten will,
dann geht das nicht.
Das geht nur, wenn man Nested Virtualisierung einschaltet.
Also, falls ihr irgendwann mal Probleme habt
und euch fragt, warum ihr in eurer VM keine VM starten könnt,
dann liegt das höchstwahrscheinlich daran,
weil keine Nested Virtualisierung eingeschaltet ist.
Normalerweise braucht es ja auch niemand.
Habt ihr schon mal VMs in einer VM laufen lassen?
Und wenn ja, warum?
Okay, Virtualisierung ist in Erbel.
Proxmox Test Setup, ja, verstehe.
Dafür ist es sinnvoll, auf jeden Fall.
WSL, ja, gut, WSL.
Moment, WSL ist doch keine Nested Virtualisierung.
Es sei denn, du hast Windows in der VM und dann WSL.
Zu schauen, wie scheiße die Performance ist.
Die Performance ist nicht gut, aber so unter ihr die Scheiße,
dass es unbenutzbar ist, ist es gar nicht.
Es geht sogar halbwegs.
So, geht mein KVM denn jetzt?
Was ist denn das hier, Mensch, ey?
KVM.
No Hypervisor Options found, okay.
Hab ich kein QEMO?
Da muss ich mal kurz gucken, wie installiert man den ganzen Campbell.
Nested, ja, okay, war alles klar.
Nein, nein, nein, nein.
Moment, was muss ich denn installieren?
QEMO, KVM?
Hm, wie heißt denn das Package, was ich da...
QEMO-Full vielleicht gibt es?
Okay, ja, ja, hauptsächlich.
Okay, ich habe es.
Gibt es?
Okay, ja, ja, hau drauf, gib ihm.
So, hoffen wir mal, dass ich jetzt ein funktionierendes...
Ah, jetzt funktioniert es, okay.
Jetzt kann ich VMS starten, alles gut.
Yo, dann muss ich mich wahrscheinlich noch in die LibVirt-Gruppe packen.
User and LibVirt, glaube ich zumindest, sonst darf ich von mir aus nicht drauf zugreifen.
Wobei, brauche ich das überhaupt?
Add Connections, User Session.
Nope.
Okay.
Ach ja.
Okay, das testen wir jetzt mal.
Debian Cloud Image Download, wir gucken mal, ob die VM in der VM funktioniert.
Bullseye Latest, klingt eigentlich ganz gut.
AMD 64, QCOW Image, genau das brauchen wir.
Debian 1 Generic, Cloud Generic, wunderbar, gib ihm.
So, schauen wir mal, ob meine VM-Lokal funktioniert.
Mit dem Virt-Manager, wie gesagt, das, was ich jetzt mit dem Virt-Manager mache,
das will ich über die KVM bzw. die LibVirt-API machen.
Das muss man über irgendwelche C-APIs aufrufen, das wird ganz abartig gleich.
Aber dann sehen wir auch, ob die Kompilierung von dort net was taugt, wenn das alles funktioniert.
Falls ich überhaupt was auf die Reihe kriege.
So, Local, Install Media, boah, wie geht denn der Kram?
Ich benutze das eigentlich nie.
Download, Debian, Select, ja, Linux, Linux.
2020, perfekt, das wollte ich schon immer haben.
2, 1 CPU reicht, 1024 MB reicht auch.
Storage, ja, perfekt, wunderbar.
Alles klar, Finish.
Okay, funktioniert. Funktioniert.
Also, ich meine, die VM bootet nicht, aber die VM startet, das reicht mir eigentlich schon.
Das ist kein easy, ISO, du hast recht.
Das ist kein ISO, das ist ein komplettes, komplettes VM-Image.
Okay, aber die VM startet, das ist das Eigentliche, was ich haben will.
Delete, funktioniert, gut.
So, und jetzt gucken wir mal, wie wir das über die API machen können.
Das wird was.
Das, das, das wird was.
Lib wird API.
Documentation, oh, jetzt wird es abartig.
API-Reference, exzellent, exzellent.
Okay.
Domain, aus irgendwelchen Gründen nennt sich eine VM in KVM Domain, ich weiß auch nicht warum.
Es hat nichts mit DNS und so.
Ach du Scheiße.
Alter.
MonkaW, okay, ich gebe zu, ich habe im Vorfeld schon ein bisschen gespickt.
Ich weiß ein bisschen, nach was ich gucken muss.
Ich muss nach Connection gucken.
Äh, nee, nach Connect muss ich gucken.
Wenn ich das, wenn ich das richtige Erinnerung habe.
Connect, hier, Connect, Connect.
Aha, nope, wird nicht connected.
Wo ist das denn?
Also, das funktioniert folgendermaßen, eine VM über die, über die Linux-API anzulegen.
Man muss als erstes Connect zu Lib wird.
Lib wird ist dieses Ding, was der Wirt-Manager auch verwendet.
Also keiner spricht direkt KVM.
Die sprechen alle über diese API-Schnittstelle damit.
Man muss sich zu Lib wird connecten.
Am Ende muss man die Connection wieder closen.
Dann muss man Create VM machen, wie auch immer.
Dann muss man aufs Netzwerk warten, dass das Ganze funktioniert.
Und dann ist gut, dann ist die VM wieder da.
GitHub Code-Pilot, frag mal, frag mal.
Okay, Connect.
Also, wie connecten wir uns zu Lib wird?
Das funktioniert so wie hier.
Man muss dann hier irgendwie so eine Connection angeben.
QEMO//Session.
Und dann funktioniert es.
Aber ich muss jetzt erstmal die richtigen APIs finden.
Das heißt auf jeden Fall Connect.
So viel habe ich im Vorfeld schon rausbekommen.
Obvious.
Ja, ich bei Cringe wäre das nicht weiß, dass es QEMO//Session ist.
Wo könnte das denn hier drinnen stehen?
Erstellst du gerade eine Linux VM in eine Linux VM?
Richtig.
Wo ist das Problem?
Das ist dann zwar nicht mal blazingly fast, aber schnell genug.
Host, Host muss ich bestimmt gucken.
Connect.
Hier, das sieht doch gut aus.
Das sieht doch gut aus.
Achtung hier.
Guck mal, da haben wir es doch.
Wir connect.
Hört sich ein bisschen, wir connect.
Das hört sich ein bisschen an wie...
Jetzt fehlen uns bloß noch Carlos Matos.
Ach, es geht ja noch weiter.
Carlos Matos vom New York City New York.
Hier, wir connect open.
Das brauchen wir.
Alles klar.
IQ Shit.
Wir connect open.
So, jetzt wird es spannend Leute.
Native C Funktion aus Dornett aufrufen.
Also, jetzt...
Okay, erstmal allow unsafe code, weil ohne unsafe code würde das auf jeden Fall nicht
funktionieren.
DLL import.
So, jetzt muss ich abgucken.
Ich muss abgucken, weil ich habe mir im Vorfeld schon ein Beispiel angeguckt und habe mir
das ins Notepad auf dem anderen Bildschirm kopiert, weil sonst pflege ich da nicht durch,
wie das aussehen muss, der Aufruf.
So muss das aussehen.
Sekunde.
Ja, so muss das aussehen.
Ha, habe ich schon rausgesucht.
Guck mal.
So muss das aussehen.
Obviously muss das so aussehen.
Ja.
Also, cringe Schwimm nicht klar ist, dass das so aussehen muss.
So, und jetzt müssen wir nur noch diese C Funktion irgendwie übersetzen in eine gültige
C Sharp Funktionssignatur.
Also, das Ganze muss schon mal in extra Klasse rein.
Es gibt wird C Sharp Bindings.
Ne, die gibt es nicht.
Habe ich im Vorfeld geguckt, gibt es keine gescheiten.
Es gibt offizielle Bindings, die sind nur für .NET Framework.
Wer auch immer seriously mit .NET Framework von Windows aus Libreed verwenden will und
der Rest ist outdated und hat so Sachen wie Netzwerkinfos und so nicht drinne.
Es gibt keine gescheiten Libreed Bindings.
Leider, sonst hätte ich die tatsächlich genommen.
Okay, wir connect pointer return there.
Das ist mir doch egal.
Was ist der return?
So, wir connect open.
Das gibt einen String.
Das sollte der richtig hinbekommen.
Public, Public Class Interop.
DLL Import.
Unsave.
Ne.
Was?
Ach so, Method.
Public Static Extern.
Gut, so.
Das müsste als Definition ausreichen, um mich connecten zu können zu meinem lokal laufenden
LibVirt.
Jetzt bin ich mal gespannt.
Gucken wir mal.
Also, was returnt denn der überhaupt?
Was ist denn das?
Was ist denn das?
This should be called first to get a connection to the hypervisor.
Ja, das ist nice.
If name is null, default environment will be used.
Pointer to the hype.
Jetzt geht's los.
Pointer, was auch sonst logischerweise.
A pointer to the hypervisor connection or null in case of error.
Alles klar.
Hi IQ.
Probieren wir mal aus.
Interop.
Connection open.
Qemo.
Doppelpunkt.
Doppelpunkt.
Doppelpunkt.
Slash.
Slash.
Session.
Warum?
Weil zu ist.
So, und da kommt irgendeine ID zurück, irgendein Pointer.
Wir gucken jetzt mal, ob das null ist.
Und wenn es null ist, ist es kaputt oder ist es gecrashed oder wenn es eine Zahl ist, dann
funktioniert's.
Hoffentlich.
Wo sind wir denn?
Repo.
VmChamp.
Dotnet.
Geh mal weg.
Dotnet run.
ForceChamp.
Es geht.
Glaub ich zumindest.
Es könnte auch ein Pointer ins Nichts sein.
Man weiß es nicht genau.
Es könnte auch sonst wohin pointen.
Ja, Dotnet 8 alpha ist rausgekommen vor zwei Wochen.
Könnte auch irgendein Int im Ram sein.
Random.
Okay.
Wir haben...
Es sieht aus, als hätten wir einen Pointer auf irgendwas, wo ich nicht genau weiß, auf
was.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
So.
Connection.
Connection open.
Wie erstellt man damit...
Ach so.
Jetzt brauchen wir das Ganze natürlich noch für Connection closed.
Ich predicte einfach mal, dass es closed heißt.
Ich hoffe, das heißt nicht stopp oder sowas.
Und dann braucht das...
Hier.
Was?
Ach nee.
Hier.
Und dann braucht es diesen Pointer, um es wieder zu close.
Also.
Also.
In pointer.
Connection.
Schauen wir mal.
Schauen wir mal, ob das Connection herstellen und schließen wenigstens funktioniert.
Close.
Con ID.
So.
Und wenn er jetzt nicht crasht, bin ich happy.
Er crasht nicht.
Das sieht doch schon mal ganz gut aus.
Okay.
Nice.
Okay.
Nice.
Und jetzt.
Also wir können schon mal, wir können schon mal eine Verbindung herstellen.
Also halber Wirtmanager ist fertig programmiert.
Wir können eine Verbindung zu einem Wirt herstellen.
Das reicht.
Rest kommt von alleine.
Okay.
Create Domain.
Nee.
Fuck.
Ach ich bin ja auch falsch.
Ich bin ja auch...
Genau.
Ich muss zu Domain.
Create Domain.
Create.
Create Domain.
Fuck.
Create.
Wie erstellt man jetzt eine VM?
Wir Domain Create Linux.
Was?
Also.
Wir Domain Create Linux.
Wir Domain Create XML.
Wir Domain Create mit...
Ach Domain Create gibt's auch einfach.
Okay gucken wir mal was das macht.
Launch Defined Domain.
Ach nee.
Moment.
Ich hab ja nichts Defined.
Launch Defined Domain.
Nee.
Nee, nee, nee.
Domain Create with XML.
Wir brauchen...
Wir Domain Create XML.
Brauchen wir anscheinend.
Guck mal.
Launch a new guest domain based on an XML description.
Die wollen uns quälen heute, oder?
XML shit.
Create XML flags.
Was sind Flags?
Bitwise or supported via Domain Create Flags.
Wir Domain Post Auto Bypass.
Okay.
Juckt mich nicht.
Okay, also.
Wir Domain.
Wir Domain Create XML.
Alles klar.
Kopieren wir das mal.
Das wird was, Leute.
Ich bin mir echt gespannt, ob ich in der Lage bin, eine VM zu erstellen über die CRP.
So, also.
Domain Pointer kommt zurück.
Wunderbar.
Kann in Pointer bleiben.
So, wir Connection Pointer ist richtig.
XML Description.
String XML.
Leute, wenn man das so macht, teilweise, gibt es Memory Leaks.
Das ist aber nicht schlimm, weil die Anwendung startet und stoppt sich eh wieder und wird alles aufgeräumt.
Scheiß drauf, ob es Memory Leaks gibt oder nicht.
Unsigned Int Flags.
Flags.
Okay, das setzen wir mal auf Null.
Ich will eigentlich keine Flags setzen.
Jetzt ist nur die Frage, wo kriegen wir mal ein gültiges XML für eine VM her?
Interop Create XML.
So.
Connection ID von meiner LibVirt Connection.
Wenn man was wie macht, gibt es Leaks.
Wenn man so nette Funktionen aufruft und Managed Datentypen übergibt.
In dem Fall in die Richtung geht es.
Aber das ist dann problematisch, sollte das die andere Seite irgendwie freigeben oder sowas.
Also es gibt manchmal Probleme, wenn man Managed Datentypen hin und her schiebt.
Und da muss man muss man genau darauf achten, wer wie wann wo was freigeben muss.
LibVirt DOM XML Example.
Okay, das ist sehr kurz und knackig.
Das ist sehr kurz und knackig.
Das probieren wir jetzt mal aus.
Okay, also war XML.
Jetzt können wir hier das neue String Literal Syntax verwenden.
Okay.
Übrigens, da müsst ihr drauf achten.
Das kann ich euch an der Stelle noch mal kurz erzählen, weil da macht man macht man sich Probleme und sucht danach ewig Fehler.
Also das ist das erinnert vielleicht ein bisschen an Python hier an der Stelle.
Das geht allerdings auch seit.net 7 glaube ich erst oder 6 oder 7.
Ich weiß ich seit einem der aller aller letzten recent C Sharp Version, dass man Multiline Strings so mit dreifachen Anführungszeichen machen kann.
Es gibt noch mehr Varianten, wie man das machen kann.
Aber wichtig ist die schließenden hier Triple Quotes.
Die müssen auf der Höhe stehen, wo euer Text in der Datei anfangen soll.
Wenn ich das so habe, wenn ich das hier so habe, dann macht ihr das mal neu.
Wenn ich das so habe, dann landet es mit einem Tab in der Datei und je nachdem ist das dann vielleicht nicht gültig.
Also bei XML jetzt egal, aber das kann durchaus sein.
Das heißt, man muss immer darauf achten, wo man hier die closenden Triple Quotes platziert, weil ihr seht es ja hier auch an dem blauen.
Das ist quasi die Baseline, wo es dann am Ende ja mit Jammen wird es dann Fehler geben.
Genau das ist so die Baseline, wie es am Ende dann auch wieder rauskommt.
Also da muss man gucken.
Man macht instinktiv ist vorne, aber es ist falsch.
Es muss dort sein, wo der Text aufhören soll.
Wenn ich die weiter einrücke, dann will er nicht und sagt, das geht nicht.
Also man muss das wirklich hier an der Stelle machen.
Das haben die in Rider auch gut gemacht, dass man hier so eine blaue Linie bekommt.
Okay, also wir brauchen, müssen ein paar Sachen generieren, dass man die vm anlegen kann anscheinend.
Gut, gleich, gut, neu.
So, dann setzen wir das mal hier ein.
Memory, ja wunderbar.
Eine CPU, wunderbar, wunderbar.
Local Time, wunderbar, alles gut.
Emulator, User Bin, QEMO, KVM, wunderbar.
Source Files, war, lib, lib wird, Images, Demo 2, Image.
Latest, Moment.
Moment, Debian Cloud hier.
Wir müssen mal kurz noch ein Debian Cloud Image runterladen, um zu gucken, ob das dann auch funktioniert.
Generic Clouds.
Copy Link.
Weget.
Schön.
32 Bit, ach so.
Ja, was muss man da einstellen?
Ich meine, ich kann es mal so lassen, es ist ja nicht...
Es sollte ja nicht davon kaputt gehen, oder?
Wir können es doch einfach mal raus.
Nee, komm, wir machen Arch.
Ja, keine Ahnung, wie das aussehen muss.
X8664, oder so?
HVM?
Was ist HVM?
Wir sollten uns mal so ein XML-File von irgendwo kupieren.
Die Mac-Adresse schmeißen wir raus.
So, ich muss gucken, ob mein...
Network...
Ah, Mist, das Netzwerk ist noch gar nicht da, aber das ist jetzt erstmal egal.
Keymap, Graphics, Output brauchen wir nicht.
Target Device, HDA.
File ist...
Ich bin mir gar nicht sicher, ob man das absolut angeben muss, aber wahrscheinlich.
Ja, also File ist Debian Image.
Bin ich mal gespannt, ob das funktioniert, alter Lul.
Ich habe so meine Zweifel, ob...
Moment, da muss ich auch an der Stelle...
QEMU, QEMU System.
AMD64, wo ist es denn?
Nee, der ist irgendwo.
Nee, System X86 heißt das, glaube ich.
Hier, X86.
Das muss ich auch eintragen, sonst kann das an der Stelle auch schon mal nicht funktionieren.
Okay, nice.
Jetzt bin ich mal gespannt.
Demo 2.
Ja, Demo 2 ist perfekter Name für die HVM.
Alles klar.
Okay, dann probieren wir das mal aus, ob er die HVM jetzt erstellt.
Imleblich, alter, imleblich.
XML.
Okay, gib ihm, run.
Network not fault.
No network with machine, with matching name default.
Ja.
Toll.
Um, warum, warum nicht?
Wir lassen das Netzwerk einfach mal weg zum Ausprobieren.
Not net run.
Die HVM läuft.
Die geht einfach.
Okay, wir wissen nicht, ob sie geht, weil wir haben keine grafische Ausgabe, aber...
Moment mal, ich delete das noch mal.
Ich delete das noch mal.
Wo war das jetzt mit dem VNC?
Wo war das jetzt mit dem VNC?
Ich hab doch irgendwo ein VNC gelöscht.
Graphics.
Hier, VNC kommt da unten noch mal rein.
Dass ich, dass ich auch was sehe.
Run.
Run.
Okay.
Run.
No boot...
No bootable device?
Okay, die HVM erstellt das schon mal.
Und jetzt?
IDE-Disk.
Äh, ne, das wird so wahrscheinlich nix.
Okay, delete.
Ihr habt recht.
Ich, ich, ich kopier mir hier eine raus.
Das hier, zack.
Wird, wird install.
Example.
Wird install.
Okay, gut hab ich drauf.
Ähm, also.
Ich hab...
KVM install GitHub.
Ja.
Ich verwende aktuell bei mir lokal so dieses Bash Script
vom Gio Torres.
Um mir ab und zu
Lokaltest-VM's anzulegen.
Das geht sehr zackig.
Und sowas könnte man auch mal in C Sharp bauen.
Allerdings kann man uns da abgucken, wie wird,
wie wird install funktioniert.
Nämlich so.
Also, wird install.
Graphics Options.
Brauch man nicht.
Graphics Options.
Brauch man nicht.
OS Variant.
Hm, bin ich mir unschlüssig, was da rein muss.
Äh, Network Options.
Disk Options.
Äh, ne, da kann ich mir nichts
so zusammenreimen gerade.
Shit.
Okay, wir müssen das, wir müssen das anders machen.
Wir müssen hier eine VM erstellen, testweise.
Create New Virtual Machine.
Manual Install.
x8664 VM.
Linux.
2020 soll da Kram
oder Linux, ja.
Generic Linux, wunderbar.
Ja, meinetwegen zwei CPUs.
Select, create custom
storage. So.
Und da wollen wir jetzt an der Stelle haben.
Wo habe ich das runtergeladen?
Repos.
VMChamp.
Generic Cloud Image.
Network Section.
User Mode.
Bridge Device.
Was haben wir denn da?
Hab ich, hab ich wir null
oder sowas?
Wir Br,
Sudo.
Und dann die standardmäßige Netzwerkinterface an.
Ist doch hier, Default. Warum ist das inactive?
Was ist da los?
Was?
Unable to find DNS
Mask.
Was der alles haben will, ich fasse es nicht.
DNS Mask, gib ihm. Nice, DNS Mask,
auch drauf.
On Boot Active.
Apply. So, jetzt sollten wir,
jetzt sollten wir eine Virtual Interface,
wir, wir Br null wollen wir haben.
Wir Br,
obbei, oder, oder einfach Default.
Jetzt bin ich mal gespannt,
ob das bootet, Alter.
Okay.
Bam.
Debian bootet schon mal. Poggers.
Aber Debian, ich habe keinen User und sonst was gesetzt.
Das muss ich über Cloud in den später machen.
Aber Debian bootet.
Ich bin, ich bin begeistert. Das heißt,
hier können wir uns gleich die VM schon mal crappen.
Also das XML von der VM
crappen.
Und mal gucken, ob sich das
in der IP zählt. Das ist eine
Nested VM, ja? Das ist eine Nested
VM. Wir testen
auch gleich mal, wie viel Nested VM ich ab kann.
Wie viel da geht.
Das sieht doch eigentlich alles ganz gut
aus. XML.
Alter, was hat
der hier denn alles?
Zieht es sich, zieht es sich in der IP?
Nee, sieht nicht so aus.
Sollte das nicht gehen, weil das sehr
wackelig aussieht alles.
Wahrscheinlich habe ich keine Rechte auf die
auf das
Interface.
Die meisten Prozessoren schützen
das nicht mit Nested Virtualisierung.
Doch, das kann so gut wie jede moderne CPU.
Nested Virtualisierung. Du musst es
in den VM-Settings einschalten, aber Nested
Virtualisierung geht eigentlich schon lange.
Was macht eine Nested VM? Die macht das
gleiche wie eine normale VM, nur dass sie selbst
wiederum in einer VM läuft. Also guck,
ich habe Linux in einer VM laufen
und in meiner VM habe ich ein weiteres
Linux laufen.
Okay, das mit
Brrrr CTL
Show.
Okay, da sind schlichter gesagt keine
Interfaces dran. Wahrscheinlich habe ich
keine Rechte. Wahrscheinlich, ich gehe
davon aus, dass ich keine Rechte habe.
Kann ich, kann ich vielleicht
via Brrrr 0 Netzwerk
Interface machen?
Okay.
Testen wir mal. Shutdown.
Force off, ja ja.
Weiter.
Put the VM
in my VM, genauer.
I can't VM
while I'm VMming.
Party, Dankeschön für den
Zapp.
Was ist der Vorteil von einer VM in einer VM?
Naja, für die VM selber nichts.
Du kannst es allerdings von dem System
managen, was du in der VM betreibst.
Was ganz praktisch ist.
So, jetzt bin ich mal gespannt, ob der
sich jetzt hier was zieht. Aha!
Schon hängt ein Interface an meiner
Bridge dran. Interessant, interessant.
Jetzt kriegt er auch eine IP.
Okay, das funktioniert schon mal.
Das finde ich nice.
Ping tut die VM auch.
Ich habe kein Login, aber das XML
können wir uns crappen.
Das ist poggers, das XML.
Das brauchen wir.
So, delete.
Delete.
Alles klar, das XML nehmen wir jetzt.
Perfektes XML.
Nice, du XML.
Nice, du XML.
Alter, ist das viel! Alter,
ist das viel! What the fuck!
MonkaS, da muss
die Hälfte raus von.
Da muss die Hälfte
raus von. WCF, das hört ja gar nicht mehr auf.
Okay, was haben wir hier?
Generic Linux.
Hier, da muss wieder
meine ID rein.
Greed.
Memory.
Nee.
Nee.
Bytes, 2GB,
dürften genau... Ah, nee, nee.
Gibi?
Nee,
Gibi?
Fuck,
Alter.
Das ist...
Peter Bytes?
Aber
was?
Nein, nein, nein.
Ja, ja.
Zu
Megabyte.
PMB?
Ach, im Moment,
das ist in unit Kilo Byte.
Ah, nee, nee, nee, nee. Okay, das sind, das sind, das sind
Kilo...
Kibi Byte zu
Megabyte. Also das ist zu
Gibi. Heißt die Gibi?
Gibi?
Ja, okay.
Also, 4GB, sehr, sehr
gut. So, das heißt, wenn ich einfach
nur, sagen wir mal...
Wenn ich, wenn ich das Ganze nur
in 500, das reicht ja
als erste Mal, man muss ja jetzt übertreiben.
Okay, wunderbar.
Man kann die Unit
anpassen wahrscheinlich schon, aber so
ist, ist okay.
Was?
Memory? Current Memory?
Ach so,
naja, das interessiert mich nicht.
Static? V?
Was? V?
Out CPU.
Placement
Static 1
reicht.
Boot Device HD?
Das sieht doch, sieht doch ganz
gut aus. Features?
Ja, wunderbar, genau.
GPU? Was?
CPU Mode?
Host Model? Was? Wie? Nee.
Host? Was? Host?
Pass to Check-None? MyCreatableOn?
Kein Schimmer. Okay, gut.
Clock? Yep.
Yep, Clock. Power Off
Destroy? PM?
Devices? Okay, jetzt wird es interessant.
Devices.
Emulator?
Disk?
Okay.
Hier ist mein Image drin.
Controller Type?
USB?
Nee, das würde ich sagen, brauchen wir.
Wobei, scheiß drauf, ich passe da einfach nichts.
Ich passe einfach nichts
dran an. Ist doch egal.
Ich lasse es einfach. Komm, alles
gut, wir lassen es einfach.
Das Einzige, was ich ändern muss, ist
die Mac-Adresse von
die schmeißen wir einfach raus,
in der Hoffnung er generiert dann eine neue.
Was da alles drin
ist, man.
Ich lasse es einfach
so.
Ich lasse es einfach so.
Okay, und jetzt kriegen wir eine
VM. Run.
Zack.
Da ist eine VM.
Und warum heißt das Linux 2020?
Weil ich den Namen
nicht geändert habe.
Der Name muss ja
keine Ahnung, VM Name
gleich
Test VM.
Irgendwie so.
So.
So.
Das scheint zu funktionieren.
Ich bin begeistert.
Und wenn ich das jetzt erstelle?
Na, da heißt es auch Test VM.
Das ist ja extrem
nice.
Nee, so einfach ist es nicht. Wir können
uns aber die Publish-Size zwischendurch
angucken.
So einfach
machen wir das der ganzen Sache hier
noch nicht.
Weil ich kann mich ja da beispielsweise per Netzwerk
gar nicht drauf einloggen. Guckt mal.
Das Ding zieht sich zwar eine IP,
aber
ich wette mit euch SSH.
SSH Login ist nicht möglich.
Nee, nee, nee, nee. Da brauchen wir jetzt noch ein
Cloud-Init-File, was wir ranhängen
oder so.
So, aber löschen wir erstmal die VM.
Ja.
Exzellent.
Und mal gucken, wie groß das Ganze jetzt
ist. Publish.
Das dürfte noch nicht sonderlich groß sein. Wir haben
ja keine zusätzlichen Libraries drinne und sonst was.
Ja, aber wenn man das jetzt...
Sag mal. Was zum...
Was genau
geht mit meinem Terminal da ab?
So.
Immer noch 1,8 MB
groß.
Ja, das ist doch nicht schlecht.
Das ist Rider. Ja, richtig.
1,8 MB.
Ja, wir haben ja auch noch nichts
ernstzunehmendes gemacht.
Boah, ist das ein abartig
fettes, großes XML,
man.
So.
War das Hello World
nicht 1,9? Gute
Frage. Weiß ich nicht mehr.
Kann schon sein.
So.
Also. Wir haben ja
ein mega hässliches XML. Interop
mit C. Die Datei ist immer noch klein.
Das ist schon mal nice. Jetzt müssen wir
noch ein paar andere Sachen ausprobieren.
Wir machen jetzt noch ein paar Libraries dazu,
damit wir einfach mal sehen, wie schnell
das größer wird. Wir machen mal ein bisschen
farbige Konsolenausgabe.
Weil wer will
keine farbige Konsolenausgabe beim
VM erstellen?
Markup.
Ah, wir müssen doch warten,
ob das Netzwerk... Wir müssen
warten, wenn
die VM richtig hochgefahren ist und das Netzwerk
ready ist. Das müssen wir
natürlich noch machen. So.
Markup, interpolated,
was auch immer.
Markup.
Markup-Line.
So.
In...
Gelb.
Starting VM.
VM-Name.
So. Jetzt können wir das in gelb.
Richtig advanced
aus langsam.
Boah.
So, jetzt ist das Binary garantiert
viel fetter.
Können ich wetten.
Weil jetzt ist noch Specter
Konsol dabei. Das ist eine recht
fette Library.
Bild.
Hä?
Schon 3,8 MB groß.
Schon 3,8 MB groß. Es wächst.
Aber es ist immer noch
komplett im Rahmen. Ich mein.
Was
sind 3,8 heutzutage? Easy.
Ist doch kein Problem, oder? Ich mein.
Also.
Eine Go-Anwendung ist jetzt auch nicht so viel kleiner.
Ich weiß nicht. Hat jemand einen Plan von euch?
Wie groß ist eine Hello World
Go-Anwendung?
Wahrscheinlich
auch ungefähr in dem
Kram.
Irgendwie 2 MB oder sowas.
Eins, zwei MB.
Das sind Log-Files größer. Ja, das stimmt.
So, wie kriegen
wir denn jetzt raus, ob die
VM
eine gültige IP hat?
Da gibt es doch bestimmt
Irgend
irgendwelche
C-Functions wieder.
Suchen wir einfach mal
hier. IP
Address. Okay.
Wir-Domain-IP-Adress.
Wir-Domain-IP-Adress?
Was?
Was ist das?
TCP-Connect
als Y-Loop. Ja,
ne, ne, ne. Wen schon machen wir das hier mit?
Was haben wir denn hier?
Wir-Domain-Interface-Adresses.
Okay, das ist
ein Pointer zur VM.
Das ist ein...
Was ist das denn?
Ein Pointer auf einem Array?
So was in der Richtung.
Unsigned-Source-Flex.
Oh, jetzt wird es eklig.
Jetzt wird es eklig.
Okay, auf geht's.
Wie kriegen wir hier
die...
Ups. Äh.
Wie kriegen wir jetzt hier die IP
von der VM raus?
Also das ganze Ding heißt schon mal
Wir-Domain-Interface-Adresses.
Obviously, wie soll es auch anders heißen.
Dann haben wir ein
Int-Pointer und das ist halt die
VM.
Ne, Domain heißt das bei denen
immer. VM. So.
Dann brauchen wir ein
Wir-Domain-Interface-Pointer auf
Pointer auf Pointer.
Moment, ist das...
Ist das ein Triple-Pointer oder was?
Ein...
Ein Pointer?
Zu einem Pointer der offenen
Po...
Ne, Wir-Shell will ich nicht ausführen.
Wenn schon, muss das über die AP gehen.
Welchen Clip-Point-Manager
benutzt du? Das ist
Green-Clip-Mit-Rofi-Integration.
Okay, wir machen mal die unstrittigen Teile.
Unsign-Int.
Also wir brauchen hier irgendwie so ein Shit, wo ich auch keine Ahnung
habe, wie wir das ganze abbilden.
Mal mal Zeilenumbruch,
Zeilenumbruch, Zeilenumbruch.
Und dann brauchen wir
Source
und Flex.
Flex lassen wir auch auf Null.
Okay.
Wie kriegen
wir diesen Krempel
dahin? Interfaces.
Wir-Domain-Interface-Pointer.
Wir-Domain-Interfaces...
Das ist ein...
Das ist wirklich ein Triple-Pointer.
Ein Pointer auf
ein Pointer, der auf ein Pointer... Ach du
große Scheiße, man.
Okay, jetzt haben wir das da, Struct.
Okay,
dann brauchen wir einen Struct.
Ich ahne Schlimmes.
Public,
Unsave, Struct.
So, keine Charakter, wir wollen
das als Byte-Array haben.
Name.
Und dann Public.
Public.
Moment, ich muss das gerade mal wegmachen.
So, also
Hardware-Adress.
Nächste ist...
Hardware, das ist wahrscheinlich die Mac oder sowas
in der Richtung.
Domain-Interfaces.
Unsigned
Int-Adresses.
Oh je, oh je, ich ahne
Schlimmes. Und dann haben wir als
letztes einen weiteren Pointer auf
Pointer...
Was?
Wie?
Okay.
Damit
setzen wir uns erstmal nicht weiter auseinander und gucken ob
es bis dahin funktioniert.
Ach du kagge, man.
Network-DHCP-Lease.
Ja, das könnten wir auch machen.
So, und das heißt jetzt,
wie zum Teufel muss das hier sein?
Das sind Interfaces,
Pointer auf...
Was hat er hier für Schmerzen?
An...
Das ganze Ding ist unsaved, man.
Unsaved.
Pointer auf
Pointer auf Pointer.
Oh fuck, man.
Okay, komm.
Unsaved, auf geht's.
Ja.
Int-Pointer auf die Domain.
Okay.
Okay, create
XML.
Das gibt, glaube ich, eine ID zurück,
stimmt's?
Das gibt eine ID zurück.
Ja, das
was man dann wiederum braucht, um
auf das andere
zu zeigen, okay.
Domain.
Komm, ich stelle jetzt einfach VMID, da weiß ich
wenigstens was gemeint ist.
Okay, Interop.
Wisst ihr, wisst... Okay, wir haben noch eine VM
mit IP laufen, das ist perfekt.
Ach nee, wir müssen die neu erstellen,
sonst klappt's ja nicht.
Das ist Megasus.
Um nicht zu sagen
Hypersus.
Ich lösche
das mal.
Weil um die VMID rauszukriegen,
müssen wir die VM erstellen, sonst kriege ich die ID nicht mehr
raus.
Und das ist keine richtige ID, das ist ein Pointer.
Das heißt, nachdem das Programm sich beendet,
eh nicht mehr gültig.
So, also, ups.
Hier.
Das muss rein und dann muss...
Interface
of...
Wie lege ich das überhaupt an?
Okay.
Example, die hatten
noch irgendein Beispiel hier drinne.
Hier.
We are domain
Interface pointer of point...
MonkaW.
Was ist denn jetzt? Ah, hier null.
Ah nee, das ist nicht so.
Aber wir interface
unsafe
weil es nicht...
Hehehe.
Und jetzt?
Nee.
Doppel...
Doppelpointern muss ich.
Inter... Und jetzt...
Und? Adresse
auf interfaces.
Okay.
Und dann
Source null flag...
Ich hoffe mal, dass Source null ist.
Was ist denn Source?
Source ist
Source.
Source ist
leases. Das klingt doch gut.
Ancient oder Arp?
Ach so scheiße.
Warum geht das jetzt nicht?
Weil...
Inter...
Moment, ist das...
Das ist ein triple pointer.
Seht ihr das?
Triple pointer.
Also ich muss quasi hier sagen
Pointer...
Hahaha.
Ach du scheiße, man.
Was ist das denn?
Seriously?
Pointer, Pointer.
Das funktioniert.
So.
Und das soll jetzt gehen, oder was?
Pointer Champion.
Was
returnt denn das eigentlich?
Was mache ich? Ich versuche eine
VM zu erstellen, über die CAP
unter Linux. Was prinzipiell
funktioniert, aber jetzt will ich rausbekommen.
Okay, das ist
ein Count quasi. N.
N ist immer die beste
Bezeichnung, weiß man Bescheid.
Okay, hier haben wir die
VM ID.
So, und das müssen wir jetzt in einer
Schleife machen, Leute, weil
das braucht ja eine Weile,
bis die true
await... Moment.
Awaiten kann man nicht in unsave,
oder?
Natürlich.
Natürlich kann man keine
Await machen in unsave, das ist natürlich
klar, ja.
Also müssen wir
den Klassiker rausholen, thread
sleep.
Für eine Sekunde, und dann
probieren wir das Ganze nochmal aus.
Bin ich ja mal gespannt, ey, run.
Okay.
Ja, noch haben wir keine,
noch haben wir keine IP,
noch haben wir keine IP.
Immer noch keine IP.
Keine IP.
Jetzt haben wir eine IP.
Das interessiert ihn aber nicht, ob wir eine IP haben.
Das ist dem ziemlich egal.
Na gut,
abbrechen.
Das probieren wir mal aus.
Auf der
Shell, wie geht denn das?
Wir Shell
Domain Interface,
Adress, ja.
Alter, meine Shell ist übelst kaputt.
Was ist denn das für ein Kack, man?
Requires Domain. Achso, ich habe jetzt gar
keine VM mehr angelegt. Doch, doch habe ich noch.
Test VM.
Hä?
Mit der offiziellen Kommandozeile
findet man auch keine IP. Warum das denn?
Ist das irgendwie
Special Hyper Secrets IP, oder wie?
Was ist ein Pointer?
Also das
Konzept an sich
ist relativ simpel.
Insgesamt schießt es dir aber relativ
schnell in den Fuß. Also ein Pointer
ist eine Kombination aus zwei Sachen.
Ein Pointer ist einmal
die Arbeitsspeicheradresse,
wo etwas liegt,
und die Typinformation,
was an dieser Speicheradresse
liegt. Also wenn du
die Information hast,
ein
16-Bit-Int
liegt an
dieser Speicheradresse,
dann kannst du das auslesen. Du gehst zu dieser
Speicheradresse hin und weißt,
du musst zwei Byte auslesen,
beginnend an der Pointer-Adresse,
dass du dein 16-Bit,
dein Int 16 bekommst.
Also ein Pointer ist nicht wirklich nur ein
Zeiger, auch wenn sich das immer so anhört.
Ein Pointer ist die Kombination aus
Speicheradresse plus
Typ.
Man wollt Pointer außen vor,
das sind nur Pointer.
Ja, wenn du sowas hier hast in C,
dann ist das die Information.
Es ist ein Int, was dort
im Speicher steht.
Also die
Speicheradresse plus die Typinformation.
Und nun? Jetzt hast du mehr
RAM. Ohne RAM zu
downloaden.
So, also
noch nicht mal die offizielle
Kommando-Zellentool
kriegt das raus.
Was kann man hier hinten noch?
Source angeben, Lease.
Das ist das, was ich gerade mache. Was haben wir sonst noch zu binden?
Agent,
No Agent, App.
Aha, App funktioniert.
Okay, warum auch immer.
Ich will es gar nicht wissen.
App ist
Magic
2. Alles klar.
Also muss ich hier Source 2
reinschreiben.
Und jetzt probieren wir das Ganze nochmal.
Delete.
Yep.
Run. Ups.
Ja, ja. Nein, nein. 2.
Run.
Bam.
Was passiert
dann, wenn ich meinen Pointer
hin und her caste?
Dann sagst du, du
weißt es besser als dein Compiler.
Du sagst ihm, ey,
an dieser Stelle ist gar kein Int,
sondern eigentlich ein
anderes Ding.
Das muss nicht zwangsläufig so
sein, aber das kannst du ihm sagen, dass du das besser
weißt.
Wenn du einen Pointer ohne
Typinformationen hast, dann musst du es sogar machen.
Und was
ja in C relativ... Oh, was ist das?
Was ist das?
Wait a minute.
Der erkennt, dass es eine IP hat.
Pog. Das geht einfach.
Stell euch das mal vor.
Also eins muss man den
Linux-Leuten ja echt lassen.
Das sieht immer abartig aus,
weil du halt
irgendwelchen C-Interop machen musst,
aber unterm Strich
funktioniert es meistens einfach.
Natürlich kannst du dir an, ja,
bei jedem Schritt selbst im Fuß schießen,
aber es funktioniert
meistens einfach.
Und die Dinger sind ja recht gut
zu bedienen auch, kann man, kann man nichts sagen.
So, und jetzt,
und jetzt ist die Frage,
wie kann ich jetzt auf meine
Interfaces zugreifen?
Also wenn ich jetzt
ein Interface gefunden habe,
dann müsste ich doch eigentlich sagen können
Interfaces
Null, weil ich habe ja
mindestens eins gefunden.
Interfaces Null.
Und dann Number of Addresses ausgeben.
So.
Wie wird die VM erstellen?
Also woher weiß der welches Image?
Hierher.
Weil ich ein riesen fettes, ekliches XML habe,
wo das alles drin steht.
Wo man die Hälfte
wahrscheinlich entfernen könnte draus.
Muss ich auch mal gucken, wie man das
XML vielleicht, so viele
PCI und Serial und so, das brauche ich.
Zata brauche ich alles gar nicht.
Oh, was jetzt?
198?
Was habe ich jetzt verkehrt gemacht?
Ah, ich kann nicht drauf zugreifen
logischerweise. Ich bin ja auch doof.
Ich kann nicht drauf zugreifen, solange es
noch nicht angelegt ist. Okay, das ist natürlich klar.
Das kann nicht funktionieren.
Also muss ich checken, ob das
Kann man einfach Null checken machen? Check machen?
Ich muss einfach checken.
If N
größer Null.
So, und nur dann mache ich das.
Ansonsten bleiben, warten wir ab.
Auf geht's.
Let's go.
So. Wir sollten jetzt
gleich die IP-Adresse sehen.
Sobald er hier eine IP-Adresse
bekommt.
Bin ich gespannt.
Okay.
Okay, da kann sogar die Adresse da
rausholen.
Nicht schlecht, nicht schlecht.
Machen das mal alles auf den
Desktop hier, sonst
so viel hin und her switchen.
So, eigentlich könnten wir gleich noch
ein Delete hinterher machen.
Wobei er dann das Image wahrscheinlich
auch löscht.
So, und jetzt muss ich die Adressen
da rausholen.
Wie hole ich die Adressen da raus?
We're domain interface.
We're domain IP-Adress
pointer.
We're domain IP-Adress
pointer.
Hier, das brauche ich
auch noch, als
Struct.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Als Struct.
Public
unsaved Struct.
We're
domain IP-Adress.
So, haben wir das mal weg.
Sonst, also.
Was brauchen wir denn hier jetzt? Wir brauchen
ein Typ.
Das ist ein
Int.
Int.
Ja, ein Typ.
Die Adresse als String.
Als Byte, ist wahrscheinlich sinniger.
Und dann ein Prefix
als unsigned Int.
Prefix.
So, und
davon wollen wir jetzt einen Array haben.
Das wird ja was.
Oh, ich blick nicht
mehr durch. Wo muss ich mal hin? Da.
So, das ist dann ja
sowas hier.
Ein Pointer
auf
das Start-Element
von einem Array.
Ich bin mir nicht sicher, ob ich sowas machen darf.
Ob der das dann richtig erkennt.
Okay.
So, und wenn jetzt alles
klappt.
Wenn ich Number of Addresses
hier hab. Ach, wir greifen da jetzt einfach drauf zu.
Scheiß drauf.
Addresses
und davon die Erste.
Und davon dann
die
Moment, das ist ein Byte.
Wie bekomme ich aus einem Byte-Array?
Dann
ein String. Wie geht das
gescheit? Ein 0-terminiertes
Byte-Array zu einem String.
Wie funktioniert das
in C Sharp gescheit? Irgendwie sowas hier, ne?
Encoding
UTF-8. Ich hoffe mal,
das sucht hier was. Get
String und dann From Bytes.
Aber da brauche ich
einen Byte-Count.
Ah, shit. Woher weiß ich denn?
Woher weiß ich? Okay.
Eine IP-Adresse ist einfach 8.
Irgendwas. Nicht
wirklich, aber die ersten, wir machen
einfach mal die ersten 8 Charakters.
Das ist dann quasi 192
Punkt 168
Punkt. Also
der Anfang von der IP müsste ich dann zumindest sehen.
Hier.
Oh, jetzt hab ich den Wirt-Manager geschlossen. Ich noob.
Okay. Run.
Okay.
Okay.
Jetzt
Crash-ts wahrscheinlich gleich.
So.
Der holt sich jetzt eine IP.
Ah, die
VM muss erst ein bisschen, dauert auch ein bisschen bis sie
startet und alles.
So.
Funktioniert.
Oh.
Ah, ne, das war ein
Zeilen-Unbruch-Problem hier.
Es geht einfach.
Aber wie kriege ich,
das Problem ist nicht gelöst.
Äh, wie kriege ich
einen nullterminierten String?
Okay, da muss du aus der
Overflow fragen.
Byte
Byte pointer
nullterminated
to string
Byte
Byte pointer
nullterminated
to string
Da gibt es doch bestimmt
Chat-GPT
Fragen.
Das kriege ich auch ohne Chat-GPT.
Da gibt es doch bestimmt
irgendein
irgendein
irgendein
ein
Trick.
Da gibt es doch bestimmt
irgendein Trick.
Wie man das, wie man das.
Also das ist ein UTF-8-String höchstwahrscheinlich.
Ein nullterminated
UTF-8-String.
Und das will ich in einen C-Sharp-String.
Ach ja, übrigens, nur mal so.
Ich, ich, ich zeige euch
mal was, weil ihr, weil ihr vielleicht mal
das Problem haben könntet.
Man denkt sich jetzt ja so an der
Stelle.
Ich muss
ich plus null machen, der ist schon nullterminated.
So, man denkt
sich jetzt ja so an der Stelle, gucke mal.
Warum nehmen wir hier nicht
Character?
Könnte man sich ja denken, warum nehmen
wir hier nicht Character? Weil es, es, es sind, es sind ja
Buchstaben.
Und jetzt machen wir
mal, passt mal auf.
New
String, weil das ist dann relativ
einfach. Dann darf man das
direkt nullterminated reinmachen.
So, was meint ihr, was jetzt passiert?
Sieht doch jetzt, sieht doch jetzt eigentlich richtig
aus. Ich kann euch sagen, dass es nicht funktionieren
wird.
Glaub ich zumindest.
Es gibt einen Schonskiet an, was sonst?
Was sonst? So, also
ich könnte wetten, dass es nicht funktioniert.
Dass es abkackt oder sehr
merkwürdige Zeichen ausgibt
auf der, auf der Kommandozeile.
Ja, macht es. Es funktioniert
nicht und mein Terminal sagt, es kackt gleich
ab.
Ja, ja. Ja, Chet, warum
funktioniert das nicht? Es ist ein null
terminatet,
null terminatet Charakter Array.
Das ist schon richtig.
Aber warum geht das nicht? Also sprich,
warum ist das hier so nicht möglich,
obwohl das noch ihr Charakter ist? Das
liegt daran, was ist das, was ihr euch zeigen
wollt, das liegt daran, weil
ein Charakter
in C-Sharp
nicht ein Byte
ist. Normalerweise
ist ein Charakter, zumindest in C ist das
so, ist ein Charakter gleich
ein Byte. In C-Sharp nicht.
In C-Sharp ist
ein Charakter. Chet,
wer weiß es?
Wieviel Byte
hat ein Charakter in C-Sharp?
Pausierungschamp.
Wer ist high IQ und weiss es?
Vier, nee, fast.
Sixty-Nine,
fast richtig.
Sechzehn, nee.
Du bist
mit sechzehn aber schon mal nicht verkehrt.
Es sind bloß nicht sechzehn Byte.
Es sind zwei, richtig.
Es sind zwei.
Es sind zwei Byte, es sind sechzehn Byte.
Es ist quasi
UTF 16,
wie C-Sharp
intern arbeitet. Warum?
Das weiß nur Microsoft.
Historisch, weil das wahrscheinlich
vor der Erfindung von UTF 8 war.
Ja.
Das sind sechzehn Byte.
Deswegen funktioniert das nicht richtig.
Deswegen funktioniert das nicht richtig.
Deswegen muss ich explizit sagen, hier guck mal,
das ist ein Byte
und jetzt muss ich mir überlegen, okay,
wie bekomme ich denn, bitte schön,
aus diesen Bytes,
aus diesen UTF 8 Bytes
jetzt ein
C-Sharp String?
So, wo ist die John Skeet Antwort,
Leute?
Pass a Sway
Pass a Sway to convert a
possibly null terminal ASCII Byte
to String.
Ja, Moment, das ist,
das ist, das zählt nicht.
Das zählt nicht,
weil das ist ja schon im Array.
Und im Array
ist ja schon eine Längeninformation
drinne.
Es muss
zweite oder dritte Antwort.
Nope, das stimmt nicht, das bringt
nichts, das bringt nichts.
Das geht
so nicht.
Ich meine,
eine Schleife, das funktioniert,
ich könnte eine Schleife machen und das selbst rausholen.
Was haben wir denn hier zu bieten?
Okay, C-Sharp.
UTF 8
Pointer
to String.
Native UTF 8
Managed String.
Boah, was?
Gibt es da nichts fertig?
Marshall Pointer
to String.
Marshall Pointer
to String UTF.
Ja, das sieht gut aus.
Der Marshall
wieder mal.
Der Marshall.
UTF 8
Pointer
to String.
UTF 8
Pointer, okay.
Bytes.
Okay,
das will er als Endpointer
wahrscheinlich haben, das ist okay.
Darf er?
Wenn er meint.
Okay,
String.
Alles klar.
Löschen wir
die VM und gucken, ob es jetzt funktioniert.
By the way, Leute, ich habe mich wieder
übel sidetracken lassen. Eigentlich wollte ich mich mit
der, mit der, meine Schelle ist
kaputt. Mit, mit der, mit der
Kulisse von Binaries beschäftigen.
Was wir wieder
nur zum Teil gemacht haben.
Aber wieder was gelernt.
So, wenn jetzt alles klappt, kriege ich die
IP-Adresse von
der VM.
Ausgespuckt.
Nice, easy.
Ackerman Shit.
Easy as fuck.
Easy as fuck.
Get rekt. Easy as fuck.
Der Marshall war es wieder.
Der Marshall war
am Start.
Ist es jetzt möglich, Unsafe
C-Sharp Inline Assembly zu schrauben?
Ich habe keine Ahnung, ob das geht.
Also, direkt
in der Sprache integriert ist es nicht.
Aber es gibt bestimmt
irgendwelche Zusatzdinger, wo das, wo das
tut.
Marshaller.
Ja, das ist gut hier.
Das finde ich nice.
Was passiert eigentlich, wenn ich die VM
lösche?
Crash das dann, weil der Pointer nicht mal
gültig ist?
Oder was passiert?
Jetzt bin ich gespannt.
Oh ja, es crashed.
Domain not found.
Object
instance not set.
Okay, man darf, man darf ihm das nicht
unterm Ass weglöschen.
Dann kackt er ab.
Aber das ist cool, das hätte ich nicht gedacht,
dass das so geht.
Publish, wie groß, wie groß ist
das executable jetzt?
Builds.
3,8 MB, das ist ja nichts.
Also, warum
ist meine Shell so abgefuckt, kaputt?
Was ist da los?
Das ist cool.
Weil das in kernel pointed, nee.
Weil
das ist nicht gecrashed.
Weil es irgendwie unmanaged
Probleme gegeben hat, das ist gecrashed.
Weil
er anscheinend
versucht hat, hier drauf
zuzugreifen, weil es
noch größer, also ich habe es wahrscheinlich gerade
in dem Moment gelöscht, wo es das
noch größer als null war.
Und dann hat er versucht hier drauf zuzugreifen,
oder? In welcher Zeit? 201, ja genau.
Also ich habe das gelöscht,
wo der checkt, das war
ein ganz unglückliches Timing anscheinend.
Na oder,
das ist noch irgendwie im
abcached drin, dass er es gefunden hat, was auch immer.
Nee, der ist gecrashed, weil ich hier versucht
habe auf Interfaces zuzugreifen, auf den
ersten Index.
Und das gab es da nicht
mehr, weil ich
es gelöscht hatte.
Aber gut, man
war ja irgendwie zu erwarten, sollte man
auch nicht machen.
Haben wir wieder was gelernt, Leute.
Wie man per
ap, also per c-Library
Interface
VMs erstellt unter Linux.
Pog.
Was wir auf die
Schnelle machen können, ich glaube nicht.
Was ich mich jetzt noch frage ist,
was ich mich jetzt noch frage ist,
worauf sind diese
Binaries jetzt lauffähig?
Das müsste man vielleicht immer schnell
ausprobieren noch. Ich kommentiere
mal alles aus.
Ich kommentiere mal alles aus.
Publish.
Oh nee, habe ich jetzt wieder mit.
Worauf
sind die lauffähig?
So, machen wir mal
Docker Run.
Warte mal.
Docker Run.
Linux Support.NET
Ja, das ist was sie supporten.
Das geht aber meistens trotzdem
eine ganze Ecke weiter
zurück.
Minimum.
Ja, ich
brauche es für.NET 8.
Ich brauche es für.NET 8.
Haben die da schon
ein
Review?
Haben sie da nicht reingeschrieben?
Ich weiß nicht, was Minimumsupport ist
für.NET 8.
Das
können wir einfach ausprobieren.
Wir sagen einfach
Docker Run.
It.
Nicht Potman.
Logger.
Rm.
Und zwar
Ubuntu.
20.04
sollte auf jeden Fall noch
gehen. Das ist glaube ich kein Problem.
20.04
So, jetzt müssen wir mounten.
Mein Docker-Stels ist
zu lange her. Wie ging das jetzt?
pwd slash
build
mounted
nach build. Mach ich das richtig so?
Alter, warum ist meine
Shell so im Arsch?
Ich will
das irgendwie kaputt, meine
vorwärts und rückwärts tasten.
bin bash
Das testen wir jetzt mal, worauf
das läuft.
cd, build
hier, vmchamp
Was?
Ah,
ich verstehe.
Wenn ich, wenn ich das
kompiliere,
dann nimmt es die C-Libraries von
meinem Host. Das ist ein
Sonderfall zu,
also wenn ich das normale erstellen von
einem executable mache mit.NET,
dann benutzt er ja die Sachen, die schon
drin sind, die quasi eingebaut sind.
Wenn ich es allerdings komplett
kompiliere, sodass gar keine.NET
mehr vorhanden ist.
Dann
heißt es,
ich benutze die von meinem
Host-System.
Okay, das ist natürlich blöd.
Das heißt im Endeffekt,
ich müsste quasi ein
Docker-File bauen.
Wird heute vielleicht bisschen knapp.
Ich müsste ein Docker-File bauen, wo
die Sachen drin gebaut werden.
Wir machen
mal die Kurzvariante
von einem Docker-File.
Und zwar, wir nehmen mal
Ubuntu. Wir machen jetzt gar
kein Docker-File.
Ich mounte das jetzt
hier rein.
Ich mounte das jetzt hier rein.
Curl install.NET
müssen wir jetzt hier machen.
Minus 8.0.
Ich meine,
Alter.
Es ist kein
Curl installiert, ich fasse es nicht.
Na gut, das sind minimale Container-Images.
Warum sollte da auch Curl drauf sein?
Kann man sich das so vorstellen wie Server-Side-Rendering?
Was? Hä?
Wie jetzt?
Das verstehe ich nicht.
Doch, du kannst eine Image von Microsoft
aufnehmen. Das bringt allerdings an der Stelle nichts.
Weil du das älteste Image,
also das älteste OS nehmen musst,
was du mit deinem Output-Binary
supporten musst. Weil wir machen kein normales
.NET-Build. Wir machen diese experimentelle
.NET-8
Komplett-Kompilierung.
Okay, Build.
Das ist schon mal, da sieht man mal schon wieder,
das ist schon mal abfuck im Vergleich
zu
zu Go. Mit Go hast du die Probleme
schlicht und ergreifend nicht.
Das ist schon mal doof.
Das ist schon mal nicht gut.
Eco, Alter.
Wie heißt denn der Kram?
Wie heißt das?
Hier, das da.
Das brauchen wir.
Go-Sundags ist halt bodenlos.
Ja, Go-Sundags ist...
Meine Güte, jetzt ist ja mal gut hier.
Go-Sundags ist...
Das ist schon mal gut hier.
Das ist schon mal gut hier.
Go-Sundags ist...
Ist schon halbwegs erträglich.
Geht schon. Aber wirklich schön
muss ich sagen. Also wirklich, wirklich warm.
So komplett werde ich mit der Go-Sundags auch nicht.
Plattform-Linker.
Not found.
Wie heißt das?
Essentials?
Nee.
Base-Build? Ah fuck, wie heißt denn das unter
Debian?
Ah, okay.
Easy.
Einfach ohne S.
Also unter Ubuntu 20.0
Alles klar, natürlich.
Was, was sonst?
Ich finde, das ist ganz eindeutig,
was das uns sagen soll.
Komplett klar.
Ja.
Also wenn sich das
noch nicht mal gescheit unter Ubuntu
20.04 übersetzen lässt,
dann kannst du es ja fast, fast
komplett... Was hat er denn jetzt?
Was will er mir eigentlich sagen?
Bist du nicht auf V20?
Doch.
Was, .NET 7
supportet doch nicht erst
ab 22.10.
.NET 7 geht glaube ich
bis Ubuntu 18.04
oder so?
Ja, commercial-Support ist doch egal.
Ihr Minimum.
Minimum libc muss mal gucken.
Es ist bis
Debian 10
und Ubuntu 18.04
Die Chance, dass es auf noch
älteren läuft, ist sogar
gar nicht so,
gar nicht so unnötig.
Also,
ich finde,
gar nicht so, gar nicht so unnötig.
Also, was der hier verschmerzt hat, ich habe
absolut keinen Plassen-Schimmer.
Also, ich weiß auch nicht, was
er für Probleme hat, ehrlich gesagt,
weil...
Also, ich hab garantiert irgendeine Abhängigkeit,
nicht?
Aber man weiß es halt nicht.
Ich kann es mal bilden, ich kann es mal
bilden ohne Ahead of Time.
So easy, gar kein Problem.
Ich hab Dependencies.
Dependencies, müssen wir mal kurz gucken.
.NET 7 Dependencies, was brauchen wir denn hier?
Clue C++
Library, ok, das müssen wir bestimmt alles
abinstall
lib
Es ist doch mit Build Essentials
bestimmt
drauf.
Oder nicht?
Welche davon denn jetzt?
Welche davon?
Geht anscheinend nicht drauf.
Welche davon denn
überhaupt?
Kann man
nicht einfach...
Gibt es da nicht so eine Standard
oder so?
Ja, ich weiß nicht welche.
Ich installiere jetzt einfach alle.
Was will der eigentlich alles
haben, man?
Ach, Stand ist da drinne?
Moment.
Hätte ich mir vielleicht mit Output richtig angucken sollen.
Cannot find
Wo zum Teufel?
Siehst du das?
Cannot find, wo
steht da? Wo steht Cannot
find minus LZ?
Ach da!
Zlib
Wie heißt denn das Zlib
Def?
Warum heißt die ganzen Sachen immer so
unintuitiv?
Zlib C
Ja, das war bestimmt das Falsche.
Zlib 1G
Zlib 1G
Natürlich, natürlich.
Was sonst? Die Header brauchen wir ja.
Ich geb dir Header.
Ah, guck mal.
Jetzt hat das funktioniert.
Also 22.04
ist überhaupt kein Problem
zu bilden.
Builds
VmChamp
Ja.
Okay.
Eine Sache, nochmal kurz gucken.
16.04, das wird sich überhaupt nicht mehr
installieren lassen, glaube ich jetzt.
Das wird sich, glaube ich, gar nicht mehr
installieren lassen.
Also ich gehe nicht davon aus,
dass es überhaupt läuft.
Okay, 16.04
läuft auch.
Moment.
.net
.net
Info
.net
Info
Jaja
Leute
Zlib
Eco 66
hieß der Krempel, oder? Def?
Ich hasse diese Namen von den
Das kann sich doch keiner merken,
Mann. 55, ne
66 war gestern, 55 war
damals.
Obviously.
Und jetzt war das was?
Zlib?
Ja, das, okay, das
heißt einfach immer gleich.
Ja, wenn man das richtig macht.
Yes.
Publish.
CD
Build
.
Okay.
Mal gucken wir beim Abkacken zu.
Plattform linke. Ach so, ja,
Abinstall, Install
Build
Generate, okay, easy.
Leute.
Guck mal, das läuft sogar
auf Ubuntu 16.04
noch.
Das ist doch gar kein Problem.
Das ist doch gar kein Ding.
Also 16.04 ist mir
alt genug.
Zeig ich euch ganz ehrlich.
1,9 MB
Library.
Und ich meine,
das ist über sechs Jahre alt
des Linux. Das ist doch schon, das ist doch in Ordnung.
Wollen wir nochmal Just For Fun?
Okay, wir machen jetzt, wir machen
jetzt als letzte Amtshandlung heute.
Wie überspringen jetzt 16.04?
Wir machen jetzt 12.04.
12.04, okay, wir wissen jetzt ja langsam,
wie es geht. Up, Update.
Damals gab es noch nicht mal
Abt.
Abt, Get Update.
Das ist so alt.
Oh fuck, Leute.
Dafür gibt es noch nicht mal mehr Packages.
Okay, wir können das nicht verwenden. Die Mirrors sind offline.
Okay, keine Chance.
Okay, 14.04,
komm, please, 14.04.
Russen-Mirror jetzt, genau.
Okay, da gab es Abt schon.
Abt, It's All Cool.
Schauen wir mal kurz, ob du es findest.
Yes.
Yes.
Okay, der Download klappt noch.
Abt, Install.
Das da und Build
Essential.
Jetzt bin ich mal gespannt, ob der Build klappt.
Ich glaube ja, ich glaube ja nicht.
Ja, ja, genau.
Wunderbar, wunderbar. Excellent, excellent.
Abt, Search.
Wie hieß das Ding damals?
Abt, Install. Ah, 52.
52 sind wir jetzt. Es wird immer
älter.
So, und jetzt bauen wir das
Ganze mal. CD-Build.
Oh.
Cannot get required
symbol SSLZ.
Z Alpenprothos,
alles klar. Die Alpenprothos sind am Start.
Ich wusste gar nicht, dass die auch in den Alpen sind.
Die Alpenprothos machen nicht mal mit.
Okay, also, Ubuntu
14.04. funktioniert nicht mehr.
Das ist zu alt.
Man könnte jetzt sicherlich
rumbasteln und SSL-Support deaktivieren
und solche Geschichten, aber
scheiß drauf.
Also das funktioniert nicht mehr. 16.04
ist das letzte, wo es drauf läuft.
Obwohl, obwohl der offizielle Support
schon bei 18.04
plus ist.
Also finde ich, finde ich okay.
Offiziellen Support auf
18.04 stellen und
in Wirklichkeit noch 16.04 supporten.
Beziehungsweise
lauffähig sein, ob es Support wird,
oder nicht.
Ich gehe mal davon aus,
mit einem gebauten Binary,
was so alt ist,
geht das schon.
Guck, das läuft doch hier drauf.
Kann ja mehr oder weniger
Zufall sein. Aber das ist
gut.
Dann sind die Binaries
tatsächlich auch
lauffähig auf
den wichtigsten System.
Ich mein,
braucht man wirklich
was,
was eine C-Library
voraussetzt.
Die älter ist als
6 Jahre rausgekommen
ist die ja wahrscheinlich noch früher.
Also die, guck mal mal,
Ubuntu 16.04
libc Version.
Okay,
G libc.
Release date
2016.
Ja, 7 Jahre alt
ist das jetzt genau.
Also ich würde sagen,
7 Jahre alte C-Libraries,
damit läufst du noch.
Das ist zwar nicht so krass,
wie mit Go.
Ich meine, Go Binaries, also
alles was Go Only Sachen verwendet,
wohlgemerkt nur.
Also mit irgendwelchen Abhängigkeiten drum herum
hast du dann auch wieder andere Probleme.
Auf der Seite wurde das sogar erwähnt.
Lass uns mal schnell gucken.
Aber das ist nicht so krass wie Go.
Mein Go Binaries sind ja lauffähig bis
zurück zu
Colonel 2638
oder so was.
Du kannst ja quasi aktuelle
Go Programme auf Linux System
laufen lassen von vor
20 Jahren oder so.
Ja, nicht ganz, aber
von vor 15 Jahren
oder so.
Hier steht nichts.
Ups.
Hier steht nichts von
Ach, hätte ich das mal gewusst,
da hätte ich es einfach copy-pasten können.
Ja, Go
ist lauffähig auf
Linux System, die älter sind als Go selbst.
Ja.
Also hier steht nichts von 16.04.
Auf der
Tabelle der Linux Version.
Hier?
18.04 steht da drinnen.
16.
Ach, hier.
Das ist die
Ja, gut.
Das passt ja.
Wir haben ja 223
bei Ubuntu
16.04 gehabt.
Aber trotzdem,
das ist alt
genug.
Kann man nichts sagen.
Also ich glaube, das ist echt ganz gute
Alternative, wenn man Bock hat, die Sachen in
C Sharp zu programmieren.
Und die
Libraries und alles, das drum herum
gescheit funktioniert mit dem
Wir haben ja heute nicht so viele eingebunden.
Reflection kannst du dir
eh wahrscheinlich abschminken mit
irgendwelchen Native-Kompilierung
Sachen. Aber trotzdem,
das ist cool, dass es geht.
Okay Leute, macht's gut. Ich geh jetzt
pennen. Bis denn, see you.
