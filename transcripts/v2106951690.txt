Ist zwingend gelb, mag ich das.
Exzellent, da bin ich.
Sartin Silver, danke für den Sub.
Richtig lange am Start.
Schon länger am Start als 10 Monate, oder?
Vielleicht nicht als Sub, aber du bist schon ziemlich lange am Start.
Zumindest sagt mir der Name was.
Du hast auch schon über 1000 Messages geschrieben, also du musst schon eine Weile am Start sein.
Mai 2023, ja.
Tatsächlich, ja, als Sub warst du vorher nicht auch mal da?
Ja, kommt echt hin.
Exzellent, nicht gedacht.
Kontrollier das jetzt, ob das stimmt.
Ne, da kann man nicht gescheit zurückscrollen, da wirst du verrückt in Twitch, wenn man zurückscrollen will.
Das ist wieder Endless-Scroll-Bullshit, Alter.
Guck ich mir nicht an.
Ich glaub dir das auch so.
Ohne Scheiß, Endless-Scroll.
Das ist eines der bescheuertsten Erfindungen des modernen Web-Developments.
Weiß gar nicht, wer mit diesem Blödsinn angefangen hat.
Ihr wisst alle, was Endless-Scroll ist, oder?
Ich schau mal kurz, ob es Package-Updates gibt.
Moment.
Arch, by the way.
Es gibt wieder mal Updates.
Ich hab heute Morgen mein komplettes System geupdatet, aber...
4 Stunden später gibt's...
...wieder Updates.
Arch, by the way.
Aber man muss sagen, manchmal hab ich Multithreading-Probleme.
Ich denke im Kopf schon, obwohl ich mit dem anderen...
...also, was Neues, obwohl ich mit dem anderen noch nicht fertig bin, mit auszusprechen.
Dann kommen manchmal so komische Sätze bei raus.
Heute Morgen hab ich geupdatet und am Freitag waren die so schnell mit Updates bei Arch-Linux,
dass das theoretisch noch nicht mal ein kaputtenes XC...
...Tools-Package bei mir angekommen ist.
Übrigens, zum Thema XC-Tools, ich zeige euch grad schon mal was aus meinem Docker-File, was ich grad gefunden hab.
Aber das ist nicht schlimm, weil Debian Bookworm, das hat die Probleme nicht.
Oh, was ist denn hier los? Moment, Moment, Moment, Moment.
Kurz, die Musik leiser machen.
Das stimmt ja überhaupt nicht. Ich muss das hier lauter machen.
Jetzt ergibt das das hier lauter und dann...
Weil ansonsten...
...ist das hier zu leise.
So.
Ja, richtig grausam.
Das schlimmste Forum, ich hab's ja schon oft gesagt, Home Assistant Forum, also die Technologie, die die verwenden,
das fuckt mich so ab jedes Mal, wenn ich hier nachgucken muss.
Und ich versteh den Vorteil davon nicht.
Der einzige Vorteil, den ich mir vielleicht noch irgendwie da zusammenfasse, ist, dass...
...Mobile User.
Ja, also zum Beispiel gehen wir mal hier irgendwie auf, was weiß ich, Mobile Apps.
Hier, 46.
So.
Und man kann hier nicht mehr durchscrollen.
Das funktioniert nicht.
Guckt, ihr seht, der lädt immer.
Und dementsprechend...
Ja.
Guckt mal hier.
I used to be able.
Jetzt scroll ich ganz runter.
I used...
Alter, das ist ja noch schlimmer.
Die überschreiben ja...
Ich vergesse es ja immer wieder.
Die überschreiben...
Ja.
Die überschreiben...
Ja.
Ja.
Ja.
Ja.
Ja.
Die überschreiben ja auch Control-F.
Das ist so schrecklich, alter.
Verjavascriptifizierung, Mann.
Vor allem komplett unnötige Verjavascriptifizierung.
Erstens benutzen die gefühlt nur die Hälfte von meinem Bildschirm.
Und das Ding ist halt, es sind 47...
Guckt mal, es sind 47 Posts.
Wo ist denn das Problem, Mann?
Lad den Scheiß halt einmal auf alleine.
Es ist jetzt nicht so...
moderner Client mit 64 GB
RAM, irgendwie von einem Thread
mit 47 Posts, auch wenn die
alle auf einmal geladen wären, irgendwie
überfordert gewesen ist. Guck mal, ich bin schon fertig
durchscrollen. Ich hasse
das, Alter. Das kann ich mir jetzt
mal übelst drüber aufregen, über
solche Webentwicklung,
Webentwicklungstrends.
Discourse, genau, ja.
Diskus,
Discass gibt es auch noch. Das ist
irgend so ein komisches Commentsystem, das ist aber auch kacke.
Okay, so, was ist das deutsche
Tesla-Forum? Okay,
zeig mal, ich war noch nie im deutschen Tesla-Forum.
Das da, TFF-Forum.
Was ist
denn das TFF?
Ach, das
Tesla-Fahrer
und Freunde-Forum.
Alles klar.
Ja, das ist auch hier, das ist
auch Discourse.
Ja, ich wollte schon immer mal einen Cybertruck.
Ja, das ist genau das
gleiche, das ist genau der gleiche Müll.
Ja, das ist, das ist doch, das ist, guck mal,
man sieht es doch hier, das ist genau das gleiche System.
Ich meine mal ehrlich,
diese alten Foren, die es da damals
so gab, so PHP-Bulletin
und, und was nicht alles,
muss man teilweise Lizenzgebühren dafür
zahlen, die waren auch schon ziemlich mies.
Gerade noch aus Zeiten von,
ich weiß schon, weil es PHP und sowas, aber
immerhin, immerhin, ja,
war das halt noch
irgendwie benutzbar.
Weil es halt einfach
den Webbrowser als,
als Web verstanden hat
und nicht versucht, irgendeine komische App draus zu machen.
Alter, da kriege ich
Anfälle bei.
Was machen wir heute? Pepo-Schei, ich zeige euch
was, was ich programmiert habe.
Und dann versuchen wir, den Memory-Leak
drin zu fixen.
Wobei ich mir gar nicht so hundertprozentig
sicher bin,
ob
ich überhaupt einen Memory-Leak
hab. Moin Patrick, danke schön für den
Sub. Bonjour.
Oh, poor girls, Alter.
Ich glaube,
ich glaube, ich muss eine andere Musik anmachen.
Ich glaube, ich glaube, dass ich eins habe.
Ich bin aber so hundertprozentig...
Ups, oh, Weeb-Musik, Leute!
Endlich!
Ayaya!
Okay, genug. Genug Weeb-Musik.
Aber zwischendurch muss das
mal sein. Was machen wir denn an?
Nicht von heute Morgen... Was haben wir denn hier?
Just...
Können wir nicht hier irgendwo
ein bisschen... Was machen wir denn?
Was machen wir denn mal an?
Epic Chillstep
Collection.
Weiß er nicht.
Ich hab auch einfach,
ehrlich gesagt,
viel zu viel Zeug
auf. Ich find hier gar nichts mehr.
Christmas Special
Music. Ich glaube, das
können wir uns doch...
Komm, wir machen jetzt hier
Epic Chillstep Collection, meinetwegen. Hauptsache...
Woop, woop, woop, woop!
Ja, da weißt du schon gleich Bescheid.
Da Call of Duty
Modern Warfare 2 2009
will die
Quickscope-Montage wieder haben.
Doom Eternal Musik.
Es gibt...
Was ich auch...
Also, welchen Game-Soundtrack ich auch
mag, ist...
Oh, wie hieß das?
Jetzt hab ich schon wieder ganz vergessen.
Ah, ja, genau, genau, hier.
Ich auch.
Den Soundtrack find ich auch nice.
Wobei, da muss ich auch...
Da rennen mir die Leute gleich weg.
Aber...
Das Game hat einen ultrageilen Soundtrack, wenn man auf so Musik
steht.
Aber...
Ich gette, dass es nicht für jeden was ist.
Ich mag so...
Musikstells.
Ich war ja schon auf einigen Heavy-Metal...
Bei einigen Heavy-Metal-Bands auf
Konzert.
Ich wollte immer mal früher schon zu Iced Earth
gehen, falls ihr die kennt. Das Problem ist nur,
mittlerweile könnte ich das machen,
aber ich kann das nicht mehr machen,
weil die haben sich aufgelöst.
Weil der Gitarrist irgendwie
damals dabei war, als die
nach der letzten US-Wahl,
da wo Trump nicht mehr gewählt wurde,
das Capitol gestürmt haben.
Da war der mit dabei und wurde irgendwie verurteilt
und da hat sich die Band aufgelöst.
Aber die hätte ich mir auch mal... Aber, gut.
Früher hätte ich mir die gerne angeguckt.
Mittlerweile muss ich sagen, die neueren Sachen
gefallen mir nicht mehr ganz so gut.
Wobei, so viel Neueres gibt's ja auch gar nicht mehr.
Okay.
Ich mach mal wieder was. Brauchen wir irgendwas
Entspannendes? Ja, hier, komm. Wupp, wupp, wupp.
Gucken wir mal, ob die Lautstärke passt.
Ja. Wupp, wupp, wupp,
wupp, wupp, wupp, wupp, wupp, wupp, wupp, wupp, wupp.
Subnautica-Musik
zum... Den Soundtrack kenn ich gar nicht.
Ich würde jetzt allerdings
mit
Wasser und so in Verbindung bringen
und nicht so super...
...entspannend
für mich.
Das ist nix für mich.
Ne, das ist nix für mich.
Das hört sich so sehr nach Tiefsee und U-Boot an.
Das ist nix, ne.
Ich hab's nicht so mit tiefem Wasser.
Das hab ich euch ja schon ein paarmal erzählt.
Alles, was nach
tiefem Wasser klingt,
mag ich nicht.
Ah, Redis-Stells, okay.
Wahlgesänge, ne, ne. So was mag ich alles nicht.
Was ich...
Okay.
Haftbefehl würde ich tatsächlich anmachen.
Das Problem ist, dass es enorm
monkatos ist. Das kann ich mir auch nicht den ganzen Tag
anhören.
Das kann ich mir just for fun einmal anhören
und dann muss ich erst mal zwei Wochen Pause
machen.
Das... Da kriegst du schon ein bisschen Gehirnschaden
bei. Aber trotzdem, ab und zu
ist das ganz nice.
Ups.
Lange nix mehr gehört. Das letzte, was ich von Haftbefehl gehört
hab in irgendwelchen News, ist, dass er sich aus Versehen
ins Bein geschossen hat oder in den Fuß geschossen
hat oder sowas.
Keine Ahnung.
Mega Gangster.
So.
Also das letzte Konzert, auf dem ich war,
war tatsächlich
vor zwei Jahren Iron Maiden
in Frankfurt. Zum zweiten Mal schon.
Und der Sound war genau...
Diesmal war es im Stadion,
nicht in der Messehalle, aber übelst mit
das verstehst nichts, ja.
Und
da hab ich mit Corona angefangen.
Ja.
Danach war ich nirgendwo mehr.
Ich wollte...
Wobei, kann ich
doch vielleicht noch...
Vielleicht hab ich das doch nicht verpasst. Moment.
Oder war das schon letztes
Jahr? Gibt gar nicht Frankfurt, oder?
Ah, das war letztes
Jahr im Sommer. Shit.
Ja, das hab ich komplett verpeilt.
Da wär ich auch gerne hin.
Heh.
Das war letztes Jahr schon.
Ja, das hab ich verpeilt.
Blind Guardian hab ich früher rauf und runter gehört.
Da ist aber auch so...
Ich weiß nicht, ich komm mir selbst übelst
Boomer vor, wenn ich dann immer sag,
ja, aber die neueren Sachen sind nicht mehr so meins.
Der Sound von denen hat sich gar nicht großartig geändert.
Aber ich weiß nicht.
Wobei das letzte Album teilweise wieder ein paar richtig nice
Sachen dabei hat von Blind Guardian, aber
so im Großen und Ganzen haben mich die letzten
Sachen nicht so extrem abgeholt, ja.
Aber dafür sind die älteren
Sachen ultra nice.
Also für mich das beste
Heavy Metal Album
bisher dieses Jahr, oder war das
Ende letzten Jahres? Ist glaube ich schon ein bisschen raus.
Was ich sehr oft gehört hab
und was ich auch immer wieder
hören kann, wenn man auf Power Metal
steht, hier. Das da.
Mega.
Man darf nicht abgeschreckt sein
von, dass das etwas
over the top ist alles.
Ach ne, letztes Jahr im Sommer, ja.
Das hat mir
glaube ich von allen Sachen, die ich letztes Jahr
neu erschienen sind, nicht gehört hab,
am besten gefallen.
Zumindest das, was mir das
als erstes in den Kopf kommt, ja.
Also
wer Power Metal mag und das noch nicht gehört
hat, sollte sich das unbedingt mal anhören.
Das ist extremly nice.
Wir können leider nichts
hören im Stream bei MonkaTos.
Aber da sind so Titel dabei
wie
Moment.
Ähm.
Und der Titel, ja.
Da sind so Lieder dabei wie mit dem Titel
Holy Flaming Hammer of
Unholy Cosmic Frost.
Alles klar, ja.
Der Titel klingt schon
so unglaublich bescheuert und so ist das auch.
Ja, beste.
Ja.
Beste.
Die, also zu dieser
Zeit, ja, zu dieser Zeit
haben die extrem viel geile Songs
gemacht von Blind Guardian.
Da konntest du dir fast alles
anhören. Ja.
Da hast du das Gefühl,
die haben aus dem Ärmel geschüttelt
ein geiles Ding nach dem anderen
rausgehauen, so. Ohne, dass sie's groß anstrengt.
Und die, die waren halt
auch zur richtigen Zeit am richtigen Ort, ne.
Da kam auch grade dann, bisschen später
kam die, kam die
Herr-der-Ringe-Verfilmung und sowas. Da hat das natürlich
ultra gut dazu gepasst.
Das basiert ja alles auf, auf Mittelerde.
Lore. Ist auch nicht
übel.
Es gibt ja manchmal so Konzerte.
So Gaming-Symphonie,
oder sowas.
Gibt's ja ab und zu.
Ist Nickelback nicht die Meme-Band, die
äh, angeblich total kacke ist?
Oder alles, alles besser als Nickelback
oder sowas? Wo ich immer nicht weiß, wo das
herkommt.
Also ich find, man kann sich
da schon einige Sachen von anhören. Das ist
halt so...
Ja. Wenn du nicht richtig
zuhören willst und trotzdem ordentliche Musik
im Hintergrund laufen lassen willst, kannst du Nickelback
anmachen. Also Nickelback ist nix, wo ich jetzt
rein zum
richtig aktiv zuhören
anmachen würde.
Ja gut, Blind Guardian kann
gefühlt eh jeder, der da ist,
den Kram auswendig singen. Wobei ich sagen
müsste, bei den neueren Sachen bin ich
aufgeschmissen, ja? Die kann ich auch nicht.
Okay.
So.
Genug rumphilosophiert.
Jetzt suchen wir mal unser Memory-Leak.
Ich zeige euch aber erst mal,
was ich die letzten
Zeiten, die letzten
drei Tage Broggers-Stells
gemacht hab.
Wir haben ja vor einer Weile im Stream
schon mal
ein bisschen hier an dieser
Webcam-Geschichte gebaut.
Aber das hat nicht richtig
funktioniert. Es lag, so dumm es
klingt, an Rust, dass es nicht richtig funktioniert
hat. Jetzt werden natürlich die ganzen
Krustentiere sagen, was?
Kann überhaupt nicht sein.
Rust is blazingly fast und das beste
ever. Und denen muss ich
sagen, doch.
Es hat an Rust gelegen.
Ganz korrekt müsste
man allerdings sagen, es hat nicht direkt
an Rust selbst gelegen, sondern
an der Library,
die in Rust programmiert ist. An der
WebRTC Library, die in Rust programmiert ist.
Die machen da irgendeinen komischen
Mist, dass es nicht funktioniert.
Auf iOS so gut wie gar nicht. Weiß nicht, was da machen.
Und auf dem Desktop hat's
auch seine laggy
Probleme. Ich glaube,
ich weiß, was das Problem ist. Allerdings
weiß ich nicht, wie ich's fixen kann.
Und am Source Code hab ich auch keinen Bock
rumzuschrauben. Ich glaube,
der Packetizer,
der die
einzelnen Videopakete
verschickt, der macht das nicht in der richtigen
Reihenfolge. Und deswegen ruckelt das.
Was auch daran
liegen könnte, dass FFmPack
die Timestamps ausliest
von den Kameras, die ich habe.
Und die Kameras sind halt billige China-Chinesen
Kameras. Da ist die RTSP
Implementierung ein bisschen schrottig und die
Timestamps stimmen nicht. Aber wenn man einfach die Sachen
ausliest und stur anzeigt, so wie sie
reinkommen, funktioniert's ziemlich gut.
Nein, nein, nein, nein.
Das Backend für eine Web-Anwendung
Das WebRTC Backend
einer Web-Anwendung in Rust
und das funktioniert nicht richtig mit iOS
mit Safari.
iOS Safari. Und ich
hab keine Ahnung warum. Safari ist
sowieso Schrott. Das ändert
nichts daran, dass man
es braucht, weil Safari ist das
einzige, was es unter iOS gibt.
Also sprich, wenn, ja Safari
ist Schrott, gäbe ich dir recht, aber du hast keine Chance
an Safari vorbeizukommen ohne iOS.
Die andere Chance wäre iOS
auszulassen und das ist, weil nachdem
ich das ja tatsächlich einzeln für mich
programmiere, weil ich meine Webcams
im Browser ordentlich anzeigen will.
Ja, aber
es ist immer noch so.
Ja, aber es gibt noch keinen anderen Browser
für iOS. Zumindest
ich zeige euch mal, was ich gebaut hab. Dazu brauchen wir
aber ein bisschen Tests. Also, ich hab das
hier weiterentwickelt. Ich hab Rust rausgeschmissen,
die Sachen wieder in Go gemacht und das Backend
in C-Sharp. Ich hab das hier mal
geklont. Also, was man damit machen kann, ist
folgendes. Ich starte das jetzt
einfach mal und da gucken wir
uns das Ganze an.
Oh, nee, kann ich nicht. Ich kann den Container
glaube ich nicht bauen.
Ich hab zum Testen Dogger-Container,
dass ich weiß, dass meine Dependency
und so alle da sind. Ich glaube, das funktioniert
nicht, weil ich noch kein Config-File
erstellt habe,
was ich dann versuche reinzumappen.
In den Dogger-Container.
Oh, XZ-Hotels, Leute!
Jetzt vorbei. Hackerman
ist drinne. Seid ihr auch schon
da? I'm in? Okay, gut.
Configuration-File
config.json was not found.
It's not optional. Ja, okay.
Config.json
Ich kopiere mir mal
was rüber, dass ich das jetzt hier nicht neu machen muss.
Also, config-Datei.
Sieht so aus.
Das muss weg. Also, mein
Team definiert, welche Kamera-Webcam-Sourcen
man abgreifen will. Hier mit einer
URL gibt dem Ding einen Namen und man kann
auch einen Cooldown einstellen, wenn das mal einen
Lesefehler hat. Wie lange er wartet, bis er
reconnectet. Das ist ganz wichtig, weil
ich hab
sehr viele billig China-Chinesen
Webcams. Nicht Webcams.
Falsche Kameras. Überwachungskameras hier.
Und die sind halt alle ein bisschen
schwachbrüstig. Dafür billig.
Und wenn man da zu oft hintereinander reconnectet,
dann ist der alte Stream noch nicht
richtig geschlossen, obwohl er abgebrochen ist. Und dann
der neue Stream braucht doppelt Ressourcen.
Ganz weird. Deswegen
5 Sekunden reconnect ist ein bisschen
klein. Deswegen sollte man eher
62 Sekunden oder irgendwie sowas machen.
Wir machen jetzt mal 5, weil wir müssen lokal
einen RTSP-Server starten. Wenn ich das Ding
jetzt hier starte, jetzt kann ich es zumindest mal
ausführen, dann seht ihr,
was ihr nicht seht.
Ups. Onfig, Jason.
Oh, bin ich pepega und hab hardcoded
Fahrt rein. Home, Max, Repos.
Ah.
Das Ding heißt Hemdchamp
2 hier. Es ist aber auch
äußerst pepega, das so in ein Skript
zu schreiben, aber ist mir egal. Es muss nur bei mir
lokal laufen. Oh, ich hab
einen Fehler in meinem JSON-File. Kann das sein?
Wo ist denn hier ein Fehler?
Seht ihr da einen Fehler? Wo ist denn da ein
Fehler? Ich seh da keinen. Ah!
Dingsfe... äh, nicht
Klammer. Hier.
Array schließen.
Fehlt.
Okay. Run. Brake.
Jetzt funzt es. Okay. Ist gestartet.
Wenn ich jetzt auf localhost
port 8044
gehe, dann kommt ihr auf die
Webseite. Die
macht nicht viel, außer einen Videoplayer anzuzeigen.
Und hier würde man jetzt normalerweise
das Bild von der Überwachungskamera
sehen.
Nachdem ich ja hier noch gerade, was er auch
versucht hier hin zu connecten,
nachdem ich noch keinen
nach keinem Server gestartet
hab lokal, der eine Webcam simuliert
oder eine Überwachungskamera simuliert,
zeigt er hier nichts an. Deswegen muss ich das gleich mal machen.
Aber man sieht ja schon eine Sache, die ich
eingebaut hab, was wirklich
ohne Mist nicht einfach
war. Ich zeige euch das mal.
Und wer ein Problem mit FFmpeg hat, oder
öfters mit FFmpeg arbeitet,
aufgepasst. Das könntet ihr auch gebrauchen.
Warum starte ich das
überhaupt so? Der letzte
Kacknoob, alter. Gehen hier rein.
Und sagen hier, Rider.
Punkt. Starten.
Wobei Rider im Background ist immer so eine Sache,
das spammt die ganze Zeit rum wie verrückt.
Naja. Wollen wir mal
auf. Ja, guck hier.
Seht ihr schon? Rider ist wieder heftig am
rumspammen. Spamchamp.
Also, was man hier in dem
Output gesehen hat, ist
Ich lass es nochmal laufen.
Ohne, dass es sich zu einer Kamera
connecten kann. Man sieht hier FFmpeg
Fehler. Guckt mal.
Hier, FFmpeg Fehler.
Und
das ist
eine, das hier ist die eigentliche
Fehlermeldung von FFmpeg.
Ja.
Wobei, ha, ne.
Das stimmt nicht. Ich hab euch Mist erzählt.
An der Stelle sieht man das noch gar nicht.
An der Stelle
da muss ich tatsächlich erstmal
einen Server Service, einen RTSP Service
starten. Ich tu jetzt mal so,
als läuft bei mir lokal eine Webcam.
Ja, hier. Hier hat
man es gesehen. Also, guckt mal.
Das ist ein FFmpeg Fehler an der Stelle.
Normalerweise sieht der FFmpeg
Fehler genau so aus. Und du weißt
nicht um was es geht.
Und ich hab jetzt eine Custom FFmpeg
Logging, tja, wie nennt man das?
Extension Custom Callback
programmiert, der unter anderem
anzeigt, von wo
eigentlich der Fehler kommt.
Und jetzt passt mal auf, das ist wirklich
so krass durch die Brust ins Auge,
wo man sich wieder fragt,
wer hat sich das ausgedacht?
So, hier.
Das da.
Äh, wo geht's los? Hier.
Hier.
Das da.
Das ist die Custom FFmpeg
Logging Funktion. Und jetzt haltet
euch fest, ich hab keine Ahnung,
wer dachte, das ist ne gute Idee.
Es ist auch überhaupt nicht richtig dokumentiert.
Du findest dazu nix.
Oder wenig.
Zumindest, wenn man FFmpeg
nicht den Standard, das Standard
Logging von FFmpeg verwenden will,
kann man eine eigene
Funktion setzen, mit
dem, also man sagt,
AVLogSetCallback und dem muss man dann
quasi eine Funktion übergeben.
An die FFmpeg, die Logs schickt.
Anstatt, äh, default auf die,
auf die, äh, ins Terminal.
Aber,
wer jetzt denkt, ja ist doch easy, haust da nen Callback
rein, sagst, äh,
print line und so und dann ist's gut. Nein.
So einfach ist es natürlich nicht. Also.
Als erstes braucht diese
Funktion erstmal super
obskure Parameter, wo
keiner so genau weiß,
was die, was die machen. Ja?
Wenn wir jetzt hier mal gucken danach, uns die Hilfe
anschauen, da stellen wir fest,
aha, alles klar,
also an Parametern, an Parametern
brauchen wir hier erstmal ein,
ein, ein was? Ein,
ein Callback, der,
Moment, der
als erstes Argument nen Void Pointer
kriegt, ohne irgendwie
nen Name, einfach nur nen Void Pointer. Man hat
absolut keine Ahnung, was das ist.
Beste,
es ist, es ist einfach, also, es ist,
du, du weißt noch nicht mal, was das für nen Namen
bekommt.
Es ist einfach nur nen Void, du weißt nicht, wofür der da ist.
Der ist, der, der, der muss halt einfach da sein.
Ja? Also, du kriegst
einfach irgendwas, irgendeinen Pointer auf
irgendwas, wo du nicht weißt, was es ist.
Das ist eh schon immer mal super Geschichte.
Danach musst du, so wie es aussieht,
halt die, das Log Level
übergeben. Das steht hier aber auch nicht richtig
dabei. Vielleicht, ja,
ah, hier steht's, hier, doch, hier steht's ein bisschen besser.
Hier steht's ein bisschen besser.
Also, das erste ist ein Void Pointer
auf ein AVCL.
Das zweite ist das Log Level.
Das dritte ist die Log Zeile und das ist
dann die Argumente für die Log Zeile.
So. So weit, so gut.
Und dann hab ich das hier gelesen.
Ich dachte mir, was zum Teufel, FFmpeg, was
wollt ihr von mir?
A Pointer to arbitrary struct, of which the first
field is a pointer to an
AV-Class struct.
Da hab ich da
vorgesessen und dachte mir so, hm,
was
willst du mir sagen, FFmpeg?
Und ich hab dann das Internet durchsucht
und ich habe nur ganz
wirre Beispiele gefunden,
die alle nicht das gemacht haben, was ich machen
wollte. Und dann hab ich selbst ein bisschen
rumprobiert. Und dann bin ich auf folgendes
gekommen. So.
Das hier ist mein Callback.
Als erstes guck ich, ob
dieser komische Void Pointer 0 ist.
Wenn der 0 ist, dann mach ich nix.
Sicher ist sicher. Ich weiß nicht, in welchen Fällen der 0
sein kann, aber dann mach ich nix.
Dann, und jetzt kommt übelst nice
C-Magic.
Wer jetzt etwa denkt, das hier
wäre der Pointer schon auf die
Daten, die man haben möchte, der liegt
falsch. In Wirklichkeit
ist das ein Void Pointer
auf einen weiteren Pointer
und wenn ich den referenziere,
dann bekomme ich einen Pointer
zu einer AV-Class.
Also.
Ist jetzt schonmal geil.
Ist schonmal logisch, oder?
Leute. Findet ihr nicht auch?
Also ich finde, das ist
Try offensichtlich, was
die hier wollen.
Ja.
Also das ist sehr logisch. Das habe ich auf dem
Stack Overflow Post gefunden.
Stand das nicht so genau in der Doku.
Das kann sein, dass das tatsächlich
so hier drinnen steht irgendwo. Ja.
Aber das habe ich bei Stack Overflow gefunden.
Dann, weil
wir ja nicht in C, sondern in C-Sharp sind,
dann muss ich den Class Name
auslesen
und in den .NET
String packen. Okay?
Und dann kann ich gucken,
ist das,
was in dieser AV-Class
drinnen steckt, ein
AV-Format-Kontext.
AV-Format-Kontext ist das,
wo FFmpeg
die Streaming-Quellen
hier ausliest. Ja.
Da steht auch die URL drinnen.
Auf was
es eigentlich versucht gerade zuzugreifen.
Das heißt, ich gucke, ist
das hier denn ein
AV-Format-Kontext?
Übrigens, dass man dann P0,
diese Class einfach in einen AV-Format-Kontext
casten kann,
steht nirgendswo.
Das steht in keiner Doku drinnen.
Das habe ich in keinem Beispiel gefunden,
noch nicht auf Stack Overflow.
Das war einfach ausprobieren, dass das funktioniert.
Ja. Also sprich,
das hier ist nicht irgendwie eine Logging-Klasse,
obwohl das ein Logging-Callback ist.
Nein, das ist eigentlich ein Pointer
auf
die Instanz, dieses
Kontext, die das
Logging ausgelöst hat.
Das steht nirgendswo. Ich habe es nirgendswo
gefunden. Das war einfach pures Glück,
dass ich es mal ausprobiert habe zu casten und das hat
funktioniert. Was ist denn nur mit
casten los?
Und dann kann ich
dort die URL auslesen. Ja.
Weil jetzt weiß ich ja, dass
das ein AV-Format-Kontext
ist und der hat auch ein URL-Field.
Dann lese ich die URL
aus, dann checke ich noch,
ob das Log-Level
größer ist als das
Mindest-Log-Level.
Und dann mache ich noch ein bisschen
.NET
C Interop Magic
und am Ende
printet er dann quasi
die normale Log-Zeile plus
die URL, die er aus dem Kontext
ausgelesen hat. Also
das da.
Und das ist alles dafür notwendig,
dass FFmpeg-Logs
normal in den .NET
Logs auftauchen
und man bei einer Fehlermeldung dahinter
angezeigt bekommt, von welcher
Quelle das eigentlich kommt.
Also ganz, ganz
wirrer Shit auf jeden Fall.
So. Aber jetzt zeige ich euch mal,
was das überhaupt macht. Das Logging ist
jetzt ja nicht so wirklich das, was
einen interessiert. Also ich
muss erst mal fake-weise
eine Kamera starten.
Ich brauche dazu mal
ordentliches Videomaterial.
Und wer sich jetzt denkt, ey Max,
das, was du hier verwendest, ist ja kein richtiges Videomaterial
von einer Überwachungskamera. Das ist richtig.
Mein Videomaterial ist
zum Testen ist anspruchsvoller als
das, was von einer normalen Überwachungskamera kommt.
Von einer normalen Überwachungskamera kommt
vielleicht mit Ach und Krach
1080p,
15 FPS und
3 Mbit. Variable
Bitrate. So.
Aber, damit ich das jetzt richtig testen
kann mal und dem Memory Leak, dem
zumindest ich vermute, dass ich ein Memory Leak
habe, auf die Schliche zu kommen,
brauche ich ein Video, was echt
ordentlich Daten verursacht.
Also sagen wir mal 1080p
60 FPS.
Das heißt, ich brauche jetzt irgendwie erst mal
ein 1080p 60 FPS Video.
Und nachdem ich ja keine Copyrights
hier verletzen möchte,
nehme ich einfach ein Video von mir.
Am besten irgendwas mit Gameplay.
Das hier.
Okay, das ist, das ist die...
Gibt's das
Game eigentlich mittlerweile?
Keine Ahnung. 4K
1000... Ey, wir können's. Wollen wir's probieren?
4K 120
FPS.
Gibt's da irgendwelche Videos?
8K. 8K. Wait a minute.
Das ist überhaupt nicht 8K.
Das ist 4K.
YouTube, YouTube
erzählt Shit.
Und außerdem, außerdem ist mir das ein bisschen
zu krass. Gibt's
da nicht vielleicht kürzere Videos?
So irgendwie
2 Minuten vielleicht so?
Ne, aber 60, mit 60 FPS
gebe ich mich nicht zufrieden.
4K HDR
Ja, das ist glaube ich ganz gut
hier. 4K
4K HDR
brauchen wir nicht. Aber es ist, es ist
4K, es ist
4K 120. Kann YouTube
überhaupt 120
FPS? Was ist denn hier
die Formate für das YouTube Video?
Ne, kann YouTube gar
nicht.
Schau mal geil, dass es hier überhaupt
4K 120
FPS heißt, wenn YouTube nicht mal 120
FPS kann.
Sehr sinnvoll. Ja.
Sehr, sehr sinnvoll.
Ist das H264?
Natürlich nicht. Es ist VP9.
Oh ne, das kann ich nicht nehmen, Leute. Ich muss das Ding erst
konvertieren. Da bin ich jetzt, da bin
ich jetzt 45 Minuten am rendern
oder so. Wir sollten
vielleicht ein bisschen was weniger übertriebeneres
nehmen. Gibt es irgendein
kurzes 4K
60 FPS? Irgendeine kurze
4K 60 FPS Demo.
Hier. Das ist doch
gut. 45 Sekunden.
Ja, das ist gut.
Das nehmen wir. Einfach mit
zwei Augen anschauen, dann hat man
120 FPS korrekt. Ja.
So sieht's aus.
Deswegen sieht das menschliche Auge ja plus
15 FPS. Aha.
Was haben wir denn da?
Ja, das ist eine gute Idee.
Ja, dann kann man das direkt runterladen.
Ja, Moment. Das ist aber
der ganze Film. Wenn ich das
umschneiden will,
bisschen was kürzeres raus ist,
bin ich blöd.
Ich lade jetzt mal das 4K
YouTube Video runter. Dann gucken wir mal, ob's
funktioniert. Format
wir wollen haben
642.
Das ist
Video only.
Gucken wir mal, ob das das richtige ist. Das sollte
zumindest relativ schnell runtergeladen sein.
Alter, heute geht
das Video da vorne mal richtig ab.
Okay, lass uns mal gucken. FF Probe.
Ist das Video Probe?
Moment.
Das ist ja Premiere.
FF MPEG kann was
nicht abspielen.
Das habe ich ja noch nie erlebt.
Das muss aber sehr
broken sein. Wahrscheinlich,
weil's HDR ist. Kann das sein, weil's HDR
Content ist, dass FF MPEG
Probleme hat mit HDR? Ich hab mal so ein fucking
Demo Video bekommen. Sven, danke für den Sub.
Haben wir vielleicht
HDR? Alter, es gibt ja
nix. Es gibt nix.
1080p 60fps.
Okay, meinetwegen.
Was ist denn
Webmdash?
Das kann FF
MPEG auch nicht, oder?
Was ist das für Autovervollständigung?
Wieso? Ganz normal.
Ja, aber das letzte, also FF MPEG ist da
mein und das ist kaputt.
Das ist natürlich schon echt doof.
FF Play.
Okay, das funzt. So, und jetzt kommen wir
das. FF MPEG, jetzt können wir das
konvertieren zu
ähm
A264, oh ne.
Wie ging das? FF MPEG
FF MPEG
Ich kann mir das immer nicht merken. Ich glaube
FF MPEG minus I
und dann musste man
musste man, oh keine Ahnung.
Bitrate und sowas. Gibt's
da nicht irgendein schönes Beispiel für
ultrafast, superfast?
Ja, das muss man machen.
Genau.
Preset Slow, nein.
Preset
ultrafast
CR22 ist okay.
Audio non
und Output
blub.mp4
oder blub.ts, bei mp4
spackt er manchmal rum.
Okay, konvertieren funktioniert.
Und Multithread
konvertiert auch ordentlich schnell.
Das Video ist bloß 46 Sekunden.
Das sollte passen.
Kenne ich nicht, dass es grau hinterlegt wird.
Ach so, das meinst du.
Ja, das sind Sachen, die ich schon eingetippt habe.
Also, wenn ich hier LS eintippe,
Leerzeichen, guck, du meinst das hier hinten, gell?
Wo ich das Auto
completen kann.
Das nennt sich
Das nennt sich
ZSH
Auto Suggestions.
Das ist das Projekt
hier. Hat nur 30.000, äh
29,4 Github Sterne.
Das ist das hier.
Das gibt es auch
Arch, by the way.
Natürlich
im Package Manager.
Excellent.
So, hat das jetzt funktioniert
mit dem Video konvertieren?
Ja, hat's.
So, FF Play
blub.ts
Videofunst noch
FF Probe
Ich hoffe es
H264, hi. Oh fuck.
H264, hi. Oh, das glaub ich nicht,
dass das funktioniert.
Ich hab hier ein Sample Video noch drinnen,
wo ich weiß, dass das funktioniert.
FF Probe Output TS
Moment, das ist ein Video.
Aber das ist ein
1280x1000, aber 60
FPS Video. Ja, was auch immer.
Weiß drauf. Und das ist, das ist
Baseline. Das muss ich nochmal machen.
Ich muss dem, ich muss dem sagen.
FF MPEG H264
Dass der nur Baseline verwenden soll.
Weil der
sonst rumspackt.
Der Browser beim Abspielen
über WebRTC.
Was darf man denn da alles angeben?
Baseline.
Okay, dann müssen wir das ganze noch.
Was? Was ist falsch?
Muss das vielleicht mit
Was?
Äh.
Was ist falsch da dran jetzt?
Muss da ein Gleichheitszeichen dazwischen oder was?
Oder muss das nach
VFF MPEG kommen?
Hä?
Ach shit.
Oh man, jetzt ist das auch noch in der falschen Farbe.
Das ist ja echt
schlimm hier ein fucking Demo Video
zu bekommen für meine Zwecke.
Jetzt bin ich, okay
wir testen mal, ob das
abspielbar ist.
Im Browser.
Wenn ich das, das glaube ich nicht.
Jetzt müsst ihr auch die Farbdings konvertieren.
Ich habe gehofft, dass macht,
dass wir den Browser nicht laufen. Nee, im Leben.
Probieren wir mal,
probieren wir mal aus.
Okay, ich hätte nicht gedacht, dass es so kompliziert ist
ein Demo Video zu kriegen.
Sich zu konvertieren.
Probieren wir mal aus, ob das funktioniert.
Also.
Ich starte das jetzt mal und ich hoffe,
das erscheint dann im Browser.
Run.
Und jetzt muss ich
hier mein RTSP Server starten.
Ich tue jetzt so, als bin ich eine Überwachungskamera.
VFF MPEG.
Oder Minus RE hier.
Das brauche ich.
Output.
Blub. TS.
Achso.
Ich bin irgendwie im falschen Ordner.
Repo. Cam.
Blub. TS.
Okay, ich glaube nicht, dass es funktioniert.
Okay, starten wir es nochmal neu.
Der tut jetzt zumindest so, als liest er von der Kamera.
Aber ich glaube nicht,
dass es im Browser funktioniert.
Local Host.
Ey, Funs.
Geht einfach.
Okay, das Demo Video.
Guck mal, wie viel CPU Last das überhaupt schon verursacht.
Also, es funktioniert.
Das ist quasi mein Fake Überwachungskamera Video.
Ja.
Und wer sich jetzt denkt, wie ist doch nichts
Spektakuläres, dass der im Browser ein Video
abspielt. In dem Fall ist das nicht einfach
ein Video abgespielt über
den Browser.
Das Video wird live über
WebRTC gestreamt
in den Browser. Das ist kein
normales HLS
oder sonstige
Videosachen. Das ist WebRTC
Streaming von H.264
encodedem Content in den
Browser über WebRTC.
Also quasi
das, was die ganzen Überwachungskameras
ausgeben. Und das ist auch der Grund,
warum ich das gebaut habe. Ich will eigentlich meine
Überwachungskamera streamen.
Und das ist jetzt halt einfach mal hier
testweise mein
Ersatzvideo anstelle
von Überwachungskamera Footage.
Absichtlich was hochauflösendes
und was
mit übertriebener Bitrate für
Überwachungskameras und alles, weil
ich will ausprobieren oder testen, ob ich
einen Memory Leak habe, weil ich glaube, ich habe
einen Memory Leak. Ich zeige euch das mal.
Wir machen jetzt mal hier Docker Status
äh Stats
äh Stats
und jetzt starte ich
das Ding mal im Container. Passt mal auf.
Das am Anfang ist ja noch nichts
Neues. Ich starte jetzt mal das Video.
Oder ob ich das Video starte oder nicht,
ist eigentlich egal. Und das geht
jetzt immer so weiter. Irgendwann sind wir dann bei 300
MB
und irgendwann sind wir bei 400 MB.
Deswegen vermute ich,
dass ich irgendwo eine Memory Leak habe, aber
ich weiß nicht wo.
What language are you speaking? German.
We are sitting
We are all sitting in one boat.
So und
Ey
Findet ihr nicht auch, dass es ein bisschen
nach einer Memory Leak aussieht?
Es ist schon ein bisschen verdächtig, oder?
Dass es immer
so im gleichen Takt, immer
die gleiche Sache hochgeht.
Warum ich nicht Rust genommen habe?
Ich habe Rust genommen. In Rust geht es nicht.
Weil die Rust WebRTC Library irgendwelche
Bugs hat. Deswegen mache ich das jetzt
in Go, die WebRTC Geschichte.
Aber die FFmpeg Sache mache
ich in .NET.
Ich finde, es sieht ein bisschen nach einer Memory Leak aus.
Chat, lasst uns mal abstimmen.
Memory Leak ja oder nein?
Sieht schon verdächtig aus. 0.
Okay, wir machen mal eine Abstimmung.
Memory Leak
Ja, nein.
Wir sind schon bei 132.
Leak zur, oh nein, was habe ich wieder
geleakt? Vielleicht.
Jetzt muss man sich
festlegen.
Doch gar nichts.
So und ich habe mir gedacht.
Okay, also es denken alle, es ist Memory Leak.
Also ich habe mir gedacht, okay, es könnte auch
generell an .NET liegen.
Und habe mal
eingebaut.
Dass der, wenn ich
das hier mal einschalte, dass der
alle 5 Sekunden
Garbage collectet.
Das macht man normalerweise nicht, aber
nur zum testen mal.
Dass der alle 5 Sekunden
Garbage collectet.
Dann werdet ihr sehen, es sieht
nicht viel anders aus.
Ach ja, wir machen das übrigens,
wir verdeutlichen das nochmal
ein bisschen mehr. Und zwar ich gehe
in meine Config und
ich tue einfach so, als habe ich mehrere Kameras.
Die greifen zwar alle auf den gleichen
Stream zu, das ist aber egal.
So machen wir mal, oh ich glaube,
da raucht meine VM gleich ab.
5 Kameras
mit
das wird nicht funktionieren ey.
5 Kameras mit 4K Inhalten
in der VM abspielen, das wird
nix. Kommt noch
ein Video zu dem XZ damals als HP?
Ja,
ich habe mir das überlegt tatsächlich, aber
ich denke halt, das ist ein bisschen
zu speziell für YouTube.
Und die, die das persönlich
interessiert, weil sie betroffen sind, die haben sich wahrscheinlich
anderweitig schon informiert.
Es ist jetzt ja auch nix Neues, das ist seit
Freitag bekannt.
Was wird programmiert?
WebRTC Streaming, wobei ich eigentlich
eher mal nach einem Memory Leak gucken will.
Und dann
weiß ich gar nicht, was wir machen.
Vielleicht, ich habe hier auch die,
vielleicht basteln wir auch, gucken wir
ob ich heute meinen
ESP zum Laufen kriege, oder
wir können per Zigbee versuchen, die
Lidl Steckdosenleisten anzuschließen,
anzusteuern,
aus Home Assistant. Ich habe hier, ich habe mir
3 Lidl Steckdosenleisten gekauft.
So, gucken wir mal, ob das Memory Leak jetzt schlimmer aussieht, als
vorher. Hm,
doch kein Memory Leak?
Das geht eigentlich nicht schnell genug hoch, dass
es aus dem Unmanaged Code irgendwie kommen kann.
Ne, das sieht nach ganz
normalen .NET Schwankungen aus.
Hä?
Ich habe genau das gleiche, ich meine, ihr seht's,
ich habe es erst wieder einkommentiert.
Das gleiche habe ich vorher auch schon mal gemacht,
regelmäßige Garbage Collection, und jetzt...
Hä?
Naja, aber das kann nicht
an den Webcams liegen. Seriously, das ist,
da gehen gerade die Ul-, die
Megadatensachen durch hier.
Ey, das Funst.
Meine CPU, Leute.
Die CPU ist übelst am brennen.
5 4K Videos, 60 FPS ist
einfach zu viel, ist gut, ne.
Okay, ich nehme das zurück, ich glaube, ich habe doch
ein Memory Leak.
Hä? Bin ich total hängengeblieben?
Guckt mal, ich hatte das hier vorher
drinnen, und ich habe es
dann auskommentiert, weil ich mir gedacht habe,
okay, eigentlich wurscht, weil
scheint woanders zu sein, und wenn
ich es jetzt wieder reinmache mit dem Collecten,
what the fuck?
Weil das sieht jetzt nicht mehr so
Memory Leakig aus, alles.
Ist viel zu lahm dafür, um da...
Ja,
das ist normal, dass .NET
eigentlich ein bisschen ansteigt. Irgendwann,
außerdem, das ist ja auch,
das ist ja die Docker Usage.
Also, das muss erstmal alles von Docker wieder abgegeben
werden, ans Betriebssystem zurück, und
alles.
Das, na gut, was von Docker,
von Docker ist Blödsinn, von der .NET Runtime
muss das erstmal wieder zurückgegeben werden, also
das kann, das ist normal, dass das ein bisschen
steigt, und irgendwann bleibt
es dann auf dem gleichen Level. Das ist für .NET
normal. Das hier, aber ganz ehrlich,
wenn es wirklich in Memory Leak wäre,
in der Verarbeitung,
wissen wir gar nicht, mit irgendwelchen großen Analyse-Tools
oder so dran, wenn das wirklich ein
Memory Leak wäre, hier, in der
Verarbeitung von
Videodaten, dann würde
jetzt der Speicherverbrauch, würde explodieren.
Bei 5, 4K,
60 FPS Videos.
Übrigens mal, just for fun,
wollen wir mal was ausprobieren.
Wollen wir mal gucken, wie viel Netzwerktraffic das gerade
verursacht. Guck mal, was habe ich denn
für eine IP, äh, ifconfig.
Das ist doch der Rust-Kram.
Ja, nur das ist nicht mehr in Rust,
weil mit Rust hat es nicht funktioniert.
Das ist jetzt in Go mittlerweile.
Rust größer Go
confirmed. Probieren wir es mal
hier aufzumachen. Okay, ich wusste,
dass mit meinem Video was kaputt ist.
Ah, ne, ne, okay.
Ich habe nichts gesagt. Der braucht ein bisschen.
Wahrscheinlich braucht der
Grafikkarten-Decoder ein bisschen.
Okay, jetzt mal gucken wir mal,
wie viel,
na, geht doch noch.
45 MB.
Okay, jetzt können wir,
okay, ich habe eine Idee. Jetzt machen wir nochmal was.
Jetzt gucken wir mal,
wie viel, es ist komplett
useless shit, den ich jetzt mache, aber
just for fun, ja.
Wir gucken mal,
wie oft ich das Ding parallel starten
kann, bis entweder meine
CPU, meine Grafikkarte
oder meine
Streaming-Software nachgibt. Oder
mein Netzwerk nachgibt. Eins von beidem.
Also, ein offenes Tab
verursacht ungefähr 50 MB
die Sekunde Traffic.
Zwei Tabs?
Na, OBS macht nicht so viel. Außerdem
wird OBS nicht getrackt.
Aus meiner VM raus.
Ah, 126 MB.
Okay,
ich denke, ich denke bei
vier Tabs ist Schluss.
Chrome braucht auch schon ganz schön lange,
bis es anfängt zu laden, oder?
Ah,
ich würde sagen, es laggt schon
etwas, ein bisschen.
Ich habe, ich habe was dazu
eingebaut, dass man sieht, ob es laggt.
Und zwar, okay, jetzt haben wir schon
200 MB
die Sekunde, 260 MB die Sekunde.
Ich habe was eingebaut, und
zwar,
man sieht alle 30 Sekunden
die Q-Size, mal gucken,
ob die ansteigt. Es wird alle 30
Sekunden die Q-Size ausgegeben
von meinen Bildern,
wie sie verschickt werden.
Okay, noch läuft
alles gut.
Noch läuft alles gut. Die Q-Size ist
bei null, also die wird
direkt verarbeitet.
Selbst macht
es ganz gute Auslastung in der VM, das
Streaming. Mal gucken, wie viele Tabs.
Ich meine, das ist ultra unrealistisch,
ne? Es geht hier um
Überwachungskamera-Footage.
Und niemand hat
als Überwachungskameras
4K 60 FPS
fünfmal laufen
und lässt sich das streamen.
Oh, oh, oh, oh, oh,
oh, oh, ah, nee, das hat...
Oh, es
laggt, es laggt, Leute, es laggt.
Jetzt ist die Frage, woran liegt es?
Liegt das an...
Liegt das an meinem Netzwerk-Trafik?
Der nicht mehr kann
hier von der VM zum Host?
Das sollte es eigentlich nicht sein.
Oder liegt das an meiner Grafikkarte, an CPU...
Warte mal, ob die...
Oh, okay. Es kann auf jeden
Fall nicht mehr schnell genug verarbeitet
werden an irgendeiner Stelle. Die Q-Size
für die Bilder steigt gerade
an wisst ihr ob man infos aus teams bekommt ohne webhooks also nur lokal ja und nein offiziell
ist teams nur über diese komische wie heißt dieser ab diesen komischen workflow für teams vorgesehen
die last auf der vmd ist ordentlich ja dies aber nicht genau eines krebs genau und du musst dir
aber dass du sachen machen kannst in teams musste in der eigene musste der quasi eine eigene app mit
token und sowas registrieren das ist ziemlicher rotz was du machen kannst ist natürlich das markt
microsoft allerdings nicht so du kannst den browser benutzen du kannst dich in einem browser
in teams anmelden und dann browser automatisierung an teams rangehen das ist sehr müßig und teams ist
nicht dafür ausgelegt aber das geht auslastung von der vm die ist so semi so ein drittel ungefähr ist
die vm ausgelastet es könnte
es könnte ernsthaft es könnte aber auch wirklich an meiner grafikkarte liegen weil
ich habe hardware ich habe hardware decoding an und hardware decoding die grafikkarte auch
obwohl sind deine 40 90 ist die hat ja auch nicht unendliche hardware decoder gpu wo ist
es denn eine gpu ist doch schon da also daran daran liegt es nicht
bei der wm macht meine gpu so wenig kann das video nicht gpu decodet werden läuft das gerade eventuell
cpu decodet oder was ist da los ich weiß woran es liegt weil der cpu ist einfach am ende okay ja das
wird es auch erklären 32 gig ram belegt und cpu am ende
na gut ich war freiwillig ein paar tabs zu ist okay
ich glaube gar kein bisschen probleme dass alles da wieder ranzukommen
aber an meiner software liegt dass schon mal nicht ja das funktioniert okay was sag die
speicherauslastung 208 ne leute wir haben keinen memory leak damit hat sich das stream
thema für heute erledigt eigentlich wollte ich gucken woran das memory league liegt aber anscheinend habe ich gar keine nep grown
Das ist natürlich sehr doof,
aber ich kann euch trotzdem ein bisschen was zeigen,
weil ich es gebrogert habe.
Nee, Quatsch, geht noch nicht off.
Ich habe noch massig Zeit.
Es gibt noch genug Zeug, was wir machen können.
Bei solchen Videos hier im Hintergrund,
da weiß ich mittlerweile nicht,
ob sowas gerendert ist oder echt.
In dem Fall würde ich,
gerade durch die kleinen Details am Ding,
ich würde auf echt tippen,
aber ich wäre mir nicht
hundertprozentig mehr sicher,
ob das im Hintergrund echt ist oder gerendert.
Könntet ihr es wirklich,
also ich tendiere zu echten Kameraaufnahmen,
aber könntet ihr das
in der heutigen Zeit
mit wirklich Gewissheit sagen,
ob Render oder echte Aufnahme?
Also ich nicht mehr.
Ich bin mir relativ sicher, es ist echt,
aber so meine Hand dafür
ins Feuer legen würde ich nicht.
Ja, nice.
Ich kann mich jetzt auf der einen Seite freuen,
ich habe doch kein Memory Leak,
aber auf der anderen Seite
ist doof,
weil was mache ich denn jetzt mit euch?
Chatgear.
Also ich habe das,
was wir das letzte Mal gebaut haben,
ich habe das alles noch ein bisschen verbessert.
Also man kann jetzt,
also Sinn der Software,
ich erkläre euch das nochmal.
Das ist übrigens was,
was ich auf GitHub pushen werde,
aber was ich weder maintaine
noch irgendwas mache.
Da kann man sich Sachen abgucken,
benutzen ist eher nicht so das.
Ich habe ein Problem bei mir daheim
und zwar ich habe,
wie viele Überwachungskameras habe ich?
Am Hoftor,
im Hof,
an der Terrasse,
im Flur,
im Keller
und am Katzenklo.
Sechs,
wenn ich jetzt keine vergessen habe.
Ich glaube sechs Stück.
Sechs Überwachungskameras
und ich möchte
die Streams von den Überwachungskameras
in meinen Browser bekommen.
Also das Video hier ist jetzt stellvertretend
für Streams von meiner Überwachungskamera.
Kamera,
nur etwas hochauflösender
und anstrengender als
Überwachungskamera Bild.
Ja, aber es ist wie es ist.
Geht ganz normal über RTSP
wie jede Überwachungskamera auch
nur gerade lokal
only zum testen.
Und ich habe da ein Problem mit.
Ich finde keine gescheite Möglichkeit
oder ich habe noch keine gescheite
Möglichkeit gefunden.
Videos von Kameras
in den Browser zu streamen,
möglichst latency free
und ohne irgendwelche irgendwie Qualitätsverlust
mit Reencoding und so ein Shit.
Late also möglichst geringe latency
eins zu eins das Bild vom Stream
abgreifen und in Browser packen.
Was was geht eigentlich gerade ab
mit meiner VM?
Warum ist sie?
Warum ist sie so am Limit
und so abkacken?
Restreamer.
Ja klar.
Ich nehme mir den Cloud Service dafür.
Ich glaube Firefox ist da gerade
ein bisschen bisschen ab am
eskalieren. Es gibt
einige Projekte,
nee,
Restreamer wird das
aber können. Ich glaube nicht, dass
das dafür das Richtige ist.
Ja, da kann RTSP,
ist halt
wiederum die Frage, wie kriegt man da,
das ist, ich vermute mal, dass Restreamer
eher dafür gedacht ist, dass man
quasi von einem Streaming-Service was abgreift
und in den anderen reinpusht.
Da gibt es keine Webseite
für WebRTC oder sowas.
Kann das Ding überhaupt WebRTC?
Nee, kann's nicht.
Nee, kann kein WebRTC.
So, es gibt
allerdings ein paar Projekte, die
sagen, dass sie das können.
Da gibt es GoTo, WebRTC
und so. Es gibt einige Projekte,
die das, da steht
HTML5 Video Player und weiter.
Was hat das jetzt genau damit
zu tun?
Das eine hat mit dem anderen nichts zu tun.
Ich will den Chat aufmachen.
Chat, gell.
So, es gibt ein paar Projekte,
die angeblich sowas machen. Ja, zum Beispiel
das da habe ich ausprobiert oder
RTSP, ToWebRTC.
Es gibt ein paar Projekte, die ähnliche Sachen
machen. Die nehmen einen Livestream
von der Kamera und streamen
den im Browser über WebRTC.
WebRTC hat den großen Vorteil,
dass es die
Latency-freiste Technik ist, die es
für den Browser gibt.
Es ist nicht wirklich richtig latency-free.
So ein paar Millisekunden,
ein paar Frames.
Du bist hinten dran, bist du immer.
Aber doch ziemlich, ziemlich gut.
WebRTC ist übrigens auch das, was
so Sachen wie Teams benutzen für Videokonferenzen
und sowas unten drunter.
Also möglichst latency-free Video
verschicken. Und das klappt auch
erstaunlich gut. Und ich habe nichts
gefunden. Ich habe diese ganzen Projekte ausprobiert
und die machen
alle Probleme mit meinen
Kameras. Entweder laufen sie
auf einem meiner Tablets nicht, sie laufen auf dem
iPhone nicht richtig, sie laufen irgendwie
auf dem Desktop nicht richtig.
Internetverbindung, Kackenlaufen, whatever.
Irgendwas ist immer scheiße
und die Dinger funktionieren nicht richtig.
Deswegen habe ich jetzt meine eigene Sache
programmiert, die genau für
eine Sache gut ist, meine
kaputten, billigen
China-Chinesen-Camps, die
Streams abzugreifen und in den Browser
zu packen.
Mehr soll das
nicht machen.
Und es funktioniert. Es connectet sich über WebRTC
und dann streamt es das Video
von den Überwachungskameras.
Wie gesagt, das ist jetzt ein Beispielvideo
vom lokalen RTSP-Server. Macht keinen Unterschied,
ob von Überwachungskameras oder hier.
Das ist das gleiche
Videoformat und das gleiche
Übertragungsprotokoll von den Kameras
sein. Das funktioniert ganz gut.
Also die Latenz über ganz normales HLS-Streaming
oder sowas ist enorm. Das sind mehrere
Sekunden Unterschied.
WebRTC ist tatsächlich relativ
nah an
geringstmögliche
Latency im Browser.
So, und damit
das Ganze funktioniert,
habe ich richtig hart rumgebastelt.
Die Software besteht
aus einer Komponente in
Go. Die war mal
in Rust, aber die Rust-Library funktioniert
nicht so gut wie die Go-Library, weil
die Rust-Library nur ein Klon der
Go-Library ist. Mir wäre Rust
in dem Fall lieber gewesen, weil sich Rust
interopt mit anderen Sprachen besser
funktioniert als Go interopt mit anderen Sprachen.
Aber so ist es halt.
Naja, mit Rusten.
Ich bin kein krasser Go-Expert,
aber so sieht der
Go-Teil, wobei ich zeige euch erstmal den .NET-Teil.
So, also es funktioniert folgendermaßen.
FFmpeg geht her.
Hier sieht man
das. FFmpeg
geht her. Das ist ganz viel FFmpeg-Magic.
FFmpeg geht her
und liest von der jeweiligen
Kamera-URL, also in
dem Fall ist das hier unten mein
RTSP-Server. Das ist
im Prinzip das, was man auch in der
Config einstellt hier. Da wird nochmal
normalerweise kommt da hier die URL
zur Kamera hin.
Jetzt halt hier zum lokalen Stream.
FFmpeg liest den ganzen Kram ein. Es werden
5-headigste
FFmpeg-Optionen gesetzt.
Fragt mich nicht, warum die da drinnen
sind, zum größten Teil.
Die sind drinnen, weil sie am besten funktionieren.
Und der entscheidendste Punkt war
das hier.
Reorder-Queue-Size auf 0 zu stellen.
Ansonsten hat das übelst krass
rumgebackt
mit meinen China-Kameras.
Und ich weiß auch warum.
Weil die RTSP
Timestamps,
die meine Videokameras
schicken,
die China-Kameras, die sind kaputt, die stimmen nicht.
Und FFmpeg
versucht quasi dann, die Pakete, die es
übers Netzwerk bekommt, in die richtige Reihenfolge
zu bringen. Problem ist nur, die richtige
Reihenfolge ist falsch, weil die Timestamps
oftmals nicht stimmen von den Billig-Kameras.
Deswegen, indem ich das Reordering
abschalte, wird einfach
das, was reinkommt, weitergeschickt
im Browser. Sofort, sobald es da ist.
Und dann stimmt die Reihenfolge wieder.
Und dann macht FFmpeg
ganz viel FFmpeg-Magic
und liest die Kamerastreams.
Und dann
übergibt es die Kamerastreams an Go.
Und Go
schickt die
Kann man das ein bisschen größer machen?
Und Go schickt
die Sachen weiter
an den Browser.
Macht es nicht Sinn, die FFmpeg
Dickkram auch in die Konfig zu packen?
Nee.
Das ist für alles gleich.
Du kannst indirekt ein paar Optionen
setzen.
Warum nicht Rust?
Dankeschön für den Sub.
Bist du jetzt wirklich erst in den Stream gekommen?
Ich habe das, glaube ich, heute schon 50
Mal erzählt, warum nicht Rust.
Der Witz ist, das war Rust.
Das war Rust ursprünglich.
Ach, ich habe mich verguckt.
Und der Friedrich Merz,
der bekannter Rust-Fan ist,
hat das gefragt.
Also, das war ursprünglich in Rust.
Was man hier sieht,
das war mal ursprünglich in Rust
programmiert hier.
Man entdeckt da übrigens sehr viele Ähnlichkeiten
zu meinem Go-Code.
Was aber auch daran liegt, dass die Rust-Library,
die ich verwendet habe, ein Clone der Go-Library ist.
Und
Rust funktioniert das Übertragen aber nicht richtig.
Das backt rum.
Ich habe das hier neu zusammen gewurschtelt
in Go.
Läuft die WebRTC-Verbindung
über TCP oder UDP?
Kann ich dir zeigen.
Das sieht man hier.
Es gibt zwei Möglichkeiten, das einzustellen.
Man kann sagen,
Use TCP oder
Use UDP.
Und aktuell geht das über
TCP.
Aber es geht beides.
Und das nice daran
ist, dass
man bei TCP als auch UDP
diese Library
verbindungs-multiplexen kann.
Also es reicht ein Port zu öffnen
für alle WebRTC-Verbindungen.
Das ist mega nice.
Normalerweise muss man einfach alle UDP-Ports erlauben,
damit das funktioniert.
Und das ist ja pepega, das macht ja keiner.
Also aktuell geht das über TCP.
Nachdem ich die Streams und so auch immer ganz gerne
im WLAN angucke und manchmal auch auf der Terrasse,
wo vielleicht auch ein paar Pakete verloren gehen,
habe ich mir gedacht, eventuell ist es sinnvoller
wobei ich mir nicht sicher bin,
ob der Gedankengang so nach
ob da wirklich was dran ist.
Ich kann es aber umstellen.
Ich kann es umstellen zwischen TCP und UDP.
Also ihr entdeckt hier sehr viele
Parallelen, falls einer dabei war,
wo wir das in Rust gebaut haben.
Zwischen dem hier in Rust und dem in Go.
Go ist quasi das, was ich in Rust gemacht habe,
nur halt mit der Go Library.
Und die Library ist eh sehr ähnlich.
Nur der Unterschied ist,
dass es eben in Go funktioniert
und in Rust nicht.
Kombiniere mit dem Monarch S Projekt.
Ne, das lösche ich wieder, das ersetzt das komplett.
Zumal ich hier keinerlei Videoaufnahmen
oder irgendeinen Shit machen will.
Einfach nur streamen in den Browser.
Was ein bisschen eklig ist,
ist Go und Interopt
mit anderen Programmiersprachen.
Weil ihr seht ja, ich rufe ja hier
zum Beispiel, hier sieht man es, guckt da hier,
SendFrame.
Ich rufe aus .NET
eine Funktion auf,
die eigentlich in Go ist.
Und da ist Go
nicht so das Beste für, für Interopt
mit anderen Programmiersprachen.
Da muss man hier oben drüber schreiben,
Export SendFrame.
Das sorgt dann dafür, dass diese Funktion
vom Go Compiler
mit C
Wie nennt man das?
C
Definitions
irgendwie exportiert wird,
sodass man von anderen Programmiersprachen
darauf zugreifen kann.
Also wenn ich hier SendFrame aufrufe,
kommt das hier in Go raus.
Also ich rufe in .NET SendFrame auf
und hier kommt das dann in Go raus.
Das funktioniert folgendermaßen,
so wie man das in C Sharp macht.
Man sieht das auch hier,
dass das alles sehr low level ist.
Wenn ich mir die Option anzeigen lasse,
Alter, Rider, please.
What the fuck.
Einfach anzeigen lassen.
Okay, jetzt.
Rider hat keinen Bock.
Ich darf da nicht mit der Maus drauf.
Es gibt einen Byte-Pointer
zu den Daten
von einem Video-Frame.
Es gibt die Länge,
wie lang das Byte-Array ist,
wie viele Bytes,
wie groß der Video-Frame ist quasi
und
wie viele Frames,
also wie lang
die Duration
von diesem einzelnen Video-Bild ist.
Kann ja auch sein, dass das nur ein paar Millisekunden ist.
Also wie lang das Bild ist.
Also wie lang im Stream.
Das Bild letztendlich dann
für die Timestamp-Generierung
ist das wichtig.
So, und wer sich fragt,
wie kann man Go und C Sharp
zusammen verwenden,
das geht tatsächlich über ein C-Interface,
so wie es der Yantari geschrieben hat.
Das ist sicherlich nicht die eleganteste Variante.
In Rust war das schöner,
das Interop, aber es ist mal nur so wie es ist.
In Rust hat es nicht funktioniert.
Da muss man sowas hier machen.
Ja, hier ist die Low-Level-Geschichte.
Da muss man dann in C Sharp sagen.
Hier, guck mal.
Es gibt hier eine unmanaged
DLL
heißt das unter Windows.
Ja, unter
Linux
würde das .so heißen.
Das ist das gleiche wie eine DLL, aber
man merkt, dass die Sharp mal irgendwann für Windows
erstellt wurden, da heißt es noch DLL-Import.
Mittlerweile gibt es übrigens eine Alternative zu,
die nicht mehr DLL-Import heißt, sondern Library-Import.
Da kann man sagen,
hier, es gibt hier eine
Shared Library
mit dem Namen WebRTC Linux
und
dort drinnen
gibt es eine Funktion, die sich SendFrame
nennt. Sieh hier,
deswegen der Export in Go.
Und die kannst du so
aufrufen. Die hat diese
Signatur, ja.
ID
Ja,
ID,
Duration, Länge und am Ende
ein Pointer zu einem
ByteArray. Da wird das ganze
zu Go rüber geschickt und in Go
macht er dann, übrigens bis ich das hier
funktionierend hatte, da hat mich Go wieder
übertrieben abgefuckt.
Ich bekomme ja hier oben
die Länge
und einen Pointer
zu dem ByteArray. Das hier ist
der Gegenpart in Go
zu dem hier.
Und
in Go gibt es die Möglichkeit,
dass du ein UnmanagedArray nimmst
und das kopierst in ein
ManagedGoArray. Ich will es aber
nicht kopieren. Ich will es einfach
nur als ByteArray verwenden.
So wie es ist. Ich will es nicht kopieren.
Und da kann man sowas hier machen.
Sogar meine IDE sagt,
das ist falsch, ja. Redundant.
Wenn ich das rausnehme, kompiliert es nicht mehr.
Da kann man sowas hier machen. Das habe ich
auch nur über StackOverflow gefunden.
Unsafe Slice
Pointer Byte
Whatever Go, aber es funktioniert.
Und dann gibt sich Go
damit zufrieden, dass das angeblich ein ByteArray
wäre. Und dann kann ich das
hier verschicken
an den Browser. Ja.
So ist das.
Also wilde Geschichte.
Aber es funktioniert echt erstaunlich gut.
Ich habe das seit gestern hier laufen auf einer Kiste,
die hinter mir im Serverraum steht.
Serverraum, also kleine.
Mein Mini-Serverrack, was da steht.
Da ist
auf der Kiste
eine VM und in der VM laufen ein paar
mehr und unter anderem das.
Und das läuft seit gestern und es funktioniert
erstaunlich gut. Es funktioniert
viel besser als alle GitHub-Projekte,
die ich bisher benutzt habe,
zum Umwandeln von Kamerastreams zu WebRTC.
Und
sogar besser als ich gedacht
habe. Ich hatte ein paar
Probleme, ja, mit Crashes,
weil ich an manchen Stellen nicht aufgepasst habe,
was ich wie unmanaged
übergebe.
Aber im Großen und Ganzen funktioniert es echt gut.
Ja.
Problem ist jetzt, Leute,
wir können nichts machen an dem Projekt
großartig im Stream, weil
eigentlich wollte ich mit euch das MemoryLeak
suchen und fixen. Aber es gibt kein
MemoryLeak. Warum C und Go gleichzeitig
benutzen? Ich benutze nicht C und Go gleichzeitig.
Ich benutze die Sharp und Go gleichzeitig.
Und warum Go?
Weil die
beste Library für WebRTC
in Go ist.
Und für mich das angenehmste, wenn es um
Web-Anwendungen geht,
.NET ist.
Und dementsprechend habe ich quasi
das Web-Anwendungs-
Backend, wenn man es so nennen kann,
in
C Sharp
programmiert und die WebRTC-Geschichte
in Go. Ja, und das FFmpeg,
Low-Level FFmpeg-Zeug
habe ich auch in
C Sharp gebaut, weil
ganz ehrlich, C Interop in Go, das ist
so ätzend. Oh, das
ist eklig, Alter. Das ist vor allem nicht
Cross-Platform. Das ist Windows-Only.
Aber ihr seid doch
übrigens nicht die Einzigen, die das benutzen.
Dice verwendet
das für Battlefield auch, habe ich gehört.
Die Frostbite-Engine
basiert ganz viel auf C++
CLI.
Es gibt eine ganz gute
WebRTC-Library
für C Sharp.
Die habe ich auch schon mal verwendet, die ist gar nicht so übel.
Aber die ist nicht so gut wie die Go-Library.
Und die kann
ein paar Sachen nicht, die die Go-Library kann.
Deswegen habe ich es da.
Und eins muss man sagen,
Go ist
erträglich, solange man
im Go-Ökosystem bleibt.
Dann geht das schon, klar.
Alles andere ist
abartig.
Wo kommt denn diese Klammer her gerade?
Kann mir das mal einer erklären?
Was macht denn die da?
Ah, das ist der Schleifen-Body und
das ist die Range-Definition.
Alter, was habe ich denn da Unleserliches gebaut?
Das sieht ja dämlich aus.
Obwohl ich wieder fast verzweifelt
bin in Go, sind einfache Sachen
oder verzweifle ich in Go immer fast,
sind einfache Sachen wie
Dictionaries,
Key-Value-Stores,
Key-Value-Hashmaps und sowas.
Weil das ist einfach
so eklig in Go zu benutzen.
Guck mal, ich habe hier
ein
also allein schon diese Syntax
in Go, ja.
Im Endeffekt
in .NET wäre das hier ein Dictionary,
mit Key-Type in 64
und Value
Track-Local-Static-Sample.
Dann muss man das irgendwie so
mit Make...
Wisst ihr, ich verstehe nicht, ansonsten machen sie
alles mit New in Go, hier ist es
Make aus irgendwelchen Gründen.
Aber gut, ich weiß, warum es Make ist,
weil die Syntax hier
kein Function-Call irgendwie erlaubt.
Es ist eklig. Zumindest, das ist noch nicht
das ekligste. Was ich richtig
abartig finde, ist...
Ne, Moment.
Das ist gar nicht das, was ich euch zeigen wollte.
Wo habe ich denn das hier?
Hier.
Löschen
aus Dictionaries und sowas.
Guck mal, es ist
super weird,
ja. Man kann
sagen...
Wo habe ich es denn?
Ja, man kann sagen,
wie man das aus anderen Programmiersprachen kennt,
in einem Dictionary quasi
so mit Array-Access kann man sagen, hier
an dieser ID soll dieser Track
rein. So weit, so gut.
Jetzt hätte ich eigentlich erwartet,
oder das ist, was mich in Go immer verwirrt,
dass man auch... Guck mal, man hat ja verschiedene...
Das ist eine Map und eine Map
hat irgendwie keinerlei Methoden drauf.
Ich hätte gedacht, okay, man hat dann
vielleicht sowas wie Delete, aber das gibt es nicht.
In Go, um was aus einer Map
zu löschen, müsste man jetzt sowas
hier machen. Delete,
Tracks
und dann die ID und sowas.
Ganz furchtbar weird.
Und das Ganze gibt es auch noch mit Append.
Das gibt es allerdings nur für einen
Slice.
Sehr, sehr merkwürdig alles.
Ah ja. Übrigens,
so einer Range Loop ist
das in N64.
Da hatten wir es ja gestern von.
Brauchst du nicht sogar einen Pointer
zur Map? Ey,
keine Ahnung. Bei Go mache ich dann
immer so lang rum, bis es funktioniert.
Zumindest,
was mich wieder echt fertig gemacht hat,
ist...
Warum ist denn das hier noch drin? Das brauche ich gar nicht mehr.
Weg damit.
Was mich echt fertig gemacht hat,
ist, ich wollte im Endeffekt
folgendes machen.
Ich habe hier
eine... Ich wollte
ein Dictionary haben,
wo ich mir meine Connections speichern
kann. Also sprich,
alle Clients, die connected sind,
möchte ich mir
speichern. Und jede Connection braucht
eine Unique ID, damit das
funktioniert. So.
Hier wird die Connection angelegt, ist vollkommen wurscht.
Und irgendwann
brauche ich eine ID für die Connection
und muss sie speichern.
Da habe ich mir gedacht, ey,
kann doch nicht so schwierig sein.
Generierst du eine Unique ID,
packst sie in den Dictionary,
dann ist mir eingefallen, okay,
UUID ist doof
für Interopt mit anderen Programmiersprachen,
weil unter der Haube ist es ein
int128 und
int128 ist nur so ein halbdefiniertes
Konstrukt und das ist immer schwierig
von einer Programmiersprache in die andere.
Dann müsstest du 2int64 drum herum machen.
Eklig, eklig.
Aber ich brauche eine Unique ID.
Das war das übelste
Gefrickel, bis ich
das ordentlich in
Go hinbekommen habe.
Und nxcxdx,
dankeschön für den PrimeSub.
Und das naheliegendste,
was mir eingefallen ist,
das nicht mit einem eingebauten
Typ direkt zu machen,
sondern das zu rappen
in einem eigenen Typ
und rausgekommen ist dann
das hier.
Ich habe mir
eine eigene Klasse gebaut
oder einen eigenen Typ gebaut,
die sich Connection Registrieren
intern besteht die wiederum
aus einer
aus einem Dictionary
in 64 Key
WebRTC Connection und einem
ReadWriteMutex
was ich auch schon
ekligst finde zu benutzen.
Aber so ist
das halt in Go.
Und dann musst du hier oben die Sachen
definieren, kannst du aber nicht initialisieren.
Das musst du hier unten in so einer komischen
new Function machen.
Und dann hast du so komische Konstrukte
wie sowas hier.
If value,
okay,
ja und wenn okay,
dann pfff, alter.
Da hat sich mir mein Hirn verbogen,
bis ich das in Go rausgekriegt habe,
wie man das auf dem
Go-Way macht.
Dann das schöne Unlocken
und wieder Locken,
weil es gibt ja in Go
keine Threadsafe
Dictionaries.
Die haben sich gedacht, braucht man nicht.
Es gibt so eine halbherzige
Sync Implementierung,
kannst du aber klicken.
Wo dein Prime-Sub läuft, weiß ich nicht.
Irgendwo in deinen Settings kannst du dir das angucken.
Moin Chainlore.
So und dann hier wieder mit Delete und so.
Du musst dich hier wirklich um jeden Furz selbst kümmern.
Es gibt kein
Threadsafe Generic Dictionary
in Go.
Gibt's nicht.
In .NET gibt's das seit 15 Jahren.
Okay, ich gebe zu, in Rust gibt's das auch nicht.
Aber in Rust gibt's sehr viele
Third-Party Sachen für sowas.
Also ich habe in Go nichts gescheites gefunden.
Muss ich ja selbst machen.
Also pff, ich weiß nicht.
Ich werde mit Go nicht hundertprozentig warm.
Ich kann in Go was machen und es funktioniert
am Ende auch, aber ich enjoye Go nicht.
Ich enjoye
ohne Scheiß Rust mehr als Go.
Wobei ich in Rust deutlich unproduktiver
bin als in Go.
Weil Rust halt Rust ist
und Rust nicht für
Geschwindigkeiten während dem entwickeln
ausgelegt ist.
Und auch grausam zu lesen ist teilweise.
Aber ich enjoye, wenn es bei den
zwei neueren Sprachen geht,
die ich gelernt habe,
enjoye ich Rust tatsächlich mehr als Go.
Also der
Weg damit zu arbeiten
gefällt mir in Rust besser.
Go finde ich immer übelst nervig.
C++ enjoy.
Wir haben gestern C++ oder vorgestern
C++ enjoyed und ich bin halb durchgedreht bei.
Hat jemand einen lustigen, warte mal.
Hat jemand einen lustigen
Clip aufgenommen?
Ich gucke mir ja manchmal die Clips an,
was die Leute machen hier vom
Stream.
Hat jemand?
Ja.
Februar 2021.
So.
C++ 2b.
Okay, was zum Teufel ist
C++ 2b?
Moment, C++ 2b
ist C++ 23
und die Versionsnummer ist
2021 00?
What the fuck?
Ja,
jetzt mal ernsthaft. Sind die alle,
hat dir irgendjemand ins Hirn geschissen
oder was?
Was zum Teufel? Wer denkt sich?
Das kannst du dir nicht ausdenken.
Das kannst du dir nicht ausdenken.
Was ist mit den Leuten los?
Ja, so sehr enjoye
ich C++, ja.
Was ist das?
Vor drei Jahren.
Ich peitsche mich auch jedes Mal, bevor ich den Editor
aufmache, Alter. Ich geißle
mich erstmal eine Runde hier. Bam.
Vorher kann ich nicht programmieren. Und danach,
mache ich noch weiter, indem ich C++
programmiere. Ich peitsche mich auch
jedes Mal, bevor ich den Editor
Ja, so sehr wird C++
enjoyed hier.
Also da enjoye ich Go tatsächlich
mehr.
C++ ist nicht zu
enjoyen. In keinster Art und Weise.
Das ist das Schlimmste, was es gibt.
Ist das die Version in Hex?
Das wäre ja noch cool, wenn das die
Version in Hex wäre. Aber 2b
ist 3...
Äh...
Ne, 2b ist ähm...
Ist denn 2b in Hex?
Auf jeden Fall
kann es nicht 23 sein.
Weil Hex
geht bis 16
und da kann vorne keine 2
stehen.
Aber 23.
2b Hex 2
Dezimal.
Okay, lasst mal kurz überlegen. Bin ich
pepega? Was ist...
Okay, 16
16, dann auch
Overfloat ist zur 1 vorne.
32
Dann
Overfloat ist
zur 2 vorne.
Also muss auf jeden Fall größer 32 sein.
Ähm...
Also 1 0
ist dann 32
in Hex, oder?
Stimmt das, was ich erzähle?
1 0 in Hex?
Hä? Was ist das für ein Schwachsinn?
Ne, aber...
2 0 ist 32.
Ach nee, 16 ist schon...
Okay. Alter, was auch immer.
Ich hab keine Ahnung.
Okay, 2b Hex zu Dezimal.
Was ist das?
43.
Also, nein.
Es ist nicht die Zahl in
die Version in Hex.
Das würde ich nicht machen.
Da müsstest du mir enorm viel Geld
dafür bezahlen. Ich bin jetzt echt grad
super verwirrt. Bin ich jetzt so blöde
im Kopf?
Dass das nicht stimmt, was ich erzählt
hab?
Gibt's irgendwie...
Hex, Dezimal... Okay, wir machen...
Wir rechnen. Hier, guck mal.
Ja, nee, ich will weiter, man. Gibt's...
Umrechnungstabelle.
Dezimal, Hex. Ja.
Dezimal...
Okay, 10 ist 16 in Dezimal.
Ja.
32... Hab ich doch gesagt!
Das ist genau das, was ich grade gesagt hab.
Ja? Bei 32 Overfloat
ist dann zur 2 vorne. War doch richtig
die Tabelle, die ich eben angeguckt hab,
war einfach nur bescheuert.
32 war doch richtig, was ich gesagt hab.
Bei 32
ist es dann 20.
10 ist 16, genau.
20 ist 32.
Das heißt 43 ist
dann...
2B ist dann 43, so rum.
Aber glücklicherweise gab's ja schon
ein paar Prime-Subs, sonst wär mein EQ noch
weiter unten gewesen.
Ich konnte das mal im Kopf alles easy umrechnen.
So zu Zeiten, wo man so was noch
in der Berufsschule gemacht hat und so.
Aber mittlerweile...
Ich kann auch keine...
Das ist ein gutes
Emote. Ich hab das doch schon.
Angeblich
hab ich das schon.
Guck mal, wir haben das Emote doch schon.
Ja, Subnet-Masten per Hand ausrechnen,
das konnte ich auch in der Berufsschule.
Mittlerweile bin ich ultra-pepega geworden,
was sowas angeht. Da wird einfach gesagt,
IP Calc, zack.
Da wird nix mehr von Hand
ausgerechnet.
Easy.
Easy.
Ja, ich würd's wahrscheinlich auf dem Papier auch noch irgendwie
hinkriegen, aber das ist so eklig.
Für's Abi?
Wirklich? Für's Abi macht man sowas?
Was sagt man?
Was macht eigentlich mein nicht vorhandenes Memory Leak?
Das Memory Leak immer noch nicht.
Hattet ihr auch
Zahlenformate und sowas? Vorzeichen addieren?
Ja.
Jaja.
Wir haben
quasi
mit
minus gerechnet
mit
addieren und so.
Irgendwie negiert und overflow
ist das Vorzeichen und so.
Ich kann mich noch ganz vage dran erinnern.
Subnetting mit
IPv6. Ja, viel Spaß.
Chatge, das hat mich
jetzt echt, ich mach das mal wieder aus, mich hat das
jetzt wirklich ein bisschen aus dem Konzept gebracht, weil
ich wollte mit euch bisschen
Memory Leaks suchen.
Das ist aber nicht erforderlich,
Memory Leaks zu suchen.
Ah, ich weiß, was wir machen.
Ich kann euch was zeigen, was
wahrscheinlich ihr schon wieder alle wisst, aber ich
nicht. Wusstet ihr,
also jetzt weiß ich's auch.
Recycle Story.
Jetzt weiß ich's auch, aber
ich wusste es bis
heute Morgen wusste ich das nicht.
Und zwar, Testschreiben
ist overrated. Es funktioniert einfach
immer.
Sollte das mal.
Wusstet ihr, dass Visual Studio Code Profile unterstützt?
Ich meine damit nicht Workspaces,
sondern Profile.
Workspaces gibt's
ja schon lange.
Man kann nämlich jetzt hier unten draufklicken
und sagen Profile und es gibt normalerweise
nur das Default-Profil,
aber das coole ist, wenn man
ein neues Profil erstellt. Erstellen wir uns mal
beispielsweise ein Profil für
Web-Entwicklung. Da kann ich
sagen, ich will alles aus meiner Default-
Config merchen mit meiner neuen
für Web-Entwicklung.
Und wenn ich das jetzt erstelle,
dann seht ihr, ich hab ein neues Profil,
was auf meinem alten Profil basiert.
Also wenn ich jetzt hier was öffne,
dann ist das noch die gleiche Schriftart und so und passt
alles. Aber es sind keine Plugins
mehr da. Das heißt, jetzt kann ich zum Beispiel
das Svelte-Plugin hier
installieren und
dann sagen wir, ich lege noch ein weiteres Profil
an für
Cloud-Entwicklung
zum Beispiel. Cloud Development
Geschichten. Nehme ich auch wieder nur die Extensions
mit und dort
installiere ich dann so zum Beispiel die
Terraform
Terraform Geschichte und sowas. So
und jetzt kann ich immer dazwischen switchen,
je nachdem, was ich mache
und das ist nicht Workspace gebunden.
Das finde ich enorm praktisch, weil ich
will die ganzen Plugins ja gar nicht Default-
mäßig laden. Ich möchte meine Web-
Entwicklungs-Plugins haben, wenn ich Web-Entwicklung
mache. Ich will meine IoT-Sachen machen, wenn ich
IoT habe und das wusste ich bis heute
morgen nicht, dass Visual Studio Code
das unterstützt. Wusstet ihr das?
Also für mich
war das neu.
Das heißt im Endeffekt, ich kann jetzt auch mein
Default-Profil mal ein bisschen aufräumen,
weil ich brauche, was ist
das? Ach ne, das ist nicht
installiert. Wollte gerade sagen.
Jetzt kann ich den ganzen Mist hier mal
uninstallen aus meinem Default-Team.
C wird uninstalled.
Hier, das ganze Zeug wird alles
uninstalled. Reload.
Seitdem die das Teil
der GitHub-Seite, was verwenden die?
Das Teil, ich verstehe
nicht, was du meinst.
Uninstall, Terraform uninstall,
Kubernetes uninstall, MonkeySea
uninstall. Brauchen wir alles nicht.
Zumindest nicht in Defaults Welt uninstall.
YAML können wir mal drin
lassen. So und jetzt sagen wir, okay,
ich will jetzt Web-Entwicklung machen.
Dann switche ich einfach das Profil
auf Web. Und da
installieren wir jetzt noch das Tailwind-Plugin.
Und je nachdem, was ich machen will,
kann ich es umschalten.
Ich finde das enorm praktisch, dass es jetzt Profile gibt.
Das gibt es übrigens noch nicht so lange.
Das ist erst ungefähr ein Jahr oder so in Visual Studio Code möglich.
Aha.
Aber GitHub Workspace ist
was anderes.
Also so eine
Remote-Entwicklungsumgebung.
Aber Microsoft weiß man nie.
Also ich finde das mega nice.
Mit den...
Ich dachte mir, ich zeige euch das mal, weil ich das selbst erst seit
heute Morgen quasi erfahren habe.
So und jetzt habe ich
ein richtig cleanes Visual Studio Code.
Defaultmäßig nur mit YAML sind.
Und das ist das
Sonntagshighlight-Ding.
Weil ich hatte bisher immer das Problem,
was mich immer übelst genervt hat, ist,
dass ich beispielsweise, wenn ich hier...
Oder gehen wir mal IoT nochmal rein.
Ah ne, IoT habe ich gar nicht.
Ich habe ja nur Cloud und Web angelegt.
Ich wollte IoT anlegen.
Machen wir mal was für IoT.
Und da würde ich jetzt beispielsweise nochmal
die ESP-Geschichte installieren.
So und was mich immer übelst genervt hat
bei Visual Studio Code ist,
dass man diese ganzen Sachen hier dann
default mitgeladen bekommen hat.
Ich hatte hier nebendrin
Plattform-IO, Terraform, Kubernetes
total voll mit allem Schrott.
Obwohl ich das in 90% der Fälle gar nicht brauche.
Nur wenn ich eine spezielle Sache mache.
So und jetzt sage ich auch
ne,
ich brauche kein IoT-Zeug.
Ich switche auf meine Web-Entwicklung.
Und dafür ist das weg.
Und dafür sind die Web-Entwicklungs-Plugins geladen.
Sehr praktisch.
Ist Visual Studio eigentlich mittlerweile
auch auf WebView2
wie Teams, ja ich glaube das war
vor Teams auf WebView2 schon.
Sind die Profile in der Settings-JSON
drinne?
Ne.
Weil die Settings-JSON kannst du auch pro Profil
überschreiben. Die können da nicht drinne sein.
Ich gehe mal davon aus, dass die irgendwo im
ich weiß gar nicht wo die gespeichert
werden.
VS Code Profiles
Where stored
Config Code User Profiles
Ok.
Also ein weiteres Ding, was man theoretisch
backuppen sollte.
Aber ehrlich gesagt, ich werde es eh nur für
Plugins benutzen.
Die restlichen Sachen bin ich fein mit meiner
Default-Config.
Was will ich da groß konfigurieren?
Ziemlich ähnlich wie bei Vim.
Inwiefern?
Du meinst, dass es ne
Config-Datei gibt, die in deinem Heimatverzeichnis liegt?
Ja gut, das ist
nahezu jeder Linux-Anwendung.
Wenn man die Config-Dateien speichert, ist das so.
Du kannst froh sein,
oder wir können froh sein, dass die Sachen
mittlerweile unter .config liegen.
Früher lagen die Dinger
gar nicht unter .config, sondern
einfach hier, direkt im Heimatverzeichnis.
Hier.
Manche Sachen machen das immer noch so, aber die meisten
glücklicherweise nicht.
VS Code anscheinend schon.
Aber das ist noch ein alter
VS Code Ordner, so wie es aussieht.
Go macht natürlich nix von beiden.
Go eliminiert sich einfach.
Ohnehin ein Folder ins
Root-Home-Verzeichnis
von einem.
Warum hab ich da einen Ordner, der keck-weight heißt?
Und warum hab ich massive
5-Fat-Chat-Gear hier drinnen liegen?
Mein Heimatverzeichnis voll mit Schrott.
Deswegen
macht man auch nur LS.
Was da für ein Schrott drinnen liegt.
Müsste eigentlich alles mal weg.
Ich lösche mal ein paar Docker-Images.
Hab ich mir wieder massig
im Hintergrund angesammelt.
Ja, hat sich.
Ah, mein Windows-Desktop
ist noch gar nicht so voll.
Noch nicht.
Das wird immer voller.
Ich dachte, ich zeige euch das mit den Profilen mal.
Weil ich das sehr, sehr nice fand.
Ha.
Also auf ESP gebastelt
hab ich jetzt keinen Bock.
Auf die Zigbee-Steckdosenleisten
dran rumzubasteln ehrlich gesagt auch nicht.
Weil dazu müsste ich die Kamera anmachen.
Also nicht für mich, sondern für
die Steckdosenleisten.
Weil die werden aufgemacht,
bisschen dran rumgelötet.
Also wohlgemerkt, nicht an den Stellen,
die für eine Strom-Steckdosenleiste
wichtig sind.
Sondern ich löte dort
einen neuen Microcontroller rein.
Warum?
Weil es geht.
Weil ich das mal testen will.
Ich könnte die auch einfach out of the box
mit Zigbee verwenden und gut ist.
Aber ich hab eine Anleitung gefunden,
dass man hier Lidl
das Motor
ja
ich hab eine Anleitung gefunden
dass man
ja
das ist eigentlich ein
Zigbee-Gerät
aber die kann man
den Microcontroller da drin
kann man austauschen
durch ein
ESP8266
oder durch ein
ESP32
wenn man den passenden Modul
hat.
Braucht man dann
sowas hier zum Beispiel.
Und das wollte ich mal ausprobieren.
Einfach nur, ob es geht.
Ehrlich gesagt macht es überhaupt keinen Sinn.
Ja, weil Zigbee kannst du auch so
wunderbar benutzen, ohne dass du da irgendwie
die China-Chinesen-Cloud bräuchtest.
Alles lokal.
Aber einfach, weil es geht.
Wollte ich es mal ausprobieren.
Die restlichen Steckdosenleisten lasse ich wahrscheinlich
stock, so wie sie sind und steuere die
über Zigbee.
Nachdem mir jetzt quasi in
knapp
eineinhalb Wochen
drei Steckdosen,
drei China-Steckdosenleisten
kaputt gegangen sind, musste ich mal
was Neues bestellen.
Hast du für RT-Zeugs eigentlich ein eigenes WLAN?
Ja. Ja, ja.
Habe ich.
Ich habe ein eigenes WLAN
und ein eigenes WLAN.
Wobei in dem WLAN
wobei nicht, dass ich jetzt Mist erzähle
Ne, in dem
WLAN steht tatsächlich gar nichts anderes
mehr. Es stand mal ein Raspberry Pi
kabelmäßig, per
Netzwerkkabel angeschlossen, stand
noch in dem WLAN drin.
In dem IoT-WLAN. Aber mittlerweile
sind es nur WiFi-Geräte.
Mit einer eigenen WLAN-SSID.
Und die haben
natürlich kein Internetzugriff
erlaubt, meine IoT-Geräte.
Die einzigen Zugriffe,
die erlaubt sind, aus dem IoT-
Netzwerk raus, sind
NTP und
MQTT für Geräte, die das brauchen.
Das ist das einzige,
was freigeschaltet ist.
Der Rest nicht.
Für was benutzt du steuerbare
Steckdosenleisten?
Zum Beispiel, dass ich im Keller
Sachen ein- und ausschalten kann.
Oder wenn ich was resetten muss.
Die Kamera im Keller,
die kackt teilweise ab, die muss ich manchmal resetten.
Sehr praktisch, wenn man
was remote schaltbar hat.
Wenn ich bei Repi im Keller mal an- und ausschalten muss,
geht das auch gut über die Steckdosenleiste.
Die Stromversorgung
für die Wand-Tablets
geht auch da drüber.
Ist auch gut, wenn ich nicht in den Keller muss,
um das ein- und ausschalten zu können.
Nein, nein, nein, du hast mich
falsch verstanden.
MQTT darf aus dem Netzwerk raus.
Das heißt nicht, dass es ins Internet darf.
Aus dem Netzwerk raus heißt,
das darf in mein anderes Netzwerk,
wo mein lokaler MQTT-Broker steht.
MQTT darf nicht
ins Internet.
Ich hab's doch ganz am Anfang gesagt,
ins Internet raus kommt gar nix.
Mit nix kommt ins Internet raus.
Du wohnst in einem
ganzen Haus ganz allein.
Nee, nicht ganz allein.
Zumindest sind
so IP-Steckdosenleisten,
nennen wir das jetzt mal,
praktisch.
Die sind zwar oftmals Spielerei,
man benutzt die dann auch an Stellen,
wo man das nicht braucht.
Aber in manchen Anwendungsfällen
sind sie echt praktisch.
Zum Beispiel den Raspberry Pi
resetten im Keller,
falls man da mal irgendwas gemacht hat,
dass er dann nicht gescheit
restartet hat.
Dann gehst du in Home Assistant,
schaltest die Steckdose für den Raspberry Pi
im Keller aus, wieder ein, alles gut.
Wofür ich das auch benutze ist,
schaltbare Steckdosen.
Ich hab bei mir
im Bad einen
Heizlüfter.
Und ich hatte mal,
weil es mir schon eine Weile nicht mehr passiert ist,
aber ich sage ich hatte,
aber ich hatte mal irgendwie ein bisschen
Brain-Lack,
dass ich öfters vergessen habe,
diesen Lüfter auszuschalten, nachdem ich im Bad gewesen bin.
Also gerade im Winter, wenn es kalt ist
und man muss aufs Klo,
das dauert ein bisschen länger,
10 Minuten oder so, da habe ich immer den
Heizlüfter angemacht, dass es schön warm ist im Klo.
Also instant schön warm.
Und ich habe es dann öfters geschafft,
den Heizlüfter vergessen auszumachen.
Und jetzt habe ich das
so gemacht,
ich habe einen einfach
beheizbaren Toilettensitz.
Meine Toilette kann den Toilettensitz nicht beheizen,
aber das Wasser im Klo kann erhitzt werden.
Also das ist so ein Klo,
das kann dir auch den Arsch absprühen.
Mit warmem Wasser, sehr angenehm.
Kann ich nur empfehlen.
Es gibt sogar ein Video dazu.
Warum findet er zu Max FPS Klo nichts?
Ja.
Acht Jahre Premium Klo Fazit.
Es ist doch.
Da sieht man das Klo.
Und hier sieht man auch wie die
hier sieht man wie die Düse
rausgefahren kommt.
Düse Champ.
Hier.
Du kriegst da Puppes abgewaschen.
So und ich habe,
vielleicht sieht man, vielleicht schwenke ich auch irgendwie mal durchs
Bad.
Glaube nicht.
Zeigt noch den NFC.
NFC Tag oder so.
Ich schwenke nicht durchs Bad.
Ich habe da einen Heizlufter.
Ich habe da einen Heizlufter stehen und den habe ich schon öfters mal
vergessen auszuschalten.
Und ich habe eine Automation gebaut
in Home Assistant,
die registriert, wenn die Steckdose
die schaltbare
Steckdose eingeschaltet wird.
Das schickt ein Event über MQTT die Steckdose.
Und
wenn die nicht innerhalb
von 15 Minuten wieder ausgeschaltet
wird,
dann schaltet die automatisch
automatisch aus.
Ich kann das einmalig
verlängern.
Wenn ich vorher auf den Knopf drücke, dann geht es
glaube ich
35 Minuten.
Das ist wenn man mal duschen will und so.
Das dauert alles ein bisschen länger.
Aber dann geht es automatisch aus.
Das habe ich gemacht, weil ich früher öfters vergessen habe
den Heizlufter auszumachen. Mittlerweile
vergesse ich das eigentlich nicht mehr.
Und da brauche ich die Automatisierung nicht.
Da sind so schaltbare
Steckdosen sehr praktisch.
Man kann auch Sachen ausschalten lassen
zum Strom sparen. Dafür ist das auch
praktisch. Wobei ich sagen muss,
so viele Sachen fallen mir
hier gar nicht ein.
Was mir da einfallen würde
ist zum Beispiel
der Fernseher im Standby.
Der muss nicht
im Standby sein.
Das habe ich übrigens
noch nie gemessen.
Das müsste ich mal machen.
Ich habe hier
einen Standby Verbrauch.
So einen Zwischenstecker.
Ich habe hier so ein Messteil.
Nein, ich wohne nicht zur Miete.
In einer Mietwohnung so das Klo rausreißen
und Neues einzubauen ist natürlich schwierig.
Naja, wenn du
das in die Schüssel gekackt hast,
dann hängt das ja nicht mehr an deinem
Pobbes. Und dementsprechend
kann der Brausekopf
dann da auch schön brausen.
Der fährt ja erst aus,
wenn du fertig bist.
Ich würde auch darauf tippen,
dass der Fernseher mehr verbraucht.
Die Steckdosenleiste braucht nicht viel.
Die Microcontroller da drinnen
die brauchen 100mA oder so.
Das dürfte
fast in der Messungenauigkeit
untergehen, so eine Steckdosenleiste.
Ja, der Fernseher
verbraucht, da würde ich auch drauf tippen,
dass der deutlich mehr verbraucht.
Stimmt, es gibt auch so einen Aufsatz, korrekt.
Ja, das Schöne ist halt
an so einem eingebauten Klo,
der ist schön integriert.
Ja, und was
der Sitz nicht kann,
ist der, der
ich nenne es immer
die Klimaanlage, das ist aber keine Klimaanlage.
Der Klo kann
den
Gestank quasi
absaugen und nach draußen pusten.
Ja, und das geht halt nicht,
wenn du es nicht voll integriert hast in die Wand.
Ja, das ist auch ein guter
Anwendungszweck.
Ja, die haben bestimmt irgendwas getrickst.
Es gibt dann bestimmt mehrere Standby-Maschinen,
Modi, und den kannst du einschalten
und dann bootet das Ding halt 45 Sekunden
oder so. Ich gehe nicht
davon aus, dass der wirklich unter einem Watt
im Standby ist, der Fernseher.
Gruselmeister, danke für den Zap.
Aber nichtsdestotrotz
wird das trotzdem mehr verbrauchen, als
die Steckdosenleiste.
Bin ich
relativ safe, dass das so ist.
Chat, wisst ihr was, ich gehe jetzt auf.
Die Suche nach dem
Memory Leak war keine Suche nach dem Memory Leak,
weil es kein Memory Leak gab.
Aber
ich kann jetzt nicht noch eine Stunde
im Kreis labern.
Reicht für heute.
Wobei, wenn ich eins
gut kann, dann ist es gesitetrackt werden
und sinnloses Zeug erzählen für 3-4 Stunden.
Das habe ich gelernt
auf Twitch. Aber heute nicht.
Ich gucke jetzt noch ein bisschen Twitch oder irgendwie
Stream oder sonst was.
Ich gucke mir jetzt ein paar
an.
Aber nichts Anstößiges.
Ganz normales Zeug.
Bis dann.
See you.
