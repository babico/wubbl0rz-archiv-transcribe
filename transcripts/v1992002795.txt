Pog Pog Pog Pog Pog Pog Pog Pog
ich muss gerade mal wagen dass mein
browser geupdated ist auf der anderen
seite
ja kekwait kekwaiting dass mein browser
geupdatet ist.
Ich gebe zu, Freitag 12.16 Uhr ist
vielleicht nicht so der normalste Zeitpunkt
zum Streamsauen. Für mich.
Aber warum nicht, ne?
Heckel HD.
Ja, ich habe Urlaub, richtig.
Ich habe Urlaub seit...
Ich meine, letzter Arbeitstag
letzter Arbeitstag
war
am 24.
Wobei, also streng genommen
letzter Arbeitstag war am 24.
Aber ich hatte
ja quasi hier nochmal Bereitschaft
und
hier hatte ich nochmal
Teambuilding-Workshop.
Also insofern... Oh Leute, das war wieder was,
ey, ich sag's euch.
Kann ich euch dann erzählen.
Wobei, es ging. Es war bisher
es war nervig wie
alle Teambuilding-Workshops, aber
insgesamt muss ich sagen, war das tatsächlich noch
der beste Teambuilding-Workshop.
Marabuna
ist 8. Moin.
Düdü-düt.
Düdü-düt.
So. Und
deswegen, also so,
sag mal so, Soft-Urlaub
habe ich quasi schon seit 24.
Aber so richtig hart Urlaub, also wo dann
auch wirklich gar nichts mehr ist,
habe ich quasi seit
gestern. Was war so toll bei dem
Teambuilding? Naja, wie gesagt...
Wartet mal kurz.
Hä?
Mon KS.
Ähm, was so
toll beim Teambuilding war?
Naja, es war nix toll, es war nur weniger nervig.
Also toll habe ich
trotzdem nicht gefunden. Ich mag solche Sachen einfach
nicht.
Aber insgesamt war es tatsächlich ganz, ganz,
ganz okay.
Ja, wir haben natürlich wieder
irgendwelche komischen Spielchen gemacht.
Also wir haben, passt mal auf, passt mal auf.
Ähm,
typisches,
typisches Teambuilding-Spiel, was wir gemacht
haben. Wir hatten zwei Teams,
also, wir waren als ein Team
da, aber wir wurden aufgeteilt in zwei
Teams. Und beide Teams
mussten
einen Atomreaktor
fixen.
Natürlich war das logischerweise
kein echter Atomreaktor und
hatte mit Vorfällen in einem Atomreaktor
auch gar nichts zu tun.
Aber das ist so eine typische Story, die gerne bei
solchen Spielchen auf
auf Teambuildings gemacht wird. Also,
das ging, das ging voll dermaßen.
Das ging voll dermaßen. Also, guckt mal.
Beide Teams,
beide Teams hatten
einen roten Kreis auf der Erde.
So, äh, einen orangen Kreis
auf der Erde. Das war der
Atomreaktor.
Und in der Mitte,
in der Mitte, what, was ist das
hier? Warum macht es so komische Dinger?
So, und in der Mitte,
in der Mitte stand eine Flasche.
Ich mach jetzt, das, das, das wird
kein Buba, Leute. Es wird kein Buba-Bild.
Sieht doch vielleicht ein bisschen so aus. Okay, kein, kein
Buba, ja. So.
Also, in der Mitte stand eine Flasche.
Und da drauf,
da drauf lag
ein Ei. Okay?
Okay, so.
Und dann hast du einen Rucksack
bekommen. Das zweite machen wir einfach wieder weg.
Und dann hast du, what,
alter Paint, mein Gott, Paint ist,
ich bin nicht wirklich traurig, dass Paint
weg ist. Naja, zumindest
hat man dann einen Rucksack bekommen mit Teilen drin.
Und
man musste quasi
mit den Teilen aus dem Rucksack
musste man was bauen.
Im Team zusammen.
Wie man das Ei, ohne
dass es kaputt geht, von der Flasche
bekommt, aus dem Kreis raus
und danach
die Flasche rausbekommt, ohne dass es
kaputt geht.
So, und da hatte man dann,
da hatte man so Sachen drin, wie
ein bisschen, also
eine Schnur war drin,
es war ein Kleiderbügel
drin, eine Mausefalle,
ein paar Kabelbinder.
Was ist mit einem Atomreaktor?
Was hat das mit einem Atomreaktor zu tun?
Also, es hat
insofern was, du darfst nicht, du darfst
nicht in diesen Kreis reingehen,
weil verstrahlt, so nach dem Motto.
Du musstest das alles von außen machen.
Und wir haben das, oh du Scheiß,
ich glaube, wir haben das mit am schnellsten von
allen Teams, die es jemals gegeben hat,
gepackt, weil wir haben einfach alle Teile
links liegen lassen und haben uns
die,
die, wie ist das,
da war so eine aufgewickelte Schnur drin.
Wir haben eine aufgewickelte, wir haben die Schnur
einfach abgewickelt.
Einer ist hierhin,
einer hat es hierhin gestellt,
einer hat es hierhin gestellt, mit der Schnur
drüber gespannt. Wir haben erst dann mit der Schnur
langsam das Ei runtergekickt.
Das ging, weil
das war auf dem Gras, ist nicht
viel passiert mit dem Ei.
Dann haben wir an die Schnur ein bisschen Metall
dran gemacht, dass quasi hier immer
weiter, immer weiter raus gedingst
das Ei. Und danach
sind wir mit der Schnur einfach ein paar Mal
im Kreis gelaufen, bis sie sich um die Flasche
gewickelt hat, dann haben wir die Flasche rausgehoben.
Also das hat irgendwie, keine Ahnung,
acht Minuten gedauert oder so, dann war
das fertig, obwohl 30 angesetzt
waren. Naja,
das sind typische
Teambuilding-Spielchen, ja.
Typische Teambuilding-Spielchen.
Jemand Oracle Pfeife, ich hoffe
ja nicht, ich habe keine Ahnung.
Und ich fasse Datenbanken
auch nicht an, weil ich weiß, dass ich davon keine Ahnung
habe. Und ihr wisst, wie das ist, es ist
wichtig zu wissen, wenn man keinen Plan hat.
Und von Datenbanken,
also insbesondere natürlich
auch
Datenbanken,
Oracle, weil da kommst du ja nur dran,
wenn du viel Geld hast.
Aber so alles, was es da gibt,
ja, ich meine, von Postgres habe ich zumindest
aus Anwendungsentwicklungssicht noch ein bisschen
Ahnung. Aber von Oracle
gar nicht, deswegen halte ich da echt die Finger von
weg. Ja, SAP HANA ist auch ganz, ganz
grausam, Alter.
Bei uns auf der Arbeit gab es eine Diskussion,
was man nehmen sollte. Pass mal auf, müssen wir uns mal vorstellen.
Gab es die Diskussion,
was man nehmen sollte für irgendeine Anwendung?
Ich glaube, es war keine neue Anwendung, aber es sollte umgebaut
werden. Gab es die Diskussion,
Oracle,
SAP HANA,
Sybase
oder Postgres?
Und da haben wir uns alle angeguckt
und haben gesagt, naja, obviously Postgres.
Weil, macht
alles, kann alles,
funktioniert,
ist etabliert,
kostet nichts, läuft auf Linux.
Also im Prinzip so,
warum, warum denkt
ihr überhaupt über die anderen Optionen nach, wenn
ihr einfach Postgres nehmen könnt?
Und am Ende hattest du dann da wirklich Leute
drin, die, die
ultra krasse SAP HANA Fans
waren. Ich kann das nicht verstehen. Ich habe damit
noch nie was gemacht. Ich will damit auch nichts machen.
Allein schon, weil es SAP ist und
wahrscheinlich wieder 30 Trilliarden
kostet.
Und Oracle will man sich auch nicht mehr ans Bein
binden, als notwendig ist. Und irgendeine
uralte Sybase Version von 1995
erst recht. Warum nicht, also
warum nicht einfach stinknormales Postgres,
wenn es doch schon zur Auswahl steht?
Aber war's nicht, war's nicht.
Ey, ist echt
böses Enterprise-Keckel teilweise.
Am Morgen wird MMO gecrindet.
Ich weiß nicht, ob ich MMO im
Stream ein bisschen crinden soll, weil das ist
ultra langweilig zum Zugucken, kann ich euch sagen.
Das ist das langweiligste, was es gibt, ey.
Leute beim MMO-Kreise
crinen zu gucken, zuzugucken.
Postgres macht keine, naja,
gut, Postgres hat keine Lobby-
Arbeitsleute, die vorbeikommen und
also Postgres hat keine
so Lobby-Abteilung, Sales-Abteilung,
die ankommt und dir das Schmacken,
ja, das stimmt, das stimmt schon, ja.
Aber in dem Fall mussten es ja
nicht mal irgendwelche CEOs entscheiden,
sondern wirklich Leute aus der Technik.
Und wie man da ernsthaft auf die Idee kommen kann,
SAP oder Oracle
versus Postgres, also, verstehe ich nicht.
Das ist überhaupt eine Frage,
dass es überhaupt die Frage gibt, verstehe ich nicht.
Wenn du Postgres nehmen kannst,
sollst du immer Postgres nehmen.
Raspberry Pi 5 sind's verfügbar, ich weiß,
ich hab's gesehen. Da habe ich trotzdem noch keinen gekauft.
Was sagt denn, was sagt denn Barry Base?
What the f...
Pi 6?
Warum habe ich am Raspberry Pi 6 gesucht?
5.
Okay.
Die sind nicht verfügbar.
Keck Waiting.
Ja, die Sortierbarkeit war hier auch schon mal besser.
Ja, ja, ja, wir machen gleich, wir machen gleich weiter.
Ich muss den ganzen, ich muss erst mal Betriebssystem
OS Update machen.
OS Update.
Eggman Update, Dings Update.
Dings Update.
Wollen Sie noch irgendwas Updates?
Ähm, ich weiß nicht, was das ist,
aber irgendwas, was wir nicht mehr brauchen.
Weiß auch nicht, warum das installiert ist.
Wenn nicht, war das mal als irgendeine Dieb...
What the f...
Okay, wahrscheinlich, wahrscheinlich
wurde das mal wegen irgendeiner
Dependency mit installiert, hä?
Ach komm, ich lass...
Naja, ich aninstall das einfach.
Wird sich schon wieder installieren,
wenn man's braucht.
So, also, Packages sind geupdatet.
Wichtigster Check, ASCII-Quarium geht noch.
ASCII-Quarium nach LOLCAT gepiped, geht auch noch gut.
Nice, Reboot-Time.
Meinst du nicht?
Aber zeig mal hier, wenn die lieferbar sind.
Ja, Starter-Kit braucht keiner.
Ja doch, doch, Starter-Kit, Starters brauchen Starter, ja?
Wenn die noch ein Netzteil brauchen, vielleicht oder so, ja dann.
Ich mein, es bietet sich an, für den aktuellen Raspberry Pi 5
auch ein Netzteil zu kaufen, weil die haben ja zum ersten Mal
also nicht zum ersten Mal, aber jetzt wiederholt, zum wiederholten Male
bisschen, bisschen mehr Maximum Leistungsbedarf, aber
das brauchen die ja meistens trotzdem nicht.
Also ich, ich würd beim Raspberry Pi mit meinem alten Netzteil ins Rennen gehen.
Das, das geht, glaub ich, immer noch voll klar.
Was kostet das Start-, das Starter-Kit?
Starter-Kit kostet Raspberry Pi
ja, vier Gig reichen Digge.
Äh, SD-Karten, Power Suppler, ein Case, das Case ist halt auch kacke.
Ja, sowas geht vielleicht noch nicht.
Ich, ich, ich würd mir ja sofort wieder das FLIR-Case kaufen.
117€.
Äh, also ich würd mir ja wieder, das gibt's ja auch schon für ein 5er,
Pi 5 FLIR-Case.
Ja, das da würd ich mir wieder kaufen.
Das geht voll klar.
Gibt's auch für Raspberry Pi 5.
Ah, ne, das ist für ein 4er.
Aber ich hab's letztens, ich hab's doch letztens auch schon für ein 5er gesehen.
Himba Pi Fall Gen 2.
Alles klar, genau, das brauchen wir.
Himba, Himba Pi Fall Gen 2.
Ah, das ist sogar fürs, fürs 3er.
Also, ich hab das, ich hab das auf jeden Fall gesehen, dass das auch fürs Pi 5 schon gibt.
Ja, fliegt.
Fliegt.
Das ist für ein Zero.
Aber guck, die haben auch, die haben auch ein Pi 5 Case.
Das ist, das ist so mein To-To-Go, äh, nee, To-Go ist das, also, falsches Wort.
Das ist mein, mein Default Raspberry Pi Case.
Ich find das Ding super.
Das sieht gut aus.
Nicht, dass es so entscheidend wär, aber es sieht clean aus.
Du kannst unten dran relativ gut noch ne, ne, SSD pappen, SATA-SSD, beziehungsweise
auf USB.
SSD pappen.
Ist auch genug Platz.
Oder legst du oben drauf.
Nimmst da so ein bisschen Klebeband.
Ja.
Machst dran.
Und dadurch, dass das gesamte Gehäuse Alu ist, Kek, Kek-Alu, ups, meine E-Mails sind
vielleicht grad ein bisschen groß, weil das Kek-Alu Case ist, verteilt sich die ganze Wärme
auch gut drüber.
Also, aber Leute, die ein Raspberry Pi quasi 24-7 auf, ähm, hoher CPU-Last laufen lassen
wollen, also auch mit 80% plus CPU-Auslastung, dann ist das Case nix.
Das Case.
Also, natürlich, dadurch, dass es so nen großen Metallkörper hat, ne, verteilt die Wärme
ganz gut und hilft auch, ein bisschen die besser abzutransportieren, aber natürlich
wird's auch mit der Zeit zu heiß, wenn du's volle Pulle 24-7 in nem schlecht belüfteten
Raum laufen lässt.
Das ist ja klar.
Aber das sind ja die aller, aller, allermeisten Raspberry Pis nicht.
Du brauchst dann ein neues Netzteil, weil der Raspberry Pi 5 einen USB-C-Anschluss hat.
Ne, brauch ich nicht.
Weil ich ein ganz normales China-Chinesen-USB-Netzteil verwenden würde.
Und.
Und dann ein USB-C-Kabel anschließe.
Also ich habe Berge.
Ja.
Ich habe Berge von denen hier.
Ich habe aber auch welche mit Quick Charge und bis zu...
Was ist Quick Charge?
Bis zu 20...
20 Volt 5 Ampere oder sowas.
Irgendwie so.
Ja, genau.
Ja.
Also sie können sogar Quick Charge.
Also die sollten da nicht auseinanderfallen.
Wenn ich den Raspberry Pi dran anschließe.
Zur Not habe ich noch meine Steckdosenleiste hier.
Die hat auch USB-Anschlüsse.
Also insofern.
Ich denke, ich bin für den Raspberry Pi gerüstet.
Fünfer.
Aber dazu müsste ich mir erstmal einen Fünfer kaufen.
Ja, macht's auch.
Kennst du...
Ja, kenn ich.
Kenn ich.
Ja, ja.
Kenn ich.
Habe ich aber noch nicht mitgemacht.
So.
Jetzt geht's los.
Jetzt werden wir mal...
Rust.
Wobei...
Bevor wir...
Wir machen vielleicht...
Vielleicht erstmal die Docker-Geschichte.
Bin mir gar nicht sicher, wo wir stehen geblieben sind.
Wie immer.
Ihr müsst nicht wirklich bei den letzten Streams dabei gewesen sein.
Weil das ja immer ein bisschen unabhängig voneinander ist.
Schadet allerdings auch nicht.
Das heißt, wenn ihr öfters dabei sein wollt, könnt ihr ein Follow dalassen.
Postchamp.
So.
Also ich muss erstmal den ganzen Krempel starten.
Repos.
Campchamp.
Hier haben wir ein paar uncommittete Sachen drinne.
So.
Hier machen wir Rider auf.
Für unser .NET Backend.
Hier machen wir Rust auf.
Für unser Low-Level-Web-RTC-Zeug.
Ja, Strives, wie kommt's?
Ich zeig dir gleich, was Sache ist.
So, Rust.
Und hier brauchen wir Whistle-Studio-Code für unser Frontend-Zeug.
Und zack, bumm, sind schon immer 80% RAM voll wahrscheinlich.
Haben wir hier einen Chrome...
Oh, es laggt.
Es laggt.
Alter.
Alter.
Die VM, man.
Was ist mit dem einen CPU-Core los hier?
VM?
VM, was ist?
Krieg dich schon mal wieder ein?
Das da oben ist meine CPU-Auslastung.
Also 8 Cores und jeweilige CPU-Auslastungen.
Was zum Teufel geht da im Hintergrund gerade ab?
Ah, Jetbrains.
Jetbrains macht's.
Jetbrains-Java-Dinger.
Mit Wim wäre es besser.
Ne.
Die CPU-Auslastung, ja.
Aber die Möglichkeiten...
Angenehme Sachen zu benutzen, eher nicht.
Es sei denn, du fragst die Hardcore-Wim-Fraktion hier auf YouTube, die für alles Wim-Only macht.
So.
Also.
Dann müssen wir noch unseren RTSP-Server starten.
Den haben wir...
Den hatte ich hier, glaube ich.
Hatte ich ein neues Tab auf.
EMP.
Dann hatte ich da den RTSP-Server drin.
Ja, RTSP.
So.
Da liegt hoffentlich auch das Video drin.
RTSP-Server starten.
FFM-Pack.
Restream.
Plup 2.
Ne, das TS-File haben wir gestreamt, gell.
Okay, und jetzt schauen wir mal, ob alles funktioniert.
Local Host Port 80...
Achso, ich muss die Anwendung ja noch starten.
Äh, Tab...
Das ist ein ganz schön langes Setup hier, bis es funktioniert.
Okay.
Run.
Jetzt schauen wir mal, ob der Kram an sich noch funktioniert.
Dann erzähle ich mal kurz was zu.
Okay, Prager.
Okay, es funktioniert.
Nice, also.
Wir streamen das Video in den Browser.
Alles gut.
Schon frei.
Ja.
Seit letzter Woche Freitag eigentlich die Arbeit vorbei.
Aber ich hatte dann noch eine Woche als Wochenende Bereitschaft und jetzt noch zwei Tage Teambuilding.
Also, so richtig...
Hardcut, so Urlaub.
Erst seit gestern.
Ja, und seit morgen...
So ist es.
Und morgen muss ich da ein bisschen MMO-Kreisekund machen.
Jetzt hat jemand gefragt vorhin.
Welches MMO?
Irgendwo?
Hier.
Hier.
Der ältere Meier hat gefragt.
Bist du noch da?
Welches MMO kann ich dir sagen?
Ich spiele ab morgen wieder...
Dark... äh, Dark Inn.
Dark Age of Camelot.
Das Spiel ist älter, als viele von euch im Chat.
Das kam 2001 raus.
Vor 22 Jahren, Alter.
Vor 22 Jahren, Alter.
Und ich habe es zu EU-Release angefangen zu spielen.
Und ich habe es zu EU-Release angefangen zu spielen.
Und spiele es eigentlich durchgehend immer wieder.
Bestes MMO ever.
Ever.
Nee, gab noch keine Diskussion über die Azubi...
über die FISI-Abschlussprüfung.
Oder Fachinformatik-Abschlussprüfung.
Nee, nichts.
Ich war auch hier nicht on.
Seit dem...
Seit Montag.
Also gab es noch keine Diskussion drüber.
War noch keine Möglichkeit drüber zu diskutieren.
Und wie war die Abschlussprüfung?
War die auch wieder unschaffbar, wie die letzte?
Also, unser Video stoppt.
So, kurze Sache.
Ihr könnt euch gerne über die
über die Fachinformatik-Abschlussprüfung auslassen.
Da sage ich auch gleich was zu.
Wenn ein paar Leute First-Hands-Experience
da haben.
Also, ich sage noch ganz kurz was zur Anwendung.
Wir werden das heute verdockerisieren, dass ich das ordentlich
testen kann, beziehungsweise ordentlich laufen lassen kann
bei mir lokal.
Ganz kurz, ganz simpel Übersicht,
was es gibt.
Wir haben eine Anwendung am Start mit etwas viel
Debug-Output, wie es aussieht.
Wir haben eine
ASP.NET-Web-Anwendung
für die
ja, fürs Frontend,
also als API-Endpunkte fürs Frontend.
Dann haben wir eine Rust
Low-Level-Web-RTC-Geschichte.
Und wir haben ein bisschen
JavaScript, HTML, CSS.
Was passiert, ist folgendes.
In diesem Video nur ganz kurz.
Heute auch nur ganz kurz.
Provider.
Ich kann das nicht.
Ich kann Provider so gut aussprechen,
wie SemperVideo.
Provider.
Ich kann es nicht.
Das ist einfach Original.
Also, im Prinzip
läuft es folgendermaßen.
Kamerastream läuft hier.
Der Kamerastream,
gerade streamt er ein YouTube-Video
von mir, okay?
Kamerastream, RTSP-Server,
FFmpeg pumpt da ein Video rein.
Backend,
äh, .NET-Backend geht per FFmpeg
an den Stream dran.
Und liest
den Stream aus. Dann baut
es mit dem Browser eine WebRTC-
Verbindung auf, mit Hilfe der Low-Level
WebRTC-Rust-Library.
Und dann streamt es das Video
in den Browser. Okay, so
funktioniert es gerade.
Das ist jetzt wirklich absolut High-Level-Overview.
So, nachdem ich das später ja
laufen lassen möchte,
in einem Container,
müssen wir das Ganze jetzt erst
mal vercontainerisieren.
Das heißt, wir brauchen jetzt
weder Rust, noch .NET,
noch JavaScript,
noch sonst irgendwas in der Richtung.
Deswegen stoppe ich die Anwendung
mal wieder. Und wir müssen uns jetzt mal ein
Docker-File aus den Fingern saugen,
das Sinn ergibt.
Ich glaube, dass das tatsächlich ein etwas
komplizierteres Docker-File wird,
weil...
Alter...
Monke ist...
...
Was ist denn jetzt los hier?
Das hört sich ja fast schon
hier...
...mäßig an.
Kommst du mit Rust inzwischen besser zurecht?
Ja, mache ich.
Man muss sagen, das ist zwar bestimmt
immer noch nicht
komplett, so wie das der Rust
Expert
designen würde, aber ich muss
sagen, ich finde, das ist schon ganz brauchbar.
Und du kannst es auch in dem Fall
gar nicht so bauen, wie es der
Rust Expert im
Rust-only-Ökosystem machen würde,
weil wir müssen das Ganze ja über eine C-Schnittstelle
aufrufen von
.NET aus. Also insofern...
Es ist deutlich weniger
Unwrap und sowas drin als am Anfang noch.
Da geht jetzt zum Beispiel sowas
drin wie if let some track
bla sonst wie und...
...
...
Guck mal, und hier...
Das sieht wirklich schon
ziemlich Rust-like
gebaut aus, ja.
Gut. Alright.
Ich würde sagen, wir
dockerisieren das mal.
Also, warum ich glaube, dass das gar nicht
so einfach wird, da ein
reproduzierbares Dockerfile zu...
...
...
Warum das gar nicht so einfach wird, ist,
ich will ein kleines
Image haben, und das, was ich
hier brauche, ist nicht klein.
Das heißt, es muss auf jeden Fall ein Multi
Stage Build, heißt das glaube ich,
werden, wo wir mehrere
Docker-Container haben, wo dann nur
mehrere Docker-Container
beim Build-Prozess benutzen,
um dann daraus
ein möglichst kleines resultierendes
Docker-Image zu bekommen, was wir starten
können. Das heißt, wir machen jetzt erstmal
Docker-Stells. Machst du bei
Advent oft... Zeig mal, was gibt's denn da...
Was gibt's denn da dieses
Jahr... Muss ich das dann auch
in Rust programmieren, Leute, wenn ich damit mache?
Was gibt's denn diesmal für Aufgaben?
Kalender.
Eins.
Oh, Kabel, ja.
Erlang.
Fortran.
Okay, das muss ich
mal in Ruhe durchlesen.
Ich schreib mir das mal auf. Leute, ich schreib mir das mal auf.
Vielleicht machen wir das...
Vielleicht machen wir da echt mit.
Ja. Warum nicht?
Ist doch immer ganz nice.
In was?
Was ist Vlang?
V-Programming.
V-Programming-Language.
Ich sag V.
Die V-Programmiersprache.
Das sieht ein bisschen aus
wie Go, ehrlich gesagt.
Das sieht...
Das sieht Go doch...
Also außer, dass es Fn ist und so, aber...
Moment mal.
Ist Go oder Rust Fn?
Ich bin grad verwirrt.
Rust ist Fn.
Das sieht eine Mischung aus wie zwischen Go und Rust.
Okay.
Ah, ich weiß ja nicht.
Ja, aber das ist jetzt ja nur wirklich kein
Aushängeschild von der Sprache.
Wie groß der Compiler und wie lange es dauert
den Compiler zu bauen, oder?
Ich mein GCC... Ich wollt grad sagen!
Alter, GCC
ist halt auch wieder so ein Ding. Das dauert auch 3 Stunden
bis das fertig ist.
Was aber nicht heißt, dass wenn ich GCC
benutze, dass das schlecht sein muss dann.
Wobei GCC checkt halt auch keiner mehr.
Ist das so? Ich hab damit...
Keine Ahnung. Ich kann dazu nicht
sagen.
Okay, wir bauen jetzt ein Docker-File. Auf geht's!
Ich versuch mal ein bisschen was dabei zu erklären, okay?
Chatgear, wer von euch
hat
viel Plan von Docker?
Also ich krieg das hin. Ich will bloß mal so grob wissen.
Also, machen wir's mal anders. Machen wir's mal anders, ja?
Wer von euch würde
sagen, er ist der krasse
Docker-Container-Bau-Experte?
Wobei man sagen muss, streiche Docker, streiche
Docker, ersetzt es einfach durch Container.
Ja? Weil mit Docker
hat ja außer als CLI-Tool
mit den eigentlichen Containern und das,
wie das heute im, sagen wir mal so, im Enterprise-Umfeld
läuft, eigentlich nur noch wenig zu tun.
Ja? Also seid ihr die krasse
Container-Bau-Profis?
Oder seid, würdet ihr eher sagen,
würdet ihr eher sagen, naja...
Ich hab schon mal ein Docker-File erstellt, aber
sonderlich kompliziert war das nicht.
Also, war das nicht. Waren ein paar Zeilen und fertig ist.
Okay. Also,
denn wir müssen jetzt, ich versuch das mal zu erklären
und dann hoffe ich, dass es
funktioniert.
Also, ich stell mir
das folgendermaßen vor. Wir brauchen ja...
Moment.
Muss ich mal gucken. Also, Ziel ist,
Ziel ist erstmal, ich weiß nämlich nicht, wie lange ich Zeit hab,
vielleicht hab ich nur bis 15 Uhr oder 14.30 Uhr
oder irgendwie so Zeit. Ziel ist erstmal, dass wir
ein Docker-File bauen, was unsere Anwendung eben
in ein Container-Image baut.
Das, das bisschen
unhandliche an dieser Anwendung ist,
ihr seht, es gibt ein
ein Low-Level-Part
in Rust. Das mit Go könnt ihr euch
wegdenken. Das mit Go
gibt es nicht mehr. Also, das gibt es noch, aber
das benutze ich, benutze ich aktuell nicht. Das ist einfach nur da,
zum abgucken. Es gibt
also, es gibt eigentlich
mehrere Parts. Wir brauchen einmal
den Low-Level-Rust-Part
und wir brauchen den .NET
Backend-Part. In Frontend
ist noch nichts drinne. Das ist, das
hab ich mir mal angelegt, falls ich ein bisschen mehr
mache als eine HTML-Seite.
Und in...
Ja.
Hier ist das Rust-Zeug drin.
Und das Ding ist halt,
ihr seht schon,
die Dinger sind relativ groß. Also,
Rust ist 2,2
Gigabyte. Erinnert mich ein bisschen an Node-Modules.
Die installieren ja auch
immer Gott in die Welt. Nicht ganz so
schlimm wie Node-Modules. Node-Modules
wäre das Ding wahrscheinlich eher 15G
groß. Aber Rust ist,
haut auch schon mal richtig rein.
So, dann haben wir unser .NET
Backend und das war's.
So, und wir können jetzt halt nicht einfach
hergehen und ein Docker-Image bauen,
die Anwendung drin bauen und das
Docker-Image hochladen. Was heißt können wir nicht?
Doch, das können wir schon, aber
das machen wir jetzt auch, dass ihr seht, wo das
Problem liegt. Das Docker-Image
ist dann am Ende halt saumäßig groß.
Weil der ganze Mist, den wir hier drinnen
brauchen, um es zu bauen,
dann im Docker-Image landet.
Das will man ja eigentlich nicht. Du willst ja
eigentlich nur den Output haben.
Kann man für Rust kein Docker-Ignore mitgeben?
Doch kannst du, aber du brauchst dieses ganze
Zeug hier drinnen, wenn du die Rust-Anwendung
baust. Also das heißt, du brauchst es dann auch
in den Build-Container.
Und wenn Build-Container gleich
als Basis
für das Image verwendet wird, sind die im
Output-Image auch drinnen. Und dann hast du im Endeffekt
dann Docker-Images, die
3GB groß sind. Das ist natürlich
Kacke. Das will man nicht haben.
Deswegen wird es wahrscheinlich auf ein Multi-Stage
Bild rauslaufen. Ich glaube, so heißt das.
Dass wir erst einmal
Rust bauen, dann
.NET bauen, dann die Sachen rüberkommen,
kopieren und am Ende dann
einen möglichst kleinen
Container bauen.
Doch, doch, doch.
Wir fangen jetzt erst
mal an, wie alle anfangen mit
Docker-Files. Und zwar
wir schreiben das mal untereinander
und da werdet ihr auch gleich sehen, wo das
eigentliche Problem ist.
Ich will ein Debian-Image
nach Möglichkeit.
Also wir fangen mal ganz unbedarft
an. Wir nehmen ein Debian-Image, installieren
uns alle Abhängigkeiten,
kompilieren das und gucken mal, wie groß das Image ist.
Ich persönlich denke, wir werden
am Ende ein Multi-Stage-Bild haben,
das offizielle Rust-Image
für Rust zum Kompilieren verwenden,
das offizielle
ASP.NET-Image
verwenden für das Output-Image und
wahrscheinlich ein stinknormales Debian oder so,
um die .NET-Sache zu
bauen. Oder ne, Moment. Microsoft hat
ja auch offizielle
SDK-Images zum Bauen.
Wir machen das erst mal von Hand und dann
verbessern wir das nach und nach. Also
from, jetzt habe ich keine Ahnung,
Debian-Docker-Hub,
wie da die Tags heißen.
Bookworm. Bookworm klingt gut.
Das ist einfach
Debian-Bookworm, oder?
Debian-Bookworm.
Hau mich einfach gleich
an Rust-Image. Doch, doch, doch.
Wie gesagt, da wird es wahrscheinlich drauf rauslaufen.
Da wird es
wahrscheinlich drauf rauslaufen.
Aber ich bin mir noch unschlüssig,
wie wir das überhaupt bauen.
Also, from Debian-Bookworm
S-Bild oder sowas.
Na, es juckt.
So. Wir bauen
jetzt erst mal ganz simpel
so untereinander das, was wir brauchen,
damit die Anwendung baut. Und dann machen wir es
schön, dass es auch klein wird und dass es nur das
baut, was es soll und rüberkopiert.
Und dass man dann auch sieht, dass es
durchaus Sinn macht, mal
länger als zwei Minuten
in seine Docker-Files zu stecken.
Also. Ich würde
sagen, wir benutzen aktuelles Debian-Image,
weil Debian beste.
Da haben wir sowas wie WorkDir. Kann man das eigentlich auch
kleinschreiben? Ich glaube, man darf das kleinschreiben.
Irgendwie habe ich mir das so angewöhnt, das
immer groß zu schreiben.
Das kann man aber, glaube ich, mittlerweile auch kleinschreiben.
Ja, die schreiben es auch groß. Guck hier
in ihren Examples.
Also, wir fangen ohne Multistage-Bild an.
Wir fangen ganz simpel mit einem
Debian-Image an
und lassen das mal da drinnen bauen. Also,
WorkDir. Machen wir mal sowas wie Bild.
WorkDir heißt,
alle Sachen an Befehle, die jetzt hier
kommen,
kannst du ausführen, ohne dass du vorhin CD
reinschreiben musst, ja?
Also, wenn man jetzt zum Beispiel sowas hier macht,
wie Copy oder sowas,
von A nach B,
dann bezieht sich das automatisch auf Bild.
Was ganz... Achso! Und es sorgt
dafür, dass das Verzeichnis, glaube ich, sogar angelegt wird.
So, als erstes,
weil es ein Debian-Image ist,
run apt
get update.
Okay, also
docker-build.
So, es ist noch nicht
viel passiert.
Hat der jetzt wirklich geupdatet?
Das erscheint mir...
Erschien mir ein bisschen
schnell. Okay,
dann run apt get install.
Was brauchen wir auf jeden Fall?
Wir brauchen bestimmt curl wget.
Curl und so Zeug.
Wget bestimmt auch.
Macht das jetzt was?
Was? Ah!
Y fehlt.
Muss man machen, wenn man das in Scripts verwenden will.
Ansonsten will er nämlich, dass man yes
eintippt. Und man kann nicht yes eintippen,
wenn es interaktiv in einem Script läuft.
Okay, hat funktioniert.
Übrigens, auch so ein Ding.
Docker verwendet ja
seit ein paar Versionen Buildkit.
Also, vielleicht kennt ihr noch Docker-Builds von früher.
Die waren...
Ja...
Sahen anders aus, auf jeden Fall.
Mittlerweile verwenden die ja, glaube ich, Buildkit,
weil es ja nicht verfügbar ist.
Ich muss sagen, mir hat der Output früher besser gefallen,
als der Buildkit-Output.
Der Buildkit-Output sieht sehr fancy aus.
Du hast recht.
Das ist sinnvoll, falls irgendwelche
Rückfragen bei apt kommen.
Ja, das stimmt.
Das schenken wir uns jetzt mal, weil ich wahrscheinlich
eh das Debian-Image da nicht verwenden werde.
Ich weiß gar nicht,
ob man das zum alten Output
wieder umformatieren kann.
So.
Ich gehe jetzt weiter.
Wir installieren ein paar Sachen.
Ich bin mir nicht sicher, was wir sonst noch so brauchen.
So, jetzt...
Ich würde sagen, wir bauen...
Wir bilden erstmal Rust, okay?
Wir bilden erstmal Rust.
Damit man Rust bilden kann,
im Container, also die
Rust-App,
muss ich quasi alles, was hier drin ist...
Ne, Moment.
Nicht alles, was hier rüber ist.
Garantiert nicht alles, was hier rüber ist.
Weil, dann kopiere ich auch 2 GB
weiter rein. Das will ich ja garantiert nicht haben.
Also,
ich will eigentlich nur
aus Web... Wie heißt das Ding?
Mein Ordner.
Aus WebRTCRust
will ich eigentlich nur
Source und die Cargo
Files rüber kopieren.
Cargo ist das NPM von Rust
und in Source liegen halt, wer hätte es gedacht,
die Source Files.
Also, copy
WebRTCRust
Machen wir mal irgendwie sowas.
Cargo, Sternchen,
dahin, copy all, docker, ignore.
Können wir auch machen, aber es sind nur 2 Sachen,
die wir kopieren müssen. Es sollte wahrscheinlich so auch
gehen. So, und dann Source
kopieren wir rüber. Source.
Ich glaube, das muss man so nennen,
damit das funktioniert.
Was macht es denn?
S bezieht sich auf was?
Weiß es Rastprogramm?
Rust.
Was das macht?
Das
sorgt dafür, wenn du ein Update
machst und Rückfragen
kommen in Debian,
dass es die Rückfragen halt einfach
mit der Default Antwort beantwortet.
Anstatt
dass du eine Abfrage kriegst.
Weil du kannst ja in einem interaktiven
Skript, im Docker-Bild,
keine interaktive Abfrage machen an den User.
Weil es gibt ja nichts
zum Inputten.
Also du hast zum Beispiel eine Sache.
Stell dir vor, du hast von Hand
deine ssh-Config rumeditiert.
Du machst ein apt-get oder
apt-upgrade, apt-was auch immer.
Eines der Update-Commands.
Und er sagt dir, hey User,
du musst mir jetzt sagen,
ob du die Default-Maintainer
Version der ssh-Config installieren
möchtest beim Package-Upgrade
oder ob du deine Version behalten
willst. So, ich glaube
Default-Antwort ist deine Version
behalten. Wenn du
das ausschaltest,
dann nimmt er immer die Default-Antwort und fragt
dich nicht. Weil er kann dich ja in einem interaktiven Skript,
was ohne dich läuft, nicht fragen.
So, schauen wir mal, ob das jetzt funktioniert, was ich
hier gemacht habe. Bild.
Ja, scheint
funktioniert. Ist das
nicht durch den Parameter y
nur halb? Das bezieht sich nur auf die
Abfragen von apt, beziehungsweise von
apt-get. Wenn irgendwelche
Packages,
die apt selbst upgradet,
Abfragen haben, dann nicht.
Das bezieht sich nur darauf, dass du nicht mehr
yes bei apt eingeben musst.
Okay, das hat funktioniert.
Dann ist jetzt die große
Preisfrage, Chatge.
Wie kriegen wir
Rust
in unserem
Debian-Image installiert? Ich würde sagen
Rust up, installieren
das damit. Perfekt, exzellent, das wollte
ich haben. Gut, dass wir in weiser Voraussicht schon
mal curl installiert haben.
Was ist das? Run curl proto
https tls v1.2
ssf
ex, genau das wollte ich haben.
Das ist, genau so hätte ich es auch
selbst geschrieben.
So.
Bild. Oh.
Was jetzt?
Unable to run interactively.
Run with minus
y to accept
ach so.
Ach so, ach so.
Jetzt bin ich mir unschlüssig. So?
Nee.
Moment, ich weiß, wo ich mir das abgucken kann.
Warte mal.
Hier, hier, exzellent.
Äh, minus y.
Ja, das stimmt.
DPKG ist ja eigentlich
die Debian-Geschichte für Packages.
Okay, Rust wird gedownloaded.
Das brauchen wir wahrscheinlich nicht, wie gesagt.
Ich denke, ich werde dann auf das offizielle Rust-Image
wechseln, was glaube ich auch auf
Debian basiert, wenn ich das richtig im Kopf habe,
gell? Ich glaube, das offizielle Rust
Docker-Image basiert auch auf
Debian.
Wie das die geilen Leute sagen.
Ja, guckt hier.
Booster.
Gibt's Bookworm? Bullseye gibt's?
Bookworm gibt's auch.
Und Alpine haben sie auch am Start.
Aber Alpine, scheiß drauf. Kein Bock.
Geh weg.
Müsste deine Variante mit minus
minus minus y auch gehen? Keine Ahnung.
Nachdem ich mir da unschlüssig war.
Wir können es ja mal ausprobieren. Nachdem ich mir da unschlüssig
war, habe ich es mal sein gelassen.
Nee.
Funktioniert
nicht.
Weil minus minus heißt ja eigentlich,
es kommen keine Options mehr. Keine Ahnung.
Ehrlich gesagt
checke ich auch gar nicht, was das macht.
Aber ich weiß, dass es funktioniert.
Und deswegen...
Ach so.
Okay, Standard-In. Aber warum
brauche ich Standard-In, wenn ich es doch schon reinpipe
in Standard-In? Wie dem auch sei,
keine Ahnung. Ist mir auch wurscht. Es funktioniert.
Debian Alpine sehe ich
tatsächlich auch so.
Ich kann jetzt zumindest aus meiner Sicht erklären,
warum ich der Meinung bin, dass Debian größer Alpine
ist. Also, eines der riesen
Vorteile von Alpine ist ja erstens,
dass es minimalistisch ist.
Minimalistische
Containerdistribution finde ich aber gar nicht mal
so relevant, weil
wenn du richtig dein
Docker-File baust,
kopierst du ja nicht quasi dein Bild-Image
in dein Target-Image rein,
sondern nur das, was du gebaut hast in dein
Target-Image rein. Das heißt also das Image,
was du dann eigentlich startest. Das heißt, es ist
eh gar nicht so wichtig,
dass das ein besonders minimalistisches
System ist, weil Debian ohne zusätzliche
Sachen installiert ist auch relativ
minimalistisch. Dann ist es vielleicht
15 MB mehr
als Alpine oder so, aber so what.
Juckt ja nicht. Dazu kommt,
dass Alpine regelmäßig mal Problemchen hat.
Zum Beispiel mit DNS-Auflösung.
Ich weiß nicht, ob das
mittlerweile gefixt ist, aber
Debian Alpine hat
glaube ich mit DNS-Antworten größer
... einem
Kilobyte oder sowas Probleme.
Alpine DNS
Error. Ja,
genau, hier.
DNS-Resolution in Alpine.
Ach ja, und das liegt daran,
dass Alpine, um besonders
minimalistisch zu sein,
nicht die normale
glibc verwendet,
sondern musel
libc. Das ist quasi
eine alternative Implementierung
der c-Standard-Library.
Wobei man sagen muss, was
in glibc drin ist, ist nicht unbedingt
alles rein standard.
Es ist eine
Neuimplementierung.
Und besonders minimalistisch
und schön für
Selfcontent-Anwendungen und sowas.
Darauf basiert Alpine, aber
die haben zum Beispiel Probleme aufgrund dessen
mit größeren DNS-Antworten. Ich bin mir gar nicht
sicher, ob hier drin steht, was das eigentliche
Problem
ist. Aber das Problem
ist, wenn die DNS-Antworten zu groß sind,
...
... dann gibt es
einen Error in Alpine.
Zumindest war das mal ein größeres
Problem vor einem halben Jahr oder so.
Das habe ich mir gemerkt.
Das kann durchaus sein, dass es gefixt ist.
Jaja. Das kann durchaus sein,
dass es gefixt ist.
Ich gehe auch mal stark von aus, dass es
gefixt ist. Aber Alpine hat öfters mal kleine Probleme.
Das Debian-Image ist größer,
das stimmt. Aber so ein riesen
Unterschied ist es am Ende nicht.
Und ich finde Debian einfach angenehmer.
Cargo-Chef.
Was es nicht alles gibt.
Cargo-Chef.
Das ist der Grund, warum ich Debian
gerne verwende als Base-Image.
Wie gesagt, ich glaube auch gar nicht, dass wir hierbei
bleiben werden, sondern das Rust-Base-Image
verwenden. Okay.
Jetgear, auf geht's. Docker-Build
am Start. Und jetzt
müssen wir Rust
bilden. Also,
wir brauchen jetzt sowas wie
Cargo-Build-Release.
Wir testen erstmal, ob das so
funktioniert.
Also, run, cd,
achso, Moment.
Was muss man machen,
nachdem man Rust abinstalliert hat?
Werden wir jetzt gleich sehen.
cd webrtc rusts
und da drinnen machen wir jetzt
Cargo-Build-Release. Vermutlich wird das nicht
funktionieren.
Bam, wer hätte das gedacht?
Can't cd to webrtc
rusts.
Warum nicht? Was ist das Problem?
Ah, ich kack noob.
Ich muss gar nicht cd'en. Ich habe doch alles hier
richtig hin kopiert. Lul.
Ich nehme wahrscheinlich
einfach die
offiziellen Microsoft ASP
.NET Core-Images.
So, Build.
Geht nicht, weil Cargo
not found. Ja, wunderbar.
Ähm, Alter,
wo liegt denn bitteschön Cargo,
nachdem man Rust abinstalliert
hat?
Okay, wir
...
Moment.
Wir gucken mal nach, Leute.
Wir gucken mal nach.
Wir machen uns mal einfach.
Wir taggen das Build schon mal gleich.
Und zwar als CamChamp
Version 0.1.
So, jetzt können wir sagen, docker run
...
Naja, "-rm".
Ist es "-it", oder ist es
...
Es gibt so ein paar Sachen, die mache ich prinzipiell
immer falsch.
So, CamChamp.
Bash.
Hat's funktioniert?
Okay, hat funktioniert.
So, ähm, was wollte ich jetzt
gucken, wo Cargo liegt, gell?
Also, wir sind jetzt, nur mal zur
Erklärung, falls man das so schnell
nicht mitgekommen ist. Ich zeig das noch mal.
Also, ich habe das Container-Image
gebaut. Und da kommt ja so eine
ID raus, oder
man gibt dem Container-Image einen Namen.
Einen Tag.
Und ich habe das, ich habe das
Image gebaut, ich habe das Image getaggt,
mit dem Name. Und jetzt kann ich
das Image starten.
So, und "-rm",
heißt, nachdem ich das Image gestartet habe
und quasi es wieder gestoppt wird,
soll es auch gleich gelöscht werden.
"-i", ist Interactive
und "-t", ist
Konsolen-Allocation oder
irgendwie sowas. Das ist
der Tag vom eben gebauten Image und das ist
das Programm, was er da drinnen starten soll.
Also im Prinzip startet er eine Shell,
im Container-Image.
Das heißt, wir können jetzt nachgucken,
wo RustUp den Kram
installiert hat.
Keine Ahnung. Guck mal, es gibt da auch ein
Cargo. Cargo? Bin?
Cargo.
Okay, vielleicht, soll ich das vielleicht direkt angeben?
Soll ich das vielleicht...
Wo ist eigentlich meine...
Wo ist eigentlich meine Cargo-
Tommel und sowas? Irgendwie...
Irgendwie ist die weg.
Badabumdingsbumsdansch
Wo ist denn die hin?
Die habe ich doch immer kopiert, die müsste doch eigentlich auch da sein.
Na, war es das nicht?
So, Build, Cargo,
Cargo, ne, Bin,
Cargo,
ja, äh,
Build.
No Cargo
Tommel found. Ja, ja, ist okay.
Ist gut, ist gut. Also
nochmal bauen. Run
und zwar Run Cargo
Build Release
und wo ist das Problem?
Sorry for Bash. Pog
Subscription. Wo ist das Problem,
dass er meine Tommel-Config
nicht rüberkopiert? Da ist sie doch.
Hier, guck, da ist noch Bestande.
Ach, guck mal, das ist klein geschrieben.
Muss das groß geschrieben sein vielleicht?
So. Übrigens, jetzt
sieht man eine Sache,
worauf man unbedingt achten muss beim Docker,
beim Docker-Image erstellen.
Was wird jetzt passieren, Leute,
wenn ich das nochmal bilden lasse?
Also, ich zeige euch das mal.
So, ja.
Docker Run, äh, nicht Docker Run, Build.
Ihr seht, zack, bumm,
geht relativ schnell. Und jetzt passt
mal auf. Wenn ich jetzt,
was wird, was wird jetzt passieren,
wenn ich das hier ändere
an der Stelle? Genau, Rebuild ab dem
Step. Der wird alles hier unten drunter neu
ausführen, also inklusive Download von Rust.
Das heißt, man sollte sich wirklich gut
überlegen, wie man seine
einzelnen Steps im Docker-File
definiert. Das heißt, es wäre
deutlich sinnvoller, die
Installation hier zu machen
und das Kopieren
und das Installieren danach.
Weil das hier wird sich
öfters ändern. Download
von der Rust-Runtime
muss wahrscheinlich nicht öfters
passieren. Build.
Hey!
Ach, nee.
Ich dachte, es kompletiert schon. Es lädt gerade Rust
runter. Rust.
Du, du, du, du, du, du,
du, du, du, du, du.
Au, au, au.
Ich weiß,
woran es liegt. Das ist Debian.
Dem fehlen seine ganzen
Package...
Devil Library
Geschichten.
Und jetzt kommt wieder ein Problem,
was ich habe, was ich mir bei Debian seit
Jahren nicht merken kann.
Wie heißt dieses Package?
Heißt es Build Essentials
oder heißt es Build Essentials?
Upt Install
Build Essentials
Essentials
Es heißt Build Essentials.
Nein, es heißt Build Essentials.
Ich bring das
ohne Scheiß jedes Mal, ich schreib das
jedes Mal falsch. Jedes Mal.
Glücklicherweise hat man Auto Complete und meistens ist es
kein Problem.
Build Essentials. So, und jetzt seht ihr,
was auch doof ist?
Ich passe diesen Step hier oben an
und jetzt wird alles nochmal neu ausgeführt.
Das heißt, man sollte schon
seine Docker Steps
carefull
wählen, dass das nicht
ausartet in
500 neuen Installs und so.
Ah ja, und jedes Image ist
lokal bei mir in der Registry noch drinnen.
Und ich müsste jetzt erstmal
Docker cleanen. Ihr werdet sehen,
guck mal, wir haben angefangen bei 100...
Wie viel haben wir? Warte mal, Chat ist doch ganz einfach
rauszufinden, bei wie viel
Plattenplatz wir angefangen haben.
Also wir werden jetzt einige Gigabyte
verschwinden.
Wir haben angefangen bei
100, guck mal,
3 Gig haben wir schon
verbraucht. Oh, guck mal,
es funzt.
Rust Compiled.
Oh, Alter, Rust Compiled, aber echt
lange. Rust
Placingly Fast.
Gut, ich mein,
es dauert halt 20 Milliarden Dependencies
zu... Boah, Alter, guckt euch
die CPU-Auslastung an, Mann.
Meine
VM ist einfach komplett...
Alter!
Fuck!
Okay,
er ist fertig, alles klar. Die VM ist einfach
komplett ausgesetzt. Aber ist ja gut, ist ja gut.
Unbenutzte CPU-Cores sind
wasted CPU-Cores, ja?
Okay, es hat
funktioniert, nice. So, wenn ich
jetzt nochmal bilde, geht's natürlich deutlich
schneller, alles klar. So, wenn das
jetzt funktioniert hat, nicht exec,
run, wenn das jetzt funktioniert hat,
haben wir hier eine
Target
Release
haben wir die Library drinnen liegen, okay.
Excellent, hat funktioniert, nice.
Alles gut.
So, Dockerfile.
Übrigens auch ein weiteres Problem,
wo jetzt Multistage-Builds schon sehr
sinnvoll wären, weil
wenn ich jetzt
was an meinem Rust-Source-Code ändere,
macht er dir alle folgenden, ab hier,
alle folgenden Steps
neu. Das heißt, als nächstes kommt hier unser
.NET-Build und da wird dann auch
jedes Mal neu ausgeführt, also
das wird auf jeden Fall auf
Multistage-Builds rauslaufen,
dass das ordentlich funktioniert.
Okay, aber ich will's
einmal zum Laufen bekommen, bevor wir's komplizierter
machen. Also, wir haben jetzt
hier Cargo, Cargo-Build, okay, das ist
richtig, alles klar.
Wie war das übrigens nochmal? Docker prune?
Ne, Docker oder Docker prune?
Es gab doch so ein
System prune.
Docker System
prune minus a, genau.
So, guck doch mal. Jetzt haben wir 106,
106 Gig.
Ich sag Docker mal, alle,
bevor ich jetzt irgendwie, ja,
ich glaube Ubuntu und
Hello World und Traffic brauchen wir nicht mehr,
sieben Monate ago.
Jetzt sagen wir mal, Docker
löscht einfach mal alles.
Oh fuck, jetzt muss ich den
Camp-Champ neu bauen. Egal, egal.
20, Leute,
20 Gig, einfach mal
weg. Ja, ja, ja,
hast du recht. Das geht jetzt aber nicht richtig,
wobei, naja, es würde doch, doch,
doch, es würde schon funktionieren,
ich könnte jetzt, ich könnte hier oben schon
die .NET Runtime installieren und sonst was,
aber das dumme ist halt, wenn man
sag mal so logisch gruppieren will,
so nach dem Motto, wir bauen erst Rust
und dann bauen wir .NET,
dann würde ich ab diesem
Step hier, sobald sich mein Rust-Source-Code
ändert, halt immer das, das ganze
.NET Zeug neu bauen. Deswegen, das
schreit eigentlich nach Multi-Stage-Build.
So, jetzt brauchen wir .NET
als nächstes.
Gig, hört sich
Boomer an. Echt, warum?
Was, was, was sagen die coolen Nichts,
was sagen die coolen Nichts-Boomer
zu Gigabyte?
GB? Wobei es ja
eigentlich Gibi, Gibi, ne,
Moment, Gibi oder Gibi
heißen müsste?
Gibi, gell?
Gibi? Aber es ist Meebi und nicht Meebi.
Niemand
Leute, ohne Scheiß, ich
kenne niemand, der diese Einheiten
verwendet, in der Aussprache, ja?
Vielleicht zum Rechnen und so, aber in der Aussprache
niemand, niemand.
Okay, weiter, jetzt brauchen wir, jetzt brauchen wir
unser .NET Zeug.
Gibt es offizielle Node.js-elt, äh,
Node.js-elt Images?
Node.js Chiseled Images?
Es gibt auf
jeden Fall offizielle Node Images, relativ
sicher. Nachdem ich wenig Node-Anwendungen
baue, weiß ich es nicht, aber es würde mich enorm
wundern, wenn es die nicht gäbe.
So, also, ich sehe schon, wir müssen trotzdem
die Sachen in unterschiedlichen Verzeichnissen
machen, weil ich kann ja schlecht
im gleichen Bildverzeichnis, äh,
.NET und Rust
bilden, wobei,
warum eigentlich nicht? Die kommen sich ja
nicht richtig, nicht wirklich in die Quere, oder?
Wobei, das durchaus, das ist,
das könnte durchaus ein bisschen verwirrend werden,
für den einen oder anderen Compiler, wenn
es mehrere, okay, schauen wir mal.
Also, als erstes müssen wir jetzt
.NET installieren. .NET lässt
sich relativ easy installieren, nämlich so,
.NET 8.
Ich schreibe jetzt mal was rein, bevor jetzt gleich,
jetzt hatten wir nämlich schon öfters im Chat, dass ich
10 Minuten vorher was erzählt habe,
und dann kam jemand rein,
beiß, danke schon für den Sub, Dennis, danke,
subscription, Leute. Ich schreibe das jetzt oben
als Kommentar rein, weil
viele im Chat lacken critical
information, wenn sie in den Stream reinkommen.
Und ich weiß nicht mehr, was es für ein Thema
war. Ich habe letztens, glaube ich,
20 Minuten lang,
fünfmal das gleiche erklärt, und dann
kamen immer Leute ins Stream und sagen,
Max, aber so macht man das doch gar nicht, macht
es doch so und so. Ja, ich
weiß, deswegen machen wir es erstmal einfach,
und dann machen wir es ein bisschen komplizierter, aber richtig,
fünf Minuten später kam wieder einer rein,
Max, aber das macht man doch gar nicht so, macht es
doch mal anders. Wir schreiben das da rein,
deswegen schreibe ich das jetzt mal da oben rein,
am Ende machen wir
Multistage, heißt das Multistage
oder Multistage Build?
Soccer Multi, ups.
Soccer Multistage
Build.
Das ist alles
an die
Five Hat Community
dass das nicht wieder so ist
wie das letzte Mal.
Style92
Pog-Subscription
Danke für die ganzen Subs, Leute, es ist
sehr...
So, also jetzt installieren wir erstmal
.net
Build
Warum bildet er
jetzt alles? Achso, weil
ich gerade alle meine Images weggeworfen habe,
ja, das würde es erklären.
Wenn man alle Images löscht,
Alter, meine Nase läuft zu schlimm,
ich habe nichts zum Putzen.
Nicht das hier irgendwie...
Nochmal
brauche ich das nicht.
Eine Sache sieht man aber jetzt schon,
was ein richtig großer Vorteil
von Docker ist.
Und es ist genau eines der Dinger,
wofür Docker ursprünglich erfunden wurde.
Für das ganze Zeug, was da raus
gewachsen ist an Container Ökosystemen
und wie teilweise
Docker heute auch, also Docker selbst,
für Sachen verwendet wird, wofür es gar nicht
gedacht ist.
Das war ja damals noch nicht abzusehen,
aber genau für sowas wurde
Docker ursprünglich entwickelt.
Nämlich um diese ganze Sache mit
ich entwickle was,
auf meiner Kiste kompiliert es,
auf meiner Kiste läuft es, aber auf dem Server
läuft es nicht, auf der anderen
Entwicklerkiste läuft es nicht, zu vermeiden.
Hauptsächlich ursprüngliche
Docker-Idee war ja sogar, es funktioniert
auf meiner Entwicklerkiste, aber auf der anderen
Entwicklerkiste nicht. Das war eines der ursprünglichen
Ideen in der Docker. Und man sieht auch schon,
dass es genau hierfür was
bringt. Auch wenn wir das hier nicht optimal machen
und wenn das langsam ist und wenn das nicht schön ist,
es ist nachvollziehbar.
Das heißt, wenn es funktioniert,
das Bild jetzt, und ich das Image
lösche, dann funktioniert es das nächste Mal wieder.
Und wenn das Image weg ist, ist der ganze
Müll aus dem lokalen System
auch weg. Richtig, genau.
So, jetzt haben wir .NET installiert.
Jetzt können wir als nächstes
äh Copy
aus unserem Backend-Projekt
können wir die ganzen CS-Files
rüberkopieren.
Da muss ich jetzt aber mal nachgucken, was wir noch so haben.
Wir brauchen
ganzen CS-Files und wir brauchen
das Projekt-File.
Mehr brauchen wir
eigentlich nicht.
Also alle CS-Backend-Files
und das Sternchen.c
Wobei, Moment.
Ne, das kopiert
ihr hier nicht mit. So, die zwei Files
brauchen wir. Danach
können wir theoretisch schon mal probieren,
wie es mit
äh .NET
publish. Warte mal, ich glaube, ich habe
gerade was im Handy gekriegt.
Nix. Dann können wir gucken, wie es aussieht mit
.NET publish
Wie geht das? War .NET build?
.NET publish
release. Das habe ich
Ja, und so, weil wir es
ja installieren mit Docker, äh
weil wir es ja installieren mit
mit dem Install-Skript.
Ok, .NET publish
release. Schauen wir mal, ob das
funktioniert. Docker haben
mir das Leben für meine Bachelor-Arbeit leicht gemacht.
Ja.
Genau für sowas ist, oh fuck, was jetzt?
Was hat er denn jetzt für Probleme?
Ja. Please install
libIQ.
Machen wir. Ja.
Das ist eines der wenigen .NET
Oh fuck. Oh fuck.
Ne.
Ok.
Das ist das Problem, wenn ich
alles da oben reinschreibe, dann muss ich
den ganzen Shit nochmal durchlaufen lassen.
Das dauert wieder zwei Minuten, da habe ich keinen Bock drauf.
Oh man, was? libIQ gibt's
nicht. Ok. exec
debian
Warum gibt's das? Nein, nein, nein, nein,
nein, nein.
debian, warum gibt's
das nicht? apt
apt search
libIQ
libIQ-dev muss ich installieren. Ok.
Alles klar.
libIQ-dev
highIQ
library
lib highIQ
Das sieht doch schon besser aus.
So.
Und jetzt haben wir unser Image am Start.
Mit
gebauter Anwendung drin, das heißt,
nachdem die Anwendung jetzt fertig ist,
achso, Moment, eins brauchen wir noch,
eins brauchen wir noch, wir brauchen noch
ähm, copy
das können wir eigentlich
danach machen, weil wenn sich das ändert, muss
ich die Anwendung nicht neu machen. Äh, copy
backend www root
nach
www root. Also für unsere
Webseite, die muss ja auch noch mit reinkopiert werden.
Build.
Ok. Run. Jetzt können wir
gucken, ob die Anwendung funktioniert.
Also unser Container-Image, würde ich sagen, ist jetzt
erstmal fertig. Mal gucken, ob's funktioniert, was
ich hier gebaut hab. Ähm.
.net
Ach, Moment. Oh, das ist ja kacke.
.net, .net
Und jetzt muss man glaube ich angeben,
wo ist es denn?
bin-release
backend-dll
Genau. Und bam!
Es geht nicht, weil unable to load
shared-library-web-rtc-rust
But why?
Warum ist
das denn? Achso, weil das im falschen
Ordner liegt.
Das liegt nämlich unter
target-release
lib-web-rtc-rust
Muss man auch noch gleich moven.
Jetzt gucken, ob's jetzt läuft.
Äh, wat?
Ach!
Nee, Moment. Nee, hä?
Vielleicht, weil das nicht im
im richtigen Verzeichnis liegt.
Einmal, cp
lib-web-rtc-rust
Kann sein. Ich bin mir nicht ganz sicher,
wo das hin muss.
release.net. Hier vielleicht?
bin-release. Also wir müssen unser Image
auf jeden Fall noch fixen.
.net
run
backend-dll
Ey, Funst!
Pog!
Warum funktioniert
denn das? Ich hab doch gar kein FFM-Pack drauf. Sollte
das jetzt nicht eigentlich
crashen? Weil...
Nee, das ist dumm,
was ich hier mache.
Such .net nach der Library im Verzeichnis,
wo du startest, wenn du nichts Spezielles
angibst.
Okay, also aber prinzipiell, das hier kommt von Rust.
Also prinzipiell funktioniert das.
Als erstes hat es natürlich keinen www-Root.
Wir müssen das auf jeden Fall noch ein bisschen
umkopieren. Das ist eklig so.
Ich will das Image aber
so eh nicht lassen. Insofern...
Was mich wundert, ist, dass der nicht meckert,
dass FFM-Pack
Probleme hat.
Hier. Ah, ich weiß,
woran das liegt, dass der nicht meckert, dass FFM-Pack
Probleme hat. Das ist nämlich in einem
Thread drinne. Und der Thread,
der crasht einfach. Und ich
bekomm nix von mit. Wir machen das jetzt mal
anders. Wir sagen jetzt mal FFM-Pack
Log Level
oder sowas. Konnte man doch hier setzen.
Set Log Level. Das setzen wir jetzt
hier irgendwie auf Quiet oder sowas.
Quiet, beste.
Wir setzen mal das Log Level und dann
sollten wir jetzt gleich nen Fehler bekommen.
Also was musste ich
jetzt noch machen? Ich musste,
ich musste es moven.
Kann man bei .net Publish
nicht nen Output Path angeben?
...
Das muss ich grad mal ausprobieren. Konnte man nicht sagen?
.net Publish
minus O Build.
Doch, konnte man. Also.
.net minus O kommt
nach Bild rein.
Und dann
moven wir noch.
Dann moven wir noch.
Target. Oh.
Mist. Vergessen, wo es ist.
Warum will ich ja nicht immer exec eintippen?
Target Release
libwebrtcrust.so
libwebrtcrust.so
...
Moven wir noch.
nach Build.
Ok?
So.
Und ich
hoffe, dass es jetzt ordentlich crasht.
Weil wenn es ordentlich crasht,
dann können wir nämlich
den Container ordentlich bauen.
So. Mal hier run.
Schauen wir mal, ob das hier gut aussieht.
Jetzt haben wir nen Ordner Build.
Ach so, da haben wir BWW-Route. Musste auch noch rein.
Wieso lese ich immer WebAds
Hier Crust
Passt doch
Ganzen Schalentiere hier
Krustentiere am Start
Okay
.NET, .NET, Run
Ne, nicht Run
Backend, DLL
Jawoll, FFM-Pack crasht
Okay
Das würde es natürlich erklären
Und jetzt sagen wir mal
Upt, Install, FFM-Pack
Das brauchen wir nämlich auch noch
Wir brauchen auch noch FFM-Pack
Oh, da fällt mir gerade was ein
Leute, es ist keine gute Idee, wie ich das gebaut habe
Wir sollten vielleicht eine
Statische, feste FFM-Pack-Version nehmen
Weil ansonsten
Ist es immer davon abhängig
Dass die Betriebssystem-Version
Also die Betriebssystem-FFM-Pack-Version
Von dem, was ich benutze
Als Base-Image
Mit der von meiner Entwicklerkiste übereinstimmt
Weil ich will ja neues FFM-Pack benutzen
Gucken wir mal, ob das jetzt funktioniert
Backend, nope
Der findet einfach mein FFM-Pack nicht
Obwohl es installiert ist
Das ist aber sehr
Keck-Weight
Gut, der Rest funktioniert
Also der Container scheint schon mal halbwegs
Halbwegs brauchbar zu sein
Äh, LD-Config
Lass mal kurz gucken, wo ist denn
Wo liegt meine Library
What?
Alter, was ist denn das für ein Scheiß-Fart
Lipx86
64
Linux-Knu
Da hätte ich ja im Leben nicht dran gedacht, dass das da liegt
Ja, da guckt meine Anwendung natürlich auch nicht nach, ob das da liegt
Außerdem ist es die falsche FFM-Pack-Version
Ich entwickle mit FFM-Pack 6.1, glaube ich
Und das hier ist FFM-Pack 5.9
Sehe ich das richtig?
5.1
Ja, das kann ja nicht funktionieren
Okay
So, dann fixen wir mal das Docker-Image
Weiter
Als nächstes mussten wir noch
Ne, das machen wir hier
Wo ist die Sache mit www.google.com?
Wo ist die Sache mit www.google.com?
Hier, www.root
Ne, www.root soll nicht dahin kopiert werden
Sondern nach
Build
Also das ist alles noch sehr unoptimiert
Hier
Wie, okay, wo bekommen wir eine statische
Also noch eine Build-Step
Um FFM-Pack zu bauen
Ne, ich baue FFM-Pack nicht
Es gibt ein Projekt, was Nightly Builds von FFM-Pack macht
Das werde ich verwenden
Ich bin mir nur nicht mehr ganz sicher
Wie das, wie das
Es gibt ein paar Projekte, die das machen
Das müssen wir uns vorstellen
Wir müssen es gleich mal auf Github raussuchen
Ich will jetzt aber erstmal checken
Ob prinzipiell das, was ich hier gebaut habe
Funktioniert
Also, .net
.net
.net
Backend
Okay
Gut, funktioniert alles
www.root ist auch da
Okay, es liegt echt nur an FFM-Pack
Jetzt müssen wir uns ein FFM-Pack-Build suchen
Mit allen Dependencies drinne
Und dann müssen wir uns ein FFM-Pack-Build suchen
FFM-Pack-Bild
Für, für Linux
Und zwar nicht ein Binary-FFM-Pack-Bild
Sondern mit
Ja, ich suche ja ein fertiges Bild
Sondern ich suche ja nicht die Binaries
Das könnte sogar das richtige Projekt sein, was ich suche
Lass mal, gibt es da nicht vielleicht sogar ein offizielles Docker-Image
Mit FFM-Pack-Library versioniert oder so?
Guck mal
Aber das ist wahrscheinlich nur normales FFM-Pack
Und nicht die FFM-Pack-Library-Library-Library-Library-Library-Library-Library-Library-Library-Library-Library-Library-Library-Library-Library
Oder?
Oder?
Oder?
Ne, das ist, na wobei, man weiß es ja nicht
Man weiß es nicht
Probieren wir mal aus
Holen wir das mal
CLI
CLI
Haben die auch ein Nicht-CLI-Image?
Wobei, bezieht sich, bezieht sich, auf was bezieht sich denn CLI?
Auf FFM-Pack?
Oder auf
FFM-Pack?
Oder auf FFM-Pack?
Dass das Image, dass es Shells und so dabei hat
CLI? LS?
Was sind denn die Unterschiede zwischen den einzelnen Sachen überhaupt?
Ja, das, das, so war ich, so schlau war ich auch
Ich vermute, da ist die
Das sind wahrscheinlich einfach nur Binaries
Und da ist die
Da sind die, die ganzen
Die Library-Parts von FFM-Pack, die spielen
Ich brauche gar nicht dabei
Okay, gucken wir, gucken wir uns das mal an
Also
Wir machen jetzt mal, wir starten einfach mal einen Docker-Container
Mit, mit dem Image
Und zwar FFM-Pack
Nehmen wir mal AMD64 Latest
Bäm
Und gucken wir mal rein
Was es da so gibt
Ob da FFM-Pack tatsächlich auch als Library drinnen liegt?
Weil da können wir nämlich die Images gleich verwenden
Und
Okay
Der versucht gerade FFM-Pack direkt zu starten
Mit einer Datei, die Bash heißt
Das ist natürlich blöd
Da müssen wir jetzt Entry-Point überschreiben
Minus, Minus
Entry-Point
Bash
Bin ich auf dem Kopf nicht gebacken, jawohl, doch gut
Passt
Hier, FFM-Pack ist am Start
Yep
AV
Ja
Ja
Ja, FFM-Pack ist am Start
Die bringen die, die bringen die Libraries gar nicht mit
Vermutlich
Lip
Äh
Die bringen glaube ich die ganzen Libraries nicht mit
Äh, suchen wir mal irgendwie nach
Die haben nur
Ne, na geil
Die bringen nur FFM-Pack
Die Binaries mit
Das bringt mir ja gar nix
Und was ist das?
Das ist das, dies, ne
Das ist natürlich blöde
Dann bringen wir mal FFM-Pack mit, das bringt mir ja gar nix
Dann bringen wir mal FFM-Pack mit, das bringt mir ja gar nix
Dann bringen wir die Images nicht wirklich was
Dann bringen wir die Images nicht wirklich was
Weil
Weil, weil, weil die FFM-Pack Binaries
Die brauch ich ja gar nicht
Gucken wir nochmal was da jetzt drin ist, ob das irgendwie anders ist
Wer sich fragt was das ist
Das hier listet alle Libraries auf, auf dem System, hier guckt
Und, ähm, AV-Format nennt sich eben ein Teil von FFM-Pack
Und, ähm, AV-Format nennt sich eben ein Teil von FFM-Pack
Das gibt es immer, wenn es FFM-Pack gibt
Ja ok, die Images bringen mir nix
Weil in den Images ist bloß FFM-Pack als Binary drin
Aber immerhin
Als halbwegs aktuelle, als genau die Version die ich brauch
Ok, das heißt wir müssen das selbst machen
FFM-Pack einbauen
Oder was haben wir sonst noch so für Images auf Docker Hub
Jellyfin, ne
WulHub
Oh vier, vor vier Jahren
Ne, ich glaube ich verzichte auf ein vier Jahre altes FFM-Pack
Kannst du nicht einfach ein fertiges Bild runterladen
Doch, doch, doch, doch, machen wir jetzt
Ich dachte nur vielleicht gibt es ein fertiges, fertiges Image-Container-Image was wir verwenden können
Updated eight years ago
Und was zum Teufel ist Open Coconut
Na gut, brauchen wir nicht
Gucken wir mal hier
Ich glaube das sind die richtigen Bills, das sind auch die die ich sonst immer verwendet, verwendet hab weil man
Weil man ein statisches FFM-Pack gebraucht hat
Ja
FFM-Pack
N1128 Dings
Git commit hash
Linux GPL
Linux GPL
Shared
Das klingt gut
Kann es sein, dass die Libraries von FFM-Pack sich LibAV nennen
Da gibt es mehrere
Es gibt AV-Format
Und AV gibt es auch
Aber es kommt
Also die Dinger nennen sich immer LibAV
Und dann kommt halt der Rest hinten dran
Aber es ist ja egal
Ich habe nach AV-Format gesucht und das hätte er finden müssen
Also da sind
Wir haben es ja auch gesehen, da lagen keine rum
Aber was haben die hier alles zur Auswahl
Die haben Linux 64
Haben die vielleicht auch
Irgendeine Tag-Version
Anstatt Master
So 6.6.1 oder so
Ja
Oder 6.0.1
Welche Packversion habe ich denn bei mir lokal
6.1
Gibt es hier 6.1
Ne gibt es nicht
Ach das liegt daran
Weil 6.1 wahrscheinlich gerade Master ist
Und 6.0.1
Das letzte Release
Kann das sein
Vermutlich
Dann nehmen wir mal 6.0.1
6.0.1 müsste auch klar gehen
Also 6.0.1
Linux
6.0.1
Linux 64
GPL Shared
Das brauchen wir
Was damit gemeint ist, ist folgendes
Also rate ich jetzt einfach mal
GPL enthält nur die
Open Source Codecs
Und
Minus Shared bedeutet
Das ist nur die Library Komponente
Und das hier ist Library Plus
Oder eventuell nur Binaries
Da gibt es aber keine oder
Das ist der Source Code oder
Das ist kein
Das ist doch nur der Source Code
Das ist doch bestimmt kein
Fertig gebautes
Ich glaube nicht das
Ich glaube das das nur der Source Code ist
Guck mal mal
Moment das heißt ja anders
Z muss weg
Ja guck das ist nur der Source Code
Das bringt mir nix
Da müsste ich FFmpeg auch noch selbst
Kompilieren
Ich hab da ein Grenzen den ich da drauf hab
FFmpeg kommt weg
Ok Dockerfile
Wir benutzen das hier
Wir benutzen das hier
Linux 64 GPL Shared
Gehen wir mal in unseren
Docker Container rein den wir eben hatten
Und probieren das da mal aus
Wie das da aussieht
Wget
Zack genau
So
X
F
Z nicht
FFmpeg
Ja das ist eine fertig kompilierte Library
Ok das ist gut
Hier haben wir es
Binaries sind auch am Start
Die wir nicht brauchen
Die können wir theoretisch löschen noch gleich aus dem Image
Da es ein bisschen kleiner wird
Da ist alles drin was wir brauchen
Genau
Excellent
Ok wir bauen unsere Anwendung kurz
Ein kleines bisschen um
Nämlich
Ich lade das hier auch mal runter
Wget
Dann packen wir
Das ganze in unser Docker Ignore File
Weil ich will garantiert nicht
Aber Dockerfile ist auch nicht
Also weil ich will ja nicht
FFmpeg da irgendwie drinnen liegen haben
Also
Machen wir in unser Git Ignore
In unser Git Ignore File
Alles was FFmpeg Sternchen hast
Soll weg
Ok
So
Also
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
So
FFmpeg suche ich jetzt unterhalb von FFmpeg slash lib. Ups. So, mal gucken, ob das jetzt startet. Run. Run. Und Funst. Nice. Ohne Fehler. Ja, ja, und es liest auch, liest auch die Sachen von der Kamera. Also, alles gut. So, FFmpeg slash, also, genau, FFmpeg slash lib.
Das heißt, im Endeffekt müssen wir jetzt nur das gleiche noch für den Docker-Container machen. Und dann bauen wir den Docker-Container noch ordentlich. So, jetzt haben wir das hier hinkopiert. FFmpeg. FFmpeg machen wir mal hier als letzten Step. Wget. FFmpeg. Wie, wie sagt man Wget, dass er direkt entpacken soll? Also, ta, kann man das einfach so reinpipen? H, X.
Vielleicht hat X nur
Z. Kein, kein, kein Pipe
oder so hin?
Ne.
Unexpected Enderfall.
Ähm.
Ne, Moment, man muss
Wget noch sagen, minus O, glaube ich, gell?
Für Output.
Oh, Moment. Wget
pipetar. So, wir fragen es der
Overflow. Hier.
Wget, groß O,
minus, gepiped.
Ne, Moment,
das muss ich jetzt hier erstmal testen.
Wget, minus, groß O, minus.
Das ist wahrscheinlich Standard-Out.
Gepiped nach ta, X, Z, F.
Alles klar.
Okay.
Nice, Stack-Overflow, GG.
Stack-Overflow lügt.
Ah, Moment, das ist kein Z. Ja, das ist richtig.
What?
Archive is compressed.
Use minus
J-Option.
Moment.
Ey, warum ist,
warum ist Chat,
äh, nicht Chat, warum ist, ist Stack-Overflow
falsch? Okay, minus
X, V, so?
Irgendwie? Hey!
Das funktioniert!
Nice, kaum macht man's richtig.
Okay, so, und jetzt ist die
große Preisfrage, ich lösch den ganzen
Kreml grad nochmal, ja, ja.
Jetzt ist die große Preisfrage,
wie kann man ta
den Output-Ordner-Namen angeben?
War das minus C?
Ta, Output-Directory-Name.
How to choose directory
name during
untarring.
Genau das wollen wir haben.
Minus C, pretty name, strip
components one.
Ach so, das ist, weil die M kardieren davor.
Anscheinend geht das nicht.
What?
Jetzt, okay, jetzt wird's
aber advanced. Was?
Minus, minus, transform
und dann regex
für den Dateinamen, oder was?
Ja, komm, komm.
Wir wollen's mal nicht übertreiben.
Ich würd vorschlagen, wir machen einfach
einen Move danach und gut ist, ja.
Es muss ja nicht,
wir müssen's ja nicht komplett übertreiben.
So, jetzt machen wir einfach Move,
FFM-Pack nach FFM-Pack.
Okay, alles gut. Und schon, und schon
ist es so, wie wir's haben wollen.
Wunderbar.
Man kann's ja mit Shell-Hacks auch
übertreiben.
So, und als nächstes jetzt noch
einen Move von FFM-Pack-Sternchen.
Nach FFM-Pack.
So.
Und dann
nach Build-FFM-Pack.
So, und wenn ich jetzt
alles gemacht habe, dann
sollte,
dann sollte mein Docker,
ups, dann sollte mein Docker-Container
funktionieren.
Ich, ich bin gespannt.
Dann löschen wir den Container
nochmal. Wir könnten
auch Quiet machen beim, beim BGET.
Ich glaub, minus,
minus Q ist es bei BGET und, ähm,
minus, minus S
ist es bei, also bei BGET
ist es minus Q für Quiet
und bei Curl ist es, glaub ich, minus S
für Silent, wenn man nicht will, dass der
unnötige
Terminal-Outputs macht.
Okay, Run.
Jetzt bin ich ja mal gespannt, ob das funktioniert, was ich hier gebaut hab.
Hier sind wir.
Bild, also .NET,
.NET,
.NET, Backend, DLN.
Falsche FFM-Pack-Version?
Fragezeichen?
Okay, das ist ausgesprochen
doof jetzt.
Das ist wirklich doof.
Was hat er denn für Schmerzen, man?
.NET, Run. Okay.
Unable to load.
Ja, ich weiß. Okay, ich kopier das mal,
kopier das mal wieder hoch.
Ja, okay, okay. FFM-Pack
nicht gefunden. Hab ich, hab ich,
kapiert? Hab ich kapiert?
Oh.
What? Alter, der crasht einfach.
Was ist denn das
jetzt?
Crashchamp.
Einfach, einfach
der Crashchamp am Start.
Weil ich grad versuche,
Rocker-Container zu bauen,
für meine Anwendung. Dafür brauch ich FFM-Pack.
Aber FFM-Pack zeigt sich
nicht
kooperativ.
Achso, ich hab auch die falsche Version. Guck mal.
Meint ihr, meint ihr, es könnte
daran liegen, dass ich
hier lokal FFM-Pack
6-1 habe
und im Container
FFM-Pack
6-0-1?
Was meint ihr? Könnte das das Problem sein?
Ich mein, es, es, es, es
deutet schon ein bisschen drauf hin, gell?
Wenn ich, wenn ich hier so Sachen sehe, wie
einfach, einfach
Instant Crash.
Warum crasht der denn?
Was ist das Problem, man?
Oh, Wim?
Okay, was, was hat er denn für
Stellen? FFM-Pack-Lib.
Ist das überhaupt richtig?
FFM-Pack-Lib.
Die sollten abwärtskompatibel sein.
Das hätt ich auch gedacht.
Aber
vielleicht doch nicht.
Was ist denn, wenn ich hier irgendeinen Mist angebe
und dann ausführe?
Run.
Dann sagt der Method not supported.
Hab ich das Richtige
runtergeladen?
Hm.
Hab ich da irgendeinen Mist runtergeladen?
FFM, also, der, der findet's offensichtlich ja auch.
Okay, wir machen mal kurz hier einen Return rein,
um zu gucken, ob's daran liegt.
Hier haben wir mal hier irgendwie Console.
Aber irgendwas, dass ich das jetzt, dass ich das
nicht, das schreiben muss. Console,
Console-Writeline, ja, perfekt.
Was?
Das artet schon wieder aus. Warum muss das alles,
warum kann das einfach nicht einfach funktionieren?
Hack W.
Bist du der Max von YouTube?
Erwischt.
Jetzt kann ich mich nicht mehr,
ausreden.
Warum geht das?
Okay, also bis hierhin funzt alles.
Aber dann crasht das hier
aus irgendwelchen Gründen.
Das könnte aber auch woanders ran liegen.
Fuck it, Alter.
Der, der crasht, irgendwo, okay, okay, der crasht.
Ach, ich weiß, warum der crasht.
Oh, ich kack Noob.
Alter, es funktioniert alles.
Guck mal.
Hier.
Fällt euch, fällt euch hier was auf?
Entdeckt ihr hier irgendwas, was im Container so garantiert nicht funktionieren kann?
Da liest einfach hardcoded von meinem lokalen RTSP-Server was.
Ne, das kann ja so nicht funktionieren, das gibt's ja da gar nicht.
Also da sieht man auch schon, mein Error-Handling ist absolut erste Sahne.
Der handelt einfach gar keine Errors.
Und, und sag mal so, so sollte man das ja auch nicht machen.
Das sollte normalerweise ein ordentlicher Background-Service sein, der sich auch bei Fehlern neu startet und sowas.
Das machen wir dann noch.
Machen wir dann noch.
Okay, ich lass es jetzt erstmal so, wie es ist.
Mein Docker-Container funktioniert auf jeden Fall.
Jetzt.
Jetzt funktioniert er.
Also, funktionieren bedeutet, er crasht, okay, ja, aber, aber, aber es funktioniert.
Also der Docker-Container ist korrekt.
Wir können, ich kann euch das auch beweisen, dass der funktioniert.
Wir machen hier einfach mal ein, kann man hier eigentlich return machen direkt?
Ne, ein return rein.
Wir machen dort ein run.
Und ihr seht, wir haben hier ein Return.
Und ihr seht, wir haben hier ein Return.
Und ihr seht, wir haben hier ein Return.
Zack, es läuft.
Alles klar.
Bam.
Funst.
Ah, wir brauchen noch was.
Wir müssen die Interfaces überschreiben, wo er dran bindet.
Und zwar ASP.NET Core Environment Variables für den Port.
Das da will ich haben.
Minus, minus, urls.
Command Line Argument.
Okay, das ist auch gut.
Minus, minus, urls.
Also, da wollen wir dann haben.
Soll Listen an HTTP, Doppelpunkt, Doppelpunkt, Sternchen, Punkt.
Jetzt brauchen wir mal irgendeinen Port hier.
Keine Ahnung, 8044.
Funst, nice.
Okay, da muss das noch als Command in unseren Docker-Container rein.
Jetzt sind wir mal so frei und kommentieren den ganzen Mediakrempel aus.
Gehen wir mal in das Docker-File rein und sagen am Ende cmd.
Ja, also das würde höchstwahrscheinlich...
Ne, Moment.
Sekunde.
.net
CD, Bild.
.net
Backend-DLL
So, ich hoffe, das funst jetzt.
Bild.
Ja, jetzt muss er noch mal kurz das .net-Bild machen.
So, dann soll der Docker-Container funktionieren.
Wenn der Docker-Container jetzt funktioniert, dann werden wir anfangen, den Docker-Container ordentlich zu bauen.
Weil, ich zeige euch auch gleich, was das Problem ist.
Ein Problem habe ich euch ja schon gezeigt.
Wenn ich jetzt was ändere in dem Container-Setup, dann dauert es halt ewig, bis das neu gebildet ist.
Weil der halt von den einzelnen Steps her kaum was cachen kann, ja.
Also sprich, wenn sich an meiner Rust-App was ändert, muss der quasi ab Step 6 alles neu bauen.
Das dauert halt.
Und dann noch schlimmer, wenn ich ein zusätzliches Paket in meinem Image haben will, dann muss er alles ab Step 4 neu bauen.
Das suckt halt, ne.
Okay, probieren wir mal aus.
Docker, Run, CamChamp.
Schauen wir mal, ob es geht.
Zack, funzt.
Docker-Image tut.
So.
Ein weiterer Punkt, warum es eine blöde Idee ist, so ein Docker-Image zu bauen.
Euch fällt hier vielleicht was auf.
Das Docker-Image ist 3,6 Gigabyte.
Ich meine, das heißt nicht, dass es nicht funktioniert.
Aber, ein bisschen groß ist es wahrscheinlich, ja.
Du kannst dein Zeug auch in einer Pipeline bauen und die Artefakte nur in den Container kopieren.
Ich wusste, dass gleich irgendjemand kommt und sowas in der Richtung erzählt.
Wobei, da warst du doch sogar da, wo ich das gesagt habe.
Lass mir das nicht so lassen.
Also, man sieht, es ist ein bisschen doof.
Ach so, du meinst, dass du irgendwie GitHub-Actions machst und dann den Output...
Ja, okay, das wäre nochmal eine Nummer-Advancer.
Das machen wir vielleicht das nächste Mal.
Müssen wir mal gucken.
Also, das funktioniert.
Das ist allerdings, wie man sieht hier, echt sehr doof.
Ja, so ein 8,6 Gigabyte Container-Image.
Sackt ein bisschen.
Ich schmeiße nochmal alle meine Container-Images weg.
Das wird man gleich sehen.
Da haben wir wieder 5 Gigabyte freigegeben.
Und jetzt machen wir das Ganze nochmal in hübsch.
Also, was ist denn...
Ah, hier.
Was ist denn die Essenz aus dem Ganzen, was wir hier machen?
Wir installieren Rust.
Kompilieren die Rust-App.
Wir installieren .NET.
Kompilieren die .NET-App.
Installieren die Abhängigkeiten für .NET.
Kompilieren die .NET-App.
Kopieren die Rust-Library, die wir hier oben gebaut haben, in den Output.
In den Output-Folder, wo dann die Anwendung drin läuft.
Kopieren die Webseite in den Web-Server-Folder.
Wir downloaden den FFmpeg.
Und kopieren es an die richtige Stelle.
Und am Ende sagen wir, wie man das Ganze starten kann.
So.
Also.
Das Ganze jetzt noch in schön.
Und es gibt so was.
Also, ihr habt jetzt gesehen.
Chat, ich möchte, dass ihr das alle zur Kenntnis...
Ach so, fuck, das Image ist weg.
Okay.
Dass ihr das alle zur Kenntnis genommen habt, dass das Image, wenn man das so baut,
3,6 Gigabyte groß ist, ja.
Chat, Noted, das wird nachher abgefragt.
Da gibt es doch so ein nice Noted-Emote.
Ja.
Habt ihr das, habt ihr das Noted alle, ja?
Dass es 3,6 Gigabyte ist, dass es keine so gute Idee ist.
Die .NET-App ist wahrscheinlich recht groß.
Nee, die ist, die ist...
Das ist ja, das ist ja sogar eine Framework-dependent-App.
Die ist nicht groß, die ist, keine Ahnung, 10 MB oder sowas.
Okay.
Der Chat, der Chat hat genotet.
Alles gut.
Alles klar.
So, und das ist natürlich doof, weil die Images fressen halt...
Das ist deutlich zu groß, ja.
Die Images fressen halt Speicher in der Registry, wenn das auch etwas optimierter da drinnen gespeichert wird.
Aber auch die Bildzeiten sind relativ groß, weil ab jedem Step, wenn sich hier was ändert, muss das ganze Ding neu durchlaufen werden.
Und dementsprechend sind natürlich auch die Updates zu den Images, die Diffs, relativ groß.
Selbst wenn er nicht jedes Mal ein komplett neues Image schreibt.
Der casht sich ja nur die Stages, das heißt, eure, eure Image-Registry wird über kurz oder lang echt viel Geld kosten, wenn ihr nur solche Images reinhaut.
Oder wenn ihr die selbst hostet, dann...
Na gut, ihr könnt's auch bei GitHub hosten, da weiß ich nicht, ab wann die was berechnen.
Ist auf jeden Fall keine gute Idee, weil es dauert alles länger und suckt.
Deswegen gibt es bei Docker sowas, das nennt sich Multi-Stage-Build.
Die Idee dahinter ist folgendes.
Man macht nicht nur ein Image.
Sondern man macht für jeden Build-Step, der ein bisschen komplexer ist und Caching braucht, einen eigenen, ja, Build-Step mit eigenem Image draus.
Und ganz am Ende macht man dann ein Image, wo man die Sachen aus den vorherigen Build-Steps rein kopiert.
Und das wird dann das Image, was am Ende rausfällt und von Docker gestartet wird oder von Kubernetes oder von irgendeiner Container-Runtime.
Hat den Vorteil, diesen ganzen Mist hier vorzunehmen.
Diesen ganzen Mist hier von, wir müssen, wir müssen Rust runterladen, wir brauchen hier komplettes Ding, wir brauchen Rust-Abhängigkeiten von 1,2 Gigabyte.
Fällt weg, die fallen nur im Build-Prozess an, im eigentlichen Output-Image sind die dann nicht mehr drinne.
Was wir im Output-Image brauchen, warum unser Output-Image doch immer noch ein bisschen größer ist...
Ja gut, ist das hier, FFmpeg.
Aber auch FFmpeg kann gecached werden, weil FFmpeg-Updaten wir ja nicht laufen, sondern immer nur dann, wenn's...
...notwendig ist.
Also, würde ich sagen, legen wir mal los.
Und bauen da mal ein Multi-Stage-Bild draus.
Ich würde vorschlagen, das erste, was wir machen ist...
Wir benennen das mal um, dass wir abgucken können.
Docker-File-Old.
Docker-File-New.
Alles klar.
So, das erste, was wir machen ist, wir gucken mal nach dem offiziellen Rust-Image.
Weil, dieser Step hier gefällt mir beispielsweise überhaupt nicht.
Dass wir unser eigenes Rust installieren.
Und wenn wir eh schon mehrere Images verwenden und unser Image beim Bauen nicht gleich dem Output-Image ist...
...können wir einfach auch das offizielle Rust-Image verwenden.
Und wir wollen...
Rust 1.7.4 Bookworm wollen wir haben.
Das ist gut.
Also, wir benutzen jetzt nicht Debian, sondern wir benutzen...
...Rust 1.7.4 Bookworm.
Das ist zufälligerweise auch ein Debian, aber das ist echt nur Zufall.
Müsste nicht sein.
So, und wir müssen jetzt auch kein Slim-Image oder sonst was verwenden, weil...
...wir kopieren ja den Output rüber und wir verwenden das Image gar nichts.
Also, wir könnten ein super fettes Image haben...
...zum Bauen, wovon wir eigentlich am Ende in dem Target-Image gar nichts verwenden.
So, Work-Dir-Bild ist glaube ich okay.
Ähm...
Update...
Updaten...
Können wir uns schenken?
Ha!
Update das Image.
Install.
WGAT werden wir weiterhin brauchen, weil wir ja noch FFM-Pack irgendwo runterladen müssen.
Das Curl können wir uns schenken.
Output kopieren.
Das müssen wir in der Tat machen.
Und...
Wir können uns aber...
Ne, wobei, ist eigentlich gut.
Wir können Cargo-Bild machen nur noch, weil wir jetzt das offizielle Image benutzen.
Da ist Cargo im Path.
Kann er ohne Update überhaupt die Pakete finden?
Wir installieren...
Achso, ja, du hast recht.
Das könnte sein, dass das ein Problem macht.
Er würde eigentlich von ausgehen, dass das geht, aber...
Ja...
Ja, du hast recht.
Ja, wir lassen es drin.
Ihr habt recht.
Wir lassen es drin.
So, das können wir uns erstmal schenken hier.
Wir machen das mal weg hier.
Bam.
So, wir haben es ja da drüben noch stehen.
So, Cargo-Bild-Release.
Bis zu dem Step sollte das jetzt eigentlich schon durchlaufen.
Probieren wir mal aus.
Ob das jetzt funzt?
Docker-Bild.
Ah.
Sieht eigentlich schon mal ganz gut aus.
Okay, das ist nur Update aktuell.
Du-du-du-du-du-du-du-du-du-du-du-du-du-du-du.
Und warum macht der jetzt so Pause-Champ?
Warum pausiert Champ das gerade so?
Upget?
Ach, ne, das war doch das Docker-Image-Pull.
Ach so.
Aber guck mal, Cargo-Bild funktioniert jetzt.
Direkt out of the box.
Ohne, dass man irgendwie einen Handstand machen muss, dass es funktioniert.
Alter, meine Kiste, Alter.
Guckt euch das mal an.
Die VM ist einfach mal komplett ausgelastet, wenn Rust baut.
Blazingly-Fast-Compile-Stells.
Blazingly-Fast, aber CPU-intensive.
Ja, das stimmt schon.
Sobald es jetzt in Docker läuft, wir könnten es ja theoretisch auch irgendwie limitieren.
Aber wozu? Aber wozu?
Exporting-Layers.
Okay, das ist noch kein, keine so gut.
Das hat jetzt bis jetzt noch nicht viel gebracht.
Weil wir haben ja noch kein Target-Image.
Wir haben jetzt so, so.
Okay, das ist der, das ist der Build-Step für, für Rust.
Ich würde sagen, wir machen in dem gleichen Step die, die FFmpeg-Geschichte.
Weil sonst muss ich ja jede,
jede Änderung, die machen wir übrigens auch davor.
Sonst müsste sich ja bei jeder Änderung quasi in Rust jetzt wieder neu FFmpeg runterladen.
Das ist natürlich auch nicht, nicht irgendwie Sinn und Zweck der Sache, ne.
Machen wir mal hier run wget FFmpeg.
Wir können das auch in einen eigenen, in einen eigenen Step ausladen.
Also hier wget FFmpeg.
Und dann wird FFmpeg umbenannt.
In, vielleicht sollte ich das nicht einfach nur FFmpeg nennen.
Sondern FFmpeg, äh, wie heißt denn der Kram?
FFmpeg-n.
Sehr schön.
So, das können wir machen.
Gut.
So, das ist der erste Build-Step.
Also FFmpeg runterladen, FFmpeg entpacken, Rust-Zeug kompilieren.
Und jetzt kommt der Trick bei Multistage-Builds.
Für den .NET-Part.
Machen wir ein neues Build-Image.
Also wieder from, jetzt muss ich mal gucken, .NET-Docker-Images.
SDK brauchen wir jetzt, genau.
SDK.
From, äh, MC, äh, das ist die Microsoft-Docker SDK 8.0.
Muss dahinter als Versions-Tag.
Wenn ich jetzt wüsste, welche Versions-Tag es gäbe, wäre schon sehr nice.
Sieht man das, wenn man hier drauf geht?
Nein?
Das wäre auch deutlich zu einfach Microsoft, wenn das funktionieren würde.
Ja, Feature-Tags.
Wäre trotzdem ganz nice zu wissen, was es sonst noch gibt.
Die haben garantiert noch mehr Tags.
Naja, gut.
Scheiß drauf.
Wir, wir, wir machen's.
Wir machen so.
So, das Ding nennen wir jetzt.
Okay, das nennen wir, das hier heißt nicht Build, sondern das heißt Rust.
Und das hier heißt, äh, .NET.
Weil das, die...
Ups.
Die Namen brauchen wir später, weil wir die Dateien von den einzelnen Steps rauskopieren wollen.
Machen wir mal hier.
Komm, ich seh mal.
Ist okay.
Build.
Rust.
Nächster Step.
Build.NET.
So, Microsoft-Image wird gepullt.
Hm.
Und jetzt?
Wir machen wieder Work, Work-Dir-Build.
Weil, warum nicht?
So, und jetzt können wir diesen Kram hier rüber kopieren.
Set no numbers.
Jetzt können wir diesen Kram hier rüber kopieren.
Copy.
Und jetzt kommen sich die Dinger auch nicht mehr in die Quere.
Das hier ist ein eigener Container beim Bilden.
Und das hier ist ein eigener Container beim Bilden.
Okay, jetzt wird das Ganze wieder...
.NET run. .NET.
Haben wir's noch hier.
Publish.
Okay, da ist...
Zack.
Das können wir uns auch sparen, weil .NET garantiert im .NET-Container verfügbar sein wird.
Werden die ganzen Stages nacheinander gleichzeitig abgearbeitet?
Gleichzeitig, es sei denn, die eine hat Abhängigkeit auf die andere.
Das ist relativ schlau.
Mittlerweile, die ganze Build-Kit-Docker-Bild-Geschichte.
Du wirst, du wirst gleich sehen.
Der macht das parallel, es sei denn, es hängt voneinander ab.
Oh ja, gut.
Und wenn sie unterschiedlich schnell sind, dann sieht's halt auch nicht parallel aus, aber sie sind parallel.
Okay.
.NET publish-c-release-output.
Eigentlich kann ich mir das komplett schenken, den Output.
Das kann ruhig das Default-Verzeichnis sein.
Das ist okay.
Okay, und jetzt, und jetzt kommt der, und jetzt kommt der eigentliche Trick.
Jetzt kann man unten nochmal sagen hier...
App oder so, nennen wir's einfach mal.
App.
So, und jetzt sagen wir from.
Jetzt brauchen wir das Microsoft-Image für ASP.NET Core.
Hier, das da brauchen wir.
Wahrscheinlich einfach nur das.
Moment, ach, nicht runtime.
ASP.NET da ist.
ASP.NET da ist doch.
Genau.
From.
So.
S.
Gachibus.
Also runtime oder sowas.
Keine Ahnung.
Ich glaub Microsoft nennt das Zeug immer runtime.
So.
Workdir.
Nennen wir's jetzt einfach mal App.
Dass wir irgendwie, dass wir einen Unterschied haben zwischen, das ist das Output-Image.
So.
Jetzt machen wir an der Stelle mal noch nix.
Ja.
Ich, ich führ's jetzt einfach mal aus.
Ist es nicht?
Wir kommen Ende zwei.
Auf alle anderen Erfolgen ein Runstatement zusammenzufügen.
Jedes Command in Dockerfall eigenes Layer.
Also, ja, da hast du, da hast du nicht unrecht.
Und zumal in dem Fall macht das Caching auch relativ wenig Sinn.
Das ist richtig.
Aber, ja, ich werd's verkraften.
Ja, es ist schon, ist schon was dran.
Ich meine, es sei denn, es macht Sinn, dass man die einzelnen Layer cached für sich genommen.
Aber du hast, du hast recht, ja.
Okay, also.
Docker-Bild.
Jetzt werdet ihr sehen, es sei denn, es kackt ab.
Es sei denn, es kackt ab.
Wir müssen jetzt mehrere Builds parallel sehen.
Nämlich einmal den Rust-Container, einmal den .NET-Container und den Output-Container am Ende.
Okay, er, er, er pullt erst mal das, er pullt erst mal das Image.
Zack, und schon ist er fertig.
Das ging.
Ach so, ha.
Docker ist zu schlau, Leute.
Docker ist zu schlau.
Der erkennt, dass der, dass von diesem Image nichts benutzt wird.
Und deswegen baut er es nicht, vermutlich.
Okay, also muss ich jetzt, muss ich jetzt doch so tun, als will ich was davon haben.
Und zwar, man kann jetzt, also wir haben ja hier oben die .NET-App, ähm, die .NET-App gebildet, gebildet.
Und hier die Rust-App.
Und das ist mein, mein Ziel-Image.
Das heißt, im Endeffekt muss ich jetzt sowas machen hier, wie copy und jetzt from.
Wobei, ich glaube, das können wir uns sparen.
Copy from.
Hier den Name von dem Image zur Build-Zeit, wo die Dateien liegen.
Copy from Rust.
Slash Build.
Weil, work dir, slash Build.
Und da drinne gibt es jetzt ein FFmpeg-Folder, zum Beispiel.
Und den kopieren wir einfach rüber uns als FFmpeg, ja.
So, als nächstes brauchen wir from Rust noch, ja.
Build target release libwebrtcrust.so.
Soll im Prinzip hier exakt genauso heißen.
Und dann brauchen wir als letzten Step noch, ich bin mir nicht sicher, ob die Reihenfolge gerade die beste ist.
Und dann brauchen wir als letzten Step noch die .NET-App.
Und zwar, jetzt ist es from.net.
From.net.
Und jetzt kann ich mir immer nicht merken, wo dieser ganze Mist liegt.
Auf jeden Fall schon mal in Build.
Habe ich das hier irgendwo stehen?
Ne.
Ähm.
Minus O.
Ja, auch in Release, aber diesen...
Liegt FFmpeg nicht unter slash Build?
Slash...
Ne.
Ne.
FFmpeg kommt hier...
Achso, Moment.
Wait a minute.
Du hast recht.
Das hätte übrigens gar nicht funktioniert an der Stelle.
Weil es Verzeichnis nicht gegeben hätte.
So ist richtig.
So ist richtig.
Siehste?
Chatge...
High IQ wieder.
So.
From Build.
Ich kann es mir einfach immer nicht merken, wo diese...
Wo .NET...
.NET publish-c release.
Alles klar.
Gib ihm.
Wat?
Was?
Achso.
Ha.
Ja.
Ja, ja.
Ist ja gut.
Nicht Docker.
Okay.
Bin.
Release.
Net.
8.
Publish.
Bin.
Release.
Net.
8.
Publish.
Alright.
Bin.
Release.
Publish.
Okay.
Auch hier.
Gleicher.
Gleicher.
Soll die ganzen Cramply einfach in das Verzeichnis schmeißen?
Einfach.
Einfach eigenen Output setzen?
Ja.
Das wäre auch eine Möglichkeit.
So.
Und als letztes kopieren wir noch von Backend www...
Das da machen wir im Endeffekt.
Moment.
Das machen wir nicht.
wwwroot nach wwwroot.
Alles klar.
So.
Das CMD sparen wir uns jetzt mal.
Ich hoffe, das funzt jetzt.
Docker Build.
Bam.
Guck.
Man sieht, er macht die Sachen auch parallel.
Hier oben ist er am .NET Image.
Hier unten ist er am Rust Image.
Guck, hier oben lädt er noch das .NET Image runter.
Hier unten baut er schon Rust.
Also es geht bis zu dem Punkt parallel.
Das letzte, das Output Image, kann er natürlich nicht parallel bauen,
weil es Abhängigkeiten zu diesen beiden Images hat.
Hi, wieso muss das FFmpeg in das Rust Image kopiert werden?
War das nicht vorher für .NET dabei?
Ne.
Also übrigens, ich gebe dir recht, es ist ein bisschen irritierend,
dass es in dem Rust Image ist.
Ich hatte einfach keinen Bock.
Für den Download von FFmpeg noch einen eigenen Build-Step zu machen.
Eigentlich gehört das in den Rust-Step gar nicht rein.
Das sollte eigentlich ein eigener Step vor allen anderen sein
oder halt zumindest ein eigenes Image.
Das war aber nicht im .NET dabei.
Ne, ne.
Das muss man runterladen neu.
So.
Das hat funktioniert, oder?
Docker run.
Schauen wir mal.
Ups.
Ach, ich habe keinen Command angegeben, oder?
Ach so.
Tja.
Das ist natürlich nicht so High-IQ gewesen.
Jetzt müssen wir auch nicht mehr wechseln in Build und auch nicht mehr Test starten,
sondern wir können einfach sagen .NET backend-dll urls.
Guck mal, passt mal auf, wie schnell das jetzt bildet auf einmal.
Bam, fertig.
Run.
Geht.
Easy.
Easy as fuck. Easy as fuck.
So, und jetzt passt mal auf.
Docker-Images.
Es ist zwar immer noch groß.
Aber was ist denn daran jetzt noch so groß, Leute?
Ich meine, das hier ist das Richtige.
Was ist denn da immer noch so groß?
Ich meine, FFmpeg ist 140 MB.
Okay, wir checken mal.
Wir checken mal kurz mal.
Ach so, ja doch.
Die .NET, das ganze .NET-Framework ist ja dabei.
Und FFmpeg.
Doch, doch, okay.
Das lasse ich mir gefallen.
Ah, wir können.
Leute, ich habe eine Idee.
Wir können FFmpeg noch ein bisschen kleiner machen.
Wir können FFmpeg noch ein bisschen kleiner machen.
Ja.
Run.
Wir gucken mal kurz.
Ja, guck mal.
Allein schon der Ordner.
Allein schon, guck mal, allein schon der Ordner ist 166 MB.
Und der Rest, der Rest ist einfach das Image.
Los.
Benutzt du was nicht AOT-kompatibles?
Ich glaube nicht.
Theoretisch, theoretisch könnte ich auch das ganze AOT compilen lassen.
Das ist noch ein bisschen kleiner.
Ja, das können wir das nächste Mal machen.
Ja.
Das können wir das nächste Mal machen.
Als nächstes, ich kann mir, ich kann mir das mal aufschreiben.
Also was wir als nächstes, wir können als nächstes eventuell, wobei das haben wir schon mal gehabt.
Bild, kann man machen.
Oder, ähm, ja.
Aber wir können, wir können noch was relativ Simples machen.
Das ist kleiner mit.
Und zwar, wir können.
Guck mal.
Wir gucken mal kurz, wie groß hier was ist.
Ja, update.
Wie gibt es, äh.
Gibt es das nicht für Debian?
Doch, gibt es.
So, also, guck mal.
User ist 210 MB groß.
App ist, also wir können das, wir kriegen das nicht kleiner.
Das Image.
Das Image ist halt nun mal, ne.
100 MB .NET.
100 MB, äh, Abhängigkeiten von .NET.
Aus irgendwelchen Gründen.
Perl Base.
Ganz essentiell, dass Perl da drauf ist.
Aber ist für uns nicht.
Aber was wir machen können, fällt mir gerade ein.
Wir können bei FFmpeg noch was löschen.
Und zwar, wir können aus FFmpeg, das probieren wir mal aus.
Wir können aus FFmpeg, theoretisch, License, Bin, Doc, Include und Man löschen.
Probieren wir das mal.
Guck mal.
Haben wir noch einmal 20 MB gespart.
Das könnten wir tatsächlich machen.
Weil das brauchen wir nicht.
Jetzt sieht man übrigens auch, dass es keine gute Idee war, von mir, das FFmpeg Zeug in den Buildstep von Rust reinzupacken.
Weil jetzt muss ich Rust neu bilden.
Dann direkt nur Lib kopieren.
Du meinst hier, dass wir quasi sagen, Lib.
Aber das verzeichnet, dann meckert er, dass es das verzeichnet.
Kann man bei mv.create.directory direkt mit angeben?
mv-p oder sowas?
Ne.
Ne, natürlich nicht.
Ach, im Runtime Image.
Ja, sehr gute Idee.
Excellent.
Pfeifert.
Doch, genau.
Wir kopieren FFmpeg.
Lib.
Aber da ist auch wieder hier kein Verzeichnis da.
Ich meine, wir könnten es auch so machen.
Und hier einfach nur FFmpeg reinschreiben.
Ist ja auch nicht verkehrt.
Testen wir mal, ob das funktioniert.
FFmpeg.
mv.ffmpeg.
Lib.
Nur nach Lib.
rm-ffmpeg.
Yes.
Lib.
Schaut mal, ob das jetzt läuft.
Run.
Ja, Kunst.
Wird funktionieren.
Können wir so machen, ja.
Ja, eigentlich gar nicht so schlecht.
Wir kopieren nur Lib rüber.
Benennen das Verzeichnis in FFmpeg um.
Kann Docker Copy auch ganze Pfade anlegen?
Das ist eine gute Frage.
Entscheidend.
Ne.
Ich meine, wir können mkdir davor machen, ja.
Das wird natürlich...
Ah, das KLG anscheinend nicht.
Aber so müsste es auch funktionieren.
Ja.
Das ist natürlich blöd, dass ich das FFmpeg...
Stimmt.
Ich bin verkehrt.
Ja, ja.
Nicht Docker CP.
Docker File.
Docker File.
Copy.
Copy.
Copies new files.
Multiple source.
Kann irgendwelches White Card Gedöns.
C-Hown.
Das mir nicht wirklich was bringt.
Ich würde aber auch darauf tippen, dass es das nicht kann.
Lassen wir es einfach mal so.
Einfach ausprobieren.
Also ohne Option geht es nicht.
Ich hatte schon öfters den Fehler, dass der irgendwelche Output...
Also nicht kopieren kann, weil er keine Verzeichnisse findet.
Aber so müsste es doch eigentlich auch funktionieren.
Ich überlege gerade, ob ich da noch einen eigenen Step draus mache mit dem FFmpeg.
Weil das in der Tat ein bisschen doof ist.
Komm, wir machen da was eigenes draus.
Sind wir mal nicht so.
Machen wir mal.
Tja.
FFmpeg.
Download FFmpeg.
Äh, what?
Da waren wir jetzt hier.
From.
Debian.
Debian.
Bookworm.
FFmpeg.
So.
Ja, ich glaube, so ist es gerade.
FFmpeg.
Äh.
Irgendwie auch Bild.
Aber das ist halt...
Da habe ich ja keinen Weg hier drauf, ne?
Oh, das ist ja doof.
Komm, scheiß drauf. Ich beiße jetzt in den Saal ab.
Wir machen das jetzt rückgängig.
Machen das jetzt einfach hier an der Stelle.
Lass uns halt nochmal bauen.
So oft updaten wir FFmpeg ja nicht.
Okay, zack.
Ich bin zu groß.
Also das alte mit den...
Mit den 3,6 Gig.
Oh, das ging jetzt erstaunlich schnell.
Ist der so schlau und hat das gecheckt oder wie?
Achso, ich habe ja nur das Copy geändert im Endeffekt.
Ja, kein Wunder, dass das...
Ist doch gut.
Hat's doch schon gelohnt.
Ging schnell.
So, run.
Tag, Funz.
Nice. Okay, sehr gut.
Dann testen wir doch jetzt mal, ob das mit dem Docker...
Also, neues Image ist 367.
Kleiner kriegen wir es nicht.
Kleiner kriegen wir es nicht.
Das ist die .NET Runtime.
Das Base Image.
Ja, Docker Copy kann Fade erzeugen, aber keine nested Fade, was er machen müsste.
Ich will ja quasi sowas hier machen.
Guck mal.
Lipp.
Und ich glaube, das geht nicht.
Wir können es ausprobieren.
Ich glaube, das geht nicht.
Ich meine, vielleicht geht es ja doch.
Okay, es geht doch.
Easy.
Ich habe nichts gesagt. Scheint doch zu funktionieren.
Ja, dann.
Dann können wir das ja auch wieder rückgängig machen.
FFmpeg.Lip.
So, also, ich habe jetzt den Source Code geändert.
Von meiner .NET Anwendung.
Von der Idee her, sollte er .NET, nur .NET Rebuilden.
Und neues Image bauen.
Äh...
Da stimmt was nicht, Leute.
Warum ist das cached?
Warum ist das cached?
Ich habe doch eindeutig hier geändert, oder?
Oder habe ich...
Moment, habe ich vorher einfach nicht gespeichert?
Kann das auch sein?
Moment, Moment, das muss ich jetzt mal ausprobieren.
Ich...
Ich kopiere das hier einfach noch ein paar mal, ja.
Ah, okay.
Ich habe vorher nicht gespeichert.
Alles gut.
My bad time. Sehr gut, Max.
Gut, alles klar.
Also, das sollte jetzt funktionieren.
Run.
Bam. Ja, Funst.
Und ihr habt gesehen, wie viel schneller das jetzt bildet.
Das Image im Vergleich zu vorher.
Und wie viel kleiner das jetzt ist.
Können wir uns mal angucken, was passiert, wenn ich in der...
Also, wenn ich in...
Wenn ich auf der .NET Seite was ändere.
Das ist jetzt relativ easy zu zeigen.
Okay, cached, weil er hat das schon mal gebildet.
Mit diesen drei Zeilen drin.
So, gehen wir mal in den Rust Part.
Gehen wir mal in den Rust Part.
Und ändern hier irgendwas.
Keine Ahnung.
Hier, active connections.
Soll jetzt unbedingt noch ein Ausrufezeichen hinten haben.
Build.
Guck, Cargo run, Build.
Jetzt muss er nur den Rust Part neu bilden.
Das dauert natürlich lang, weil Rust...
...lange braucht zum kombinieren.
Irgendjemand hat doch vorhin Cargo Chef angesprochen.
Du, du, du, du.
Leute, ich habe eine Idee.
Gibt es so was wie Cargo Pull oder sowas?
Gibt es so was wie Cargo Pull oder sowas?
Gibt es so was wie Cargo Pull oder sowas?
Das könnte man tatsächlich noch ausprobieren.
Das könnte man tatsächlich noch ausprobieren.
Weil man könnte jetzt ja an der Stelle...
Machen wir das mal wieder weg.
Was macht ihr? Wir haben einen Multistage-Docker-File gebaut.
Wir haben einen Multistage-Docker-File gebaut.
Also, was ich mir überlegt habe, ist folgendes.
Guckt mal. Hier kopiere ich den Source Code Cargo hin und mache ein Bild.
Guckt mal. Hier kopiere ich den Source Code Cargo hin und mache ein Bild.
Wenn ich sowas machen könnte, ich weiß nicht, ob es sowas gibt.
Wenn ich sowas machen könnte, ich weiß nicht, ob es sowas gibt.
Dann würde ich auch beim Ändern an der Go...
Dann würde ich auch beim Ändern an der Go...
Was labere ich mit Go?
An der Rust...
An dem Rust-Source-Code.
Wenn sich nichts an den Dependencies ändert,
Wenn sich nichts an den Dependencies ändert,
wäre das hier gecached an der Stelle.
Gibt es sowas wie Docker-Pull oder sowas?
Oder Cargo-Cargo-Pull, nicht Docker-Pull.
Cargo-Pull?
Was soll das tun?
Alle Dependencies runterladen,
die man braucht,
die in der Cargo-Tommel stehen.
die man braucht, die in der Cargo-Tommel stehen.
Weiß ich, ob sowas gibt.
Also, bei .NET heißt es Restore.
Cargo-Pull.
Gibt es sowas?
Was haben wir denn?
Build. Check. Clean.
New. Init. Add.
Remove. Run.
Bench. Update.
Bench. Update.
Nee.
Nee, gibt es nicht. Cargo-Fetch.
Nee, sowas gibt es ja anscheinend nicht.
Oh.
Hä?
Das steht aber gar nicht hier dabei.
Windows? Was macht denn Cargo-Fetch?
Minus-List wären alle.
Weil, das wäre natürlich gut.
Da muss er nicht jedes Mal diesen ganzen Krempel help.
Alter, was gibt es denn hier alles?
Build. Check. Clean. Clippy. Config. Fetch.
Build. Check. Clean. Clippy. Config. Fetch.
Okay, das ist schon mal gut.
Install. Locate.
Install. Locate.
Was auch immer miri ist.
Owner. Package.
Remove. Report.
Update.
Okay, Fetch ist glaube ich echt nicht verkehrt.
Okay, Fetch ist glaube ich echt nicht verkehrt.
Was ist das an der Stelle? Das probieren wir jetzt doch
glatt mal aus. Cargo-Fetch.
So, dann hat er
zumindest die Dependencies gecached.
An der Stelle.
Das sollte doch eigentlich ganz brauchbar sein.
Aber er muss den
gerade trotzdem compilen.
Ja, keine...
Ich glaube, da kommen wir jetzt nicht.
Ich glaube, da kommen wir jetzt nicht drum herum.
Oh.
Fail to pass manifest. Warum?
Ach so.
Ja. Okay, nee, das funktioniert nicht.
Das funktioniert so nicht,
wie ich mir das gedacht habe. Ich glaube, den Compile-Step,
den können wir nicht, können wir nicht
beschleunigen. Ich meine, wir könnten das,
wenn wir, also bei
GitHub Actions könnte man den
Bild-Output
vom letzten Mal cachen,
dann irgendwie wiederherstellen,
sodass er an der Stelle dann nicht alles
neu runter... Was auch immer. Ich kann damit leben.
Ja, ich kann damit leben. Das ist okay.
Aber ich würde sagen, passt soweit.
Mission erfüllt.
Wir haben ein schnelles
relativ kleines
Docker-Image.
Das ist gut.
Hat funktioniert.
Nice.
Okay, Chat.
Ich hoffe, ihr konntet jetzt ein bisschen bei der Arbeit noch
abgammeln bei mir im Stream, bevor ihr heim
müsst. Ich weiß nicht, ob man das
als Fortbildung verbuchen kann, wenn man
nicht viel mit Docker gemacht hat bestimmt.
Das Problem ist, glaube ich, nicht, dass
Base-Image,
dass Debian so groß wäre,
sondern eben, weil halt die komplette
.NET-Runtime drauf ist. Sieht man
ja auch. Und die .NET-Runtime, die ist halt unter
Ubuntu auch nicht kleiner als
mit
Debian.
Echt?
Ist das so? Ist das kleiner?
Okay, Moment. Das probieren wir jetzt mal kurz aus.
Also.
Wir haben aktuell
von unserem
Imager App, lassen wir mal
außen vor. Da werden wir nichts dran machen können.
Das ist mal User. So. In User
ist lib,
ist IQ, das
Brauma und
Pearl, was auch immer. Und 100 MB
davon sind .NET.
Ja, probieren wir das mal aus.
Okay.
Okay. Also, was brauchen wir?
Jammy schisselt
für ASP. ASP.
So.
Äh.
Ja, nix Preview. Die gibt's wahrscheinlich
schon komplett.
Die gibt's. Okay, das. Da bin ich,
da bin ich jetzt ja mal gespannt.
Also, im Prinzip
brauchen wir jetzt nur ASP.
Jammy
schisselt.
Schisselt.
Schisselt.
Bild.
Sehr nice. Stalker Image.
Ja.
Damit kann ich leben, oder?
260 MB.
260 MB.
Bash ist da natürlich
SH drauf. Irgendwas. Da ist nichts drauf.
Da ist einfach gar nichts drauf.
Ach so, funktioniert's noch? Das ist eine gute Frage.
Ja. Ne.
Ne.
Ne.
Fokussiere dich mal.
Ah, ich glaube, ich weiß, warum.
Ich weiß, warum. Wir müssen's so schreiben.
Ne, ne. Wir müssen's
so schreiben, Leute. Passt mal auf. Ich weiß, woran
das liegt. Wenn das was, wenn das, wenn das
jetzt geht, erklär ich euch, woran das lag.
Wenn's nicht geht, dann nicht.
Fuck.
The application
dot net does not exist.
Ist das
vielleicht nur für self-contained
Apps? Bin ich denn zu viel
geschisselt?
Äh, da brauch ich...
Ich bräuchte mal
ein Example.
Ein Example-Docker-File.
Publish dot net
nicht auch ne Binary?
Die ist aber standardmäßig abhängig
von der, von der Runtime.
Und wenn die Runtime nicht da ist,
also, es ist ja nix da,
dann
geht das nicht. Die müsste ich als
self-contained application
raushauen, dann würde es funktionieren.
Das ist, das ist geschisselt
im Entry Point.
Also quasi so, oder wie? Ne.
Ich brauch mal
ein Example. Ich brauch, ich brauch mal
ein Example-Docker-File.
Gibt's hier irgendwie ein
Example-Docker-File? Ja.
Entry Point. Ach,
tatsächlich, guck mal.
Man gibt da wirklich nur...
Gibt man da vielleicht so wirklich nur
das hinten gar nicht
mit an? Das braucht man wahrscheinlich
gar nicht, ne?
Geht. Nice. Aha.
Dot net
weggeschisselt, anscheinend.
Gut zu wissen.
Gut zu wissen. Easy. Easy.
Guck mal, und jetzt haben wir
noch 260 MB.
Und jetzt abschließend mal den Test.
Wie lange würde so ein komplettes
Bild jetzt brauchen? Wahrscheinlich
so eineinhalb Minuten.
Bild? Weil ich habe jetzt alle meine
Caches und sonst wie weggeschmissen.
Okay.
Also, gucken wir mal drauf, wie lange
so ein komplettes Bild jetzt braucht.
Jetzt wird richtig drauf losgeschisselt, ey.
Das heißt, glaube ich, schmeißeln, gell?
Auf Deutsch.
Schisseln.
Schisseln oder so. Ich glaube, es heißt
meißeln. Da haben die...
Ja, ist das ein Image
von Microsoft oder ist das
ein Image, was die Canonical-Leute
schisseln?
Vielleicht finden wir noch mal.
Ich habe noch eine Idee.
Docker-File-Rust.
Vielleicht gibt es da noch...
Bald neu der Schissel-Champ.
Ähm...
Vielleicht gibt es ja da ein Example für...
Äh...
Ich überlege gerade, ob es nicht vielleicht
was gibt, dass man irgendwie dieses Cargo-Bild...
Dieses Cargo-Library-Gedöns
Cachen könnte.
Habt ihr auch ein bisschen
gemeißelt heute an euren Containern?
Sehr nett.
Cache Rust-Dependent.
You need a dummy AS
and your Cargo-Yammel first.
Then build it to cache the dependencies
and then copy your...
Ach so!
Hi,
Hi IQ!
Hi...
Ach, guck mal!
Die legen so eine Fake-Lib-AS
an und danach
in einem Build-Step die richtige.
Okay, das probiere ich jetzt noch aus.
Jetzt wird Rust geschisselt, Leute.
Okay, Image hat gebildet
jetzt wie lang? 280 Sekunden.
Alles klar. Pass auf,
wir schisseln jetzt das Rust.
So, also...
Cargo?
An der Stelle, wenn man jetzt hier sagt
Cargo-Build, dann
meckert er garantiert,
weil keine
äh...
Lib-AS da ist.
So, wenn ich jetzt sage run
touch lib...
Ne, Moment, was? Source
lib-as...
Geht das jetzt?
No, such file or directory.
Äh...
Moment, kann das sein, dass es
touch einfach nicht gibt?
Das ist zu...
Hyper-Gachi?
Ne.
What?
Wie jetzt?
Ist das nicht irgendein Base-Tool, was immer dabei ist?
Ach, der Source-Ordner
wird... Okay, okay.
mkdir Source.
Äh...
Ich dachte eigentlich, dass touch-bash
Build-In ist.
Okay, ne, passt, passt, passt.
Passt.
Ich glaub, Leute, das funnst.
Better Twitch-TV
Shizzle. Ja, so oft werden wir das nicht brauchen,
vermute ich.
Aber, Leute, ich glaub, das funnst, was ich hier vorhab.
Glaub, das funnst.
Guck mal. Der hat, der hat
jetzt die Datei angelegt, diese leere
Lib-Datei.
Jetzt kompiliert er. Und
jetzt, für den nächsten Step, sollte,
sollten, sollten die Dependencies
eigentlich gecached sein.
Ja, der, ich glaub, ich glaub,
das funnst, Leute. Ich glaub, ich glaub, das funnst.
Cargo-Build.
So, probieren wir jetzt aus.
Wir ändern
jetzt, also, eben hat's ja noch lange gedauert. So, wir machen
jetzt einfach hier doppelten Output. So, ist ja
egal.
7TV Emotes.
Rust.
Das ist ein gutes
Emote.
Das find ich
gut, das, das mach ich mal.
Use Emote.
Ich mein, das bezieht sich ja,
das bezieht sich ja auf das Game, ja.
Aber es passt in dem Fall ja auch.
So, schauen wir mal, wie schnell das jetzt geht.
Nice. Es funktioniert, guck mal.
Die Dependencies sind gecached.
Jetzt. Das ist richtig high
IQ gewesen. Guck mal, wie viel schneller das
jetzt fertig ist. Es funktioniert.
Okay, das ist nice.
Guck mal. Dadurch, dass der hier eine
leere Lib, also, hier
holt er sich die neuesten
Cargo, das neueste Cargo
Dependency-File. Dann
legt er eine Fake-Lib-RS an.
Sodass Cargo Build funktioniert.
Ab der Stelle ist es gecached.
Bis zu dem Zeitpunkt, wo sich an
meinen Dependencies was ändert. Und da ändert
sich ja selten was dran. Und nur dann, wenn
sich die Dependencies ändern, dann
bildet er Dependency und Anwendung neu.
Sonst bildet er nur die Anwendung neu.
Eigentlich sehr nice, oder?
Excellent.
Die standard.net
Docker-File-Templates machen das
by the way auch. Was?
Die schisseln?
Was machen die?
Ich committe das mal.
Pack-Wait.
Hier ist das
Docker-File drin. Der Urlaub wird
ausgenutzt, ja. Erst Restore, dann
Source kopieren. Ach das. Ja.
Deswegen bin ich drauf gekommen
mit dem Restore, weil ich bilde mir ein,
weil ich das da mal gesehen hab. Deswegen wollte ich gucken, ob Cargo
auch sowas hat. Aber muss
ein bisschen tricksen. Aber ist schon okay.
Geht eigentlich ziemlich gut.
Ähm.
Okay.
Ja, das ist noch
die Sachen vom letzten Mal.
Die pushe ich jetzt
einfach
mal ins
ins CamChamp Shit.
Git push
origin master. Bam.
Schau mal, was
der CamChamp macht auf GitHub.
Der hat
jetzt ein Comet.
Und er hat mit Abstand
die allerbesten Comet-Messages.
Das gefällt mir.
Ja, nice.
Excellent, würde ich dazu sagen.
Excellent. Guck mal, die machen hier
super kompliziertes Zeug. Das
müssen wir gar nicht machen.
Excellent.
Okay.
Ich würde sagen, wir waren heute
highly effective.
Nee, effective ist
das Wort. Highly
productive, nicht effective.
Image
unter 200 MB.
Da muss ein bisschen was
weggeschisselt werden.
Unter 200 MB ist enorm schwierig,
wenn FFmpeg schon
140 MB groß ist.
Und
dementsprechend das OS.
Ich glaube nicht, dass das funzt.
Könnte man
das Programm auch als Dienst
programmieren?
Wie jetzt? Du meinst Windows Service
oder was?
Bestimmt.
Bestimmt. Damit will ich mich nicht
beschäftigen.
Also wir müssen... Okay, wir könnten
FFmpeg selbst kompilieren und wirklich
nur das einbauen, was wir bräuchten.
Das wäre eine Möglichkeit. Leute, das machen wir.
Leute, das machen wir.
Das machen wir. Nicht jetzt. Nicht jetzt.
Das machen wir.
Da habe ich schon lange Bock
drauf, mal FFmpeg selbst zu bauen mit
genau den Options, die man braucht. Weil wir
brauchen nicht viel. Wir brauchen RTSP-Support,
H.264.
Noch nicht mal H.264-Support.
Wir decoden ja nichts.
Wir brauchen eigentlich nur FFmpeg,
nur mit RTSP-Support.
Da wird FFmpeg eine ganze Ecke kleiner.
Wir brauchen keine Filter. Wir brauchen
nichts. Netzwerk.
Wir brauchen Netzwerk, RTSP-Support.
Das machen wir mal.
Und dann können wir...
Das ist... Okay, Leute.
Unsere Mission wird sein,
für den nächsten Stream,
Image...
Image kleiner...
kleiner 200 Mbps
Das machen wir im nächsten Stream.
Image kleiner 200 Mbps
Es kann sein, dass wir OpenSSL
brauchen für RTSP. Das ist möglich.
Was macht FFmpeg?
FFmpeg verbindet sich hier
zu Webcams.
Also ich kann es ja mal starten, dann siehst du es.
Also Webcam ist jetzt
ein bisschen das falsche Wort. Webcam ist
stellvertretend von einem lokalen RTSP-Server.
Aber im Prinzip Webcam...
Oh shit.
Jetzt habe ich irgendwas kaputt gemacht. Warum?
Da ist es doch.
Ach ich kack knub.
Wie geht's?
Naja. Angular.
MonkaS. No.
I'm no Angular...
expert.
No frontend expert.
And especially
no Angular expert.
Okay. MV...
FFmpeg zu FFmpeg.
So, jetzt sollte es eigentlich funktionieren.
Ja. Funst.
Also was das macht
ist folgendes. Das verbindet sich zum...
Achso, jetzt habe ich den Kram hier noch auskommentiert. Kann ich ja gar nicht zeigen.
So, es verbindet sich lokal zu einer
Webcam.
Und dann streamt
es den Webcam-Output in den
Browser. Und der Trick dabei
ist, wenn es jetzt funktioniert, wenn ich es nicht irgendwie
kaputt gemacht habe, habe ich nicht... Also stellvertretend
für Webcam-Output gibt es halt ein YouTube-Video
von mir. So.
Und ohne zu re-encoden.
Das ist halt das Ding. Also
der nimmt einfach... Der connectet sich
per RTSP.
FFmpeg RTSP connectet er sich zum...
zur Webcam.
Liest die einzelnen
Frames oder ja, Packages
aus, aus diesem H.264 encodeten
Stream. Und schickst die 1
zu 1 weiter per WebRTC
in den Browser. Und der Browser decodet
dann. Also das heißt, es ist...
Braucht nahezu keine CPU-Last auf
Serverseite. Bloß ein bisschen zum decoden
im Browser.
Und wie performant ist das jetzt im Vergleich zu Go?
Ich habe keine Ahnung.
Ob es in der Praxis überhaupt einen
nennenswerten Unterschied macht?
Höchstwahrscheinlich nicht.
Höchstwahrscheinlich nicht, weil
der große Unterschied
zwischen Rust und Go in dem Fall
ist, also wo es wirklich richtig krass
Performance gut machen könnte,
ist an der Stelle, wo man oft
callen muss nach Go
von .NET aus.
Und so oft call ich nicht. Ich meine, es sieht
zwar hier viel aus. Ihr seht es hier durchrattern.
Aber das sind halt
auch nur alle 16
Millisekunden. Alle 16 Millisekunden
ist halt gar nichts.
Im Browser kann man das nicht seeken. Korrekt.
Das geht um Live-Webcams.
Du kannst
nicht seeken.
Wieso nicht RustCamp? Weil
CampChamp. Weil meine Dinger immer Champ
heißen. Außerdem ist es nichts, was ich
will, dass irgendjemand verwendet.
Das ist gebastelt für mich.
Und ich werde es wahrscheinlich
bei mir benutzen.
So, wo wir gerade dabei sind. Lass mal gucken.
Ich glaube, der 4er-Champ hat immer noch keine Bugs.
Nee, obviously
keine neuen Bugs.
Ist ja auch komplett bugfrei.
Der 4M-Champ hat
natürlich auch keine neuen Bugs.
Okay, alles klar. Weil Bugs
produzieren wir hier ja nicht.
Bei uns ist alles immer
first try
five head community
gefederfrei.
So, Chat.
Sehr schön,
dass es dann heute wunderbar funktioniert.
Nächster Stream.
Ahead of time compilation.
FFmpeg selbst kompilieren. Und gucken,
dass wir das Image unter 200 MB kriegen.
Also mit AOT sollte es easy
funktionieren, weil dann ist auch .NET kleiner.
Und FFmpeg, wenn das geht...
Also nee, AOT sollte easy...
So rum. AOT sollte easy funktionieren. Da ist auch
diese ganze .NET Anwendung kleiner.
Wir bräuchten theoretisch auch gar kein .NET
Image mehr. Und
FFmpeg, wenn das geht,
kommen wir easy unter 200 MB.
Wenn das Custom sich...
Was jetzt gemacht wird, Offstream,
ich bin heute noch nicht mal eine Runde gelaufen.
Das werde ich jetzt machen. Vielleicht
so in dem Dreh, ja. Wobei man halt sagen muss,
Teile von der .NET
Runtime müssen ja trotzdem
rein. Beziehungsweise
nicht von der Runtime,
aber von der Standardlibrary trotzdem rein.
Weil sonst läuft das Zeug ja nicht.
Also, wir sehen uns, Leute. Bis dann.
Macht's gut. Ich hoffe, euch hat das Stream gefallen.
Wenn euch das Stream gefallen hat, dann könnt ihr mir jetzt
followen, dass ihr
beim nächsten
Broadcaststream oder bei was auch immer wir machen,
wieder mit am Start seid. Würde mich freuen.
Und schön, dass ihr da gewesen seid.
Wir sehen uns im nächsten Stream. Bis dann. Macht's gut.
See you!
So, so muss das sein.
Bis dann. Macht's gut. See you.
