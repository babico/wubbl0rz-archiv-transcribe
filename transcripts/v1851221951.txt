Da bin ich.
Zarex ist auch schon wokige.
Da magst auch. Und DJSW77
auch am Start.
In meinem Stream musst du es nicht selbst machen, du kannst zugucken,
das ist der Unterschied.
Mal davon abgesehen, die Sache ist die,
ich hab schon wieder fast alles vergessen,
was Helmchart-Erstellung angeht. Ich weiß noch, du brauchst
eine Chart-Jamme und ein Template-Verzeichnis,
wo du deine Kubernetes-Ressourcen reinschmeißt.
Ja, und dann zum Überschreiben Value-Files, aber es hält sich
ganz hart in Grenzen.
Du hast den ganzen Tag alte Streams laufen gehabt,
das ist extrem nice.
Views of what?
Weiß ich nicht, ob das was bringt auf Twitch, aber
trotzdem gut, dass du jetzt am Start bist.
Ja, also, ich muss euch ehrlich sagen, ich bin mir nicht sicher,
ob ich das geistig heute Abend noch
genug Gehirn-Kapazitäten für alles hab.
Muss ich nochmal schauen, ja.
Ich will ein eigenes Chart erstellen, ich will nicht unbedingt
was erweitern oder auf Repos oder das damit installieren.
Ich will ein eigenes Chart erstellen, das wird was super Simples,
was wir heute erstellen. Wie gesagt, ich hab schon einige
erstellt oder zumindest mit dran gearbeitet,
aber ich hab fast alles wieder vergessen.
Ich krieg noch nicht mal mehr die Template-Syntax richtig aus dem Kopf hin.
Aber Go-Templates sind eh massive abartig.
Ja, ich kann euch ja mal den Grund erzählen. Moment, wir müssen erstmal
kurz ein bisschen was Entspannteres anmachen.
Machen wir ne Runde Wup Wup Wup an? Weiß ich nicht.
Wir können auch Relaxing...
Das ist... Jawohl, excellent.
Dire Dire Docks, beste.
Was ich Kubernetes-Ready machen will,
ein Hello-World-Web-Server.
Nichts Großartiges, Kompliziertes.
Ich mein, es bringt ja nichts, wenn ich zwei komplizierte Sachen mache.
Ich muss erstmal wieder ein bisschen in Fahrt kommen hier.
Gatschi-Bass.
Ich müsste jetzt mal ein paar Liegestützen machen.
Oder irgendwas. Ich bin zwar schon seit
eineinhalb Stunden daheim,
aber es ist schon immer ein bisschen anstrengend gewesen,
wir haben den ganzen Tag wieder gemietet.
Kurze Stand-Up. Leute, Daily Scrum, auf geht's.
Daily Scrum, Stand-Up, alle hinstellen von Rechnern.
Und jeder halbe Minute,
was hat er heute gemacht, was will er heute machen.
Boah, ey, wie ich so gezwungene Sachen hasse.
Ich finde an sich das eigentlich sehr sinnvoll, das zu machen.
Wirklich, ich finde das wirklich sehr sinnvoll.
Allerdings nur unter der Prämisse,
dass es okay ist,
wenn man auch sagen kann, gibt nichts Spannendes, Neues.
Alle anderen haben das System auch nicht verstanden,
wenn du was sagen musst.
Was findest du persönlich besser?
In einer internen IT zu arbeiten oder bei einem IT-Dienstleister?
Äh, intern in der IT zu arbeiten,
weil als Externer oder als IT-Dienstleister
für größere Enterprise-Dinger bist du immer der Gearschte.
Heute ist Sprint angesagt,
für die nächsten vier Wochen.
Heute machen wir Sprint-Review,
Sprint-Retrospektive und Sprint-Planning.
Alles in einem heute im Stream.
Und das alles als Stand-Up.
Wir dürfen uns nicht hinsetzen dabei.
Sonst sind wir nicht agile genug.
Ja, und wir machen natürlich auch so schöne, äh, so schöne,
agile Boards, wo dann jeder, wo dann jeder...
Wobei, kein Witz, Leute, wir haben ein neues,
wir haben einen neuen Scrum-Master bei uns.
Und der hat sich jetzt was überlegt.
Ich find's eigentlich gar nicht so schlecht,
aber es ist schon ganz lustig, was für Ausmaße das annimmt.
Und zwar, wir haben jetzt eine Wetterkarte für unser Sprint,
für unsere Sprint-Retrospektive.
Haben wir eine Wetterkarte.
Ich glaub, so heißt das.
Ja, Max, genau so, genau so, das hab ich mir auch gedacht.
Wisst ihr, was das ist?
Das ist eigentlich, ich zeig euch das mal.
Das ist eigentlich nur ein Paint-Bild mit,
äh, wie fügt man bei Paint, kann man bei Paint Emojis einfügen?
Äh, selbstverständlich nicht.
Warum kann man bei Paint keine Emojis einfügen?
Warum ist das schon wieder so kacke alles?
Leute, wie fügt man in Paint Emojis?
Das muss doch gehen.
Gar nicht, ne?
Naja, gut.
Aber in Affinity Designer kann man Emojis einfügen.
Hoff ich, glaub ich.
Hab ich noch nie ausprobiert,
ob das über das Windows-Menü geht.
Also, wir haben eine...
Alter, geh mir nicht auf den Sack,
ich will einfach nur ein Bild anlegen.
So, wir haben eine Wetterkarte,
und das sieht dann so aus.
Moment, mal gucken, ob man hier Emojis machen kann.
Ne, geht auch nicht.
Okay, ähm.
Pass auf, wir machen jetzt Trick 17.
Wir fügen jetzt, pass mal auf,
das ist ZigZag, Cloud.
Wir nehmen jetzt hier ein Bild,
ein Emoji, copy...
Ach, das geht, oder was?
Das geht wohl.
Aber richtig vergrößern kann man es nicht,
das muss man dann mit der...
mit der...
Textgröße machen.
Okay.
Excellent.
Also, wir haben eine Wetterkarte,
das sieht dann so aus.
Cloud, Regen,
Wolkig,
Wolke mit Sonne,
und Sonne.
So.
So eine Wetterkarte haben wir jetzt.
Sieht so aus, ja.
Ja, okay, alles klar.
Chat, geh.
Ja.
Und...
So, und da sollst du jetzt...
So was haben wir jetzt, weil wir sind super agil auf der Arbeit.
So was haben wir da.
Und da soll jetzt jeder für den letzten Sprint
eintragen, was gut
und schlecht gelaufen ist.
Was schlecht gelaufen ist, ist nicht schlecht,
sondern ist Regen, Wolke.
Was eher schlecht gelaufen ist,
ist Wolke.
Was eher gut gelaufen ist, ist Sonne und Wolke.
Und was top gelaufen ist, ist Sonne.
Und da müssen die Leute jetzt drunter schreiben,
Ah, also im letzten Sprint
war die Abstimmung
in dem und dem Bereich schlecht.
Regen, Wolke.
Ich find's nicht schlecht.
Jetzt war Spaß,
ich find's vom Ansatz her eigentlich gar nicht übel.
Aber ich find's immer lustig,
wenn dann irgendwie 20 Leute da sitzen
und erstmal irgendwelche Paintbildchen
wählen. Habt ihr auch einen Redestock?
Nein.
Das haben wir zum Glück nicht.
Diesen Blödsinn haben wir nicht gemacht.
Was wir haben ist,
wir haben Elmo, heißt das Ding?
Elmo?
Aus der Sesamstraße?
Ja, Elmo. Wir haben Elmo.
Und man kann,
man kann ein Bild von Elmo
einblenden. Und wenn man ein Bild
von Elmo einblendet, jetzt überlegt
wir sind nicht im Kindergarten oder so.
Also wenn man ein Bild von Elmo
einblendet, dann bedeutet
das in unserer agilen
Agilitätssprache, ein
Thema wird zutiefst behandelt
im Daily Scrum, bitte
macht ein
weiterführendes Meeting zusammen.
Ohne mich.
Ja, also mal angenommen,
man hat Daily
und zwei Leute unterhalten
sich fünf Minuten lang über
was weiß ich,
Bitcoin oder keine Ahnung,
über irgendwelche Sachen, die nicht wirklich was für alle relevant
sind. Und dann blendest du Elmo
ein und sagst, mach doch
mal ein Meeting dazu, da braucht ihr uns doch nicht bei.
Ja, das ist alles ein bisschen,
ein bisschen Kindergarten ist das schon.
Aber vom Ansatz her machen die
es eigentlich ganz gut.
Kann ich es nicht durch...
Du hast recht.
Du hast recht. Deswegen ist das
Elmo. Das habe ich ja noch nie gecheckt.
Das heißt, enough, let's move on.
Chat, siehste?
Wieder was gelernt.
Absolut massive high IQ Chat.
Das ist richtig.
Deswegen heißt das Elmo.
Hab ich nie gecheckt.
Wieder ein kompletter IQ
Increase für den gesamten Chat.
Boda
Shields2395, danke
für den Prime Sub.
Was war der Grund, weswegen du in der
IT, in der Finanzbranche tätig bist?
Der Grund?
Weil es Geld gibt.
Weil ich nicht unter der Brücke schlafen will.
Und was zu essen haben will.
Okay, das habe ich zu
ernst gesagt. Wahrscheinlich haben es ja sogar ein paar Leute
geglaubt. Also, der Grund,
der Grund, warum ich in der IT-Branche tätig
bin. Ich meine, in der IT verdient man nicht schlecht.
Ich könnte auch in jeder anderen Branche in der IT arbeiten
und würde wahrscheinlich auch genug verdienen, um nicht unter der Brücke
schlafen zu müssen. Also, der Grund, warum
ich in der Finanzbranche tätig bin, ist ganz einfach.
Ich bin damals
in die Frankfurter Finanzbranche reingerutscht.
Ich war ja zuerst beim Internetprovider,
wo ich gearbeitet habe und meine Ausbildung
gemacht habe und nach der Ausbildung auch noch ein bisschen
weitergearbeitet habe. Und dort waren
wir tätig für eine Bank in Frankfurt
und
als mir der Internetprovider
dann zu sehr auf den Sack ging,
bin ich gewechselt
zur Bank in Frankfurt.
Also, die kannte ich ja damals
schon. Das war halt auch Frankfurter Finanzbranche.
Jetzt bin ich zu einer Versicherung gewechselt in Frankfurt.
Das ist auch Frankfurter Finanzbranche.
Allerdings muss man sagen, die fanden das
richtig gut, dass ich schon über 10 Jahre Erfahrung
in der Frankfurter Finanzbranche habe. Was auch immer
das genau bringen soll, ich weiß es nicht.
Vielleicht, dass man weiß, dass man sich an Regulierung halten
muss und sowas.
Das klingt aber ziemlich Fremdschäm
Peter Prometheus.
Was ich im Vorstellungsgespräch dazu
gesagt habe,
nichts. Ich glaube, ich wurde
dazu nichts gefragt.
Also, ich habe das sicherlich mal erwähnt,
aber nichts weiter.
Ich bin ja auch schon 10 Jahre hier.
Über 10 Jahre Finanzbranche-Erfahrung.
Ich weiß, wie das mit Regulation
und Vorgaben ist.
Ich glaube, das war es.
Es kam nicht groß zur Sprache.
Außer, dass sie das nice finden.
X Defiant, Peter.
Heute schaffe ich das
geistig nicht mehr. Aber ich wollte unbedingt
mal noch ein bisschen spielen.
Weil ja die Leute schon wieder anfangen.
Der COD-Killer.
Das glaube ich nicht.
Vielleicht ein ganz guter
Ersatz für einen Multiplayer.
Die letzten normalen Multiplayer
waren einfach
Shit. Also nicht der
Shit, sondern richtig mies.
Da ist er wieder.
Da hat dann aber auch keiner was von.
Also, eine Sache,
die mir wirklich gefällt
in der
Firma, wo ich aktuell arbeite.
Kann ich mal erzählen.
Eine Sache, die mir ein bisschen
in der alten Firma auf den Keks gegangen ist,
ist, dass die immer gesagt haben,
wir suchen bei Problemen ja keinen
Schuldigen, sondern wir suchen, wie man das
besser machen kann. Das haben die immer gesagt.
Das ging dann bis zu dem Punkt,
wenn mal was kaputt war, dann wurden eigentlich
nur Schuldige gesucht und nicht das Problem angegangen.
Das war in meiner alten Firma so.
Das hat dazu geführt, dass eigentlich die Leute
lieber nichts gemacht haben,
weil wenn du nichts machst,
machst du auch nichts kaputt und kriegst keinen Ärger.
Da habe
ich heute mit jemand in der neuen Firma,
wo ich arbeite, drüber geredet und da meinte der,
ich bin hier schon irgendwie 15 Jahre da
und das war früher bei uns auch so,
aber
die neue IT-Leitung
und sowas, die es jetzt seit ein paar Jahren gibt,
die hat das wohl geschafft zu transformieren.
Er hat gesagt, es war früher auch ganz
stark hier verbreitet, so dieses,
wenn du nichts machst, machst du nichts kaputt und kriegst
keinen Ärger und das haben die wohl
die letzten 5, 6 Jahre über geschafft,
die Transformation von wirklich
richtig Oldschool, Dienst nach Vorschrift,
keiner macht was freiwillig, weil er dann
Ärger kriegt, wenn was schief geht, zu
moderner und
weniger Gebläme und mehr
Sachen lösen. Das fand ich
wirklich gut. Da hat man gesehen,
es geht auch der umgedrehte
Trend. Bei meiner alten Firma, wo
ich war, war der Trend eher von, es war
gut zu, wir blamen jetzt nur noch Leute den
ganzen Tag und dort, wo ich jetzt bin, ging es
von, wir blamen nur noch die Leute zu,
wir suchen eigentlich Lösungen dazu.
Was viel sinnvoller ist,
weil, seriously, das führt halt echt
dazu, wenn du bei jedem
Handschlag Ärger für kriegst,
wenn irgendwie mal irgendwo was ein bisschen nicht
ganz richtig gelaufen ist, dann machst du halt
in Zukunft wirklich nur noch das absolute Minimum
und damit fährst du besser, was ja
halt auch eigentlich unterm Strich scheiße
ist für alle Beteiligten.
Aber das fand ich gut, was
er heute erzählt hat.
Hat die Asus Dual RTX
eine Kaufempfehlung? Keine Ahnung,
keine Asus
Dual RTX 4070.
Ich weiß es nicht.
Ansonsten
guckt mal bei PC Games Hardware oder so,
irgendwo, wo es gute Grafikkartentests gibt.
Boah, ich hab Durst heute ohne Ende.
Aber es ist ja auch warm.
Klimaanlage läuft schon. So Leute,
ich mach mal kurz meine 4M an.
Skip Stream.
Let's go.
Okay, ich versuche euch mal zu erklären,
was wir heute probieren. Also,
heute,
erstmal
die Story drumherum.
Ich hab mich heute auf der Arbeit
freiwillig dazu gemeldet, ein paar Sachen
zu verhelmisieren.
Weil ich mir gedacht hab, ich bin wahrscheinlich noch
der, der bei uns im gesamten Projekt,
also von den internen Leuten,
im gesamten Projekt noch am meisten Ahnung
davon hat.
Und
außerdem ist immer ganz gut,
wenn man weiß, was man dann im Endeffekt da auch deployed.
Zumindest hab ich mich gemeldet
und hab gesagt, Jungs, ich guck mir das mal an.
Wenn ihr mir erklärt, was ihr genau,
was genau rauskommen soll am Ende.
Also, was ihr genau deployen wollt, wo es die
Images gibt, was für Optionen ihr braucht und so was,
dann mach ich das.
Und als ich das gesagt hab, ist mir aufgefallen,
es ist bestimmt schon 3 Jahre her, wo ich
das letzte Mal, oder 2 Jahre her, wo ich das letzte Mal
was mit Helm gemacht hab. Ich hab keine Ahnung mehr.
Also ich hab mir jetzt quasi irgendwas ausgesucht,
was ich machen will, aber ich hab keine Ahnung mehr davon,
wie es geht. Aber ich hab's schon gemacht.
Ich komm da relativ einfach wieder rein.
Und ich weiß bei Helm Charts
noch 2 Sachen. Du brauchst
eine Chart-Jammel, wo du deine Metadaten
reinschreibst und du brauchst einen
Templates-Ordner, wo deine eigentlichen Kubernetes-Resourcen
reinkommen. Fertig.
Mehr weiß ich nicht. So, und was Helm
ist, das zeige ich euch jetzt.
Helm ist quasi so ein Setup-
Installer für Kubernetes.
Das heißt auch, im Endeffekt, wir brauchen
erstmal ein Kubernetes-Cluster, dass wir das machen
können. Aber das ist easy,
weil den können wir lokal starten
und den benutzen.
Ich kann euch mal sagen, was offiziell
Helm sagt, was sie sind.
Ich glaube Helm sagt,
Helm ist der Kubernetes-Packet-Manager
oder sowas. Kann man nicht wirklich
was mit anfangen,
aber wir gucken trotzdem auf die Seite, was die
sagen. Package-Manager
für Kubernetes. Also von der Idee
her ist es folgendermaßen.
Du hast einen Kubernetes-Cluster und willst darauf
eine Anwendung laufen lassen. Die Anwendung
geht aus
eine Message-Queue,
vielleicht
einer Datenbank, zwei
Applikations-Servern und sonstige
Geschichten oder zwei Applikations-Containern
und
die Secrets, die du brauchst,
die Ingress-Definition und sowas.
Also sagen wir mal so, damit die
Anwendung in Kubernetes läuft, brauchst du
so, keine Ahnung, sieben, acht verschiedene Ressourcen.
So, und die kannst du jetzt entweder von Hand
anlegen oder
das Software hat schon ein Helm-Chart
angelegt oder ein Setup-Package
ist das ja, eigentlich ein Installer, quasi
erstellt und dann kannst du sagen, Helm install
Kekl-App
und dann installiert er das in dein
Kubernetes-Cluster und du kannst es mit Helm
ich glaube Delete ist es, dann auch
wieder entfernen.
Helm 2 ist absolut
mega, Ultraschrott gewesen.
Das braucht man
glücklicherweise nicht mehr.
Ne, das braucht man nicht mehr. Das war
kompletter Schrott.
Hat man es verstanden?
Es ist quasi Up-Install für
Kubernetes-Cluster.
Up-Install und Up-Remove
ist es, glaube ich, für
Anwendung für Kubernetes-Cluster.
So, wir brauchen...
Klar, also den kenne ich noch.
So, haben wir Helm installiert?
Ja, haben wir.
Hast du den
Bahn-Rent verpasst? Nö.
Hab ich nicht. Ich hab mich heute ein bisschen
auf Twitter ausgekotzt,
weil ganz im Ernst, ey.
Heute sind wir wieder richtig auf den Sack gegangen
bei der Bahn. Müsst ihr euch vorstellen,
wir sind in Frankfurt hier.
Wir sind in Frankfurt.
Mein Geflame kam heute nicht so gut an.
Guck mal, es haben bloß 2500 Leute gesehen.
Sonst ist der Bahn-Flame...
Der Bahn-Flame geht immer besser.
Also heute ging es mir echt auf den Sack.
Wir stehen in Frankfurt
und die Türen gehen zu
und es gibt irgendwie Türprobleme.
Dann sagt der erstmal, ja, alle wegbleiben von den Türen.
Passiert nichts. Und dann, oh, wir haben eine Türstörung.
Es verzögert sich. Dann sind wir schon
10 Minuten später in Frankfurt losgefahren.
Dann waren wir in Frankfurt-Süd.
Dann ging es dann weiter und dann waren wir in Offenbach.
Und in Offenbach hatten wir wieder eine Türstörung.
Alter!
Das ist so unfähig alles.
Ich meine, der Typ, der den Zug fährt,
der kann nichts dafür, dass der Zug kaputt ist.
Aber die Dinger sind halt so
schrottreif teilweise.
Und da kommt jetzt noch die Wärme dabei,
womit im Sommer ja auch keiner bei der Bahn immer rechnet.
Das ist aber richtig...
Na gut, auf einer Citrix-VM suckt.
Aber CL...
Achso, ohne Copy-Paste, weil Citrix-VM...
Ja, das ist shit. Das benutzt ja auch keiner noch
irgendwie bei Verstandes.
Boah, Mann.
Okay. Also wir brauchen
einen lokalen Kubernetes-Cluster.
Ja, aber
nicht, wenn deine Citrix-Admins
das Ganze disabled haben.
Was Massive-Pepega
ist,
Citrix
Copy-Paste zu deaktivieren.
Ja, es ist komplett
lächerlich. Das kannst du knicken, Alter.
So, also wir müssen
erstmal einen lokalen Kubernetes-Cluster
hochfahren. So, Minikube start.
Bäm, mehr brauchen wir nicht.
Aber Moment, wir haben noch einen. Dann Minikube
delete. Start.
Minikube V1301
on Arch
Linux by the way.
Nur mal für den Fall,
dass ihr es noch nicht mitbekommen habt.
Ich benutze Arch Linux
für den Fall der Fälle, dass euch das interessiert.
Das ist ein Arch Linux-System.
Äh...
Warum geht...
Warum ist mein Minikube
kaputt? Was ist los?
Docker restart.
Hab ich irgendwas broken oder...
Hab ich ein Kernel-Update
gemacht? Nö.
Docker funktioniert. Ich hab kein
Kernel-Update gemacht. Was ist denn das?
Soll ich mal restarten?
Bin mir nicht
ganz sicher, aber ich reboote mal.
Sehr merkwürdig.
Verstehe ich nicht.
Sicher, dass du Linux benutzt?
Ich benutze nicht einfach nur Linux. Ich benutze
Arch Linux.
By the way.
WhitePepoBadgetTime
Start. Nein, nicht Start.
X. Minikube start.
Ah, jetzt funktioniert's.
Keine Ahnung, was der für Schmerzen hatte, aber jetzt
funktioniert der Minikube-Cluster.
Das ist ja kein Cluster. Kann man so nicht sagen.
Der
Minikube-Kubernetes-Node.
Reboot tut halt
manchmal echt Wunder wirken.
So, wir brauchen mal einen
Test-Container, den wir deployen können.
Hello
World Web-Server
Docker. Da gibt's doch
irgendwie sowas. Easy.
Linux-Demo. Ja, perfekt.
Hello World.
Wobei, da gibt es doch den
Hello World
Traffic
Container, oder?
Traffic.
Der ist doch, glaube ich, ganz gut.
Ja, genau.
Hello World Container.
Wie heißt denn das Ding nochmal?
Ne, ne, ne, ne.
Hier, den Who Am I?
Container, meine ich.
Hier.
Deprecated. Use
das hier. Ja, okay, dann use ich das hier.
Ist auch okay. Ah, nervt
mich rum, Alter. Kann das mal
weggehen? Use Traffic.
Okay, ich lass das mal kurz in dem Docker-Container.
Docker run.
Port.
Moment, ne, das muss man immer vorne hin machen.
Port 8000
auf Port 80, vermutlich,
in dem Container. Ja.
Curl. Local
Host Port 8080.
What? Ach, ne.
8000, nicht 8080.
Null.
Okay, Pfundst.
Local Host Port 8000. Jawohl.
Okay, wir haben unseren Hello World Webserver.
Oh, fuck, Leute.
Shit.
IP-Leak.
Moment, Moment.
Chat, nicht klippen. Ich muss das
Wort erstmal entfernen.
Moment, Moment.
Nicht klippen. Okay.
Okay, ich hab alle Clips
entfernt und Wort gelöscht. Jetzt ist gut.
Oh, ne, da steht's noch. Immer noch Leak.
Doppel-Leak. Leak.
Ja, jetzt ist auch egal.
Jetzt hab ich's ja schon geleakt.
Ja, guck hier. Fuck IP-Leak.
Nicht hacken, Leute.
Und nicht DDoS'n, please.
Also DDoS mich jetzt,
please, nicht. Okay, weiter.
Also.
Stimmt, und ich hab auch noch den...
Ich hab auch noch den Port offen.
Das ist ja doppelt schlimm.
Okay, jetzt haben wir unseren
Hello World Container.
Okay, also machen wir mal einen extra Ordner.
Gibt es irgendwelche guten
Visual Studio Code Extensions?
Direkt mal Nmap.
Du bist wahrscheinlich schon mit Reverse Shell
auf meiner Kiste drauf. Gib's zu.
Rootkit ist installiert.
Oh, was haben wir denn hier noch offen?
Ah, der
Copypasta Champ
Demo. Kann auch gleich
weg. Das JetBrains
Plugin ist eigentlich ganz gut.
Ne, wir machen jetzt das mit
VSCode. Temp.
MKDIR.
Ja, keine Ahnung.
Helm, Heckweh.
Irgendwas.
Visual Studio Code öffnen.
Ist da Linux in einer
VM? Ja,
ist es.
Guck, ich hab das so,
weil die Frage immer aufkommt,
wie schnell ich zwischen Windows und Linux hin und her
wechsle. Ich hab zwei Desktops.
Ich hab einen Desktop
für Windows,
einen Desktop für die VM im Fullscreen,
das ist VMware Workstation,
und einen dritten Desktop, den ich benutzen kann,
wenn ich mal brauche.
Und ich kann jetzt mit
Pfeiltasten hin und her schalten. Guck, ich mach jetzt
Control, Windows, links,
dann bin ich hier auf dem Desktop. Control, Windows,
rechts, dann bin ich hier in der VM.
Control, Windows, links, dann kann ich ganz einfach
hin und her schalten.
Zwischen der Linux VM und
meiner Windows-Kiste. Es ist sehr praktisch.
Für mich
ist es der beste
Workflow. Gibt Leute,
die schwören drauf, dass man
Linux als Host benutzt und dann irgendwie
Windows in der VM. Aber ehrlich gesagt,
ich mach genug unter Windows, dass mir das
auf den Sack gehen würde. Dann mach ich lieber die Sachen,
wo Linux seine Stärken hat in der VM.
Und nachdem ich da keine Videos
anzeige oder irgendwelche Sachen brauche
mit GPU Access oder sonst was,
ist die Performance absolut
in Ordnung.
Kann man die Animation deaktivieren vom
Switchen? Welche Animation?
Siehst du irgendeine Animation beim
Switchen? Oder meinst du unter
Windows 10? Jaja, unter
Windows 10 gibt es eine Animation.
Unter Windows 11 hat Microsoft die
Animation einfach entfernt.
Na gut, prinzipiell
kann man
auch Spiele in der VM
spielen. Sowas wie
SuperTuxCard, aber naja, warum
sollte man? Ja, geht mir
ähnlich. Ich mach unter Windows halt zu
viel, als dass ich das lohnen würde
Dualboot zu machen bzw. Linux
als Host mit VM für Windows.
Ich spiele, ich mache
Videos, ich streame,
ich mache Thumbnails für die Videos,
ich schneide meine Videos. Das mach
ich ehrlich gesagt am liebsten unter Windows mit der
Software, die ich kenne. Ich sag gar nicht mal
so sehr, dass man die Sachen, die ich machen würde,
vielleicht bis auf den Gaming Aspekt,
den kannst du unter Linux,
das weiß ich mal, kannst du vergessen.
Du könntest das meiste wahrscheinlich auch unter Linux machen,
aber ich bin zu faul, mich umzugewöhnen
von der Software an, die ich mich
gewöhnt habe. Also insofern,
ich werde das Setup höchst
wahrscheinlich so lassen, wie es ist.
So, also,
Ziel ist jetzt folgendes,
und zwar, guckt mal,
get pods-a
Wir haben einen lokalen
Kubernetes-Cluster laufen, da ist nichts drauf,
außer die Standard
Kube-Systems-Sachen, die wir brauchen. Wir brauchen noch
ein Ingress-Add-on,
wobei brauchen wir das überhaupt?
Ich installiere es einfach mal.
So, also guckt, wir haben hier ein paar
Kubernetes-Sachen drauf laufen, wir haben ein Ingress
laufen, also ein Ingress.
Habt ihr vielleicht schon mal,
Chatge, ich hab mal eine Frage an euch.
Wer hat
Ingress schon mal im Umfeld von
Kubernetes gehört, hat aber keine Ahnung,
was es ist.
Also das muss ich jetzt wissen, weil
davon hängt ab, ob ich es jetzt noch mal
erkläre oder es sein lasse.
Okay, also ihr habt es schon gehört, ihr wisst nicht, was
es ist. Im Prinzip,
genau, im Prinzip ist es eigentlich,
im Prinzip ist es eigentlich ganz einfach.
Guckt mal, ihr habt hier einen,
also Namesplate, das ist das, was von
dem Add-on kommt, ja? Ihr habt hier einen
Ingress-Controller laufen, das ist
in Nginx. Was ist
Kubernetes? Oh, da wird es jetzt natürlich schon ein bisschen
komplizierter. Kubernetes ist
ein Container-Orchestrierungstool.
Also quasi so eine Art
Docker, nur geklustert.
Das trifft es eigentlich
ganz gut. Oh, ich habe extrem
Durst heute, Leute. Ich muss, glaube ich, gleich noch eine Flasche Wasser holen.
So.
Und zwar,
wir haben jetzt einen
Ingress-Controller laufen. Ein Ingress-Controller
ist eigentlich
erstmal nichts anderes, also in dem Fall
hier, wie in dem Fall
in Nginx. Nginx ist ein
Web-Server, der nicht nur gerne als
Web-Server benutzt wird, sondern auch als
HTTP-Reverse-Proxy.
So.
Und jetzt kommt ja irgendwann
mal der Tag, dass man Services
auf Kubernetes laufen hat, die man
der Außenwelt zugänglich machen möchte.
Da gibt es, sagen wir mal, prinzipiell
zwei Möglichkeiten, wie man das machen
kann. Entweder
man gibt dem Service selbst eine externe
IP, zum Beispiel mit
der Loadbalancer-Config, also
es ist eingebaut in Kubernetes,
kann man sagen, Service-Typ, Loadbalancer
und dann zieht er sich eine externe IP,
wenn man externe IPs bekommen kann bei
einem Cloud-Anbieter, dann hat der
jeweilige Service eine externe IP,
man biegt sein DNS drauf um
und dann funktioniert das.
Das Problem ist aber, du brauchst
für jeden Service
eine Public-IP,
was auch Geld kostet
und du musst dich
drum kümmern, was
Zertifikate angeht,
oder auch vielleicht um Firewall-Freischaltung
und sowas. Brauchst du,
also geht, ist teilweise
auch sinnvoll, aber
einfacher ist es eigentlich mit einem Ingress.
So, und ein Ingress ist im Prinzip
ein Webserver, den hast du einmal
gestartet,
beziehungsweise du hast einmal
den Ingress-Controller laufen
und wenn du jetzt Anwendungen und Services in Kubernetes
hast, dann expost du nicht mal direkt
den Service, sondern
sagst, ok, der soll jetzt den Ingress benutzen
und was dann passiert ist,
wir gucken uns auch gleich die Config dafür an,
was dann passiert ist,
dass der
Webserver, in dem Fall ist es halt ein Nginx,
dass der sich merkt,
ok, diese Anwendung soll ich quasi
Reverse-Proxien, das erzeugt quasi eine
Reverse-Proxy-Config für Nginx, das Ganze
und dass Nginx den
Server kennt, den Service kennt und darauf
Loadbalancen kann. Also eigentlich
legst du damit eine
Reverse-Proxy-Config
an und dann musst du nur noch eine
Sache machen,
du brauchst eine Public-IP für deinen
Ingress, das kann man sich auch anzeigen,
kube get Ingress
wir haben noch keine
Ingress-Objekte angelegt, wir haben bloß den
Ingress-Controller angelegt,
der übrigens, also wenn man sich jetzt Public-IPs
und so anzeigen
lassen würde, dann würde man
das auch sehen, wir haben auch glaube ich
keine Services und sowas,
also noch keine eigens angelegte Services,
genau hier sieht man es.
Normalerweise hätte das hier dann
Public-IPs,
wenn wir jetzt bei einem Cloud-Anbieter wären.
Ja und dann
musst du eigentlich nur noch deinen DNS
für die jeweiligen Services
umbiegen
auf die externe IP von
deinem Ingress
und deinem Service, den du
einrichten willst, dass der den Ingress
benutzt, legst du eine Config an, die unter
der Haube quasi eine Reverse-Proxy
Config erzeugt für Nginx.
Also das heißt im Endeffekt,
du kannst über eine Public-IP
mehr oder weniger alle deine Anwendungen
drüber laufen lassen, das ist sehr praktisch,
es ist automatisch nur Port 80
und 443 exposed, du kannst so ein paar
Standardsachen einstellen, du kannst theoretisch auch
unterschiedliches
Routing für die unterschiedlichen
Pfade und so noch
einstellen in deinem Ingress, wenn du willst.
Also du musst dich auch nicht um Zertifikate
kümmern, wenn du es
einmal ordentlich eingerichtet hast
und das funktioniert in der Regel besser, eigentlich
sind Ingress die beste Variante, Sachen
zu exposen in Kubernetes.
Das ist nichts anderes wie eine Reverse-Proxy
und bei einer Sache muss man sich
muss man sich
wenn ich "-a"- mache, nee,
"-a"- ist all Namespaces, siehst du doch hier, guck
get pods-a
namespace ingress, namespace
kubesystem, wenn du "-a"- dran machst, ist das
all. Du kannst "-a"- schreiben oder
"-all Namespaces",
aber "-a"- ist kürzer.
So, und also es ist im Prinzip
eine Reverse-Proxy, so wie man es kennt.
Ja, jetzt habe ich gerade vergessen,
was ich sonst noch sagen wollte.
Bin ich denn gerade stehen geblieben?
Ach, keine Ahnung mehr.
Ach ja, jetzt weiß ich es wieder.
So, das ist, also
Ingress ist so die allgemeine
Bezeichnung für quasi eine Reverse-Proxy
für den Kubernetes-Cluster.
Also quasi für einen Eingang.
Ingress steht ja im Prinzip für sowas
wie Eingang. Es gibt auch noch Egress,
das ist Ausgang, aber
Ingress ist deutlich, wie soll ich sagen,
deutlich öfters verwendet als
Egress. So, Ingress
heißt ja eigentlich nur, dass es ein zentraler Eingang
ist, aber hier seht ihr,
das ist ein Nginx-Ingress.
So, und da gibt es jetzt, es gibt noch mehrere.
Du kannst Traffic als Ingress verwenden,
du kannst eine A-Proxy als Ingress verwenden,
du kannst bei Google zum Beispiel den
Google Cloud Native Ingress verwenden,
oder was gibt es noch?
Kong oder so gibt es noch,
ähm,
Envy oder Envoy,
oder wie das Ding heißt, gibt es noch.
Was fallen euch noch für
Ingress-Sachen ein? Gibt es einige.
Quasi jeder x-beliebige Webserver
hat wahrscheinlich irgendein Ingress-Modul.
Die Musik ist ein bisschen lauter.
Wir brauchen mal grad was
bisschen Relaxing.
Wupp, wupp.
Wupp, wupp, wupp, wupp, wupp, wupp, wupp.
Istio ist,
ja doch, Istio
ist, oder Istio, ich weiß gar nicht,
wie man das richtig ausspricht, ist aber jetzt nicht
ein klassischer Ingress, das ist ja eher was
Richtung kompletter, komplettem
Service-Mesh, also auch mit
MTLS und allem möglichen.
Ja, also so sieht das Ganze aus.
Und jetzt um die Verwirrung mal
komplett zu machen, wir benutzen
hier halt einen Nginx als Ingress.
So, und damit es nicht zu einfach wird,
es gibt jetzt
Ingress Nginx und
Nginx Ingress.
Und wer jetzt denkt, das ist das gleiche,
der liegt falsch.
Es gibt einmal
den Nginx Ingress Controller
und es gibt einmal den
Ingress Nginx Controller.
Ist von der Benahmung her schon ziemlich
kacke, ja. Man würde eigentlich
erstmal denken, das ist das gleiche,
aber ist
es nicht. Der Unterschied
ist folgendes.
Beides sind
Ingress Controller für Kubernetes
und beide basieren
auf Nginx. Der Unterschied
ist, das hier
ist der Nginx Ingress Controller
vom Nginx
Hersteller
und das hier ist der Nginx
Ingress Controller
vom offiziellen Kubernetes Team.
Also Kubernetes
stellt einen offiziellen Ingress Controller
bereit, der auf Nginx Basis
arbeitet. Allerdings die
Nginx Hersteller stellen auch
einen aus ihrer Sicht offiziellen
Nginx Ingress Controller bereit.
Total pipega, fragt mich bitte nicht
warum die
mit diesem Blödsinn überhaupt erst angefangen haben,
aber in der Regel, wenn ihr
euch fragt, welchen davon solltet
ihr verwenden, ihr solltet immer den
hier verwenden. Den offiziellen
von Kubernetes.
Wenn nichts dagegen spricht.
Das ist auch, ich persönlich
würde sagen, das ist der verbreitetste Ingress
auch für Kubernetes, ja.
Und
eigentlich immer den, wenn nicht
irgendwas dagegen spricht.
Hat das Minikube
add-on hier auch installiert?
Ja, du kannst
TLS kannst du mit ganz vielen machen.
Also TLS kannst du auch
mit Nginx machen.
Kadi ist halt schön easy,
weil Kadi direkt Let's Encrypt und alles
integriert hat. Da brauchst du wahrscheinlich
keinen Third Manager oder sowas mehr.
Moin, Lothanox.
So, Chat, hat man soweit
verstanden, oder?
Was ich jetzt hier versucht habe zu erklären.
Ich glaube jetzt haben wir alles Ingress mäßig
hier soweit abgedeckt.
Also wir haben lokalen Kubernetes Cluster
mit den Kube-Systems Sachen,
die man so braucht,
Key-Value-Store, den API-Server
und alles mögliche Zeug.
Ein paar Storage-Klassen sind drin und
eben auch einen Ingress-Controller.
So, was wir jetzt machen wollen ist,
ich will einen ganz
billigen Hello-World-Container
oder Hello-World-Web-Server
als Helm-Chart verpacken.
Hast du auch mal Ingress
gespielt? Nein, habe ich
nicht. Erlebt das noch?
Also Ingress ist ja quasi
das gleiche wie
Pokémon Go oder
das Harry-Potter-Mobile-Game.
Nur dass es damals
am Anfang noch Portale und
Raumschiffe und sowas waren.
Oder bringe ich das jetzt durcheinander?
Nee, ne? Das ist doch das Game.
Habe ich nicht gespielt.
Aber bei mir auf der alten Arbeit, als es neu war,
fanden das manche Leute total geil.
Die sind den ganzen Tag durch Frankfurt gelaufen, haben Portale
gecaptured. Traffic ist
eklig. Wo Traffic
gut ist, im Kubernetes-Umfeld weiß ich nicht.
Habe ich Traffic noch nie benutzt.
Wo Traffic ganz nice ist, wenn man
beispielsweise
ein Docker-Compose-File
hat
und
dort zum Beispiel automatisch
ein paar Container tanken will für
Zertifikate und sowas.
Dann ist das ganz nice mit Traffic.
Aber ansonsten
finde ich Traffic auch eklig.
Also die Traffic-Config ist richtige Abfuck.
Wer schon mal Traffic-Config von Hand
machen muss, kann ein Lied davon singen.
Endlich
Silber. Ja, drei Monate.
Das ist extrem.
Nice.
Chat, wo wir gerade dabei sind.
Was ist denn heute? Sind heute Weebs in
oder Weebs out?
Sind wir heute
Weeb-freundlich oder eher nicht?
Ja, ich würde auch sagen.
Heute
alle Weebs in.
Ich habe noch Subs übersehen.
Von gestern.
HolyLuckGamers und SvenSupreme
und WotCS
auch am Start.
Danke Leute für die Subscriptions.
Oder um nicht zu sagen.
Relax.
Dankeschön für den Sub.
Wir machen demnächst...
Oh, der Scam-Train ist unterwegs, Leute.
Wir machen demnächst übrigens
tatsächlich einen Daily-Sub-Counter.
Ich muss mir nur irgendwas
überlegen, was ich mache, wenn wir die Daily-Subs
packen.
Irgendwas, was ich eh machen würde.
Dass es easy ist.
Mülli.
Danke für den Sub.
Jetzt hier, der Scam-Train ist am Start.
Jetzt geht's los. Eine Face-Leak.
Ja, klar.
15 Subscriber gleich Face-Leak.
Ja, doch.
Face-Leak mit meiner Keks-Maske auf.
Das ist kein Problem.
Okay, ich mag...
Ne, GPU-Pass-Train vor allem.
Du lernst endlich PHP.
Habe ich doch gemacht vor zwei Tagen.
Und festgestellt, dass es suckt.
Sub-Count in Grafana, ja.
Weiß gar nicht.
Müsste eigentlich gehen, ohne Probleme.
Twitch-API.
Das Garten-Stelz-Video.
Weiß bis heute nicht, warum das so beliebt ist.
Du lernst gerade React.
Das ist sehr nice.
Sebasu-Chan.
Oh, das ist auch
ein nicer Weeb-Name, oder?
Sebasu-Chan.
Oder das
Nvidia-Shield-Review
im Fernsehen.
Ich weiß nicht, was mit YouTube los ist.
Keine Ahnung.
So, wo sind wir stehen geblieben?
Unsere Kompanie, das Zeug.
Und was ich jetzt probieren will,
ist, ich möchte
einen Installer quasi erstellen.
Für
diesen Container.
Meine Erfahrung mit Helm
ist zwei Jahre her.
Und ich weiß eigentlich nichts mehr.
C++, was?
Das haben wir doch sogar schon gemacht.
Ich weiß eigentlich
nichts mehr. Das Einzige, was ich noch
weiß, ist, dass man
einen Ordner anlegen muss.
Für seinen Helm-Chart.
Also, keine Ahnung, mkdir.
Ja.
HelloHelm, oder so.
So, und da drinnen
braucht man jetzt, also, das war es
wirklich, chart.yaml.
Wobei ich mir auch nicht mehr sicher bin,
ob man es groß oder klein schreiben muss.
Und dann braucht man
da drin, glaube ich, den Template oder
Templates-Ordner.
Wo man dann seine Kubernetes-Ressourcen reinschreibt.
Mehr weiß ich legit nicht
mehr. Ich habe keine Ahnung mehr.
Deswegen brauchen wir jetzt mal
einen Quickstart-Guide.
Using Helm.
Creating Charts.
Charts Template Guide. Getting Started.
Ja, perfekt.
Jaja, man kann das,
stimmt, du hast recht, man kann das auch mit dem
CLI anlegen.
Helm.
Create.
HelloHelm.
Ja, genau.
Ja, das hat schon alles
angelegt für mich. Okay, nice.
Machen wir mal
ein Visual Studio Code auf und gucken, ob es da
irgendwelche nice Plugins für gibt.
Helm Ignore.
Okay, die haben sogar ein eigenes Ignore-File.
Das wusste ich gar nicht.
Values.yaml.
Naja, gut.
Values.yaml.
Zum Testen natürlich nicht verkehrt. Ansonsten müssen die Leute
das halt selbst erstellen oder überschreiben
später, besser gesagt.
Templates.
Ja, so, und jetzt ist halt das Ding.
Tests.
Ich glaube, es geht los.
Testen muss man nur,
wenn man Fehler macht.
Oh, den Witz habe ich heute auf der Arbeit gebracht.
Den fanden sie mega lustig.
Also den, den ich hier schon tausendmal erzählt
habe. Man, wir machen keine Tests, weil wir machen
keine Fehler. Okay,
also.
Ja, anscheinend. Also, okay, okay.
Ich erkläre das nochmal kurz.
Also, wenn man jetzt
ein Kubernetes-Cluster hat, wie wir hier
gerade haben, und du möchtest dort
jetzt eine Anwendung installieren,
die jemand anderes
entwickelt hat.
Wie machst du das dann? Es gibt mehrere
Möglichkeiten, das zu machen.
Du erstellst
beispielsweise ein YAML
Deployment-File und
pushst das in deinen Kubernetes-Cluster.
Oder du hast so eine,
du bist modern und hast sowas wie Argo-CD,
was das für dich applied.
Meistens ist es aber so,
dass eine Anwendung nicht aus einem einzelnen Deployment
besteht, sondern aus mehreren Sachen.
Zum Beispiel könnte
eine Anwendung aus
zwei Applikations-
Containern bestehen.
Ich meine nicht Pods, ich meine verschiedene
Images.
Aus zwei Applikations-Images
eine Message-Queue-Image,
ein paar Kubernetes-Secrets
und eine Datenbank.
Jetzt hast du quasi fünf verschiedene Sachen,
die du
brauchst in einem Cluster, dass die Anwendung,
dass der Service, den du eigentlich betreiben willst,
läuft.
Das heißt, entweder erstellst du jetzt alles
von Hand an Kubernetes-Ressourcen
oder du
erstellst einmalig einen Helm-Chart,
mit dem du es installieren kannst, oder der Hersteller
hat schon einen Helm-Chart.
Meistens hat der Hersteller schon einen Helm-Chart.
Das ist eigentlich so der Weg schlechthin,
jeder Hersteller von Software, die in Kubernetes
laufen soll, bietet Helm-Charts an.
Im Prinzip ist ein Helm-Chart
quasi ein Installer.
Angenommen, ich möchte jetzt
in meinem Kubernetes-Cluster
eine Software installieren, die sich
keq-ws-service
nennt
und der Hersteller hätte
schon einen Helm-Chart bereitgestellt
für mich. Dann könnte ich einfach sagen,
Helm-Install
Ist das mit Terraform
vergleichbar?
Vielleicht ein
bisschen.
Vielleicht ein kleines bisschen.
Terraform
hat aber noch deutlich mehr.
Terraform hat noch State-Tracking
zum Beispiel. Das juckt
Helm nicht wirklich.
Naja doch,
ein bisschen minimal mit Terraform
ist das schon vergleichbar.
Du erstellst irgendwelche Description-Files,
die auch getemplated
werden können
und appliest die dann.
Am Ende fällt halt irgendwas raus.
Ein bisschen damit kann man es
vergleichen. Wobei man halt sagen muss,
Helm ist rein für Kubernetes-Resources
und Terraform ist für alles.
Mit Terraform kannst du Datenbank
anlegen, VMs anlegen,
Kubernetes-Cluster anlegen, alles anlegen.
Und mit Helm kannst du eigentlich
nur Kubernetes-Ressourcen anlegen.
Aber, und der Vorteil
davon ist, du kannst die Sachen halt templaten.
Das heißt, wenn du jetzt 20 Secrets
anlegen musst, dann machst du eine Schleife
in Helm, anstatt 20 Secrets im YAML zu definieren.
Es ist schon
Infrastructure as Code.
Ja, irgendwo schon.
Ja. Nein, Helm
hat nichts mit Security zu tun.
Helm ist ein Install-Skript
quasi, könnte man sagen.
Helm führt Installer-
Setups aus für Kubernetes.
Also, wenn ihr euch für Windows
was runterladet,
ihr ladet euch
das kekw-Setup runter
und führt das aus,
das ist ein Installer.
Und sowas ist Helm für Kubernetes.
Hier installiere ich jetzt diesen
Krempel bei mir auf Windows,
und mit Helm installen würde ich quasi
kekw-as-a-Service in meinem Kubernetes-Cluster installieren.
Alles, was dazu gehört.
Sofern der Hersteller den Helm-Chart bereitstellt.
Natürlich gibt es kekw-as-a-Service nicht
als Helm-Chart.
So.
Und
das Coole daran ist,
wenn du das einfach nur benutzt,
wenn du jetzt eine Software installieren
möchtest in einem Cluster,
wo der Hersteller halt dir Helm-Charts
bereitstellt, oder ein Installer,
in Form von einem Helm-Chart
bereitstellt,
dann kannst du es halt darüber installieren.
Du kannst, sagen wir mal,
halbwegs, ist nicht wirklich richtig,
aber halbwegs
wieder entfernen aus deinem Cluster.
Auch halbwegs rückstandslos
wieder entfernen aus deinem Cluster.
Und du musst halt selbst die ganzen
Ressourcen nicht anlegen.
Das macht das Helm-Chart für dich.
Und halt in der Art und Weise,
wie der Hersteller schon getestet hat,
dass es funktioniert.
Leider artet das teilweise aus.
Und du kannst, nachdem Helm-Charts
aus Go-Templates bestehen,
du kannst vieles der Sachen auch
ändern. Das sind dann Value-Files
bei Helm.
Man sieht es hier zum Beispiel.
Da gibt es Value-Files.
Und in diesen Value-Files lege ich meine
Optionen für die Installation fest.
Also ihr seht es ja, das hier sind
keine Kubernetes-Ressourcen, die man
hier anlegt. Das ist Config,
anhand dessen dann das
Helm-Chart meine
Kubernetes-Ressourcen erstellt.
Also man kann die Image-Pull-Secrets
anlegen, man kann das Repository
anlegen, wo das Ganze hergepullt
werden soll und sowas in der Richtung
Replica-Count, wie viele Pots im Endeffekt
laufen sollen und so. Und wenn ich das
dann ausführe, das Helm-Chart,
das können wir jetzt ja auch gleich mal machen,
dann läuft unter der Haube
hier dieses ganze Templating durch,
wo ich mich als reiner Anwender nicht
drum kümmern muss. Das Ganze hier,
hier ist das Deployment. Ihr seht,
das ist quasi Kubernetes-Ressourcen
mit Go-Templates drin.
Und wenn ich jetzt ein Helm
installen mache, dann nimmt
Helm mein Value-File
das hier quasi als
Variablen, ihr könnt euch das hier mehr oder weniger
als Variablen vorstellen,
und setzt das hier an den passenden
Stellen, guck hier, das hat auch
ein If,
und sozusagen
setzt es hier an den richtigen Ingress-Class-Name,
guck mal, Values-Ingress-
Class-Name, guck mal bei Values rein,
Ingress-Class-Name,
hier kommt die Variable her.
Also, hier wird das eingesetzt.
Helm templatet das und erstellt
Kubernetes-Ressourcen, die dann applied werden.
Wir können mal gucken, ob das Ganze ausgeführt
werden kann. Ich habe keine Ahnung, was die hier eigentlich deployen.
Hello Helm.
Ja, okay, wir deployen das jetzt einfach mal.
Also, wir haben jetzt das
Default-Chart erstellt, also sagen wir Helm,
Helm,
Helm install,
Punkt. So, Punkt ist,
wir haben das Helm-Chart hier im aktuellen Verzeichnis
liegen, das selbst funktioniert
funktioniert noch nicht, weil
man sollte einer Helm-Installation
einen Release-Name
geben, nennen wir es mal Kekl.
Und
jetzt hat das, glaube
ich, funktioniert.
Holen wir uns mal die Ports.
Hat nicht funktioniert. Doch, hier.
Da ist es.
Also, wir haben jetzt das
Helm-Chart installiert, was im Endeffekt nur
ein Container ist im Default-Namespace.
Aber ihr seht, wir mussten keine
Kubernetes-Config von Hand anlegen.
Und wir können den ganzen Kram jetzt auch wieder
löschen. Brauchen wir nicht.
Und jetzt ist
der ganze Krempel wieder weg.
Jetzt ist der ganze Kram wieder
weg. Also es ist, wie ihr seht,
hier guckt mit Install und Delete, es ist so eine Art
Package-Manager und das sagen sie ja auch selbst.
So, was man eigentlich machen sollte
ist folgendes, wenn man den Kram installiert.
Man sollte einen Release-Name angeben
und
ich zeige euch gleich den Unterschied,
man sollte einen Release-Name angeben,
man sollte einen
Create-Namespace
machen.
Ach Moment, ich bin ja blöd. Jetzt habe ich
was vergessen. Ich muss ja erst den Namespace
noch angeben.
So, dann gebt ihr den Namespace an.
Minus L. Also wir installieren
jetzt dieses Helm-Chart.
Der Release-Name ist keckel und
wir installieren das ganze im Namespace.
Keine Ahnung.
Machen wir was Realistisches.
Wir installieren es im Namespace
Test oder
Dev.
Jetzt ist das installiert.
Oh Fuck. I'm not found. Gut, zum Glück.
So, und wenn ich jetzt mal hier die Pots
anzeige, seht ihr, im Namespace
Dev wurde jetzt hier mein Deployment
durchgeführt. Wenn ich jetzt sage
Helm List, dann sehe ich auch
okay, wir haben ein Deployment gemacht mit Helm.
Funktioniert auch alles. Namespace
Dings und Namen. So, und warum
muss man Release-Namen angeben?
Naja, man kann ja
diese Anwendung mehrfach deployen.
Heck weh.
Guck, und jetzt habe ich im gleichen
Namespace das gleiche
Helm-Deployment mehrfach.
Realistisch betrachtet
wird man wahrscheinlich nicht im gleichen
Namespace die gleiche Anwendung mehrfach
deployen, sondern man wird eher sowas
hier machen.
Delete.
Wahrscheinlich
realistischer wird man
sowas machen. Guck mal, wir haben jetzt
die App
die Kackle-App deployed
im Namespace Dev.
So, vielleicht habe ich aber auf meinem
kombiniertes Cluster noch mehr Environments
laufen. Dann würde ich sagen Helm
Install
Release. Wieder
das gleiche. Äh, nicht Release-Name.
Jetzt könnte ich
im anderen Namespace
jetzt wird er
sagen, okay, alles klar, passt.
List.
So. Das ist, dass man das
halt mehrfach deployen kann.
List.
Und sowas bringt der Standard nicht mit.
Was meinst du, mit welcher Standard?
Gibt es eigentlich den
Helm Delete
All oder sowas?
Wahrscheinlich nicht, oder?
Namespace Dev.
Namespace
Bots.
Jetzt haben wir das ganze wieder gelöscht.
Jetzt sind auch alle Bots wieder weg.
So, also das ist der Sinn
hinter Helm Charts.
So, und
nachdem ich ja nicht unbedingt wissen muss
wie genau
oder welche
Kubernetes-Ressourcen unter der Haube
generiert werden, aber ich trotzdem
vielleicht, also rein als Anwender,
ihr müsst euch jetzt vorstellen, ich habe mir irgendwie eine Software eingekauft,
die ich bei mir, oder
benutze ein Open-Source-Projekt,
was ich bei mir im GitHub Cluster
installieren will.
Da will ich ja doch vielleicht die ein oder anderen Sachen
customisen,
aber ich möchte mich
nicht damit rumschlagen, wirklich jede einzelne
Kubernetes-Ressource
und Config anlegen zu müssen von Hand.
Und dafür gibt es Value-Files
in Helm, die man überschreiben kann.
So, also
das hier sind jetzt quasi die Default-Values,
aber ich kann das ganze überschreiben.
Also entweder kann ich es direkt
im Value-File ändern, das macht man
aber meistens nicht, ja,
sondern man macht sowas hier,
äh, Values, sagen wir,
Values für die
Entwicklungsumgebung.
Und jetzt möchte ich, dass in
meiner Entwicklungsumgebung, äh,
drei Replikas
laufen von dem Pod, falls
auch mal was kaputt gehen kann.
So, es reicht übrigens,
wenn ich das so mache, also wenn ich nur das
reinschreibe, was ich
überschreiben will. So, und dann kann ich
sagen, okay, wenn ich das jetzt
installiere, dann, sagen wir mal,
ich mache jetzt eine Installation wieder in Def
von der Kackle-App, dann kann ich sagen,
Helm install,
das hier ist der Release-Name,
komm, wir geben dem Ding mal einen ordentlichen Release-Name
hier, keine Ahnung, äh,
MyApp oder so, ja.
Release-Name MyApp,
Create Namespace, im Namespace
Def wird das Ganze installiert und jetzt kann ich sagen,
Value-File,
ähm, Values
Def, und jetzt
wird er das überschreiben.
Jetzt wird er das installieren, nur,
ihr werdet es gleich sehen, Get Pods
und wir haben auf einmal drei Pods
laufen. Also ich hab das quasi
überschrieben, das hier sind die Default-Values,
aber jetzt hab ich das customised, ich hab
quasi die Werte angepasst
für die Installation, das ist quasi wie so ein
Option-File für den Installer,
hab ich jetzt quasi angepasst, ja, aber
ich möchte, dass, äh,
wenn ich das mit diesem Value-File, also quasi
für meine Entwicklungsumgebung installiere,
dann will ich aber drei Replikas haben.
Und wir könnten, wir können das jetzt
noch weiter treiben, wir kopieren jetzt mal
das Value Def zu Values,
nennen wir es mal Values,
Values Prod
zum Beispiel, und ich sag,
ja, Moment, aber,
äh, für mein Live-System will ich
zehn Replikas laufen lassen.
So, und jetzt kann ich das installieren,
Install, äh,
darf auch ruhig meine App heißen, jetzt installieren wir
jetzt aber im Namespace Prod
und nehmen als Value-File
das Prod-Yaml, und jetzt
werdet ihr feststellen, guckt mal da,
für die Produktions, äh,
also für die, für das Produktions-Deployment
von dieser App, haben wir jetzt
zehn Replikas laufen.
Also sind wir super krass ausfallsicher,
alles auf einem
Single-Node-Kubernetes-Cluster.
Aber ich glaube,
Chat, ich glaube, man gettet es, oder?
K8, äh,
K9S kenne ich,
ich glaube, wir haben es sogar installiert,
ich muss dir ehrlich sagen,
ich mach's trotzdem
lieber mit, mit Kubernetes,
äh, von Hand, per, per
kubectl auf der Command-Line.
Die wichtigsten Sachen kann ich
mittlerweile auch alle aus dem Kopf.
Sei es, oder ich hab mir
einen Cheat-Sheet gemacht, sei es jetzt den EXEC,
oder Logs für, für,
äh, Sidecar-Container und sowas.
Ja, ich kenne K9S, aber
bis jetzt hat sich mir der,
also, ja gut, wo es
ganz cool für ist, ist natürlich so eine Übersicht
über den Cluster, äh, wo ändert
man den Namespace,
äh, all,
ja, ja, da kannst du hier,
hast du hier so eine Übersicht über den Kubernetes-Cluster,
du kannst, glaube ich,
konnte man nicht auch irgendwo
eine Auslastungs,
so einen
Top anzeigen lassen, in K,
K9S
Top?
Ging sowas nicht auch irgendwie?
Äh, man kann aber auch ansonsten kubectl
Top, glaube ich, machen.
Äh, Pots.
Ach, Metric-API,
oh Gott, Alter.
Äh, Add-Ons.
Enable Metric-Server.
Äh, okay.
Warum geht der Metric-Server nicht?
Weil Brocken, oder was?
Okay, keine Ahnung.
Irgendwie ist es kaputt.
Muss ich das nochmal neu starten?
Minikube Stop.
Oder nochmal Start?
Nee, der Metric-Spot lief doch.
Der war sogar healthy, oder?
Oder habe ich mich eben verguckt?
Oh, nee, war er nicht.
Ha, der war noch nicht oben.
Deswegen ging es nicht.
Aha.
Das würde es natürlich erklären.
Kann man mit K9S auch mehrere
Kubernetes-Contacts verweilen?
Es gibt ein relativ gutes kubectl-Plugin,
um das zu switchen.
Also vermute ich auch mal.
Also eines der besten Plugins,
wo wir gerade dabei sind.
Komm, wir machen nochmal ein bisschen
Kubernetes-Commandline.
Ich zeige euch nochmal was Praktisches.
Und zwar...
Error running?
Ah, der Metric-Server ist noch nicht.
Guck mal, der ist noch nicht.
Der Metric-Server startet nicht.
Aber wir können auch sagen,
kubectl-n
kubesystem
logs
und dann hier auf den
Metric-Server.
Der scheint zu funktionieren.
Ich gehe mal
davon aus, dass der Pod jetzt auch ready ist.
Ja.
Ja, das ist halt...
Guck mal, der ist eigentlich sowas wie
H-Top.
Okay, dafür gibt es keine.
Egal, brauchen wir uns jetzt eh nicht zu interessieren.
Ja, das wollte ich euch nämlich zeigen.
Und zwar, es gibt für kubectl
ein paar ganz praktische
Describe-Nodes.
Ja, aber da sieht man glaube ich nicht die CPU-Auslastung.
Ich habe
eigentlich gehofft, man hätte vielleicht
so eine coole Anzeige.
Aber da gibt es Plugins für,
dass das schöne grafen und so auch macht.
Top-Nodes mag er
bei mir aber nicht.
Hä, warum ging das eben noch nicht?
Habe ich doch eben vorhin ausprobiert.
Das ist das, was ich eigentlich gesucht habe.
Das habe ich eben ausprobiert, da ging es noch nicht.
Da meinte er Matrix not ready.
Das ist das, was ich eigentlich machen wollte eben.
Ja.
Also es gibt für kubectl
gibt es
einen Plugin-Manager.
Der nennt sich Crew.
Man braucht den Plugin-Manager
nicht wirklich.
Man kann die Sachen auch von Hand hin kopieren.
Aber es ist insofern ganz praktisch.
Ich weiß gar nicht, ob ich installiert habe.
Wahrscheinlich nicht.
Nö.
Habe ich gar nicht installiert.
Und da kann man ein paar ganz nützliche
Plugins installieren.
Für sein kubectl.
Zum Beispiel Namespaces und Kontext-Switchen.
Das finde ich jetzt persönlich ganz nützlich.
Denn zum Beispiel,
wenn ich jetzt sage kubectl
oder besser am besten noch hin zu
aliasen übrigens
getpods, dann sagt der mir
nö, da gibt es ja keine pods, weil im default
Namespace gibt es keine pods.
Das heißt, ich müsste jetzt immer "-a"- hinten dran hängen.
Das will ich aber oftmals nicht,
weil mich meistens diese ganzen
Sachen in kubesystem und ingress
und so nicht interessieren.
Da gibt es ganz coole
Plugins für, dass man das relativ
easy switchen kann.
Man kann auch einfach den Namespace angeben
und sagen Namespace dev oder
Namespace prod und das geht ja sogar mit
Autocomplete. Also das ist gar nicht so wild.
Aber wenn man die Sachen nicht so genau
aus dem Kopf weiß, dann kann man sich zum Beispiel
Wie installiert man den
kubectl eigentlich jetzt offiziell?
Ah, obviously.
Wir copy-pasten es einfach.
Leute, ihr wisst,
immer Sachen
blind copy-pasten aus dem Internet.
Das ist einfach das Beste.
Excellent.
Das ist das Beste.
Kann nichts
schief gehen.
Achso, ich hab's sogar schon drinnen stehen. Ich hab's bloß nicht installiert.
Search.
Ja, da sind wir doch.
Alles wunderbar.
TMP, Helm.
So, da sind wir.
So, und jetzt können wir uns
ein paar Plugins installieren. Es gibt nämlich ein ganz
praktisches und zwar Search.
CTX heißt das, glaube ich.
Switch.
Für Namespace und CTX.
Das ist im Gleichen.
Ja, das meine ich.
Genau.
Das ist alles im gleichen Repo.
So, install
skubectl
plugin.
Genau.
Ja, ja.
So, und was man jetzt
machen kann, ist man kann sagen kubectl
ns
und da bietet ihr so ein
Quasi-Finder-Menü an.
Und das kannst du dann als Namespace
setzen. Da sag ich, ich will jetzt prod haben.
Dann steht hier da, ok.
Active Namespace ist prod. Und wenn ich jetzt
get pods ausführe, dann bezieht sich
das automatisch immer auf prod.
Oder ich kann sagen kubectl ns.
Ah, ne, mich interessiert eigentlich dev.
Und alle weiteren Kommandos, die ich ausführe,
die beziehen sich dann halt auf den
dev Namespace. So, und das gleiche gibt es
noch für CTX.
Und
da kann man jetzt alle
Kubernetes-Cluster, die man eingerichtet hat bei sich,
in der
in seiner
Config hier,
kann man den Kubernetes-Cluster auswählen.
Also, ich hab hier aktuell bloß
meinen lokalen Minikube eingerichtet und
einen Google Kubernetes-Cluster
mit dem tollen Namen GKE
KeklStream1.
Das heißt, wenn ich den hier jetzt
setze als Kontext und sage
get pods
minus a, dann würde ich mir jetzt die pods
von dem Kubernetes-
Cluster anzeigen lassen in Google Cloud.
Aber der Cluster läuft nicht mehr, den hab ich
mittlerweile schon wieder gelöscht. Also insofern
nehme ich meinen lokalen Minikube
und dann geht das auch wieder.
Oder ich sag wieder k set
Namespace. Ach, eigentlich interessiert mich hier bloß Sachen
in prod.
Und dann sag ich wieder pods und hab hier nur die prod pods.
Also, es gibt in der Tat tatsächlich
sehr nützliche Plugins.
Die haben bei denen auf der Seite
auch ein Ranking.
Naja, man kann es hier nicht richtig sortieren.
Das ist natürlich massivst
pp-gar.
Man kann sich das hier mal durchgucken.
So Plugins mit
300, 400 Stern plus.
Ob da ganz coole Sachen dabei sind.
Guck mal hier. CertManager hat
beispielsweise ein eigenes Plugin.
Cloudflare
ist jetzt egal. Cluster.
Coast ist auch cool, wenn man
Prognosen haben will. Gibt es ein paar
solcher Tools, wenn man Prognosen haben will.
Was das einkostet sein Kubernetes.
Kontextswitches für den Cluster.
Und sonst was.
Kann man sich mal angucken.
Was ich ganz praktisch fand,
was ganz wichtig ist. Tail.
Wobei
das mittlerweile
Logs
glaube ich von Hand
eingebaut kann.
Aber hier kannst du halt
aus mehreren Ports
hier von mehreren Ports
Logs tailen.
Und musst nicht nur von einem.
Also müsst ihr mal gucken. Gibt es wirklich viele
praktische Plugins.
Aber auch gefährlich,
wenn man denkt, man ist in einem anderen Namespace.
Ja, natürlich. Allerdings
du machst ja meistens kein
Delete oder sonst was. Du machst ja meistens
mit kubectl read commands.
Und dann ist das nicht
so wild.
Wenn du jetzt halt einen kubectl
apply-f für irgendeine Datei machst,
dann würde ich vorher schon mal
gucken, dass man im richtigen Kontext ist.
Ja, so sieht es aus.
Das ist übrigens
eine sehr gute Idee.
Exzellent. Da weiß ich gar nicht, wie man das
Das probieren wir jetzt mal aus.
Das interessiert mich. Und das ist enorm praktisch.
Ähm
kubectl, wie würden wir
das denn rausbekommen überhaupt?
kubectl ns
Ja, im Starship. Genau.
Wie würden wir das rausbekommen?
Wie bekomme ich raus,
in welchem Kontext ich gerade bin?
Oder in welchem Namespace
gerade gesetzt ist?
kubectl
Im Moment Kontext, aber nicht Namespace, oder?
config
current context
Nee, das ist Minikube.
Ich will current Namespace haben, falls es
sowas gibt. Aber das gibt es nicht, gell?
Ach, das kann Starship einfach
so schon, ja?
Aha, das probieren wir mal aus.
Die Frage ist nur, wie ich das
jetzt mache gescheit.
So wahrscheinlich, ja?
So? Wow.
Jetzt habe ich irgendwas
destroyed.
Und jetzt hier oben Kubernetes reinschreiben noch.
Das hat aber nicht so wirklich
funktioniert, ne?
Aber woher kann das
denn Starship
überhaupt?
starship
rs
config
kubernetes
Ja, übertreibt halt mal.
Namespace
Disabled gleich falls. Hä?
Achso, ja.
Ah! Ja, praktisch.
Sehr gut. Nice.
Ich meine, wir sollten vielleicht
mal ein bisschen
Das sieht ja schon ein bisschen kacke aus
an der Stelle jetzt.
So.
Dann sagen wir ihm jetzt hier
Style, was ihn nicht juckt.
Warum juckt ihn mein Style nicht?
Ah, weil
hier
Context Namespace und hier muss
und hier muss dann quasi der
Style
rein. Dollar
Style. Cool.
Sehr schick. Das gefällt mir.
Das hat was.
Das ist nice. So, jetzt brauchen wir noch ein cooles
Symbol dafür. Symbol.
Symbol, Kontext.
Da kommt noch irgendwas davor.
Okay, so jetzt brauchen wir
ein ordentliches Symbol dafür.
Ähm.
Power
Line
Icons
Search
Ja, das meine ich.
So. Gibt es da irgendwas
Gescheites für
Kubernetes oder Container?
Hallo?
Öffnen, please.
Kubernetes
Ey, tatsächlich.
Container
Hm.
Docker
Dann haben wir das Kubernetes-Symbol
und gucken wir
mal, ob mein
Ja!
Mein Font kann das sogar.
Guck mal, schon haben wir ein Kubernetes-Symbol
hier vorne. Es sieht aber schon ein bisschen
kacke aus, ne?
Das erkennt doch niemand, dass das ein
Package ist. Wir brauchen irgendein ordentliches
Symbol.
Habt ihr eine Idee,
was es für Container geben
könnte? Irgendwas Gutes?
Docker?
Helm? Ne, glaube ich nicht.
Aber es hat ja mit Helm gar nichts direkt
zu tun. Vielleicht machen wir
wirklich den Docker-Fish hin?
Aber ich meine,
das ist aber eigentlich okay so.
Da weiß man schon Bescheid.
Ja, cool. Ne, das
finde ich gut. Das finde ich richtig gut.
Ne, das
gefällt mir. Das gefällt mir. Guck mal.
Jetzt haben wir sogar die Anzeige,
welchen Cluster wir als
Kontext haben und in welchem
Namespace wir sind. Checken wir mal.
kubectl ns. Switchen
wir mal auf Dev.
Oh, da steht Dev. Das ist sehr nice.
Chat-FiFat-Idee. Gefällt mir richtig gut.
Mein, wie würdest du diese
Aufgabenstellung interpretieren?
Raspberry Pi als Kubernetes
Master parametrisieren
zusätzlich drei
Ubuntu-Maschinen, die er verwalten kann.
Die meinen, dass du einen
vier
vier Node-Cluster
machen sollst und ein Node
davon ein Raspberry Pi
ist? Oder
meinen die, dass der Raspberry
Pi quasi der
RP-Node ist?
Und dass du
Ach, das meinen die. Ja, das
meinen die. Okay, jetzt
hab ich's gecheckt. Du sollst den Raspberry
Pi als RP
Node einrichten und
drei Ubuntu-Kisten als
Worker-Nodes, oder?
Vermute ich mal. So was
in der Richtung.
So was. Ja, ja, ja. Okay.
Ja, das ist vielleicht ein bisschen blöd geschrieben.
Ich hab's auch erst nicht gecheckt, aber
so was wird es sein.
Ja, das wird es sein.
Aber soll ich die Ubuntu-Maschine
auch aufsetzen?
Naja, wenn du
keine hast, würde ich
das schon mal da rein interpretieren.
Weil du kannst ja schlecht
einen Cluster machen mit drei
Ubuntu-Worker-Nodes, solange du keine
Ubuntu-Kisten hast, oder?
Also irgendwo müssen die ja herkommen.
Also
da würde ich nochmal nachfragen,
was er eigentlich will.
Aber ich würde sagen, ja, die musst du
auch aufbauen, weil
die materialisieren sich ja nicht einfach
so. Chatge.
So, aber so viel
zu meinen bisherigen hier Helm-
Ausführungen.
Ich glaube, man hat das soweit verstanden.
Auch mit den Value-Files und dem
Überschreiben. Wisst ihr, was
das Coole ist? Ich dachte, ich
müsste jetzt theoretisch ein Helm-Chart
komplett from scratch erstellen.
Aber wir haben ja hier auch ein ganz gutes
Beispiel.
Also mit dem
mit dem Default
Hello-World-Node.
Was deployen die da eigentlich?
Gucken wir mal kurz rein. Die machen
Image
Image
Repository, Value-Tag
Chart-App-Version
Ja, Nginx.
In Nginx deployen die da.
Der dann im Endeffekt sowas wie Hello-World
sagt wahrscheinlich.
Ja, verstehe.
Okay, Leute, ich glaube,
das müssen wir uns an einem anderen Tag nochmal
gesondert angucken. Ich merke gerade, dass ich keine
keine freien
Hirn-Kapazitäten mehr habe, mich
im Detail der Sache zu widmen. Aber ich glaube,
so als kleine Übersicht war das heute gar nicht
schlecht.
Was passiert denn eigentlich gerade im Hintergrund?
Nix, okay.
Wir haben jetzt ja auch schon
einen Chart mit einer Demo-Anwendung.
Was ich noch gucken
wollte ist folgendes.
Gibt es gescheite
oder gibt es gute
Visual Studio
Code-Plugins
dafür?
Was dir auch ein bisschen
Autocomplete bietet.
Okay, Moment.
Habe ich schon installiert?
Anscheinend.
Aber wenn ich hier jetzt irgendwie Template-Syntax
machen will,
checkt der dann was?
Tatsächlich?
If?
Ja, okay.
Okay. Auch wenn ich
diese Go-Template-Syntax
total abartig finde.
Gibt es denn ein
Autocomplete von
.values? Ey, guck mal da.
Ey, das ist ja richtig gut.
Das ist ja richtig angenehm.
Was habe ich denn da für Plugins installiert,
dass das geht?
Was habe ich denn, zeig mal her.
Project Manager, wer braucht denn
sowas, Alter?
Also den Project Manager, der kommt auf jeden Fall
wieder weg, den braucht noch wirklich niemand.
Was habe ich denn für Plugins installiert, zeig mal her.
Terraform,
Kubernetes, okay.
Ist das Helm-Plugin in
Kubernetes schon dabei?
Das ist ja sehr nice, das gefällt mir.
Das wusste ich gar nicht.
Pog, easy.
Und sogar
halbwegs
guck mal, sogar gescheite
halbwegs gescheite Autocomplete.
Das ist doch praktisch.
Praktisch.
Aber man muss schon sagen, Leute,
die Helm-Syntax, also
die Go-Template-Syntax ist schon
echt
zum Kotzen, oder?
Das sieht schon echt
eklig aus.
Und da hilft das Syntax-Highlighting auch nur
beschränkt.
Nee, das ist abartig.
Chatge, komm,
wir gucken uns noch die ein oder anderen
Sachen auf YouTube an.
Meine Hirn-Kapazität reicht nicht
mehr aus heute, um mich damit zu beschäftigen.
Was haben wir denn
hier, was gucken wir uns denn
mal an?
Devops is terrible.
Hat einer im Chat vorgeschlagen,
dass ich da drauf reacten soll.
Das heißt, nur wenn ich das
jetzt richtig verstehe,
ihr wollt, dass ich auf eine Reaction
reacte, ja?
Verstehe ich das richtig?
Hi Max, spielst du Diablo 4?
Nee.
Ich bin immer noch am überlegen, ob ich es mir kaufen soll.
Ich glaube, ich werde es mir kaufen,
wenn es die
erste Season gibt,
die Kinderkrankheiten
mehr oder weniger weg sind, wobei es ja erstaunlich
gut läuft.
Und ich weiß, ob sich das langzeitmäßig
lohnt, dass man es eine Weile spielen kann.
Ich weiß nicht.
Blizzard hat mich so enttäuscht die letzten
Jahre über, ich bin echt ein bisschen
zurückhaltend,
jetzt das Game zu kaufen.
Außerdem habe ich wahrscheinlich eh keinen Bock
auf drei Wochen non-stop grind,
weil ich weiß, wenn ich so ein Game erstmal
anfange, dann höre ich auch nicht auf.
Ich persönlich freue mich
viel mehr auf Path of Exile 2.
Mal gucken, ob das irgendwann
rauskommt.
Morgen kommt Final
Fantasy 16.
Ja, das hätte ich komplett
vergessen, aber ich habe heute am Hauptbahnhof
auf einem
Display Werbung dafür
gesehen.
Final Fantasy 16
ist doch in guter Alter Final
Fantasy Tradition.
Hat nichts mit Final Fantasy 15
zu tun, oder?
Weil was mich ultra verwirrt
hat ist,
dass
der Dude hier irgendwie
aussieht ein bisschen auf dem Cover
wie der Final Fantasy 15 Typ.
Ja, ich weiß, die sind immer eigene
Story, aber das hat mich ein bisschen verwirrt, weil die sich so
ähnlich aussehen, so ähnlich gesehen haben.
Battlefield 3 ist
nichts, was abgeschaltet wird.
BC2 ist Ende des Jahres weg.
Danach kommt wahrscheinlich echt Battlefield 3.
Das Schöne ist, dass BC2 nie
sterben wird, weil du Custom Server hosten kannst.
Und den BF3 mittlerweile auch.
Okay Leute, ich muss mir nochmal kurz
was zu trinken holen.
Und dann
we made a huge mistake.
Haben sie mal wieder einen Server
runtergeschmissen und beschweren sich jetzt drüber,
dass sie Datenverlust haben.
SSST.
Clan Tumulte in Essen.
Was ist da wieder los?
Chat, ist heute
irgendwas passiert in der Welt,
was man missen müsste?
Ich habe nichts mitbekommen. War heute irgendwas?
Außer, dass...
Doch, eine Sache habe ich tatsächlich
mitbekommen.
Da weiß ich aber nicht, was da schon wieder abgeht.
Dass irgendwelche Rammstein-Konzerte in Berlin
verboten werden.
Dass Leute eine Petition gestartet haben,
dass Rammstein-Konzerte in Berlin
verboten werden. Das habe ich
vorher in irgendwelchen Nachrichten gehört.
Aber ansonsten habe ich
heute nichts mitbekommen. War heute irgendwas?
Morgen ist Nintendo Direct.
Okay, ja.
Juckt mich jetzt nicht so groß.
Ich gucke mir da wieder die Zusammenfassung an.
War heute irgendwas Spannendes?
Glaube nicht.
Ach doch!
...
...
...
...
...
..
...
...
...
...
...
30.000
30.000
...
Hat er gelöscht oder wie?
Das ist doch noch gar nicht so lange her, wo der On war.
Ja, zuletzt vor elf Tagen, ja.
Keine Ahnung,
warum man die gelöscht hat.
Okay.
Auf geht's. Also, was gucken wir uns jetzt an?
DevOps is terrible.
Ja, DevOps schlecht gemacht ist auch tatsächlich terrible.
Und
eigentlich ist es ja an der ursprünglichen DevOps-Idee vorbei,
wenn man sagt, man gründet eigene DevOps-Teams.
Die Idee dahinter ist ja eigentlich,
das Wort,
also, dass auch das Entwickler auch den Betrieb ihre Anwendung machen.
Das ist ja die ursprüngliche Idee dahinter.
Nicht so sehr, dass man sagt, ah, wir setzen jetzt zwei Leute hin und das sind
unsere DevOps-Leute. Aber gut,
letztendlich ist es egal, so hat sich das in der Industrie halt nun mal durchgesetzt.
Von der ursprünglichen Idee ist ja auch was Agilität angeht und so nicht mal
viel übrig geblieben.
Also.
Boah, ich halte es nicht aus. Der ist immer so super energiegeladen und
so
Energy Drink vollgepumpt. Ich glaube, ich kann mir das, das halte ich heute Abend
nicht aus.
Type one in the chat, if you think DevOps
is bullshit.
Okay, we got a lot of ones in the chat.
Die Leute wieder.
Ja, das stimmt, das stimmt.
Ja,
weil,
ja, wenn man ein DevOps-Team,
richtig,
exakt das ist, exakt das, was ich gerade gesagt habe, was der Typ schreibt. Aber
ich meine,
das ist insofern auch Realitätsverweigerung,
weil es hat sich halt nun mal so durchgesetzt.
Es ist egal, ob das vielleicht der ursprünglichen Idee nicht mehr folgt.
Das gibt es heute, das wird heute halt so genannt.
Es ist doch egal,
ob der beim DevOps-Team jetzt eine neue Datenbank beantragt oder beim
Cloud-Plattform-Team oder beim Admin-Team oder sonst was.
Wollen wir uns nicht einfach den Blog-Post angucken?
What the fuck?
Ja, das ist mir zu energiegeladen, das kann ich mir heute nicht angucken.
Es ist mir zu anstrengend.
Haben wir nicht noch irgendwas Entspannendes?
Ah, ich weiß nicht. Leute, mein Hirn macht heute nicht mehr so viel mit.
Ich gehe jetzt auf.
Guck mir noch irgendwie eine Stunde irgendein Video an oder so und dann gehe ich
pennen.
Ne, ne, passt schon.
Ich gehe jetzt, Leute. Macht's gut. Bis dann. See you.
