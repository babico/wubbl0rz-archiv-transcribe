mega pock exzellent wir müssen aufpassen und zwar ich habe hier das handy von der
arbeit liegen weil es kann sein dass ich angerufen werde bis montag früh 37 kann
das noch sein oder 7 uhr ich glaube 37 kann das noch sein weil ich habe ich
habe dieses wochenende wieder passives einkommen ist ja der neueste trend
überall 200k passives einkommen im monat der nur hier aber ich habe wirklich
passives einkommen wobei so passiv ist das gar nicht so passiv ist das gar
nicht ich wurde heute morgen angerufen und morgen wurde ich angerufen
wegen der das kann ja nicht so genau nicht sagen wegen wegen einem
umschreiblichen ist jetzt am besten so pass
wo zink system was nicht funktioniert hat und irgendwie leute wollten
wartungsarbeiten am wochenende machen aber das ging nicht weil das aus
irgendwelchen gründen irgendwie alle keine berechtigung mehr hatten und ich
habe keine ahnung von dem system und ich kann ja auch nicht alle alles
bekehren die waren ich habe dann glücklicherweise den erreicht der plan
von hat dann easy als gefixt dns nein ein passwort zink was vorzügen
Ob ich sie laut hier?
Passwort-Sync.
Guck mal, ich hab das auf
20% Volume runterstellen, oder was?
Zu leise.
Boah, so ist gut.
Excellent ist das.
Excellent.
Nein, das war kein DNS-Problem.
Ja, der Spruch, der ist schon
seit ein paar Jahren irgendwie outdated,
overrated, cheap-baited.
Ich weiß nicht, ob man wirklich pauschal
irgendwie sagen kann, was so
die Probleme sind.
Aber DNS ist erstaunlich selten
in letzter Zeit dabei.
Weil ich kenn natürlich den Spruch.
Ich würde sagen,
eigentlich ist es eher ein Komplexitätsproblem
in der heutigen Zeit.
Weil es überall tausend Sachen gibt
und keiner mehr wirklich den Überblick hat
über alles, was ja auch gar nicht mehr geht.
Alright.
Was ihr startet erst, warum startet ihr erst im Dezember?
Also ihr startet jetzt
allgemein im Dezember?
Oder ihr macht immer nur im Dezember?
Also, oder ihr fangt jetzt halt
neu an, was die Firma
sich jetzt ausgedacht hat. Ab Dezember geht's los.
Also ihr habt das quasi dann auch das nächste
Jahr über. Muss mal kurz Update machen.
Hogu.
So, soll ich euch
nochmal sehr, sehr
nice Sachen sagen? Sehr
extremely nice.
Und zwar
zwei Sachen.
Zwei Sachen. Excellent.
Excellent. Zwei Sachen.
Das erste ist, ich hab jetzt
Moment, ich muss mal kurz meine Zeit ein bisschen richten.
So, muss besser.
Ich hab jetzt Urlaub.
Quasi ab gestern.
Bis Januar.
Wobei das noch nicht so
ganz stimmt.
Weil streng genommen hab ich noch
Bereitschaft bis Montag.
Und Dienstag und Mittwoch
haben wir nochmal ein
Team-Building-Workshop auf der Arbeit.
In irgendeinem Hotel hier
in der Nähe.
Da wird dann zwei Tage
wahrscheinlich wieder ganz tolle Spiele
gemacht, auf die alle wahnsinnig
Bock haben. Ihr kennt sowas, ja?
Und dann
war's das aber für mich. Das ist richtig
weird, Cem. Immer mal gucken.
Mal gucken. Ich werd mich
zunächst zwingen lassen, wenn ich gar
keinen Bock drauf hab. Aber
ich mein, das muss ja auch nicht so schlimm sein.
Aber meistens, wenn man sich denkt, das muss ja nicht
dann ist es auch. Dann ist es auch schön. Montag, Dienstag,
stimmt übrigens nicht, was ich erzählt hab.
Dienstag, Mittwoch ist das ja.
Aber gab es keine... Achso, okay.
Ihr fangt jetzt quasi direkt damit an.
So. Warte mal.
Ich wollte euch ja noch was erzählen. Achso, ja. Und eine
Sache, die ist wahrscheinlich nicht so gut für... Doch,
drei Sachen. Drei Sachen kann ich euch erzählen, ja?
Also das erste ist...
Das erste hab ich ja schon erzählt.
Urlaub jetzt bis Januar.
Das zweite ist, ab
2. Dezember mach ich den
Ultra-MMO-Kreisel-Crind wieder.
Ihr kennt mich immer, wenn irgendwelche
privaten Server rauskommen, muss ich irgendwie mal
ein paar Monate krassen MMO-Kreisel-Crind
machen.
Das Game spiel ich halt schon seit
20 Jahren. Und das muss
immer mal wieder so
einmal im Jahr oder
so. Und dann wieder für ein paar
Monate muss ich krassen
Kreisel-Crind machen.
Und das zweite ist... Ach nee, das dritte.
Das dritte ist,
Dezember mach ich wieder viele Videos.
Ich hab mir jetzt auch ein bisschen überlegt.
Ich mein, nachdem ich ja mit Gaming
ja in letzter Zeit wirklich gar nicht mal so viel
am Hut habe, dass ich da zu groß was sagen könnte.
Ja, und ich weiß, dass
sagen wir mal, viele Leute
über das Gaming zwar zum Channel gekommen sind, aber
mittlerweile auch sich für viele andere Sachen
interessieren. Deswegen hab ich mir gedacht, ich werd
mal so ein paar allgemeine Themen
abarbeiten. Also zum Beispiel,
muss ich euch endlich mal meine Bewerbung zeigen.
Die hab ich euch ja schon seit
einem Jahr oder so gesagt. Ich zeig's euch mal. Hab ich ja noch nie gezeigt.
Dann könnt man sich
mal über so Sachen unterhalten, wie
ob Open Source
wirklich sicherer ist oder ob's auch
Kack Open Source Sachen gibt. Dann
könnte ich eine... Hab ich mir überlegt,
was auch immer bei Videos recht beliebt ist,
so Tierlists zu erstellen.
Ich wollte mal eine Linux-Distribution
Tierlist machen. Das machen wir wahrscheinlich im Stream zusammen.
Und dann frag ich den Tyler,
ob er das zusammenschneidet.
Ja, ich wollte mich mal
so ein paar allgemeinen Themen widmen,
die vielleicht nicht so sehr mit Gaming
zusammenhängen im Dezember.
Was? Du darfst eine Schulung zu ISO?
Was zum... Wie viele von diesen
Kackdingern gibt's denn eigentlich? Okay, ISO
2, 1, 4, 3
2, 1, 4, 3, 4
Road Vehicle
Cyber Security Engineering
What?
Cyber Security... Eine Norm
zur Cyber Security in Kraftfahrzeugen.
Was es nicht
alles gibt, ey.
Was es nicht alles gibt, ey.
What the fuck? Ja, beste, ne?
Leute, ich bin mal gespannt.
Ich bin mal gespannt. Also, ich hab mir...
die letzten Monate über
so ein paar Punkte aufgeschrieben,
die ich sehr sinnvoll fänden würde,
wenn man die mal diskutiert
zum Teambilden.
Ja, zum Beispiel, was
Komplexitätsreduzierung angeht
oder dass viele quasi nur vor sich hin
basteln und ihr eigenes Ding machen
und sowas.
Man könnte sicherlich die Zusammenarbeit
oder zum Beispiel, dass während man
eine Besprechung hat und man mit
Leuten redet, die nicht
halt mit dem Kopf AFK sind und was
anderes machen, was ich ja auch teilweise,
was ich auch gefühlt immer mache, ja.
Also, es gibt sehr viele Sachen, die man machen könnte,
um die Zusammenarbeit zu
verbessern. Ich fürchte aber,
dass für die wirklich wichtigen Sachen
auf diesem Teambuilding-Workshop, zumindest,
wenn ich mal davon ausgehe und das
vergleiche mit den Teambuilding-Workshops, die ich schon
die letzten Jahre über ab und zu mal gemacht hab,
dass für die wirklich wichtigen Dinger,
die tatsächlich was bringen würden,
eigentlich gar kein Platz ist, dass es
dann eher um so bescheuerte Spiele geht,
wie wir machen eine Schnitzeljagd im
Wald oder sowas.
Was war das
dümmste, was ihr mal machen musstet
auf so einem Teambuilding?
Also, mir fallen zwei Sachen ein.
Mir fallen zwei Sachen ein.
Das erste ist Sport.
Ja, das ist doof. Ich werde übrigens,
nachdem das so ein Hotel ist,
da ist auch
ein See und sowas in der Nähe
und so, da werde ich morgens mal meine
5-6 Kilometer um den See rennen. Mal gucken,
ob ich dann morgen früh oder morgens,
bevor es losgeht.
Zumindest, okay,
jetzt wurde ich
abgelenkt von der Seite.
Also, genau.
Also, zwei Sachen,
die mir so im Kopf hängen geblieben sind,
die richtig dumm waren bisher
bei Teambuilding-Workshops, die ich schon mitgemacht hab.
Das erste war irgendwie so,
war tatsächlich auch so eine Art Sitzkreis
und da musste man Dinge beschreiben.
Aber ohne, dass du es
sagen durftest.
Kennt ihr dieses Spiel,
wo die Leute sich,
so Dinge auf die Stirn kleben müssen
und wurde dann,
quasi raten musst, welcher Promi man ist
und sowas. Übelst dummes Spiel, hab ich nie gerne
gespielt. Aber sowas in der Richtung,
sowas in der Richtung war das. Nur, dass man
dort Wörter bekommen hat,
sowas wie Baumstumpf.
Baumstumpf.
Und da musstest du quasi durch,
du durftest auch noch mehr machen. Also,
du musstest das erklären
und du durftest das auch zeigen.
Ja, also du durftest dann quasi
so auf der Erde so einen Kreislauf,
so drum kreisen. So, und
du durftest quasi erklären und zeigen und
die anderen mussten dann raten,
was du führen wolltest.
Ultra dumm, wie auch immer. Also, das hat
tatsächlich das Team gebildet. Das hat das Team
gebildet in der Form, dass es alle kacke
fanden und alle einstimmig dagegen
waren. So kann man ja auch Teams bilden.
Ja, das ist ja auch okay.
Also, die dummen, teambilligen Sachen,
die ich da damals beim Provider machen
musste, wo ich euch, wo ich mal ein Video
drüber gemacht hab, die Last-Race-Projekt. Und das andere,
das andere, Leute, ihr lacht euch,
ihr lacht euch jetzt. Das ist so dumm
gewesen. So dumm. Die hatten mal
dort,
die hatten mal vom
Ulmer
vom Ulmer Schauspielhaus
oder so, hatten die mal irgend so einen Team-Building-Typ.
Keine Ahnung, warum die da sowas haben.
Zumindest,
der hat mit uns Sprechübungen gemacht und die
waren so unglaublich dämlich.
Man sollte sich, also man
sollte sich wegdrehen gegen die Wand.
Ja, also da haben sich quasi
alle, die sich vorher angeguckt haben, rumgedreht
gegen die Wand. Und dann sollte man,
ich hoffe, mein Mikrofon macht das jetzt mit.
Ich hoffe, mein Mikrofon pickt das ab, richtig.
Du solltest dich umdrehen,
an die Wand stellen, deine Hände
es ist eins zu eins so gewesen, ja.
Du solltest deine Hände an die Wand
legen und dann solltest du
gegen, dann solltest du gegen die
Wand machen.
Das war so dumm, Alter.
Das war so dumm, Mann.
Das hat das mit
Kaufplatz zu tun.
Und das haben die uns damals,
das haben die uns als Teambuilding verkauft.
Ich meine, das einzig Gute war auch wieder,
wir haben es alle gemeinsam abgelehnt
und deswegen hat das
das Team gebildet, okay.
Nein, das war, das war irgendwie
irgendwie so ein Schauspiel-Drehen
oder so, der wollte mit uns Sprechübungen
machen. Du musstest dich, aber das war wichtig,
war wichtig, du musstest die Hände
auf die Wand legen und dich dann
und wir haben dann halt immer gesagt, so nach dem
Motto, wir spucken jetzt die Wand,
an oder wie. Wo solltest du denn
wirklich an die Wand gehen und machen?
So dumm, Mann.
Aber es war, es war so
unglaublich dumm, dass man es sich gemerkt hat.
Mikronavi, danke schön
für den Zapf.
Also so dummes Zeug merkt man sich.
Ich hoffe, ich hoffe,
dieses Teambuilding nächste Woche,
da bei uns, da wo ich jetzt bin,
das wird nicht ganz so blöd.
Oh Mann.
Ja, ihr habt bestimmt
auch schon dummen Teambuilding-Kram mitgemacht,
oder?
Ich gehe von aus, Chatke,
ich gehe von aus.
Also ich gehe von aus,
jeder hat schon mal ultradummes
Teambuilding mitgemacht. Und wisst ihr,
ich frage mich bei dieser ganzen
Teambuilding-Geschichte immer,
mach mal kurz hier meinen ganzen Krempel an,
also ob das Absicht ist,
dass die so dumm sind, oder
ob man wirklich denkt, das bringt
was. Also,
es könnte ja auch sein, dass das absichtlich so
dumm ist, dass die Leute, wie gesagt,
sich einig sind, dass es dumm ist
und quasi gemeinsam an
einem Strang ziehen, weil sie es
dumm finden. Das könnte ja auch sein.
Ich glaube, das ist
zu high IQ und zu weit gedacht, ehrlich
gesagt, dafür.
Glaube ich dann doch nicht,
irgendwo.
Echt.
Verrätst du uns, was
Schlimmes gewesen ist?
Ihr musst zu Beginn einen Partner
aussuchen und ihn fragen,
haben die auch bisher Lieblings-Eins von anderen?
Oh nein!
Das ist, oh, das sind auch so Dinger,
ich hasse solche Sachen, Alter,
ich hasse. Zumindest, ich hab mir
eine Punkte, ich hab mir so eine Liste gemacht,
da sind, glaube ich, mittlerweile zwölf Punkte drauf
oder so, wo ich glaube,
wenn man sich da mal drüber unterhält,
das würde wirklich was
bringen und die Zusammenarbeit
verbessern. Da bin ich
stark davon überzeugt, dass es wirklich was
bringen würde, wenn sich alle mal wirklich
da um ein paar Sachen Gedanken machen
würden und eventuell versuchen, sich ein
bisschen zu entgegenzukommen. Aber ich glaube
nicht, dass es um wirklich essentielle
Sachen da
gehen wird. Gib mal die Liste,
die hab ich. Also erstens hab ich die nicht hier
auf dem Account und zweitens
kann ich euch die auch nicht zeigen.
Ich bin mal gespannt,
ich bin mal gespannt, wie blöd es wird.
Vielleicht wird's auch gar nicht so blöd. Man sollte
sich ja die Option wenigstens offenhalten,
dass es nicht so doof wird. So, ich pull
mal kurz Shit up.
Neuesten Changes.
Changes Pult.
Ja, es macht
nix übrigens, wenn ihr die letzten Streams
nicht dabei gewesen seid. Wir werden
heute ein bisschen was anderes machen. Also ich meine, wir
benutzen die gleiche Anwendung weiter, aber
wir werden heute das machen, was ich die ganze Zeit machen wollte, nämlich
endlich Videos in Browser streamen
vom Server aus.
Was? Wie soll ich das verstehen? Deine Firma
wird bald Teambuildings
anbieten. Ja, da bin ich mal gespannt.
Kannst du im Chat ja mal ausprobieren.
Wenn es im Chat klappt, dann ist das
...
...
... alltagstauglich.
So, den Kram hier an ... Oh, was ist jetzt
los hier?
Aha, aus irgendwelchen Gründen geht's wieder. So, Rust.
Rust Idee starten.
Oh, haben die ein neues Bild oder sah das schon immer so aus?
Moment, Zack.
Soll ich vielleicht mal den ganzen Krempel aktualisieren?
Java-Zeug. Java-Zeug zieht einfach mal wieder
300% CPU.
Updating. Okay, ja, ich hätt's vielleicht mal
updaten sollen.
Ich mach's manuell.
Manuell.
Ohne, ohne Binding-Generator.
Es ist ja auch nicht so viel.
Es sind irgendwie
acht verschiedene Funktionen, die ich aufrufen
muss. Das reicht für WebRTC.
Habt ihr auf
Windows auch immer so Probleme mit
Docker-Desktop?
Keine Ahnung. Ich würde im Traum nicht drauf kommen,
Docker auf Windows zu benutzen.
Das ist wahrscheinlich das erste Problem, was du hast.
Es gibt so ein paar Sachen, da hätte ich echt
keinen Bock drauf.
Gibt's noch Black Friday Shopping? Nee.
Nee. Also, vielleicht, vielleicht
morgen Abend oder so, weil es ist ja
Montag ist ja auch nochmal, ne?
Montag ist ja Cyber Monday wahrscheinlich wieder.
Müssen wir mal gucken. Vielleicht, vielleicht machen wir
noch eine Runde. Aber
ich weiß nicht, also
ist
ich hab keinen Bock, mich
jibbelten zu lassen, deswegen kauf ich einfach nix.
So, jetzt hat er hier geupdatet.
Gibt's, gibt's Updates für die
für die IDEs oder sowas?
Nee, okay, passt. Nice. So, Rust
am Start. Da müssen wir noch ein bisschen
Visual Studio Code aufmachen. Wir haben ja hier
Multilingual
Cross-Plattform-Technology
High IQ
Anwendung am Start.
Und dann zeige ich euch mal
kurz, was es aktuell macht.
Dann werdet ihr feststellen, das ist
Extremely Pog
und alle gleich subscriben
und followen.
So, Backend.
Müssen wir starten.
Hier brauchen wir noch ein Terminal.
Äh, Rust.
Das
kompilieren wir noch mal schnell.
Äh, nicht mit
Go. Cargo.
Jawoll.
Bild, weil ich hab auch an der ganzen Rust-Geschichte
noch was geändert. Also
Ground-Breaking-Application
werdet ihr gleich sehen.
Auf jetzt. Guck mal hier.
500% CPU-Last.
Was treibt es denn?
Oh, fertig. Okay.
Nice. So, ich hoffe, ich hab nix kaputt
gemacht. Das funktioniert noch.
Net. Run.
Okay, sieht schon mal gut aus.
Also, folgendes.
Das ist die Anwendung.
Absolut Ground-Breaking.
Ich glaub, sowas geiles habt ihr noch nicht
gesehen. Äh, wie ging das
nochmal bei WebRTC-Logs?
Äh, nee.
Einfach nur WebRTC?
Nee, WebRTC
Internals?
Ja, Internals.
Aus irgendwelchen Gründen hab ich
zwei Verbindungen, die ich nicht checke,
woher die kommen, aber okay.
So. Also, das ist
die aktuelle Anwendung. Ihr müsst nichts mitbekommen
haben von dem, was...
Okay.
Ihr müsst nicht wirklich was davon mitbekommen haben, was wir das letzte
Mal gebaut haben. Ich werd's jetzt
ganz kurz nochmal erklären,
damit man der Sache grob
folgen kann. Und ja,
ich sag's jetzt gleich. Zumindest
werden wir uns heute um das Streamen
von Videos in den Browser kümmern.
Wie lange
hat es gedauert, den ursprünglichen Go-Code
zu schreiben? Das ging relativ schnell,
weil, weiß ich nicht,
so ein...
zwei Stunden oder so.
Weil ich kenn die Library schon und ich hab
sowas ähnliches... Wir haben sogar sowas ähnliches schon
am Stream zusammen gemacht vor ein paar Jahren.
Das ist tatsächlich nicht sonderlich kompliziert
gewesen, das in Go zu basteln.
Also.
Ja, also was
das machen soll, ist folgendes.
Ich hab einige Webcams
bei mir. Wie sieht deine
CPU-Prozessor-Konfiguration in VMware aus?
Äh...
Vier... Vier... Oder acht...
Acht Kerne.
Acht Cores.
Und...
24 GB RAM.
Also so hier sieht das aus.
Number of Processors, acht Cores.
Standardmäßig
macht VMware acht.
Und da unten eins.
Merkwürdig, warum auch immer.
Das hab ich an, dass ich nested-Virtualisierung
machen kann.
Euren Max.
Community.
Ist am Start.
Dann hab ich 256 GB SSD.
Und ich glaube...
Warum auch immer
acht Gigabyte Grafikspeicher?
Macht überhaupt keinen Sinn.
I3 ist auch zufrieden mit 256 MB.
Das braucht keine acht Gigabyte.
Aber wisst ihr was?
Ich hab ja so viel RAM, dass ich gar nicht weiß, wohin damit.
Deswegen einfach RAM.
Beste.
Ah.
Und ihr wisst doch, unbenutzter RAM ist verschenkter RAM.
So, also was soll das Ganze machen?
Ich werd das kurz mal zeigen.
Irgendjemand hat das doch gefragt.
Hier.
Also, ich hab...
Jetzt hab ich mit dem Finger gegen das Headset gehauen.
Ich hab eine...
Wobei, eine, stimmt.
Ich hab acht Kameras bei mir im Haus.
Und...
Die Kameras sind erreichbar über RTSP.
Und streamen über H264.
Ja, acht Stück.
Heiß Security.
Wobei, lass mal zählen.
Mal gucken, ob das überhaupt stimmt, was ich hier erzähle.
Also.
Eine am Eingangstor.
Eine vorne im Hof.
Eine hinten im Hof.
Eine im Keller.
Eine im Flur.
Eine oben da, wo die Katze immer rumgammelt.
Nee, Leute.
Es sind nicht acht.
Ich glaub, es sind nur sechs.
Ja, ja.
Wenn ich jetzt irgendwas vergessen hab, sind es, glaub ich, nur sechs.
Ja.
Also, wenn ihr einbrechen wollt, wisst ihr jetzt, wo die Kameras sind.
Keck, wait.
So.
Und...
Die Kameras, die will ich streamen in den Browser.
Das Problem dabei ist nur...
Das ist übrigens extrem underrated, find ich, das Emo.
Ich find das geil.
Ich weiß auch nicht, warum.
Aber es verwendet kaum einer.
Also.
Das Problem ist,
dass man Kameras nicht einfach in den Browser streamen kann.
Das funktioniert nicht.
Weder...
Weder kann der Browser RTSP,
noch kann der Browser irgendwie...
Ja, pff, solange es ein Decoder drin ist.
Noch kann der Browser ordentliches Realtime-Video über RTSP von der Kamera.
Also, das funktioniert nicht.
So.
Deswegen gibt es verschiedenste Varianten, wie man das machen kann.
Video-Streaming in den Browser.
Die allereinfachste Variante ist wahrscheinlich...
ähm...
HLS.
HLTP-Live-Streaming.
Das ist das, was Twitch auch macht, wenn ihr nicht, glaube ich zumindest,
wenn ihr nicht den Latency-Modus, Low-Latency-Modus bei Twitch aktiviert habt.
Wobei, ich bin mir nicht sicher, ob...
Ich glaube, selbst beim Low-Latency-Video-Dings macht Twitch das auch so.
Also, HLS-Streaming ist ganz easy.
Es wird einfach über HTTP immer kleine Häppchen vom Videoclip runtergeladen
und in ein Video-Element im Browser gerendert.
Das funktioniert natürlich nur,
solange der Browser den Codec kann.
Aber wenn der Browser den Codec nicht kann, hat man andere Probleme.
Viel nicer ist das und viel schneller und viel...
weicher und...
ja, noch kein AV1, ne?
Und auch viel mehr ohne Lag...
ist das, wenn man das Ganze bei WebRTC macht.
WebRTC ist eigentlich dafür gedacht,
für Echtzeit-Video-Audio-Kommunikation von Clients zu Clients.
Also, wenn ihr zum Beispiel Teams verwendet oder Zoom...
oder...
irgendwas.
Ist eigentlich egal.
Discord ist eigentlich vollkommen wurscht.
Vieles davon, wobei Discord nicht.
Discord, glaube ich, nur das Video.
Glaube... weiß ich gar nicht, ehrlich gesagt.
Aber dann machen die WebRTC.
WebRTC ist... steht's ja hier.
Ein offener Standard, der eine Sammlung von Blablabla...
Okay, die Beschreibung ist halt richtig pepega.
Das ist für Echtzeit-Video-Audio-Kommunikation,
wie zum Beispiel bei Microsoft Teams.
Und Teams benutzt es auf jeden Fall.
Was man jetzt macht... also, wie gesagt, das ist eigentlich gedacht,
für Client zu Client, P2P.
P2P-Kommunikation.
Also, du machst einen Gruppencall mit fünf Leuten
und die streamen dann untereinander ihr Audio und Video.
Was man aber auch machen kann, ist...
Man kann... ja, eine Serverkomponente hinzufügen,
die dann zwar auch im WebRTC nur ein Client ist,
aber die auch Videos schickt.
Und jetzt wird's advanced und da müssen wir heute weiterbauen.
Deswegen ist es nicht schlimm, wenn ihr nicht dabei gewesen seid,
weil den Part haben wir noch gar nicht gebaut.
Man kann jetzt zum Beispiel auf Serverseite
die Kameras auslesen.
Per FFmpeg zum Beispiel.
Per FFmpeg sich zu den Kameras connecten.
WebRTC ist in JavaScript und C++ geschrieben.
Das stimmt nur zur Hälfte.
Kann ich gleich was zu sagen.
Also, pauschal ist erstmal nicht richtig.
Aber auch nicht ganz verkehrt.
So, was wollte ich jetzt sagen?
Genau.
Also, man kann beispielsweise mit FFmpeg...
sich connecten zu den Kameras per RTSP,
von den Kameras das Videobild auslesen,
also die einzelnen Frames, encodeten, wohlgemerkt nicht decodeten Frames,
encodeten Frames von einem H.264 Videostream.
Und diese Frames, die man von der Kamera ausliest,
die kann man dann, wenn man eine WebRTC-Verbindung aufgebaut hat,
zu einem Browser, so quasi im Browser schicken,
so wie sie kommen, ohne so zu decoden und neu encoden,
wie sie kommen, kann man die da reinschicken.
Und quasi so tun, als ist man im Endeffekt eine Webcam in einem Teams Call.
Um es jetzt mal bis in höherem Niveau zu sagen.
Und dann kann der Browser das auch anzeigen.
Also, man wandelt quasi den Webcam-Stream um,
in was, was der Browser in Echtzeit anzeigen kann.
Was ja nice ist, da hast du überhaupt kein Delay drin.
Also, wenn die Kamera Delay hat,
wenn die Kamera Delay hat, natürlich.
Aber du hast ab dem Zeitpunkt des Stream-Abgreifens
und in den Browser zu streamen, so gut wie,
so gut wie, sagen wir mal, kein Delay.
Also, deutlich unter einer Sekunde.
Eher im Bereich von ein paar Millisekunden.
Also, das ist wirklich ziemlich Echtzeit.
Was halt auch nice ist, wenn du zum Beispiel,
wenn es klingelt und du siehst unten den Typ
dann an der Gegensprechanlage stehen.
Und die Mundbewegungen passen zu dem, was du hörst zum Beispiel.
Ja, das ist halt nice.
Könnte man nicht auch über Nginx RTMP,
nö, wie willst du denn das in den Browser kriegen?
Kann kein Browser, kann das nicht.
Browser können HLS dann da drüber machen zum Beispiel.
Ja, aber das ist dann mit ein bisschen Delay und Lack verbunden.
Außerdem ist WebRTC ein Pogger, eine Poggers-Sache,
mit der man sich mal beschäftigt haben sollte.
Kann auf jeden Fall nichts schaden.
So, um jetzt da was dazu zu sagen.
Also, Icos, du hast im Prinzip Recht.
WebRTC ist eine Technologie für den Browser.
Ganz klar, wird auch von Browser-Herstellern mit,
initiiert.
Und die Referenzimplementierung ist in C++,
weil, ja, die Browser sind halt in C++.
GitHub, WebRTC, die Referenzimplementierung gibt's auch,
gibt's auch irgendwo auf GitHub.
Kann man die sich angucken?
Irgendwo habe ich die, habe ich die schon gesehen, ja.
Aber macht keiner, weil die C++-Geschichte ist eklig.
Deswegen,
gibt es auch alternative Implementierung von WebRTC,
die nicht in C++ geschrieben sind
und auch kein JavaScript auf Server-Seite brauchen.
Zum Beispiel gibt es da Pion, das ist in Go programmiert.
Das ist eine, hier, eine Pure-Go-Implementation von WebRTC.
Und dann gibt es zum Beispiel auch noch für Rust,
das ist das, was wir hier verwenden,
gibt's für Rust, gibt's in WebRTC Implementierung auch alles jetzt nicht ganz unbeliebt,
wenn man sich die Sterne anguckt.
Es gibt auch, es gibt, glaube ich, auch eine Python-Implementierung,
die habe ich mal kurz ausprobiert, die war richtig schrottig.
Zumindest für das, was ich machen wollte.
Also, das gibt's, es gibt verschiedene Implementierungen,
aber prinzipiell hast du nicht unrecht, wenn du, wenn du sagst,
dass es JavaScript in C++.
Ähm, Acara-Sensoren und so.
Hast du, hast du die selbst geflasht?
Da hast du jetzt wirklich, du musst auf jeden Fall die Zeit,
was die zum Senden brauchen, runterstellen.
Stell das auf 12 Minuten.
Stell das auf 12 Minuten, 15 Minuten oder so.
Zeit zum Sensorabfragen runterstellen, äh, hochstellen,
nicht runterstellen, hochstellen.
Und Zeit zum Verschicken hochstellen.
Weil das reicht, wenn du 15, alle 15 Minuten weißt,
wie warm es bei dir im Flur ist.
Und dann hast du 2 bis 3 Jahre, mindestens 2,5,
hatte ich, ich hatte fast 3 Jahre Batterielebenszeit
von so einer kleinen CR2302-Knopfzelle.
Das ist, das hast du mit sonst keinem anderen Sender,
das, äh, keinem anderen Sensor, das ist extrem pogu.
So, falls ihr irgendwas überlesen habt,
sagt Bescheid.
RTSP Relay, die verwenden Websocket.
Na, Websocket alleine bringt denen ja nix, ne?
Die müssen, streamen die, streamen die dann die Videodaten
über Websocket.
Und irgendwie in einem Video, ähm, kenn ich nicht.
Kenn ich nicht.
Aber WebRTC ist für sowas halt gemacht.
Also ich weiß nicht, wie die das machen,
aber WebRTC ist auf jeden Fall lower latency.
Würdest du empfehlen, wenn man sich mit Kubernetes beschäftigt?
Ja.
Ja.
Ach, was?
Nicht ob, was?
Ja, also ich würd's, ich, ich würd's auf jeden Fall,
ich würd's auf jeden Fall empfehlen,
sich mit Kubernetes zu beschäftigen.
Wenn man irgendwie Interesse daran hat.
Wenn man sich mit Kubernetes zu testen würde,
also, also, Minikube.
Wenn du anfängst, Minikube.
Minikube ist das Allereinfachste, was du verwenden kannst.
Zeig ich dir.
Das ist so einfach, dass ich das jetzt einfach zeigen kann.
Minikube.
Start.
Einfach mal schnell was ausprobieren.
Nicht.
Aber kann man sich drüber streiten,
aber ich find einfach mal schnell Minikube das Beste,
was du machen kannst.
So, es gibt anscheinend eine neue Kubernetes-Version,
die man neu runterladen muss.
Okay, nice.
Dann müssen wir kurz warten.
Du kannst Minikube übrigens einfach auch hier über,
also, falls du Arch, by the way, verwendest,
was du hoffentlich machst,
weil High-IQ-Stream, Arch, by the way, use ich auch.
So wie, so wie allen coolen Leute natürlich.
Arch.
Und es ist wichtig, dass man das öfters erzählt.
So, guck.
Das war's.
Minikube.
Start.
Der lädt die neueste Kubernetes-Version runter.
Startet entweder eine VM oder Docker-Container mit der Kubernetes-Control-Plane drinnen.
Außerdem hat es Emojis.
Und jetzt sagst du kubectl get pods-a und du siehst, du hast einen laufenden Kubernetes-Cluster.
Also, viel einfacher als Minikube.
Viel einfacher als Minikube zum lokalen Basteln gibt es meiner Meinung nach nicht.
Minikube hat ein paar Nachteile, wenn du etwas advancedere Features verwenden willst.
Zum Beispiel, wenn du Kubernetes-Loadbalancer verwenden willst.
Also, den Service-Typ Loadbalancer verwenden willst.
Dann geht das nicht so ohne Weiteres.
Aber das geht offline eh nicht so ohne Weiteres.
Da muss man sich da ein bisschen Gedanken machen.
Aber wenn du einfach nur basteln willst, ist Minikube das Beste.
Und wenn du fertig bist, wenn du fertig bist, noch besser.
Minikube Stop oder noch besser, wenn du Platzfehler freigeben willst, Minikube Delete.
Dann löscht er den ganzen Krempel wieder rückstandslos weg und du hast kein Kubernetes-Cluster mehr.
Also, kann man sich sicherlich drüber streiten.
Ich persönlich würde Minikube empfehlen.
So sieht es aus.
Und an Projekten würde ich mal klein anfangen.
Nimm irgendwelche Hello-World-Applications, die einfach funktionieren.
Irgendwelche Web-Anwendungen.
Lass die mal möglichst stateless.
Lass die mal deployen.
Skalier die mal hoch und runter.
Bau einen Service davor.
Setz den Ingress davor.
Guck, dass du vielleicht anfängst mit, okay, wie sieht es denn aus, wenn man da Configs reinmountain will.
Wenn man da Secrets reinmountain will.
Wenn man, vielleicht Zertifikate kannst du dir angucken.
Vielleicht Persistent Volumes, falls man das doch mal braucht.
Was man öfters mal braucht.
In der Theorie ist es immer so geil.
Kubernetes ist alles stateless.
Es ist alles stateless, bis es nicht mehr stateless ist.
Also, man braucht schon ab und zu nochmal Volumes.
Und wenn man es ganz übertreiben will, kann man sich alles angucken.
Aber wenn man es ganz übertreiben will, dann geht man einfach auf...
Oh, wie heißen diese...
Wie heißen die? Cloud Native? Cloud Foundation?
Hier, Cloud Native Computing Foundation.
Die meine ich.
Und wenn du es voll übertreiben willst, dann guckst du dir den Cloud Native Computing Foundation Landscape an.
Von allen Projekten, die was mit Kubernetes zu tun haben.
Und du wirst feststellen, du bist erschlagen.
Du blickst überhaupt nicht mehr durch.
Und damit es dich nicht so komplett überfordert, musst du dich hier umstellen.
Dass du nur...
Dass du nur...
...CNF-Projekte anzeigen willst.
Aber selbst dann sind es immer noch ein paar.
Das, was Kubernetes kompliziert macht, ist zum Großteil mit das Kubernetes-Ökosystem drum herum.
Aber was man auch braucht, weil mit Kubernetes alleine wird man halt auch nicht glücklich.
So.
Gut.
Dann fangen wir mal an.
Mal gucken, ob mein Connection-Abbauen richtig funktioniert.
Warte mal, ich mach mal die Connection zu.
Connection direkt.
Dann solltet ihr gleich schreiben.
Active Connect.
Okay.
Stay disconnected.
Er hat es schon mal gecheckt.
Okay.
Nice.
Hat funktioniert.
Also.
Soweit so gut.
Ich habe jetzt ausgeholt, was wir heute machen wollen.
Also heute...
Ne.
Also was die Anwendung machen soll.
Wie weit wir bisher sind.
Wir haben es bisher nur geschafft, dass eine Webseite ausgeliefert wird.
Hier.
Das ist die gesamte Webseite hier.
Das ist alles.
Und die baut aktuell...
Und die baut aktuell nur eine Web-RTC-Verbindung zum Server auf.
Guckt, der versucht...
Der legt eine Web-RTC-Verbindung an.
Callt den Endpunkt für Web-RTC-Start.
Dann kriegt er...
Dann kriegt er eine Liste geschickt, mit was der Server für Codecs unterstützt.
Das ist nur H264.
Und dann schickt der Browser selbst zurück, was er für Codecs unterstützt.
Der Server nimmt das an und dann ist die Web-RTC-Verbindung aufgebaut.
Ja.
So.
Und...
Ist auf dem Low-Level-Web-RTC-Layer am Start.
Weil wir verwenden hierfür die...
Ich glaube, die heißt einfach Web-RTC-RS-Library.
Das Ganze...
Ihr werdet es vielleicht hier sehen.
Ab und zu mal.
Das Ganze habe ich auch mal in Go gemacht.
Aber...
Hab mir überlegt.
Ey, wenn man schon mal sowas neu baut.
Was man schon mal gebaut hat.
Dann kann man es doch auch mit ein bisschen was anderem machen.
Und jetzt ist Rust am Start.
Genau.
Im Prinzip...
Ich zeige euch mal ganz kurz den Rust-Part.
Lasst euch mal nicht von abschrecken, dass Rust so eklig aussieht.
Das ist normal.
Ich finde, das ist...
Wo sind eigentlich unsere zwei...
Unsere zwei Spezial...
Unsere zwei Spezial-High-IQ-Rust-Enjoyers?
Moment.
Ich weiß...
Ich weiß die Namen auch noch.
Weil...
Die haben mich letztens ins Commit reingeschrieben.
Wo sind denn...
FronAqua und Odolmed?
Wo sind jetzt die Ober-Rust-Enjoyer?
Rust sieht eklig aus.
Ja.
Rust sieht eklig aus.
Ja.
Go ist auch nicht die schönste Sprache.
Aber...
Ganz ehrlich.
Im Vergleich...
Im Vergleich zu Rust...
Ist Go noch hübsch.
Ich lasse mir das ja gefallen, dass es unterschiedliche Ansichten gibt.
Aber in dem Fall nicht.
Also...
Okay.
Okay.
Sagen wir mal so.
Es ist vielleicht kein C++.
Aber schön ist es wirklich nicht.
Da...
Da...
Da...
Da...
Da...
Da...
Da...
Da...
Da...
Da...
Da...
Das hier ist jetzt noch halbwegs ordentlich.
Ja.
Glaube ich zumindest.
Ich bin ja auch kein großer...
Kein großer Rust Checker.
Also, ich...
Ich zeige euch mal ganz kurz, was die...
Was sie...
Was die Rust...
Was die Rustseite macht.
Äh.
Ich habe sicherlich vieles drinnen, wo jetzt die richtigen nicen Krustentiere sagen würden,
dass das nicht...
Wie sagen sie immer?
Das ist nichts, äh, idiomatic rust oder idiomatic...
Wie spricht man das aus, Chat?
Low-IQ-Time.
Low-IQ-Time.
Low-IQ-Time.
Oder vor allem, wie heißt das auf Deutsch?
Das ist nicht, das ist quasi nicht, wie man Rust macht.
Das Ding ist, viel anders werde ich es nicht machen können,
weil ich halt Interop mit C brauche und deswegen Rust.
Ganz kurzer Überflug über das Ganze.
Was passiert?
Idiomatisch, nicht ideologisch, idiomatisch, irgendwie sowas.
Also mal ganz kurzer Überflug über das, was hier low-level-mäßig in Rust passiert.
Es gibt eine Init-Methode, die wird als allererstes aufgerufen.
Sieht man auch hier.
Achso, hier ist auch das alte Go-Zeug drin, das kann man mal wieder rausschreiben.
Es gibt eine Init-Methode, die wird als allererstes aufgerufen,
sobald wir, sobald die Web-Anwendung gest...
Warum werden meine...
Active Connection 1.
Was ist das?
Achso, ich habe tatsächlich eine Active Connection.
Mein Programm funktioniert besser als mein Kopf.
So, gucken wir mal, ob die Verbindung, gucken wir mal, ob das jetzt gleich weggeht.
Ja, State is disconnected.
Er sollte jetzt eigentlich checken, dass es...
Zero Active Connection.
Skippt, ja.
15 Sekunden.
Guckt alle 15 Sekunden nach.
Zero, okay, nice.
Also, als allererstes wird hier einmal Init aufgerufen.
Init in Rust macht folgendes.
Initialisiert das ganze Web-RTC-Zeug.
Ja, frag, frag ruhig.
Initialisiert das ganze Web-RTC-Zeug.
Macht ein Netzwerkport auf und setzt das Zeug, was man für Web-RTC braucht.
Wichtig ist das hier.
Das setzt das...
Das wir auf Server-Seite nur H.264 unterstützen als Video-Codec.
Sieht man hier oben.
Wir unterstützen als Video-Codec nur H.264 und das ist auch hier Rust-Logik.
Hab im PC TPM aktiviert, aber kann nicht auf Windows 10 wechseln.
Warum?
Keine Ahnung, ich habe von Windows keinen Plan.
Vielleicht wird die CPU nicht unterstützt.
Wobei ja eigentlich theoretisch alles unterstützt werden soll, was TPM hat, oder?
Oder braucht man nicht sogar TPM2?
War das nicht so, dass es nur mit TPM2 läuft?
Also wenn es nicht TPM2 hat, hast du TPM2.
Also vielleicht wird die CPU nicht unterstützt.
Ich meine, es gibt diesen komischen Trick, wie man das trotzdem installiert.
Aber das habe ich noch nie gemacht und ich habe auch von Windows keine Ahnung.
Also da kann dir wahrscheinlich der Chat besser helfen, als ich.
Ich habe da keinen Plan von.
Ich bin planlos.
MonkaS.
Ja, dann müssen wir...
Dann ist halt die...
Secureboot, ja stimmt, Secureboot brauchst du auch noch.
Ja gut, das muss ja irgendeine Fehlermeldung geben.
Ja gut, das muss ja irgendeine Fehlermeldung geben.
Oder es ist irgendeine Standard-Microsoft-Fehlermeldung.
Es ist ein unbekannter Fehler aufgetreten.
Klicken Sie auf Fortfahren.
Nope.
Keine Ahnung.
Von Windows bin ich der falsche Ansprechpartner.
Okay, Chatgear.
Also, wir sagen, dass wir nur H.264 unterstützen.
Weil in dem Stream sind halt auch die Videos von der Webcam.
Das ist das Erste, was aufgerufen wird.
Und dann machen wir nochmal einen kurzen Überblick über die anderen zwei Sachen, was passiert.
Ähm, es gibt eine Create-Connection, das baut die Web-ATC-Verbindung auf.
Der sammelt erstmal alle IP-Endpunkte ein, erzeugt eine Liste, mit was für Codecs unterstützt werden
und sendet das zurück an den Browser.
Wie gesagt, eigentlich müssen wir das gar nicht wissen für heute.
Deswegen machen wir das jetzt nur ganz schnell.
Ähm, dann stellt er noch ein paar Sachen bei der neuen Web-ATC-Connection ein.
Zum Beispiel, dass die entfernt wird, wenn sie...
...geschlossen wurde.
Ähm...
Wenn nach 10 Sekunden die Verbindung immer noch im State New ist...
...dann wird sie auch gelöscht.
Antwort vom Browser setzen.
Track anlegen.
Track ist quasi das, wo man dann die Videobilder schickt.
Und hier...
...wo man Videomaterial schicken kann.
So, das ist im Prinzip alles.
Der Rest ist Rust-Zeremonie, damit es funktioniert.
So.
Gar nicht so genau angucken.
Das heißt, heute gibt es auch eine Mischung aus Rust und C-Sharp.
Wie viel Rust wir brauchen, muss ich nochmal gucken.
Ähm...
Also, wenn ihr was wissen wollt, könnt ihr mich gerne fragen.
Ich bin absichtlich jetzt da im Schnelldurchgang drübergegangen,
weil erstens ist es für heute nicht so wirklich relevant.
Und zweitens, für die, die das letzte Mal dabei waren, die kennt ihr wahrscheinlich noch.
Also, insofern...
Gucken wir mal.
Jetzt bin ich ja... bin ich gerade am überlegen, wo wir weitermachen.
Wir müssen eigentlich jetzt ein bisschen C-Sharp machen und FFM-Pack.
Und damit FFM-Pack funktioniert, brauchen wir erst einmal ein Video.
Also, Ziel für heute ist, dass ich mich verbinden kann per WebRTC.
Und hier kommt ein Videoplayer hin.
Ich glaube, wir haben gar keine sinnige Erklärung heute drin für das Projekt.
Also, Ziel für heute ist...
Das kommt mal theoretisch...
Theoretisch könnte man, wenn ich jetzt schnell bin, könnte man das mitschneiden und als Track machen.
Also, Ziel für heute ist, dass wir hier einen Videoplayer kriegen.
Und vom Server...
Über WebRTC...
Videostream schicken können an den Browser.
Deswegen können wir theoretisch schon mal, damit wir wissen, wohin das...
Das Ganze gehen soll...
Können wir theoretisch schon mal hier oben einen Videoplayer reinpappen.
Wo haben wir das hier?
Video...
ID gleich...
Tja, Player.
Dass es wenigstens so aussieht, als könnte er was anzeigen.
Inline-Style...
Beste...
Breite 100%.
So, Massive.
Und da haben wir...
Background...
Black.
So, jetzt haben wir einen Videoplayer.
Der Videoplayer macht natürlich noch nichts.
Weil es zur Zeit keine Videoframes zum Playen gibt.
Aber man sieht zumindest schon mal einen Videoplayer.
Dann schalten wir hier noch ein...
Ich glaube, Auto...
Auto...
Play...
Man muss es Muted machen.
Und dann gab es hier noch so ein...
Wie hieß das?
Inside?
Ja, HTML...
Place...
Place Inline, nicht Inside.
Place Inline.
Die Dinger sind wichtig für Mobile.
Also falls ihr...
Jetzt nochmal, pass auf.
Krasse Web-Frontend-Developer-Tipps und Tricks hier.
Vom Web-Developer...
High-Skiller...
Ultra-Skiller schlechthin.
Ähm...
Wenn ihr Probleme habt mit...
Autoplay-Content auf Mobile.
Dann liegt das daran, dass Muted und Place Inline nicht gesetzt sind.
Also sowohl iPhones...
Also iPhones definitiv.
Bei Android bin ich mir nicht sicher.
Aber ich glaube, bei Android ist es auch so.
Sowohl iPhones als auch Android spielen Videos nicht ab.
Solange die nicht Muted sind.
Und solange die nicht auf Place Inline stehen.
Spielen die nicht automatisch ab auf der Webseite.
Und warum?
Weil Spam.
Weil ansonsten Werbung halt alles voll spammen kann.
Browserseitig wird doch immer gemutet.
Ja, das wird aber nicht abgespielt.
Wenn es nicht gemutet ist.
Zumindest auf iOS ist das so.
Solange es nicht gemutet ist, hast du keine Chance.
Wird nicht automatisch...
Du kannst noch so viel Autoplay einstellen.
Wird nicht abgespielt.
Es muss Muted sein.
Sonst wird das nichts.
Du kennst mich.
Das ist...
Ho, gut, dass du deinen Weg hergefunden hast.
Wie hast du das gefunden?
Zufällig?
Über Empfehlungen auf Twitch?
Oder bist du über den Link auf YouTube hergekommen?
Recommendation auf Twitch, da ist er.
Hast du erkannt am Logo?
Gehe ich mal von aus.
Vermute ich jetzt einfach mal.
Weil...
Du siehst ja in der Vorschau nur unten links so kleine Icons.
Yuki Cat ist wieder am Start.
Immer noch.
Nicer Weep Name.
So.
So, jetzt muss ich mal kurz konzentrieren.
Wo sind wir stehen geblieben?
Check hier.
Videoplayer.
Also, HTML-Zeug scheint ja zu funktionieren.
Das brauchen wir jetzt erstmal nicht.
Rust-Zeug geht auch.
Brauchen wir auch erstmal nicht.
Also, wir müssen FFM-Pack-Zeug...
Wir müssen FFM-Pack-Kram machen.
Also.
Ich hab hier sogar schon minimal angefangen mit FFM-Pack.
Also.
Das Ding ist folgendes.
Damit wir das jetzt überhaupt ausprobieren können, brauchen wir erstmal ein Test-Video.
Weil ich brauche hier irgendwas, was ich im Browser anzeigen lassen kann.
Deswegen würde ich sagen, wir gehen jetzt einfach mal bei mir auf YouTube.
Und ziehen uns irgendein Test-Video.
Irgendein kurzes Video vielleicht.
Man kann ja nicht mehr gescheit sortieren auf YouTube.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
mein neuer pc ist auch verkehrt das ist gut dass damals alle warum leckt man
browser so das nehmen wir jetzt also mal hier mk dir verzeichnet haben wir schon
keine ahnung rtsp video youtube dl laden wir mal das video runter
annie ist groß ff pain respect wieder so wir laden das video in ich glaube 720p reicht erstmal
aus und zwar auch nur das video runter und als nächstes brauchen rtsp server um die webcam zu
sehen weil nicht die webcam die die kamera zu simulieren und da habe ich früher immer den
hier verwendet rtsp simpel heißt dieses ding der heißt jetzt nicht mehr
rtsp simpel da ist jetzt media warum auch immer rtsp simpel war zu simpel das ist jetzt
medien gibt es das dass man gucken ob archi links wieder superior ist ja gibt es als package aber
wir laden das binary runter an jemand einem film möglichst leisen managt 48 port switch ich muss
dir sagen
ich schon ein bisschen her dass ich geguckt habe ich kann dir ich kann dir was empfehlen aber nicht
blind kaufen muss guck erst mal ob das wirklich was passt für die was hältst du von mikrotik
switchen zum beispiel brauchst du zehn gig oder oder eigentlich oder was was brauchst du also was
ich dir empfehlen kann ist also dass er eigentlich fast schon dass ihr das hier ist ja fast schon der
klassiker
aber wenn 48 port ermitteln passiv gekühlt das ist ja noch 24
sport24 sport reicht hier nicht ja dann müssen wir gucken ob die auch acht haben die davon auch
in 48 port ja da bin ich tatsächlich überfragt für 48 port von denen ja das hier sind 24 port
24 tatsächlich aber 48 ok das natürlich das natürlich schon ein
bisserl bisserl advanced da 48 gigabit 4 x 10 gig 2 2 40 gig oder es ist zwei
kurses 40 gig dann kann ich dir leider nichts gutes
empfehlen weil ich nicht weiß wie die sind also bei den anderen wäre es
relativ no brain gewesen da war ich dass sie tun da dann weiß ich nicht da
kann ich dir kann ich dir nichts empfehlen
aber der chat der chat ist high IQ laden wir uns mal den ltsp server
runter copy link without sight tracking was soll denn hier getrackt werden wo
ist das video das du angekündigt hast was
denn was habe ich da angekündigt das wird der bewerbung ja das gibt das war
ich noch das mache ich im dezember ok also jetzt starten wir mal ins den
server und also das hier ist jetzt unsere webcam ja beziehungsweise unsere
kamera das ist ein lokaler rtsp server zum testen
und jetzt müssen wir uns auf der seite noch mal raussuchen wie man hier mit ffm
pack das hat nichts mit unserem server seit ich in ffm pack zu tun immer mit
ffm pack zu tun immer mit ffm pack zu tun immer mit ffm pack zu tun immer mit
ffm pack da rein streamt über nennen das video mal kurz um mein neuer pc ist
overkill mein punkt mp4 so und jetzt streamen wir das hier rein und ich hoffe
der codec passt weil da ist es teilweise ist der browser da sehr wenig aber wir
ein fake rtsp stream lokal oder gucken wir mal ob wir das ganze abgespielt Kodec dream Labs b aussi foldeden bekommen ob
ob der überhaupt funktioniert.
FF Play oder VLC.
VLC geht genauso.
Kann FF Play das spielen?
Okay, FF Play kann das.
Warum auch immer VLC das nicht kann?
Kein Plan.
Aber FF Play spielt mal ein Video ab.
Über RTSP.
Also das ist unsere
Beispiel-Kamera quasi.
Das ist der gleiche Weg
wie irgendein 115-China-Chinesen-Cam,
die ihr bei AliExpress
oder Amazon kauft,
und den Videostream ausliefert.
Nur, dass das hier ein bisschen höhere Qualität hat vom Videostream.
Gut, das
funktioniert. Jetzt können wir uns
um den FF MPEG-Part kümmern.
Glücklicherweise
habe ich schon ein paar Sachen mit FF MPEG
gemacht, sodass ich nicht
komplett planlos bin,
was FF MPEG angeht.
Aber so 100%ig High IQ
aus dem Kopf
jetzt auch nicht unbedingt.
Wir machen das einfach mal testweise.
Also, wir brauchen die
URL von dem Stream.
Also, wie gesagt, Ziel ist,
hier mit FF MPEG,
also mit der FF MPEG-Library,
nicht mit dem FF MPEG-Command-Line-Tool,
was die meisten kennen,
mit der FF MPEG-Library den Stream auszulesen
und dann den Stream an den Browser
zu schicken.
Soweit, so gut. Soweit die Theorie.
Das Ganze.
Let's go. Also, das...
Okay.
Ich habe ja schon mal angefangen.
Hier muss die URL sein.
Also die URL rein, für unseren Stream.
So.
Jetzt muss ich das Result ausgeben,
um zu gucken, ob das alles funktioniert hat.
Lass uns mal checken.
Ah, wir warten. Wir warten einfach mal.
Okay, FF MPEG macht einfach gar nichts.
Ich glaube, das...
ich glaube, das crasht oder so.
Warum crasht das?
Es suckt, wenn das crasht, Alter.
Mal kurz ohne task.
Das ist ja richtig Schrott, wenn das
crasht. Was hat er für Schmerzen?
Okay, es crasht, weil
not supported exception.
Specified method is not supported.
Dynamically loaded bindings.
Nice.
Excellent. Also ich meine, ich habe
FFmpeg offensichtlich installiert.
Ich glaube, ich weiß, dass man
musste
den Pfad zu den Libraries setzen.
Jetzt ist nur die Frage, wo
unter Linux wahrscheinlich lib oder so?
lib?
Es heißt nicht FFmpeg, es heißt libAV.
Genau hier.
libAVfilter. Okay, legt das
in lib? Probieren wir es mal aus.
Crasht es immer noch?
Es crasht nicht mehr!
Fixed!
Easy.
Hier müssen wir noch
to do
auto detect.
Ich habe nicht FFmpeg
4.4. Ich weiß auch nicht, warum das so heißt.
Ich habe FFmpeg 6.1.
Ja, 6.1.
Ich gehe davon aus, es ist zur Abwärtskompatibilität
da irgendwie mit verlinkt noch.
Aber unter der Haube ist es wahrscheinlich 6.1.
So.
Also das funktioniert.
Es ist auch Return Code 0.
Also FFmpeg ist in der Tat
etwas gewöhnungsbedürftig als Library.
Ja. Aber wenn man sich einmal
dran gewöhnt hat, so an diesen FFmpeg
Style, wie man es verwendet, ist
das, finde ich, eines der
angenehmeren Libraries zu benutzen.
So.
Man merkt aber, dass es
Low-Level-Kram ist, weil man hier Sachen
machen muss, wie AV-Format,
Alloc-Kontext und solche
Geschichten und mit Pointer
und Unsafe und sonst was.
So.
Wenn ich das jetzt richtig im Kopf habe,
was wir jetzt als nächstes machen müssen,
ist sowas wie,
ich glaube, Feind, irgendwas mit Feind
heißt das. Feind-Stream-Info,
das meine ich.
So.
Da muss das rein
und
das
Dictionary
braucht man da, glaube ich, nicht.
Aber ich kann es ja auch mal mit übergeben.
Der Reference
gibt auch ein Result zurück.
Kurz gucken, ob das funzt.
Okay. Passt.
Passt. Laut genug.
So. Und jetzt müssen wir irgendwie
die einzelnen Frames auslesen.
Ich bin gespannt, ob ich das aus dem
Kopf noch zusammenkriege, wie das funktioniert hat.
Also wir brauchen auf jeden Fall eine Schleife.
Erstmal eine Endlosschleife
zum Testen.
So. Also.
Wir haben FFmpeg jetzt gesagt,
wir wollen diese URL hier öffnen.
FFmpeg ist wirklich
auch ziemlich clever, was das
angeht. Wenn ich jetzt hier
beispielsweise HTTP
irgendwie angebe, eine URL oder
irgendein lokales File oder sowas,
FFmpeg kann relativ
gut autodetekten, was
in diesem Stream drin ist. Also man muss
so gut wie nie von Hand
irgendwas setzen. Also FFmpeg ist da ziemlich
schlau.
While true 0w.
So. Und jetzt müssen wir irgendwie Packages
auslesen. Ich glaube
dazu brauchen wir erstmal ein Package.
Package ist bei
FFmpeg quasi
encodete Videoframes im Endeffekt.
Das gibt es irgendwie sowas wie
Alloc Packet. Naja.
War umgedreht. Packet.
Oh.
Okay.
Und wie ging das jetzt noch
mal?
Oh. Ich weiß es nicht mehr.
Ich glaube irgendwas Readframe oder sowas. Read.
Readframe.
Genau.
Readframe
Format.
Und da muss jetzt das
Packet rein.
Oh.
Und jetzt bin ich gespannt, ob das
funktioniert. Theoretisch sollte der
jetzt den Webcam Stream einlesen.
Das ist übrigens schon alles, was wir in FFmpeg
machen mussten. Also kommt auch ein bisschen mehr drum rum.
Aber FFmpeg ist, wenn man sich dran gewöhnt hat,
extremly POG zu benutzen.
So. Result. Schauen wir mal.
Der sollte jetzt eigentlich in Endlosschleife den Videostream
einlesen. Macht er auch.
Können wir
einfach ausprobieren, ob er das wirklich macht.
Pack. Oh.
Ich habe so ein kleines Memory Leak hier am Start,
wie euch vielleicht auffällt.
Erkennt ihr es auch, Leute?
Erkennt...
Ja. Filter ist abartig.
Erkennt ihr auch mein kleines
Memory Leak?
Free is bloated.
Wir müssen hier nichts freeen, ja.
Ich kann euch auch zeigen, dass es
etwas Memory Leak...
Ähm...
Wie? Warum Memory Leak
das nicht?
Das Memory Leak gar nicht.
Doch.
Doch, das Memory Leak.
Doch. Doch, doch.
Guckt jetzt.
Ja.
Es sind halt immer nur 1-2 MB pro Durchlauf.
Und es sind nur
60 FPS pro Sekunde. So krass liegt
das nicht. Aber es leakt.
Ja, ja.
Nee, es geht nicht. Leute, wenn...
Das kannst du 2 Stunden laufen lassen,
dann ist dein RAM voll.
Guckt, das ist Unmanaged Memory auch.
Das größte Teil. Ja.
Also. Leak.
Woop. Leak.
Also ihr seht, das ist keine so gute
Idee. Ich habe viele
64GB RAM. Ich kann es ja beide laufen lassen, ja.
Also, das
können wir auf jeden Fall nicht so lassen.
Und es ist auch ganz
einfach zu fixen. Nämlich
einfach Packet
raus aus der Schleife und gut ist.
Ich bin mir jetzt bloß nicht sicher,
ob das das Package einmal komplett cleart.
Ich bin mir nicht
sicher, ob wir das Package
clearen müssen.
Oder ob das AV Read Frame
macht. Das müssen wir mal
gucken. Aber wenn ich mir
ansehe, bin ich mir unflüssig.
Hat Packet ein Dispose?
Nee.
Packet ist ein Pointer
zu einem Packet.
Nein, natürlich ist alles
RAW.
FFmpeg Zeug. Da wird nichts Disposed.
Nee, nee.
Aber so ist ja gut. Wir
allocaten das ja nur einmal. Da hat es auch kein Memory
Leak mehr.
So, jetzt lesen wir den Stream ein.
Und jetzt müssen wir noch checken.
Weil das
Video könnte ja
Audio und Video Streams haben.
Aber wir wollen ja nur den Video Stream.
Jetzt müssen wir checken.
Achso, wir können übrigens mal
gucken.
Packet. Wir können mal gucken, ob da auch
wirklich immer neue Frames kommen.
Das sollte jetzt hochzählen, theoretisch.
Ja.
Das sind die Timestamps von den einzelnen
Video Frames. Also
das sieht gut aus.
So, jetzt müssen wir noch irgendwie
überprüfen.
Ob das ein
Video Frame ist oder ein
also ob das Packet, müssen wir sagen.
Ob das Packet Audiodaten oder
Videodaten hat. Weil wir wollen ja nur
Videodaten an den Browser schicken.
Da
weiß ich gerade nicht mehr
genau, wie es funktioniert.
Irgendwie
Hype oder sowas.
Oder ging das über
Stream Index?
Ich glaube, das ging über Stream Index.
Da muss man sich im Vorfeld rausholen,
welche Streams es gibt.
Gucken, ob das ein Video Stream ist
und dann den Stream Index vergleichen.
Ja, das war ein bisschen, ich erinnere mich, das war ein bisschen eklig.
So, Streams
gibt es
glaube ich hier.
Was ist das?
Pointer zu einem Pointer.
Ok, also
Vorschleife.
Oh.
Alter.
Nervt mich.
Oh.
So.
Format.
Wie ist das?
NB Streams?
Stream gleich
Format
Context Streams
I
So, und jetzt konnte man hier glaube ich
gucken, Stream Type
oder so. Hä?
Was war doch da?
Hier war das drin.
Ja, und da gibt es jetzt
Codec Type, genau.
Und da kann man jetzt gucken, ob das wie
ein Video Stream ist.
Bert Wolf.
Excellent. Trinken. Ja, muss ich machen.
Yes. So.
Also wir wollen gucken, ob das ein Video Stream ist
und wenn das ein Video Stream ist, dann
dann speichern wir den
hier. Achso.
Besser.
Temp ist immer mit Abstand der beste
Variablen Name. Da gibt's nix.
So. Sobald wir ein Video
Stream gefunden haben, wird er gesetzt
und gut ist. Wir könnten das
Ganze jetzt natürlich auch schön machen.
Wollen wir das schön machen, Leute?
Soll ich euch mal zeigen, wie ich das machen würde normalerweise?
Ich würde jetzt nämlich ne... Oh.
So würde ich das machen. Genau so.
Achso. Ja.
Ah. Null. Okay, passt.
Ja. Also.
Wisst ihr, wie ich das machen würde normalerweise?
Ich würde jetzt wahrscheinlich ne Extension Method bauen.
Ich würde ne Extension Method bauen
für...
...
Formatkodex, glaube ich.
Oder?
Für Format, nicht Kodex.
Kontext, würde ich sagen.
Das probieren wir mal.
Komm, wir machen heute ein bisschen
hübscheres .NET.
Lass uns das mal ausprobieren. Wir machen hier ne neue
Datei. New File.
Extensions.cs
Extensions.cs
Also, wer Extension Methods
nicht kennt. Wir können ja auch ab und zu mal
ein bisschen was drum herum erklären.
Wer Extension Methods nicht kennt,
das gibt es seit Csh...
Ne, oder seit .NET
3.5 oder so. Das gibt es ewig schon.
Das ist ne Sache, die C++ beispielsweise
sehr gut tun würde.
Weil man dann den Standard-Kram, den die da drinnen haben
und der Sack ein bisschen erweitern könnte.
Aber, zum Beispiel, wenn man sich
jetzt mal hier die verfügbaren
Methoden anguckt. Oder, naja,
Methoden ist gut. Die verfügbaren
ähm, Felder
von Formatkontext.
Da sieht man jetzt,
es gibt Streams. Es gibt auch
die Anzahl an Streams. Aber
was es natürlich nicht gibt,
ist
irgendwas managed, was
sich gut in .NET integriert. Ist ja auch
klar, FFmpeg ist ne C-Library.
Das heißt, wenn man jetzt beispielsweise
eine Liste bekommen möchte
mit allen Streams, dann
muss man ne Schleife machen. Und das ist
ein bisschen unschön, auch ein bisschen unübersichtlich hier drinnen.
Deswegen könnten wir ne Extension Method
bauen, die alle Streams
zurückgibt. Und die können wir dann hier drauf
benutzen, wie als wäre
sie bei Formatkontext
definiert.
Ich tu mir immer bei
der allerersten Extension Method pro
Projekt, tu ich mir immer schwer, weil ich mir immer
Probleme hab, die
Syntax
mir in der richtigen Reihenfolge zu merken.
Also, es muss auf jeden Fall
schon mal static sein.
So viel ist klar.
Und die Methode muss auch
static sein. Public
static
ähm, gute Frage.
Irgendwie
getStreams
So, und
nun muss man
wie war das, this
und dann av
Formatkontext
nenn ich mal Context. So, okay.
So, wenn man das angelegt hat, dann
werdet ihr feststellen, sobald ich jetzt hier auf
Formatkontext gehe, richtig gemacht,
Formatkontext,
hier taucht meine
Streams Methode auf, so als wäre
sie auf Formatkontext
definiert. Das ist enorm praktisch
und Leute, hätte C++ sowas,
wäre auf einen
Schlag C++
um die Hälfte besser.
Also immer noch nicht geil,
aber besser.
Weil du dann den ganzen
eingebauten Shit, den die nicht auf
die Reihe kriegen,
über irgendwelche zusätzliche
Extension Libraries fixen könntest, ja.
Du könntest zum Beispiel ja die
Stringklasse ordentliche Methoden
geben, dass man damit auch was anfangen kann.
Man könnte beispielsweise
Vector und
den ganzen Containern ordentliche
Filtermethoden geben.
Aber das geht nicht, weil C++ keine
Extension Methods kann.
Also, ich finde, ich finde,
magst du Senf? Ah, du bist auch mal wieder am Start.
Nice. Ich habe heute Senf gefuttert.
Ich habe heute Lachs mit, Nudeln mit
Lachs gefuttert und da war ein bisschen Senf dabei.
So, so, süßer
Senf.
In der Soße drin.
Ich hoffe, du bist jetzt glücklich.
Du fragst das ja schon seit zwei Jahren oder so.
Magst du denn C++ nicht?
Doch, doch, beste.
Ach so, Max hat das gefragt. Ja, dann ist es...
Dann weiß ich, wie es gemeint ist.
Muss die File
dafür Extensions heißen? Nein.
Die File muss nicht Extensions für heißen.
Ich nenne das einfach jetzt gerade so.
Wichtig ist das hier.
Es muss in der Static Class sein
und es muss selbst Static sein
und am Anfang muss es eben
die, das Struct
oder die Klasse haben.
Ich glaube, für Struct geht das auch.
Das ist doch ein Struct, oder?
Die Struct oder die Klasse mit das davor
auf welche du erweitern willst.
Und das können wir jetzt machen.
Jetzt gehen wir einfach hier hin und sagen
Extensions Methods. Wir kopieren uns das
hier raus.
Kopieren uns das hier raus.
Context, Streams, Streams
mit Video. Wir können es sogar
filtern lassen. Ist eigentlich auch nicht verkehrt.
Können wir hier sagen.
Noch so als Zusatzoption hier.
Type.
Als Zusatzoption, dass man das filtern kann.
So. Type.
Das muss unsafe sein, weil
Pointer geht uns.
Sortieren.
So.
Was hat der jetzt für Schmerzen?
Achso. Ja.
Streams.
Stream gleich
Type.
Das können wir eigentlich fast so benutzen.
Mit dem Unterschied, dass wir jetzt noch eine Liste brauchen
oder sowas. Streams gleich
New Lists
AV Stream
Streams
Add Stream
So. Und das müssen wir jetzt dereferenzieren.
Sonst funktioniert es nicht. Weil in Generics kann man
keine Pointer packen in C Sharp.
Und dann am Ende
Return Streams
Und das hier
Ne. Wir wollen keine Liste. Wir haben Return
eine Read
Read Only
Liste.
So. Und schon
können wir uns das hier alles viel einfacher
machen. Guck mal. Wir können diesen ganzen Shit
hier einfach wegschmeißen.
Moment. Hier. Habe ich ja schon.
Diesen ganzen Kram, den wir hier eben gehabt haben, können wir wegschmeißen.
Einfach jetzt sagen. Formatkontext
Get Streams
Get Streams
Gefiltert nach
Video
Gefiltert nach Video
Und davon den ersten.
Zack.
Und schon haben wir anstatt
diesen ganzen Krempel hier
in line stehen. Was will der hier
eigentlich von mir?
Make Enamorable. Ne.
Machen wir nicht. Anstatt
diesen ganzen Krempel hier zu stehen
haben wir jetzt
was relativ übersichtliches, wo man
jeder so. Wo denke ich mal jeder
halbwegs versteht, was es
was es macht. Ja.
Manchmal wünschte ich mir, ich könnte proprimieren oder so.
Dann sehe ich das hier und denke mir Glück, dass ich sowas nicht mache.
Wieso?
Ich verdiene damit nicht mein Geld.
Zumindest nicht. Hauptsächlich.
Und es macht auch überhaupt keinen
doch nice sich damit zu beschäftigen.
Du musst ja nicht gleich sowas bescheuertes machen
wie ich hier.
Mit drei verschiedenen Sprachen. Interop
und Lowlevel, WebRTC
FFmpeg Geschiss.
Das machen die meisten Leute ja auch nicht.
So. Jetzt haben wir den Stream
hier am Start. Jetzt können wir
das gleiche wieder machen.
Index. Nur das ist jetzt
deutlich.
Okay. Achso.
Bin verwirrt. Was ist das Problem?
Achso. Ja.
Wenn man das mal richtig schreiben würde.
Packet
Index.
So.
Und jetzt sollte es funktionieren.
Und übersichtlicher sein.
Jawoll. Er lest den Stream noch aus.
Nice. Gut.
Jetzt können wir auch
schon mal gleich probieren.
Proof of Concept mäßig.
Ob das funktioniert.
Wir werden jetzt mal den Stream
senden.
An den Browser.
Mit WebRTC.
Da bin ich enorm
gespannt ob das funzt.
Task Run. Das ist by the way
nicht the way
das zu machen.
So ein einzelner Task am Anfang
mit nur einem Dings und unsaved
und ohne Exception Handling und nix.
Das packen wir am Ende in irgendeinen
Background Service.
Der dann automatisch gestartet wird am Anfang.
Aber zum testen ist das jetzt erstmal okay.
Okay. Starten wir das mal.
Es läuft. Unser Browser
funzt auch noch. Gut.
Dann können wir jetzt mal versuchen den Stream
an den Browser rüber zu senden.
Chatgear. Ihr dürft mal grad euren
Senf dazu abgeben ob ihr denkt dass das funzt.
Wir machen mal kurz eine Abstimmung.
Geht gleich
das Video im Browser.
Geht gleich das Video im Browser.
Ja. Auf keinen Fall.
Bin mal gespannt.
Also was wir jetzt machen müssen ist
die Videoframes die wir von hier
bekommen rüber senden
über WebLTC also von hier
in Rust und Rust sendet es an
Browser. Das bringt dir aber dann
nicht die Vorteile davon.
Ich streame ja meine
Designology streamt ja nicht
über WebLTC in deinen Browser.
Oder gut vielleicht können die das auch.
Hast du im Browser ein Websocket
auf? Nö. Warum?
Ich hab ne WebLTC-Verbindung offen.
Ihr seid aber äußerst
zuversichtlich dass das funktioniert.
Also ich glaube nicht dass das funktioniert.
Allein schon aus dem Grund weil ich nicht glaube
dass das Video im richtigen
Format ist. Es ist zwar
grundsätzlich im richtigen Codec aber wahrscheinlich
nicht im richtigen Format.
Ja du kannst dir das auch mit nem Java Applet Plugin
im Browser angucken.
Von ner 10 Jahre alten China Kamera.
20, 30 Jahren alten China Kamera.
Also irgendwie angucken kann man sich das immer.
Du kriegst nicht beispielsweise alle deine 6
Webcams in Echtzeit auf die gleiche
Webseite. So.
Dann schauen wir doch mal ob wir das rübergeschickt
bekommen an WebRTC.
Also Interop
Rust. Eigentlich könnte
ich den Go-Interop Teil doch mal raus
schmeißen. Und
nur noch Rust oder?
By the way was hat der?
Okay.
Wir haben sowas wie SendFrame.
Das ist eine Methode die
gibt es schon in Rust. Und zwar ist das
die hier. Guckt.
SendFrame. Was die macht ist folgendes.
Die braucht als Argument eine ID
vom Track
für den ein Frame gesendet
wird. Die Länge
von den
Bytes
und ein Pointer zu den Bytes.
Also die Länge von den
Videodaten
und die Videodaten an sich.
Und dann sucht sich
es den Track raus mit dieser
ID. Übrigens guckt mal Leute. Ich habe
hier in Q-Rust manuell gelesen.
Da kann man sowas hier machen.
If let someTrack
und
wenn TrackID was
findet dann steht das in someTrack.
Ansonsten findest du das nicht.
Habe ich im Rust
Handbuch gefunden.
So. Und was der
macht. Der nimmt sich die
Länge. Der
nimmt sich den Pointer. U8
ist ein Byte in Rust. Weil es gibt keine
Bytes in Rust. Es gibt nur U8.
Also unsigned
im Prinzip. Unsigned
8 Bit. Man könnte sagen
halt ein Byte.
Aber in
in Rust ist es U8.
Ich meine es gibt bestimmt auch I8.
Oder so. Gibt es das nicht.
Es ist aber. Es ist halt. Es sind 8 Bit.
Ist halt ein Byte. So.
Und dann kann man sagen. Man möchte
einen Slice bauen. Das ist Rust Logik.
Von
aus den Raw
Parts. Die Raw Parts sind der Pointer.
Und die Länge.
Und das hat den Vorteil. Wenn man da einen Slice
draus baut. Das es nicht
kopiert werden muss.
Ein Slice ist in Rust quasi
so ein Manage. Das ist das falsche
Wort. Ein
halbwegs Memory Safe
View
auf Speicher.
Nachdem das ja hier mit Pointer Magic ist.
Musst du das auch in Unsafe Rust machen.
So. Und danach
baut er ein Video Sample draus.
Das habe ich mir in der Hilfe angeguckt.
In der Library.
Bei Data müssen eben dann.
Muss der Byte Slice gesetzt werden.
Und bei Duration. Da bin ich noch
ein bisschen planlos.
Bei Duration habe ich im Example gefunden.
Eine Sekunde. Aber das ergibt ja keinen Sinn.
Weil ein
Frame ist
ja bei 60 FPS
nicht eine Sekunde lang.
Das ergibt ja
keinen Sinn.
Und dann schreibt er es in den Track und schickt es an den Browser.
Rust das Spiel.
Ja.
Genau.
Wir bauen gleich die Base.
Ich habe ehrlich gesagt Leute.
Ich habe noch nie Rust gespielt.
Ich kenne das nur aus ein paar Videos.
Aber das ging voll an mir vorbei.
Ex-Kollege von mir auf der Arbeit.
Müsst ihr euch mal vorstellen.
Der war voll im
Rust Game am Start.
Und der hat
das auf der PS4 gespielt.
Und er hat auf das mal Nachtschicht gehabt.
Und er hat zur Nachtschicht
seine PS4 mitgebracht auf die Arbeit.
Und hat dann dort auf dem großen Fernsehen
Rust gespielt.
Also soweit der Rust Part.
Ich hoffe das klappt.
Was ich mir hier ausgedacht habe.
Ich glaube so kurz war der Rust Hype gar nicht.
Es gibt immer noch Channels die ziemlich
viele Views damit generieren.
Ich glaube das hat immer noch ziemliche
Dedicated Followers.
Was einen kurzen Hype hatte.
Warum Ex-Kollege?
Weil ich nicht mehr da arbeite.
Dieses...
Es gab doch von den Rust Herstellern so Nachfolge Games.
Das hat glaube ich
nicht so viel Anklang gefunden.
Gucken wir was Rust.
Sorry Leute ich habe euch Mist erzählt.
Der hat gar nicht Rust
gespielt.
Der hat nicht Rust gespielt.
Ich habe das verwechselt.
Wie heißt das Survival Dings?
Ark hat der gespielt.
Nicht Rust.
Auf der PS4.
Was ich entwickle.
Das du Webcam Streams per WebRTC
in den Browser schicken kannst.
Ey Rust hat
auch nicht viele Spieler noch.
Ark hat der gespielt.
Oder Ark.
Nicht Arch Linux.
Hat auch noch.
Ist jetzt auch nicht übel oder?
Weil Rust ist natürlich...
Aber ist auch nicht übel für so...
Weil das Game ist jetzt ja auch nicht...
Was ist denn da...
Ist das ein neuer Part?
Was ist denn da der Unterschied?
Das gibt es erst.
Das gibt es erst neu.
Also das hat sich auch gut gehalten.
Ihr kann es nicht sagen.
Da sieht man halt wieder was langlebige Games ausmacht.
Das gab es auch noch?
Ich blick da nicht durch.
Was zum Teufel ist Survival of the fittest?
Das ist Battle Royale Ark oder was?
Ich blick da nicht mehr durch.
So machen wir mal weiter.
Send Frame.
Ok. Schauen wir mal ob das funzt.
UID.
Track ID. Track ID weiß ich.
Track ID von oben.
Länge.
Jetzt wird es etwas
komplizierter.
Packet.
Wenn ich das richtig in Erinnerung habe.
Es gibt in...
Es gibt in dem Packet einmal
Data und Size direkt.
Und es gibt
Buffer Data und Size.
Ich bilde mir ein,
dass ich damit schon mal
Tage verbracht habe
zu debuggen, warum ein Video
nicht richtig funktioniert.
Boah.
Zwei, drei Jahre.
Und ich bilde mir ein,
dass Data
aus Packet direkt
nicht richtig
benutzbar war.
Aber Data aus dem Buffer
aus irgendwelchen Gründen
gut funktioniert.
Ich kann euch nicht erklären warum.
Ich weiß nur, dass ich
da tagelang rum probiert habe.
Deswegen nehmen wir das
jetzt gleich mal hier.
Da gibt es auch Buffer und
Data und Size.
So. Size brauchen wir.
Also was brauchen wir als erstes?
Size und
Data.
Ok. Funzt aus irgendwelchen Gründen nicht, weil
Byte Sternchen ist not assignable
to Endpointer.
Dann werden wir einfach... Moment.
Dann werden wir das einfach
casten zu Endpointer.
Das ist ja nur mit casten los.
Dann funktioniert das.
Ok. Also.
Von der Theorie her sollten jetzt
Daten von
meinem Backend
an den Browser geschickt werden.
Ich lass hier nochmal kurz was ausgeben.
Dass ich auch weiß, dass
der das immer, immer
schickt. Und jetzt müssen wir
die Frontend
Seite bauen. Also.
Nach dem Verbindungsaufbau werden auf jeden Fall
Daten an den Browser geschickt.
Jetzt müssen wir dem Browser noch beibringen.
Öh. Geh mal weg.
Jetzt müssen wir dem Browser noch beibringen
diese Daten in das Video, hier in den
Videoplayer zu schreiben.
Oh. Wie ging das nochmal?
Also. Wir bekommen den Video Track
irgendwo
irgendwo hier. Track. Hier.
On Track.
Und den Track, den kann man
irgendwie setzen. Ich weiß aber wirklich nicht mal
genau wie. Da müssen wir mal
das Internet befragen gleich.
Wie man das hier als
als Daten setzt für
den Videoplayer.
War Arc nicht übel unperformant? Ja.
Aber das Arc ist auch alt. Mittlerweile
wird es wahrscheinlich auch auf
ordentlicher Art und Weise ganz gut laufen.
So. Also.
Document. Get Element
by ID. Pass auf hier.
Richtiger Frontend Champ wieder am Start.
Let Player.
So.
Warte mal.
Und jetzt weiß ich nicht weiter. Player.
Okay. Das muss ich im Hinterhand nachgucken.
Video Element
Web RTC Set Stream.
Changing Moving Video
Element.
Ne.
What? Was?
Nein.
Das ist auf jeden Fall. Okay.
Was macht der Dude hier überhaupt?
Was macht der hier?
Das da. So was brauche
ich. Genau.
So was. So was in der Richtung. Okay.
Also.
Ja.
Source Object.
Gibt das so was hier? Source Object.
Moment.
Null. Okay. Das heißt aber das
gibt es. Das. Oder?
Wobei es ist JavaScript. Shit.
Man weiß nicht ob es das gibt.
Okay. Source Ob.
Object. Und was jetzt?
Web. Okay. Wie. Oh. Meine Güte.
Funzt denn das?
Ähm.
Track. Was hat denn dieses Track Element
hier drinne? Streams.
Track.
Was ist jetzt der Unterschied
zwischen dem Track und dem Stream?
Track. Media Stream.
Was? Media Stream
Track?
Und hier oben gibt es ein Array mit
Media Streams.
What the fuck? JavaScript.
Wer denkt sich den Scheiß immer aus?
Alter.
Und was davon soll ich jetzt benutzen?
Streams. Okay. Track.
Kein Video.
Okay. Wir verwenden Track.
Player.
Source. Object.
Ah. Ne. Ne. Ne. Okay. Wir brauchen doch.
Ich glaube. Ich glaube wenn ich es mir recht.
Ich glaube wenn ich es mir recht überlege brauchen wir wahrscheinlich doch
den Stream. Weil ein Track
kann mehrere Streams enthalten.
Also brauchen wir wahrscheinlich
doch den Stream.
Ich denke wir brauchen doch den Stream. Aber wir probieren es mal aus.
Wir setzen mal Track. Gucken was dann passiert.
Uncored.
Track is not defined. Achso. Ja.
Track.
Fail to set source object.
Ja. Toll.
The provided value is not of type
media source handle or media stream.
Okay. Hey. Okay. Leute.
Wir sind nicht die einzigen die den Fehler machen.
Sonst hätten die im Leben nicht diese idiotensichere
Fehlermeldung eingebaut. Dass man weiß man muss
das andere verwenden.
Na gut. Idiotensicher ist bei JavaScript nix.
Ne. Funst net. Shit.
Sadge.
Sadge.
Das wäre jetzt auch zu einfach gewesen.
Wenn das Video einfach anfängt
zu spielen.
Ich weiß nicht woran es liegt.
Entweder liegt das daran
dass das Video in der
Okay. Wartet mal.
Was für einen Codec hat denn das Video?
Also äh. Nicht Codec.
Was für ein
Geht das jetzt eigentlich von vorne los?
Ähm. Wartet mal.
FFprobe
Main
Das Video hat den falschen
Das falsche
Profil.
FFmpeg
Constraint Base oder sowas.
Base hieß das doch.
Constraint Base
Line Profil was man braucht dafür.
Wobei es eigentlich auch so
funktionieren sollte.
Du musst glaube ich url create media url
Ne. Glaube ich net.
Ich hab das ja auch schon gemacht und ich bilde mir ein.
Wobei Leute ich hab das schon gemacht.
Cool. Warum guck ich hier einfach nach?
Best Logo
Ähm. Guck ich hier einfach nach?
Äh. What the fuck?
Ähm. Source
Oh alter. Ist das noch ne Vue.js
App man?
Hab ich denn da gebaut man?
Views. Home
Streams
Ach das hab ich mit Magic
View Sachen gemacht. Streams
Cam ID
Wo kommt Streams her?
Oh. CraftQL
Max. Was zum Teufel hab ich da
auferengineert?
CraftQL
Alter was hab ich da gebaut?
Ok. Keine Ahnung.
Ich checks nicht mehr was ich da gebaut hab.
Nice. Sehr gut. Excellent. Excellent.
Ok.
Das. Das wollen wir haben. Ok.
Ich muss das. Leute ich muss das. Ich muss das
reincarnen das Video glaube ich.
Das ist normalerweise nicht notwendig.
Ich bin mir aber nicht sicher ob ich
re-enconen muss.
Ich bilde mir ein. Ich hab auch schon Video
Streams mit Main Profil. Ok.
Input. Mein
mp4
Profile high. Nein nein.
Base
Profile
Baseline. Level ist mir
vollkommen egal. Copy Audio haben wir
nicht. Wir machen Audio none.
Und ja.
Output mp4. Wunderbar.
Was?
Achso. Copy geht ja nicht.
Boah ist das
super lahm.
Aber wobei. Geht eigentlich.
Warte mal.
H264 FFM Pack.
Very
Fast. Das konnte man doch aussetzen.
Preset. Preset
Very Fast.
Preset Ultra Fast.
Super Fast. Very
Fast. Meine Güte.
Jetzt übertreibts halt mal FFM Pack.
Ok. Es ist. Ok.
Ich hab nichts gesagt. Es ist noch
deutlich schneller. Ultra Fast.
Das ist
auch written in Rust. Blazingly Fast.
Ok. Das flutscht.
Das juckt. Das flutscht.
Guck mal. Schon 4 Minuten
vom Video einfach encoded.
Das Video selbst war ja nicht so lang.
Ne. Das Video.
Wie lange war das Video? Irgendwie 7 Minuten oder sowas.
Also. Gucken wir mal.
Output.
Guck mal. Ist mein FF...
Ist mein VLC
irgendwie ein bisschen im Arsch? Kann das sein?
FFPlay hat überhaupt
keine Probleme mit dem Video.
Ok. Also dann probieren wir es doch mal mit
Output.
Probieren wir es doch mal mit dem anderen.
FF...
FFM Pack.
Streamloop. Output MP4.
Output MP4.
Deine Augen sehen FFM Pack.
Auf der Command Line.
Und FFM Pack C Library.
So. Schauen wir mal ob es jetzt funktioniert.
Ok. Pregge Time. Pregge Chat.
Pregge. Shit.
Es funzt nicht.
Kein Video im Browser.
Ich vermute das liegt daran.
Weil die Duration
nicht stimmt. Guckt mal.
Eine Sekunde ist komplett
bescheuert. Das Sample ist ein paar
Millisekunden lang. Komm. Wir testen
mal was. Wir sagen hier From.
From Milli. Nicht Micros.
Micros ist vielleicht ein bisschen übertrieben.
Von Millisekunden.
Sagen wir mal. Ok. Chatge.
Das Video hat glaube ich 60 FPS.
60 FPS heißt
ein Frame alle 16
Millisekunden. Korrekt?
QuickMuffs?
Nein. Ich weiß es aus dem Kopf.
Das sind 16,6 Millisekunden.
Also ich habe das nicht. Ich habe es nicht
ausgerechnet.
Ok. From Millis. Machen wir einfach mal 16 Millisekunden.
Ok.
Gucken ob es jetzt funzt.
Sucked.
Denken sich denn überhaupt meine
Argumente hier. Ok. ID.
Länge.
Pointer.
ID. Länge. Pointer. Ne passt.
Ähm.
Was ist damit?
Ah. Millisekunden hier.
Cargobild.
Ja aber das muss auch so funktionieren.
Weil die China-Chinesen Streams von den Kameras
die entsprechen auch keinen Standards.
Ok. Prage. Prage.
Shit.
Fuck. Warum geht das nicht? Was mache ich? Ok.
Ich mache irgendwas verkehrt. Chat.
Ich muss. Ich muss irgendwas verkehrt machen.
Ähm.
Weißt du nicht was?
Ok.
Wir starten mal das hier neu.
Und wir
starten mal das hier neu. Ok. Ok. Alles klar.
Ok. Mal gucken. Mal gucken
ob auch das Richtige hier passiert.
So. Ähm.
Buffer.
Size. Gucken wir mal wie groß
das ist was der da ausliest. Ob das überhaupt
irgendwie schlüssig Sinn ergibt.
Ok.
Buffer. Size. Das sind immer so 15
15 äh 15k
oder so.
Ja oder 20k oder sowas.
Ja das funktioniert. Das klappt
nicht.
Ist ja ganz schön scheiße Mann.
Warum geht das nicht?
Jetzt bin ich gerade
was. Komm wir gucken mal ob es in Firefox
geht. Firefox ist ja manchmal ein bisschen
umgänglicher.
Show Controls.
Ok.
Da geht nix.
Aber warum geht da
nix? Liegt es an
meinem Video?
Liegt es an
meinem WebRTC Kram?
Bei dem On Track
bekommst du dann nur ein Track und ein
Medias. Äh ein Track. Ich bekomme
einen Track in dem Medias Streams.
Guck da.
Dann nehme ich den ersten davon.
Mal gucken was ist wenn man den
wenn man den ausgibt was
Javascript dann da sagt.
Das ist Streaming Platform.
What?
I don't understand the question.
C Sharp im Backend. Ja.
Backend und Rust.
Backend im
Backend C Sharp und Rust.
A Time of Project.
I try to read
RTSP Streams from
China Webcams
from China Cameras
and extract the frames
and send it via WebRTC
to the browser.
I have already implemented
something similar
in Go and it works but in
Rust it does not work.
So. Aus irgendwelchen Gründen
findest du das nicht.
Woran könnten das liegen?
Hier. Medias Stream.
Active. True. Lolwee.
Also ich.
Warum beides?
Warum nicht?
Achso. Du meinst
warum Webframework in C Sharp
und WebRTC in Rust?
Das ist ganz einfach.
Weil ich keinen Bock habe mir mehr als notwendig
in Rust anzutun.
Ich würde mal sagen.
Nachvollziehbar.
Ich würde mal sagen
mein Frontend Zeug
Ich weiß nicht ob mein Frontend Zeug funktioniert.
Das ist das Problem.
Also ich würde mal drauf tippen
mein Frontend Shit funktioniert halbwegs.
Frontend noch mit Go testen.
Den Part habe ich hier
in Go nicht eingebaut.
In VLC testen. VLC funktioniert.
Ist gar kein Problem.
Aber VLC geht ja auch einen komplett
anderen Weg.
Okay VLC FF Play.
Das geht ja auch einen komplett anderen Weg.
Das geht direkt auf meinen Test
RTSP Stream.
Naja.
Und nicht über WebRTC.
Nehmen wir einfach mal von aus
mein Frontend Zeug
funzt.
Wir tun einfach mal so.
Mein Frontend Kram tut.
Was könnte kaputt sein?
Mein FFmpeg Zeug
könnte kaputt sein?
Oder
mein Rust Zeug könnte kaputt sein?
Ich konnte ja
beides nicht testen
bis jetzt.
Ja.
Also ich glaube
der hat Schmerzen mit der Duration.
Wobei 16
Millisekunden ziemlich gut hinkommen.
Lass uns das doch mal
ausrechnen hier in Dotnet.
Das hier
das hier stimmt. Alles okay.
Lass uns das doch mal ausrechnen.
Es gibt doch hier eine
Package Duration oder sowas
in der Richtung. Genau.
Rust App kompiliert
also passt das. Die Chancen sind bei Rust
auch wie bei keiner anderen Sprache.
Okay.
Es ist immer 1500.
Moment ist das Video überhaupt
60 FPS?
FF Probe.
60 FPS.
Okay.
Wir rechnen einfach mal die
Duration aus. Okay.
Also.
Wie ging das jetzt nochmal?
Ist sonst. Okay lass mal überlegen.
Ist sonst irgendwas
doof von dem was ich hier mache.
Es ist auf jeden Fall
ein Video Stream.
Es gibt ja auch nichts anderes
als Video Streams bei mir gerade
hier drinnen.
Also mir fällt jetzt echt
nicht ein woran das liegen könnte.
Okay.
Lass uns mal die Duration. Ich tippe immer noch
auf die Duration. Lass uns mal die
Duration ausrechnen. Also in
Millisekunden.
Duration of this Package
Moment was?
Duration of this Package
in AV Stream
Time Base Units.
Okay. So eine Duration
in Millisekunden oder Mikrosekunden
wäre auch glaube ich deutlich zu einfach gewesen.
Aber es ist FFM Pack.
Die haben wahrscheinlich echt einen guten Grund dafür.
Also in was? In Stream.
Time.
Was? Time Base.
Kannst du schauen ob
was im Client ankommt über den Netzwerk Tab.
Du hast. Das ist eine gute Idee.
Das ist eine wirklich gute Idee. Nicht über
Netzwerk Tab.
Und Netzwerk Tab geht das nicht mit WebRTC.
Aber wir können in den WebRTC
Analytik in der
Analytics Seite gucken.
Ob was ankommt.
Irgendwo hier.
Wenn ich jetzt wüsste wie.
Oder
kommt das nur auf Firefox?
Stats Graph.
Stats for Transport.
Guck mal hier.
Bytes Sent. Bytes Received.
Der kriegt was. Guck mal.
Der kriegt Videodaten.
Nur zeigt er nichts an davon.
Ok.
Er kriegt Videodaten. Das ist schon mal gut.
Das ist eine gute Idee gewesen.
Also das Streamen von
was auch immer.
Funktioniert.
Machen wir das ganze nochmal.
Ich kommentiere das mal aus.
Und wir starten das jetzt nochmal.
Ich glaube ich habe
irgendwas einfach eben bei mir verkehrt.
Oh.
Crafts.
Ok. Jetzt wird nichts Received.
Was richtig ist.
Ok. Es ist auch viel weniger hier.
Jetzt wird nichts mehr Received.
Großartig.
Weil ich habe es ja auch auskommentiert.
Ok. Lassen wir es mal einkommentiert.
Ok. Woran könnte das ganze liegen?
Duration. Wie rechnet man diese
Kack Duration aus?
In Time Base Units.
Was? Oh.
Oh ne. Quick Maths.
Complex Numbers.
Was ist denn?
Und was ist Num?
In dem Fall.
9001. Ok.
Muss man die Frames
terminaten oder so? Normalerweise nicht von Hand.
Das macht eigentlich die Library
für einen.
Ich gehe davon aus, dass hier irgendwas
stimmt hier nicht.
Also lasst mal die Duration ausrechnen
von so einem Frame.
Die Frage ist, wie rechnet man die Duration von so einem Frame aus?
Also ich habe aus
irgendwelchen Gründen
habe ich jetzt hier
die Infos 9001
und Duration
1500.
Zweimal Result.
Ne, das ist kein Problem.
Wir sollten aber, Chatge,
wir sollten aber
tatsächlich
das mal
überprüfen, ob das Result
ob das Result
auch wirklich
0 ist.
Weil wenn es nicht 0 ist, dann klappt das Lesen des Streams
nicht.
Result ist 0. Ok, das Lesen vom Stream
funzt.
Ja.
Funktioniert, ok.
Das wäre jetzt zu einfach gewesen, wenn da irgendwas...
So, wir machen das auch nochmal anders.
Wir sagen hier if.
Wenn das hier nicht gleich ist, dann
sagen wir continue.
Ein bisschen einfacher zu lesen
hier unten.
Ah.
Ok, so.
Also wie rechnet man diesen Krempel
aus, man?
Wie rechnet man das aus?
Da muss ich die Kugel befragen. Ok.
FFM Pack.
Packet, Duration,
Timebase.
Timebase working for
Video, ok. How to set
Duration always
0. Question about
Packet Duration.
Oh.
Gucken wir mal.
Seconds, irgendwie.
Kein Plan.
Keine Ahnung.
Gibt das Sinn? Ich weiß nicht, ich kann das mal machen.
Ich hab mich jetzt noch gar nicht gecheckt,
was mir diese Sachen überhaupt sagen sollen.
Aber wenn der Chat
das meint, wir können das mal ausprobieren.
Also
was meinst du?
War.
Duration.
Millisekunden.
Also was jetzt hier?
Stream.
Timebase.
Num durch
Stream.
Timebase.
Denn die
Camps stehen in China. Nein.
Das sind Chinesen
Camps.
Die
von
Chinesen Herstellern.
Ok. Duration
Millisekunden. Da sollte irgendwas wie 16 rauskommen
jetzt. 0.
Ah, ich weiß, woran es liegt.
Der ist wieder zu dumm.
Das sieht nicht richtig aus.
Naja, wobei, warum eigentlich nicht?
Das sind Sekunden
jetzt, oder? Und was ist, wenn man
das hier umdreht?
Nicht, dass ich wüsste, was ich mache, oder so.
Äh, nein.
Das funktioniert nicht.
Moment, Moment, Moment.
Da fehlt ja auch noch Package Duration
in dem Ganzen.
Moment, Moment, Moment.
Moment, Moment, Moment.
Package Duration fehlt ja dann noch.
Da muss ich Hack it.
Hier.
Hack it Duration
mal
das da.
Ok.
So.
Und das sollte jetzt die Duration pro Package.
60 FPS
hat das Video.
Das sieht gut aus.
Das sieht gut aus. 16 Millisekunden, sage ich doch.
16 Millisekunden.
Du, du, du, du.
16 Millisekunden.
Das sieht gut aus.
Das dumme ist nur, dass ich 16 Millisekunden
eingestellt habe in Go schon.
So, ziemlich hardcoded.
Äh, nicht in Go, in Rust.
Vielleicht ist mein Video aber auch einfach
Kacke.
Wobei, ich hab's
re-encoded mit FFmpeg.
Also, da hätte ich eigentlich vermutet,
dass
Funst besser
stream ich überhaupt das richtige Video?
Ja.
Mach ich.
Gibt's da keine Sample-Videos? Doch, sicherlich.
Sicherlich.
Aber ich wüsste nicht welche.
Stimmt. Gibt's halt.
Ok, komm. Wir machen jetzt einfach mal hier. Duration?
Ne, ne, ne, ne.
Keine Rust Duration.
Äh, Duration, äh, Double.
Ähm, oh.
Alter, was ist ein Double?
Ein Bloat?
Ein F64
oder sowas? Ok.
Ok, Duration.
Was will er nicht?
Oh Gott, jetzt.
Ernsthaft?
Er frisst keine Floating Point Units
bei Duration?
Was ist das schon wieder für ein Schrott?
Muss ich das jetzt selbst umrechnen, oder was?
Was haben wir denn da zu bieten?
From?
From Seconds, from Millis, from Micros.
Ok, from Micros.
Also, also, ok.
Äh, let
Micros?
Äh, Duration mal, äh,
mal 1000, ha?
Pfeifferta...
What?
What?
Cannot multiply F64 mit Int.
Oh Gott, Rust! Rust!
Ähm...
Debated!
Oh shit, jetzt geht das andere nicht.
Und der, und der will, der will ja keine Floats.
Rust!
Please, mach's mir doch nicht so schwer immer.
Hey, vielleicht jeden zwei, jeder
zweimal fragt. Ja, das kommt öfters vor, aber...
das macht nix.
Aber was empfiehlst du als erste Programmiersprache?
Welche hat man mehr Arbeitsperspektive?
Python oder Javascript?
Ich bin 28 und will meinen Job programmieren.
Ähm, also.
Beides ist gut zum Einstieg.
Ich empfehle Javascript zum Einstieg aus dem einfachsten Grund,
aus dem ganz einfachen Grund,
weil Javascript die noch kleinere Einstiegshürde hat.
Javascript
brauchst du, zum Beispiel Studio Code
und Browser, fertig, kannst du anfangen.
Und du lernst ein bisschen Frontend Zeug,
was ganz nice ist, weil man das immer braucht.
Egal was man macht, ein bisschen Frontend
CSS, Javascript, HTML
brauchst du immer.
Es ist schade, definitiv nie sich
damit auszukennen. Ja.
Und du siehst
halt visuell auch was, wenn du, wenn du
was baust, ja. Ich würde dir gar
kein Javascript Framework empfehlen, wenn du
erst anfängst. Einfach ein bisschen
sich die Sprachbasics angucken.
Du kannst aber auch mit Python anfangen, es sind beide gute
Sprachen zum Einstieg. Es gibt noch mehr gute Sprachen
zum Einstieg. Solange es
nicht gerade C++ ist oder sowas.
Die Sprache ist
noch nicht mal, also
weder für Einstieg noch für irgendwas anderes
gut. Aber
Python und Javascript ist beides nice. Ich würde
sagen, wenn du dir schon grob
vorstellen kannst, auf was du Bock hast,
dann würde ich die
Sprache danach aussuchen.
Also wenn es dir mehr ist nach Frontend
Sachen oder vielleicht
Node.js. Und bei Node.js,
nun ja, mein Favorit ist es ja
nicht.
Dann Javascript, wenn du
vielleicht irgendwas AI und
Machine Learning mäßiges machen willst
oder so.
Bei den hippen Leuten sein willst,
dann eher Python. Also
hängt ein bisschen von deinen Vorlieben ab. Es ist beides
gute Einsteigersprachen. Ich persönlich würde
Javascript empfehlen, weil die Einstiegshürde
geringer ist. Was für ein Javascript.
Also wie gesagt, ich würde, wenn du anfängst,
gar keins empfehlen. Ansonsten
mittlerweile Svelte. Svelte ist mein Lieblings
Lieblings Framework zur Zeit.
Gut. So, das war's.
Das müssen wir jetzt erwarten. Okay. Wie kriegt
man das jetzt hin?
Wie kriegt man das in Rust hin?
Ein Float. Okay.
Rust F64 to
U64. Jawoll.
Das will ich
haben. Looks like
F64
two bits.
Obviously. Was sonst?
Ganz klar, dass diese Methode dafür
benutzt werden muss.
Two bits
U64.
Alter.
Ist was komplett anderes. Wirklich?
Converters. Doch. Das. Oder?
Doch.
Das ist. Das ist das.
Was? Reinterpret
U64. Doch.
Raw transmutation to U64.
Wobei.
Ne. Ne. Das ist nicht das, was ich
haben will. Du hast recht.
Der.
Dann hab ich auf einmal eine riesengroße
Nummer. Da hab ich nicht 16,
irgendwas. Sondern ich hab. Ähm.
Was bekomme
ich denn dann da raus?
16 Milliarden oder so.
Okay. Chat. Chat.
Das muss ich jetzt mal ausbringen. Keine Ahnung, was
da jetzt rauskommt.
Brindeln.
Rust.
Was jetzt? Ah ja.
Duration.
Duration.
Duration. Okay.
Give him.
Massive. Dann müssen wir das ganze
in .NET noch schnell anpassen, dass das funktioniert.
Double.
Double.
Duration.
Und jetzt
Duration.
Ist eigentlich egal, weil wir verwenden das eh noch nicht.
Ich will
jetzt bloß gucken, was der ausgibt.
Uh.
Nein, das ist echt nicht das, was ich
hab.
Der nimmt einfach die Bits und castet's quasi
zu nem 1 zu 1.
Das ist wirklich nicht das, was ich haben will.
Ach.
I mean, das sind from
seconds. Ich hab's doch als
milliseconds. Alter.
Rust. Was?
Into. What?
Okay. Into?
Ne, ne, ne, ne.
Chat. So einfach. So
einfach geht das nicht.
Ihr habt gesagt, ich soll
machen SU64.
Can be replaced.
Ach so. Ja, ja.
Micros.
Nice. Chat.
Ihr wisst Bescheid.
Pass auf. Ich wette, es geht immer
neu. Shit.
Mann. Es funktioniert nicht.
Okay. Jetzt glaube ich, dass es doch am Video
liegt.
So. Packages werden noch geschickt.
Okay. Okay.
Jetzt könnte es echt
am Video liegen, was
ich schicke. Das ist irgendein Mist.
Versuche ein Standbild zu senden.
Ich brauche ein Standbild im richtigen
Format. Das ist halt das Ding.
Mein H2.
Warte mal. FFm-Pack.
Wie habe ich das?
Das sieht doch eigentlich
gut aus. Das ist alles ziemlich 0 nach
15. Das müsste funktionieren.
Oder es
liegt am Frontend. Ja, ich schiebe nochmal
das andere Video rein.
Ne.
Ach, Kacke. Alter. Warum geht das
nicht? Ne. Aber
das stimmt quasi. Ich meine, es sind zwei Zeilen
Frontend. Guck mal hier. So. Video.
Wo setzt er das denn?
Es ist outdated, overrated,
jebaited, oder?
Das Source Object
gibt's. Okay. Wir machen das mal so. Aber ich glaube
nicht, dass das besser funktioniert.
FFm-Pack.
Äh. Das funktioniert nicht.
Das ist schon richtig
so hier.
Ich habe das ja schon mal gemacht. Das sieht
sehr nach dem aus, was ich in Erinnerung habe.
Ich glaube nicht, dass das
muss man überhaupt so
das jetzt machen, oder?
Gibt's nicht. Öffnen wir das mal.
Firefox. Okay. ID Player.
Funzt das denn überhaupt hier?
Warte mal. Gibt's...
Findet er hier was, was Player heißt?
Video Player.
Autoplay. Muted Play.
Okay. Seht ihr was?
Wir machen Autoplay mal weg. Wir machen Muted.
Und Controls anzeigen.
Ja, okay. Oh, der Scheiß
funktioniert nicht.
Source Object.
Ja.
Stream.
Und wo kriegt der Stream her?
Get User Media.
Ja. Okay, das ist schon richtig,
was ich mache. Gut.
Get User Media habe ich nicht, weil
das ist ja von der Webcam.
Es ist Source Object.
Was ist das denn? Warum funzt
das nicht?
Öffnen wir Firefox.
Haben wir doch vorhin schon gemacht.
Ne.
Source Object.
Ich habe keine Ahnung.
Ich habe keine Ahnung, was der für ein Schmerz ist.
