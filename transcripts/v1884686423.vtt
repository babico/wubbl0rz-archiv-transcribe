WEBVTT

01:42.900 --> 01:44.900
So leute da bin ich

01:45.060 --> 01:52.620
Heute werden wir uns mal kotlin angucken oder kotlin oder ich weiß noch nicht mal wie man das überhaupt richtig ausspricht ich glaube es ist kotlin

01:55.380 --> 01:57.380
Not not sicher ja

01:57.700 --> 02:07.160
Aber das heißt auch wir müssen uns wahrscheinlich mit ein bisschen sachen aus java beschäftigen

02:08.500 --> 02:10.500
Da bin ich aber unschlüssig

02:10.740 --> 02:12.900
Ob das nicht ziemlich paints champ wird

02:19.230 --> 02:22.590
Ist von jetbrains ist ja aber es ist ja wohl irgendwie auf

02:23.270 --> 02:30.270
Jvm basis und dementsprechend sind wir auch ziemlich so was die java standard library angeht dran geboten glaube ich

02:30.470 --> 02:33.550
Keine ahnung ich habe ich habe es noch nie großartig verwendet

02:34.190 --> 02:37.700
das ist so

02:37.820 --> 02:48.980
Monka java

02:48.980 --> 02:52.060
was

02:52.060 --> 02:54.060
Microsoft hat auch in java

02:54.540 --> 02:58.140
Das war mir noch gar nicht klar ich kenne nur das oracle java

02:58.780 --> 03:05.300
Beziehungsweise eigentlich ist es ja mittlerweile glaub sogar open jdk ja was ist eigentlich das habe ich nie verstanden leute

03:06.940 --> 03:09.700
Was ist denn der unterschied zwischen open jdk

03:10.500 --> 03:17.060
Und dem oracle java zeug ich dachte ich dachte eigentlich immer das ist das gleiche aber anscheinend ist es doch nicht das gleiche

03:17.060 --> 03:19.060
Und

03:19.340 --> 03:24.580
Was ich auch nicht checke ist was der unterschied zwischen java und java enterprise edition oder sowas ist

03:25.460 --> 03:27.460
Das sind so dinger die habe ich noch nie kapiert also

03:28.820 --> 03:31.580
Fiveheader java kenner können wir das bestimmt erklären

03:33.260 --> 03:38.580
Ach du meinst das ist nur für minecraft na klar das neue minecraft ist doch sogar glaube ich c++

03:39.740 --> 03:45.660
Also dass das neu implementierte minecraft was jetzt nicht 16g ram braucht

03:49.640 --> 03:52.200
Ich habe gehört da bricht doch öfters mal der vulkan aus

03:54.240 --> 03:59.960
Kommerzieller support ja aber ist das feature mäßig irgendwie irgendwie was anderes weil ganz ehrlich wozu brauche ich

04:00.080 --> 04:03.840
kommerziellen support für für die run time im endeffekt ich meine das

04:04.240 --> 04:09.120
Niemand holt sich für dort nett bei microsoft zu wobei ich will das will ich jetzt mal gar nicht so in frage stellen

04:09.200 --> 04:12.840
Vielleicht vielleicht gibt es das ja wirklich vielleicht kann man sich ja für dort netz sogar

04:13.400 --> 04:17.720
Support holen bei microsoft aber ich kenne ich kenne niemand der das bisher gemacht hat

04:20.350 --> 04:23.390
Okay das das ist der erklärung damit kann ich was anfangen

04:23.910 --> 04:29.790
Open jdk war open source nachbauen bis alle oracle gehasst haben dann ist es jetzt offizielle standard okay

04:30.430 --> 04:36.350
Und der standard den macht auch nicht mehr oracle sondern haben die auch so eine art c++

04:36.750 --> 04:41.230
gremium nur für java oder ein jvm gremium oder sowas

04:45.420 --> 04:50.060
Java enterprise hat auch noch mehr features aber wahrscheinlich nichts weltbewegendes oder

04:54.850 --> 04:56.970
Dürfte wahrscheinlich ein bisschen so sein wie

04:57.850 --> 05:00.850
Ich weiß es ist ein dummer vergleich aber ich bringe es trotzdem

05:01.210 --> 05:07.090
Dürfte wahrscheinlich ein bisschen so sein wie ja wie visual studio community versus visual studio professional

05:07.090 --> 05:09.090
Es hat auch ein bisschen mehr features aber die braucht keiner

05:09.490 --> 05:14.130
Soll ich mal kurz package updates haben wir zwar gestern schon aber arch by the way

05:18.260 --> 05:20.260
wer zum teufel

05:20.780 --> 05:23.660
Warum warum nennt man seine library abseil

05:24.660 --> 05:28.060
Abseilen ist für mich ein synonym für ich geh mal kacken

05:29.540 --> 05:35.380
Abseil was ist das github abseil c++

05:41.860 --> 05:45.820
Abseil ich glaube ich glaube das hat nichts mit abseilen zu tun

05:50.820 --> 05:52.820
Augmente standard library

05:56.090 --> 06:00.890
Er hat auch keine erklärung zu dem namen na gut was auch was auch installieren es einfach updaten gut ist

06:01.730 --> 06:04.210
Brauche hier noch mal andere packages updaten

06:08.540 --> 06:10.660
Es gab keine updaten das heißt wir müssen rebooten

06:12.100 --> 06:13.420
Reboot

06:13.420 --> 06:25.450
hat man wieder zeit für mod gehockt der max ist aber immer am start

06:26.450 --> 06:37.210
Der maxi quasi fast jeden stream ist aber ach max ist eigentlich hat es jetzt ich habe es gar nicht mehr im discord geguckt hat

06:37.210 --> 06:39.210
das jetzt alles funktioniert

06:39.650 --> 06:41.650
Mit neuen domains

06:42.610 --> 06:44.610
Wenn wir gerade dabei sind

06:46.130 --> 06:48.130
Das kommt darauf an was man machen will

06:49.410 --> 06:54.930
Läuft okay ich mache mal kurz discord auf ich habe das schon tagelang nicht mehr reingeguckt kurz schauen

06:58.000 --> 07:00.000
Jemand hier rum gespampt hat oder so

07:02.200 --> 07:10.940
Was ist da

07:10.940 --> 07:13.100
Oh nice da bin ich mal gespannt bis ich nachher lese

07:17.500 --> 07:18.700
okay

07:18.700 --> 07:31.300
Ja also wie lange das dauert bis man bis man sich eingearbeitet hat das hängt ganz entscheidend davon ab was du machen willst also

07:34.000 --> 07:39.120
Als erstes musst du dir mal überlegen in welche richtung das gehen soll der einfachste einstieg ist tatsächlich

07:39.640 --> 07:44.640
Du schnappst dir einen browser und einen texteditor und machst ein bisschen javascript um dir das anzugucken

07:45.480 --> 07:52.080
Kannst du dich auch gleich ein bisschen mit html und css auseinandersetzen kannst du webseiten bauen beziehungsweise interaktive webseiten oder halt

07:53.360 --> 07:58.800
Applications wie man das heute nennt weil webseiten alleine klingt ja zu langweilig webapplications kannst du dann bauen

07:59.600 --> 08:03.080
Das schöne ist das hat die mit abstand kleinste einstiegs würde allerdings

08:03.560 --> 08:10.200
Hat es auch eine relativ steile lernkurve sobald man anfängt ein bisschen mehr als vanilla javascript und im text mit dem texteditor machen zu

08:10.200 --> 08:16.440
Wollen dann guckt man sich irgendwelche frameworks an die man lernen muss dann muss man neue javascript features lernen dann muss man

08:16.800 --> 08:21.800
sich eventuell wenn man pech hat je nachdem was man nimmt mit nimmt noch mit webpack auseinandersetzen

08:23.160 --> 08:25.800
Glücklicherweise ist webpack nicht mehr so verbreitet

08:34.620 --> 08:40.660
Irgendwas ist auch bei twitch kaputt vielleicht vielleicht liegt es auch an mir vielleicht streame ich einfach zu oft

08:41.620 --> 08:43.380
in letzter zeit

08:43.380 --> 08:48.740
Man weiß es ja nicht ich meine ich habe aktuell so viele subscriber tatsächlich wie noch nie wir müssen nachher wieder

08:50.020 --> 08:52.100
Subscriber schätzen machen

08:54.760 --> 08:59.160
Gucken ob jemand das gut erraten kann

09:01.240 --> 09:05.050
Zumindest

09:05.050 --> 09:08.050
Was mir aufgefallen ist ich habe sonst immer

09:09.650 --> 09:11.650
War mal im monat so

09:11.770 --> 09:17.650
12 sein so 60 70 damals schwankte so zwischen 50 und 150 oder sowas vielleicht

09:18.610 --> 09:23.250
den follower auf twitch bekommen aber die letzten glaube ich

09:23.770 --> 09:26.010
hier fünf so die letzte woche oder so

09:27.490 --> 09:29.490
Kein mehr doch ich glaube drei oder so

09:29.490 --> 09:31.490
Und

09:32.130 --> 09:39.330
Dabei waren zwei richtige hiq streams dabei die auch die auch zumindest wenn ich mir das hier im chat angeguckt habe richtig gut angekommen sind

09:40.490 --> 09:45.050
Nämlich einmal unser steckdosen flash stream und einmal den

09:46.970 --> 09:51.610
Cloud den den google kubernetes stream sind beide richtig gut angekommen aber twitch

09:52.450 --> 09:58.410
Die milfra steckdose genau aber twitch hat gedacht was natürlich auch sein kann ist

09:58.530 --> 10:03.690
Dass irgendwelche leute follow bottet haben und das jetzt erst mal wieder aufgeräumt wird man weiß ja lieber twitch so genau

10:04.170 --> 10:06.170
dass sich das ungefähr ausgleicht

10:06.290 --> 10:08.290
Dankeschön für den sub

10:10.770 --> 10:12.770
IQ wieder gestiegen

10:13.810 --> 10:17.530
Kannst du erzählt in frankfurt co-location empfehlen nee

10:18.770 --> 10:20.770
also ich kenne

10:21.170 --> 10:27.210
In frankfurt nur standorte wo man sich rex und so zeug mieten kann aber jetzt nicht so nach dem motto

10:27.970 --> 10:35.290
Managt sondern du bekommst halt einen raum und da musst du dann selbst deine sachen einbauen du kriegst quasi netzwerkkabel aus der wand

10:35.290 --> 10:36.770
sozusagen

10:36.770 --> 10:38.010
jetzt

10:38.010 --> 10:40.010
leicht vereinfacht ausgedrückt

10:40.770 --> 10:43.410
Aber so so geschichten mit

10:44.290 --> 10:49.140
Du kannst da deine eigene hardware hosten

10:50.220 --> 10:52.220
Eventuell eventuell darfst du auch selbst rein aber

10:52.900 --> 10:58.420
Du hast auch irgendwelche support sachen kommt kommt wahrscheinlich ein bisschen darauf an was du haben willst ja willst du das komplett

10:59.260 --> 11:04.460
Gemanagt haben dass du auch leute da hinschicken kannst die die festplatte tauschen oder willst du da selbst rein also

11:05.460 --> 11:12.820
Die die einzige sache wo ich das wo ich tatsächlich mal in der location war in frankfurt wo wir uns kein eigenes

11:14.300 --> 11:21.100
Rechenzentrums abteil gemietet haben war im d6 das dürfte aber wahrscheinlich für die meisten leute viel zu teuer nicht erschwinglich und auch nicht

11:21.460 --> 11:26.780
Sinnvoll sein also den zeiten wo ich noch beim provider gearbeitet habe da hatten wir ein ganzes

11:27.100 --> 11:34.060
Im d6 stehen jetzt ich weiß gar nicht gibt es gibt es davon überhaupt ordentliche bilder im internet

11:35.780 --> 11:48.150
Ja ja gut so sehen schränke da drinnen aus d6 von innen ja super sieht man bloß netzwerkschränke

11:49.950 --> 11:55.710
Es sieht auch nicht viel anders aus als in anderen rechenzentren halt gefühlt deutlich mehr netzwerkinfrastruktur

11:56.710 --> 12:01.190
Zumindest dort haben wir den recht gemietet und ich bin mir noch nicht mal sicher ob wir das weg alleine hatten

12:01.750 --> 12:03.990
oder ob wir in diesem recht sogar nur

12:05.550 --> 12:09.350
Paar höhen einheiten gemietet haben das kann nämlich auch sein ich bin mir da nicht mal ganz sicher

12:09.750 --> 12:13.550
Ja und da muss man rein und damals muss man storage neu starten

12:14.790 --> 12:17.510
und ich habe damals auch gesehen wie ein

12:18.510 --> 12:20.190
wie ein

12:20.670 --> 12:26.270
Peering anschluss zwischen providern aussieht das hört man ja öfter so nach dem motto oder das peering

12:26.430 --> 12:32.270
Bei youtube zu youtube von der telekom ist so kacke und hier und da haben sie probleme das ist äußerst unspektakulär

12:32.590 --> 12:37.470
Wie so ein peering aussieht als das peering oder heißt es peering peering glaube ich

12:38.870 --> 12:45.710
Das ist letztendlich ein stecker also das ist ein kabel was du in deinen switch schräg schräg router stöpselst

12:45.710 --> 12:52.190
Und auf der anderen seite stöpselst du das in einen switch schräg schräg router

12:52.790 --> 12:57.990
Von einem anderen provider fertig mehr ist das nicht natürlich kann man das beliebig aufblähen

12:58.590 --> 13:04.470
Aber ich habe damals unser peering mit free net gesehen das war stinknormales kabel

13:04.870 --> 13:07.270
Könnte könnte glasfaserkabel gewesen sein aber

13:08.190 --> 13:12.390
Von unserem switch an den switch fertig der router switch schräg schräg router

13:13.510 --> 13:15.510
Das war das gesamte peering

13:26.530 --> 13:29.730
Was jetzt das blicke ich jetzt nicht was willst du wie jetzt

13:30.370 --> 13:37.260
Ach so was du programmieren willst habe nämlich ein problem mit meiner tastatur ich will halt mit einer software oder im code

13:37.260 --> 13:41.700
Der tastatur gucken warum einige tasten plötzlich doppelt gehen oder teilweise gar nicht das nervig

13:42.180 --> 13:47.540
Das wirst du dir aber wohl kaum in der mit der software angucken können das wird mechanisch bedingt oder im

13:48.380 --> 13:50.100
ungünstigsten fall

13:50.100 --> 13:54.500
Direkt in dem controller von der tastatur passieren das wirst du nicht einfach auslesen können

13:54.820 --> 13:59.540
Haupt also das eigentliche problem wird höchstwahrscheinlich mechanisch bedingt sein also gerade

14:00.780 --> 14:02.460
mechanische also

14:02.460 --> 14:03.860
clicky clicky

14:03.860 --> 14:08.220
tastaturen mechanische tastaturen die neigen dazu zu wie nennt man das

14:10.020 --> 14:15.380
Doppelte tastenanschläge zu haben wir haben die heißen das so prellen oder so was also ich hatte ich hatte auch schon

14:15.780 --> 14:19.980
mechanische tastaturen wenn du da auf den knopf also wenn du dir wirklich zu fest

14:21.100 --> 14:23.500
auf den auf die taste

14:25.500 --> 14:30.180
Gedrückt hast dann kamen doppelte tastenanschläge und es war mega nervig

14:30.820 --> 14:38.740
Und die ganz ehrlich die schlechteste tastatur die aber bei weitem nicht die billigste war die schlechteste tastatur die ich je hatte

14:40.580 --> 14:42.580
War die hier korsar

14:43.140 --> 14:45.060
k95 rgb

14:45.060 --> 14:50.740
Die ist abfakt teuer gewesen weil wahrscheinlich weil rgb

14:51.540 --> 14:54.940
Und ganz ganz ganz im ernst ich mach das ding mal groß

14:55.420 --> 15:00.260
Vielleicht hatte ich auch ein sonntagsmodell also wenn ihr die tastatur habt und damit zufrieden seid ist das schön für euch

15:00.580 --> 15:05.180
Aber ich habe mir in der tastatur so viele probleme gehabt also erstens hatte ich doppelte tastenanschläge

15:06.900 --> 15:11.660
Ich weiß nicht mal was es war ich glaube dass es

15:13.060 --> 15:16.780
Ich habe mich doch im stream immer drüber aufgeregt was war denn das backspace

15:17.060 --> 15:19.060
Nee

15:19.100 --> 15:20.780
V

15:20.780 --> 15:27.420
Kontroll v war es es war v genau ich habe ich habe ich habe manchmal doppelt doppelt copy pasted und so was

15:27.660 --> 15:29.660
das war extrem nervig

15:29.860 --> 15:31.820
du

15:31.820 --> 15:34.420
Ich habe kontroll v gedrückt hat auf einmal so gemacht

15:35.060 --> 15:41.340
Also hier ich habe das copy pasted habe eingefügt auf einmal hatte ich das irgendwie so hatte ich das irgendwie zwei dreimal drinstehen ganz ganz schrecklich

15:42.340 --> 15:44.740
Also das das war wirklich das war wirklich mist

15:45.180 --> 15:50.180
der grund warum ich mir das ding für daheim geholt habe ist war tatsächlich die die makrotasten und die

15:50.780 --> 15:56.780
programmierfähigkeiten aus und vielleicht ein bisschen rgb von den features her also auch auch hier vorne mit dem mit dem

15:57.540 --> 16:04.180
Mit der handballenauflage wobei die auch nicht nicht richtig richtig gut war die war sehr gummimäßig weniger weich aber das war okay

16:05.060 --> 16:08.580
So also dass das war eines der großen probleme in der statur hatte

16:09.140 --> 16:14.640
dass ich doppelte tastenanschläge hatten mit v jetzt habe ich da habe ich mehrfach mehrfach

16:17.070 --> 16:18.750
da

16:18.750 --> 16:26.740
so

16:26.780 --> 16:29.960
Dann

16:29.960 --> 16:34.560
Hatte ich das problem dass manche tasten nicht mehr richtig funktioniert haben

16:34.640 --> 16:40.800
Wann es war glaube ich umschalten war glaube ich irgendwelche numm tasten hier oben das weiß ich noch als ich mit i3 hier

16:41.040 --> 16:44.760
Desktop umschalten wollte ging es manchmal nicht da muss ich mehrfach die gleiche taste drücken

16:45.120 --> 16:49.480
Danach hatte ich übrigens eine logitech mit der war es auch nicht viel besser da ist mir eine taste abgebrochen abgebrochen

16:49.560 --> 16:55.080
Ich weiß auch nicht was mit modernen tastaturen hochpreisigen modernen tastaturen los ist dass sie so probleme haben

16:55.360 --> 16:58.880
So also die zwei sachen hatte ich und ganz ehrlich ich hatte das ding nicht lange

16:59.880 --> 17:03.320
ich hatte das

17:03.440 --> 17:05.440
eineinhalb jahre oder sowas

17:05.960 --> 17:07.960
Und da hat es schon angefangen kaputt zu gehen

17:08.480 --> 17:13.720
Richtig richtig räudig so und das nächste ding dass es jetzt allerdings also das waren zwei wirklich

17:14.920 --> 17:17.040
Kann man sagen da geht es jetzt nicht um

17:17.880 --> 17:24.680
Subjektive ein oder zwei objektive fehler an der tastatur so dann hatte ich aber auch noch ein paar subjektive sachen die mir persönlich überhaupt nicht

17:24.680 --> 17:31.560
gefallen haben erstens hatte ich den eindruck ich kann es nicht genau beschreiben warum und zwar waren die tastatur waren die

17:31.880 --> 17:35.560
die oberfläche von den tasten war zu

17:36.040 --> 17:38.040
Glatt

17:38.040 --> 17:40.040
Komisch zu beschreiben

17:40.120 --> 17:42.880
Aber ich hatte nicht richtig halt auf den tasten

17:43.600 --> 17:50.640
Ich meine ja alle tastaturen sind oben glatt aber ihr hattet sicher ihr hattet doch auch schon mal unterschiedlich tastaturen in den händen du hast du hast

17:50.920 --> 17:52.920
tasten die sind und

17:53.080 --> 17:59.960
Die sind die alles ein bisschen gebogen oben aber du hast teilweise tasten wenn du damit den finger so ein bisschen drüber

18:00.800 --> 18:06.920
Drüber streichste du merkst da schon dass du minimalen widerstand hattest hast so dass wenn du die

18:07.080 --> 18:13.520
Beim angenommen du legst die finger ordentlich auf wasd dann bleiben die finger da halt drauf wenn du die nicht wenn du nicht absichtlich

18:13.520 --> 18:14.840
Hin und her wackelst

18:14.840 --> 18:18.360
Hatte ich hier überhaupt nicht war ganz nervig war ganz ganz schwammiges gefühl ich hatte nie den eindruck

18:19.200 --> 18:23.560
Und ich habe auch das hatte ich auch noch bei keiner anderen tastatur ich hatte auch das

18:24.160 --> 18:27.680
Nicht das gefühl dass ich mit den fingern auf den richtigen tasten bin

18:27.880 --> 18:34.360
Also ganz im ernst wenn ich auf der tastatur nicht drauf gucke und nicht sicher feststellen kann

18:34.800 --> 18:37.360
Ob ich auf wasd gelandet bin

18:38.520 --> 18:40.520
Ohne auf die tastatur gucken zu müssen

18:41.160 --> 18:43.120
Dann stimmt irgendwas nicht

18:43.120 --> 18:47.880
Mein wasd an sich ist ja recht einfach festzustellen du musst gucken ob das f daneben hast aber trotzdem

18:47.960 --> 18:50.760
Du willst es du willst es eigentlich wissen und ich glaube das lag daran

18:51.680 --> 18:53.680
dass du zwischen caps lock

18:54.200 --> 19:00.880
Nicht nicht so richtig in abstand hattest und zwischen tap also mit der mit der aktuellen tastatur die ich hier habe habe ich halt

19:00.920 --> 19:06.640
So die tasten habe ich merkt es sofort ich merke instant wenn ich hier meine finger richtig auf wasd liegen

19:06.640 --> 19:11.040
Habten so und die rutschen dann auch nicht rum also damit hatte ich damit habe ich ein problem es hat mir überhaupt nicht gefallen

19:12.800 --> 19:18.160
Und ne ne macht ja macht ja nichts raus ich das muss man muss man mal erzählen falls die leute sich das kaufen wollen

19:18.400 --> 19:22.080
Und ein ding womit ich überhaupt gar nicht klar gekommen bin

19:22.680 --> 19:27.680
Was hast du aktuell für das ich habe ich habe mehrere ich kann ich sag dir gleich was ich für was verwenden verwende

19:28.240 --> 19:35.530
Also ein problem wo ich gar nicht drauf klar gekommen bin bis zum schluss nicht auf gar nicht drauf klar gekommen bin ist

19:35.850 --> 19:41.050
Übrigens diese geriffelte lehrt hast da habe ich bis heute nicht verstanden warum die geriffelt ist jetzt lieber war wir es die riffeln sollen

19:41.690 --> 19:43.930
Zumindest eine sache auf die ich überhaupt nicht

19:44.690 --> 19:51.520
Echt war nie da dabei geriffelte wasd ist okay möglich möglich

19:51.600 --> 19:53.080
Möglich möglich

19:53.080 --> 19:58.120
Da hätte ich vielleicht mal in die packung gucken müssen also dann kann man den kritikpunkt schon mal streichen aber der rest bleibt bestehen und

19:58.120 --> 20:00.120
Bei den anderen tasten war es ja im prinzip genau das gleiche

20:01.680 --> 20:08.320
So aber eine sache wo ich bis bis zum schluss nicht auf klar gekommen bin ich war chat ihr könnt mir mal sagen wie ihr das

20:08.320 --> 20:10.320
macht aber ich

20:10.360 --> 20:16.440
Stelle öfters mal ganz gerne fest dass meine tastatur richtig liegt und alles auch ohne dass ich

20:17.000 --> 20:21.520
Also ich überhaupt nicht ich sage ich überprüfe ganz gerne mal meine tastatur und so und alles richtig liegt

20:21.760 --> 20:28.600
Ohne dass ich drauf gucken will und wie ich das mache ist folgendes ich gehe mit dem kleinen finger an den linken unteren

20:28.600 --> 20:33.160
Rand der tastatur und ich weiß der linke untere rand der tastatur ist kontroll

20:34.320 --> 20:35.960
und das ist hier nicht so

20:35.960 --> 20:37.960
Ich bin regelmäßig mit meinem finger

20:38.360 --> 20:44.640
Zwischen den makro tasten und kontroll stecken geblieben mit dem kleinen finger beim beim fühlen ob ich die tastatur an der seite habe

20:45.440 --> 20:47.440
Und ich habe oftmals

20:48.120 --> 20:53.000
G6 anstatt kontroll gedrückt weil ich gesagt habe ok tastatur und links das muss kontroll sein

20:53.720 --> 20:57.480
Mag irgendwie ein bisschen übungssache sein war aber war aber total

20:58.520 --> 21:01.660
unintuitiv

21:01.660 --> 21:07.460
Hat mich hat mich gestört ja und dementsprechend kann ich sagen die tastatur kann ich zumindest nicht empfehlen

21:08.460 --> 21:14.330
Ja die die untere makro taste hatte ich auch gar nicht gar nicht belegt

21:15.050 --> 21:19.410
Aus aus dem grund die makro fähigkeiten sonst was war

21:20.290 --> 21:24.090
Okay, würde ich mal sagen nicht super nice aber okay

21:24.730 --> 21:29.210
So aktuell habe ich folgendes ich habe zwei ich habe zwei tastaturen ich habe einmal eine

21:29.530 --> 21:33.410
Ducky one was ich witzig finde weil es auch schon ein paar leute im chat vorgeschlagen haben hier

21:34.610 --> 21:37.330
Einfach max ans trinken hat man gleich

21:39.370 --> 21:41.370
Exzellent mach ich jetzt mal

21:43.420 --> 21:47.500
Also irgendwelche leute haben geschrieben ich soll mir eine ducky tastatur kaufen genau

21:48.780 --> 21:50.300
so

21:50.300 --> 21:55.860
Ich habe auch eine ducky one skyline aber die alte und full size

21:56.380 --> 21:58.380
Also sowas hier mit num block

21:59.260 --> 22:03.180
Allerdings mit dem nicht mit diesem hässlichen enter key sondern mit dem normalen

22:03.900 --> 22:09.860
die so so sieht die aus

22:10.220 --> 22:15.740
Wobei ich mir auch ein bild ich habe die auch mit einem blauen enter key komisch vielleicht kommt man in tauschen oder so wirklich

22:16.300 --> 22:21.020
Also sowas hier in der kombination die habe ich am start die habe ich allerdings auf der arbeit mittlerweile

22:21.580 --> 22:27.900
Was heißt mittlerweile mittlerweile ist gut gesagt ich habe mir die explizit für die arbeit gekauft damals und ich habe die dann auch mit

22:27.900 --> 22:29.900
Die alte firma genommen habt jetzt in der neuen firma auch

22:29.980 --> 22:34.780
Ich habe quasi das einzige was ich mitgenommen habe von der alten in der neuen für die neue firma ist meine tastatur und meine maus

22:34.780 --> 22:36.780
Maus habe ich noch eine

22:37.100 --> 22:38.860
Logitech

22:39.340 --> 22:42.380
Logitech g502 pro toyscore

22:45.460 --> 22:50.860
Also das ding habe ich am start auf der arbeit als tastatur und das mega nice tippt sich wirklich sehr angenehm

22:51.420 --> 22:56.620
Das einzige problem ist das ist eine rein mechanische tastatur das heißt du nervst ein bisschen die leute auf der arbeit

22:57.340 --> 23:02.660
Wenn man nicht jetzt total heftig drauf schlägt dann geht das aber

23:03.420 --> 23:06.900
Es gibt allerdings auch silikon ringe für die tastaturen

23:07.620 --> 23:09.620
Das

23:09.860 --> 23:17.140
Macht es bei manchen tasten ein bisschen erträglicher so und für daheim habe ich eine logitech g512

23:18.180 --> 23:20.180
so eine

23:23.390 --> 23:28.230
Sowas hier das ist nicht die geilste tastatur die ich jemals hatte aber

23:29.150 --> 23:31.750
Ich habe schon die zweite weil die erste kaputt gegangen ist

23:32.550 --> 23:39.390
Ich habe ich habe auch übelst glück mit meiner tastatur hardware gehabt die letzten jahre aber man muss sagen logitech hat das ding einfach ausgetauscht

23:40.070 --> 23:44.830
beziehungsweise amazon hat das ding einfach ausgetauscht also die ist die war kaputt

23:45.670 --> 23:47.670
und dort ist mir tatsächlich

23:48.830 --> 23:50.830
control abgebrochen

23:51.790 --> 23:53.790
Die kontrolltaste ist abgebrochen

23:56.570 --> 24:01.130
Ich hätte nicht gedacht dass das überhaupt passieren kann aber kontrolle ist abgebrochen

24:04.020 --> 24:12.180
Und ich also ich kann mir vorstellen warum die abgebrochen ist aber die darf nicht abbrechen und zwar die ist abgebrochen weil wenn meine tastatur

24:12.740 --> 24:18.060
Schief liegt dann greife ich hier unten links an die tastatur also da habe ich dann

24:18.180 --> 24:24.860
Da habe ich mein mittelfinger an an dem gehäuse und meinen zeigefinger habe ich an der kontrolltaste und dann schiebe ich halt die tastatur

24:25.060 --> 24:27.900
Ein bisschen wieder in die richtung wie sie hingehört

24:29.020 --> 24:32.780
Und das hat die kontrolltaste einfach nicht verkraftet die ist kaputt gegangen

24:41.150 --> 24:43.150
Die ist verreckt komplett

24:43.670 --> 24:50.720
Und wenn das abbricht kannst du die halt auch nicht fixen

24:51.720 --> 24:58.760
Das ist ja keine rubberdome tastatur oder sowas wo du auseinanderschraubst was im dreck raus pustest und gut ist wenn der schalter im arsch ist

25:00.760 --> 25:02.760
Ist es ist das ding halt kaputt

25:04.680 --> 25:09.120
Also da war der war sowohl der schalter im arsch als auch die kontrolltaste selbst gehen also

25:09.440 --> 25:14.640
Ich weiß ich hatte übelst pech mit mit meinen mein tastaturen das letzte mal aber muss man echt sagen logisch hat das ding

25:14.920 --> 25:20.520
Ausgetauscht ohne probleme zack habe ich eine neue tastatur gekriegt hat wunderbar funktioniert und die neue hält

25:20.720 --> 25:25.040
Also anscheinend hat sie hat sie ein bisschen morsche kontrolltaste gehabt

25:33.180 --> 25:38.700
Logitech g hub das ding habe ich auch am start auch wenn es doch hier ist es ja finde ich auch nicht so geil

25:39.900 --> 25:41.900
Aber gibt gibt schlimmere software

25:43.660 --> 25:45.660
Ich muss noch was zur ducky

25:45.860 --> 25:47.460
tastatur sagen

25:47.460 --> 25:53.500
Weil eines der gründe schlechthin warum ich mir die gekauft habe für die arbeit war

25:54.020 --> 26:01.100
Dass die keine zumindest dachte ich das zum damaligen zeitpunkt so dass die keine irgendwie großartige software sonst irgendwas braucht

26:01.100 --> 26:08.620
Und ich wollte nichts mehr für makros und sonst was also der unterschied also muss ja also der grund warum ich daheim die hab

26:09.100 --> 26:09.860
und

26:09.860 --> 26:11.460
eine ducky one

26:11.460 --> 26:15.980
Auf der arbeit beziehungsweise die zwei unterschied tastaturen warum ich nicht zweimal eine ducky one habe ist

26:16.180 --> 26:20.140
dass ich daheim gerne was hat mit makros und auf der arbeit will ich nichts mit makros haben

26:20.220 --> 26:23.580
Weil das ist unterliegungs mit custom software für tastaturen und so eh so ein ding

26:24.460 --> 26:30.500
Bis ich irgendwann festgestellt habe das wollte ich jetzt mal hier lobend lobend erwähnen dass die ducky one

26:31.100 --> 26:37.180
Tatsächlich makro funktionalität hat ohne software die tastatur hat anscheinend ein microcontroller drin

26:37.620 --> 26:40.100
Mit der man makros mit dem man makros programmieren kann

26:40.980 --> 26:48.220
Ja custom treiber sind immer so ein bisschen problematisch weil

26:49.220 --> 26:56.620
Je nachdem wie die software funktioniert wenn die auf betriebssystemebene erst funktioniert dann funktionieren einige sachen nicht zum beispiel

26:57.540 --> 27:04.780
Wenn ich in vm war bin und du willst jetzt mit nehmen wir mal auto hotkey nehmen wir auto hotkey auto hotkey ist so mit das

27:04.780 --> 27:06.780
bekannteste was es so gibt für für

27:08.780 --> 27:14.380
Tastatur input faken wenn ich hier in vm war drinne bin und vm hat meine maus geklebt

27:14.780 --> 27:20.220
Und ich hätte habe jetzt ein auto hotkey laufen im hintergrund unter windows was sagen wir mal

27:21.020 --> 27:26.940
Rausgehen möchte aus der vm dann geht das nicht weil vm war workstation so low level meine tastatur

27:27.140 --> 27:33.420
Da funktioniert auto hotkey nicht du kannst keine richtigen usb kommandos senden mit auto hotkey sondern du kannst halt nur

27:33.820 --> 27:40.580
Windows quasi sagen hier ist wohl eine tastatur gedrückt deswegen wenn man wenn man wirklich low level makros braucht für automatisierung zum beispiel

27:40.820 --> 27:47.980
switch aus einer vm raus und sowas dann geht das mit manchen sachen nicht das hier keine ahnung ob wie gut das

27:48.540 --> 27:54.740
Das ist aber wenn es eine firmware ist dann ist es höchstwahrscheinlich so dass es tatsächlich direkt von der tastatur ausgeht und dann ist gut

27:54.860 --> 28:00.220
So das war zumindest der grund warum ich daheim logische tastatur habe und auf der arbeit hatte ducky one skyline

28:01.220 --> 28:02.580
aber

28:02.580 --> 28:04.700
Was mir erst im nachhinein aufgefallen ist

28:05.620 --> 28:16.450
Die ducky one skyline hat ein microcontroller drin mit der man doch makros programmieren kann ich zeige euch mal

28:19.470 --> 28:21.470
Back gibt sie irgendwie von hinten

28:22.510 --> 28:28.790
Bild von hinten guck mal die hat hier unten nämlich so eine so einen switch man sieht das gar nicht

28:30.990 --> 28:39.380
Ducky one skyline manual ich zeige euch das mal haben die hier

28:40.700 --> 28:42.700
ein offizielles pdf

28:43.700 --> 28:45.700
Download

28:46.460 --> 28:50.470
User manual

28:50.590 --> 28:55.700
Jawohl

28:56.500 --> 28:58.500
China chinesen ding

28:59.580 --> 29:04.900
Ach guck mal es gibt ja sogar ducky macro das kann ich noch gar nicht das gab es damals noch nicht und weiß ich ob das meine

29:04.900 --> 29:06.940
Tastatur unterstützt nice sehr schön

29:07.860 --> 29:11.740
zumindest meine die erste ducky one skyline die hatte da unten so eine geschichte zum

29:12.420 --> 29:17.180
Mit so dip switchen zum makro programmieren da musstest du die tastatur umdrehen den

29:17.180 --> 29:22.780
Makro das micro button anmachen da konntest du was drücken und da konntest du den makro button wieder ausmachen so das war sehr sehr

29:24.380 --> 29:31.180
Umständlich ist es damit makros aufzuzeichnen aber das coole ist die befehle kommen dann halt auch direkt von der tastatur und sind da halt mit

29:31.180 --> 29:33.180
drinnen on board also

29:33.380 --> 29:35.380
Eigentlich gar nicht übel

29:38.020 --> 29:40.020
So viel zum thema tastatur

29:40.740 --> 29:42.740
Nämlich lange zu ausgelassen

29:44.820 --> 29:54.320
Nee quatsch die habe ich komplett selbst bezahlt die tastatur die kenne ich nicht

30:00.210 --> 30:02.490
Das ist nicht die ergonomische tastatur oder

30:03.290 --> 30:08.330
Also leute die ich glaube die tastatur die ich am längsten in benutzung hatte

30:09.650 --> 30:15.690
Damals wo es obwohl ich noch kein geld verdient habe und ich wirklich gucken musste wie ich wie ich über die runden komme so

30:16.410 --> 30:22.450
Taschengeld mäßig habe ich auch nicht viel gekriegt als die tastatur die ich am längsten verwendet haben war ein microsoft office

30:25.650 --> 30:29.730
Keyboard

30:29.770 --> 30:31.770
Das da

30:32.010 --> 30:37.050
Kennt das noch jemand hatte das zufällig auch jemand rar ist die rare

30:38.490 --> 30:40.490
Das ding hatte ich ewig

30:44.140 --> 30:49.180
Was das das ist also aus zeiten wo tastaturen versucht wurden super ergonomisch zu machen

30:49.940 --> 30:52.500
Das ding hatte ich ewig das hatte ich das war

30:53.220 --> 30:55.220
release date

30:55.980 --> 31:00.380
Release date das war was für sich 1998 oder so war das wann das rausgekommen ist

31:01.180 --> 31:04.620
Wir suchen wir suchen nicht nach release date sondern review

31:10.690 --> 31:17.930
Das war wie so ein altes nokia handy man findet das noch mal hier pc welt oder irgendwelche schrottzeiten haben doch bestimmt sowas

31:21.370 --> 31:25.190
2001

31:26.630 --> 31:30.550
Und man findet das geil wobei da stand doch da stand doch wie heißt das ding

31:31.910 --> 31:34.150
rt 9 4 5 0

31:35.910 --> 31:37.910
Release date

31:38.870 --> 31:40.870
Das findet man auch nicht mal

31:41.590 --> 31:44.920
fest

31:44.920 --> 31:46.000
chip

31:46.000 --> 31:48.800
Welche seiten von damals müssen den kram noch getestet haben

31:49.040 --> 31:54.640
War so immer das hatte ich das habe ich ewig gehabt dass das das hatte ich wirklich eben ihr müsst davon ausgehen ich hatte

31:54.640 --> 31:56.640
das so lang ich habe damit noch

31:57.120 --> 32:04.560
Cs gespielt bevor es 16 wurde ich habe damit noch cs 05 und sowas gespielt mit dem mit der taste so alt ist die ist

32:04.560 --> 32:09.640
die ist die tastatur also vielleicht nicht so release aber aber kurz danach und

32:10.800 --> 32:12.800
zeitgleich hatte ich noch eine microsoft

32:14.160 --> 32:16.160
Intelli mouse

32:16.960 --> 32:18.960
Explorer

32:19.480 --> 32:23.000
Nicht die nicht die die erste die allererste ja

32:24.000 --> 32:30.830
Die da nee ja aber in anderer farbe hatte ich die

32:31.390 --> 32:36.270
aber nee nee nee nee nee nee nee das war das war nicht die die sie die sah der aber

32:38.310 --> 32:41.310
So sah meine aus genauso exakt so

32:42.950 --> 32:44.870
Und

32:44.870 --> 32:47.670
Das war eine der ersten optischen

32:51.900 --> 32:54.500
ob optikel explorer ist das ding

32:58.750 --> 33:00.750
Ja ja

33:04.110 --> 33:06.470
Und damals waren optische mäuse noch richtig schrott

33:12.330 --> 33:19.890
Aber aber wie gesagt dass microsoft also die microsoft das microsoft office keyboard das hatte ich so lang das hatte ich bestimmt über zehn

33:19.890 --> 33:21.890
jahre dieses teil

33:25.470 --> 33:27.470
Das habe ich glaube ich erst weggeschmissen

33:29.190 --> 33:33.070
Nachdem ich also ich kann es ich kann es mir ungefähr zusammenreihe zusammen reimen

33:33.350 --> 33:38.310
Weil es gab ja mal eine zeit da habe ich viel pc gespielt und dann gab es eine zeit dann habe ich

33:38.590 --> 33:42.870
Total viel xbox 360 gespielt es war dann wahrscheinlich so 2005 rum

33:44.310 --> 33:49.310
Oder so xbox 36 ja genau irgendwie 2006 rum bis bis

33:50.630 --> 33:52.790
2011 12 wo ich dann auch die

33:53.310 --> 33:59.830
Call-of-Duty zeug im fabian und so gespielt habe so viel xbox gespielt und als ich danach wieder angefangen habe wieder viel mehr pc

33:59.830 --> 34:04.710
Zu spielen da habe ich die rausgeschmissen so als eine der ersten abends handlung also ich hatte das ding quasi

34:05.190 --> 34:07.510
10 bis 15 jahre diese tastatur

34:09.620 --> 34:14.820
Ich glaube das wäre mit der aktuellen tastatur gar nicht machbar wenn da schon nach einem jahr die kontrolltaste abbricht

34:16.180 --> 34:21.100
Na gut lange nur über tastaturen jetzt gelabert gucken wir uns mal jetzt was das eigentliche an was im titel steht

34:27.470 --> 34:29.830
Aliexpress tastatur das auch mutig

34:35.020 --> 34:41.460
Ja so ist das halt chat gab es schon mal einen stream wo wir die ersten 45 minuten irgendwas sinnvolles gemacht haben

34:42.580 --> 34:48.410
So habe ich die taste habe ich habe ich die poemme neu gestartet

34:51.280 --> 34:53.280
Ich glaube ich glaube schon

34:54.080 --> 34:57.160
Chat ja doch doch doch ich glaube

34:58.320 --> 35:01.640
Egal ich dachte doch ich glaube ich habe neu gestartet ich starte die noch mal neu

35:03.600 --> 35:05.600
Wieder mal c++ nicht immer bloß auf

35:06.600 --> 35:08.960
Fernseht vermeiden lässt gibt es hier nichts c++

35:14.140 --> 35:17.820
übrigens seitdem ich das so eingestellt habe dass ich

35:18.220 --> 35:24.020
Einfach nur noch start x eintippen muss ich frage mich warum gibt es leute die noch display manager und sowas verwenden

35:24.300 --> 35:27.700
Einfach auf der kommandozeile einloggen ein kommando ausführen und das

35:28.140 --> 35:32.540
Der desktop startet wozu braucht man display manager mit irgendwelchen fancy login

35:33.140 --> 35:35.140
alles blutet leute

35:35.940 --> 35:37.220
blutet

35:37.220 --> 35:43.140
arts by the way nicht blutet

35:44.820 --> 35:47.260
By the way i use arts by the way

35:53.400 --> 35:54.680
gut

35:54.680 --> 35:59.960
Vermutlich aber wir updaten den ganzen klempel mal gibt neue rider version pie charm professional

36:00.960 --> 36:08.080
Aus welchem grund habe ich pie charm professional installiert es ist jetzt nicht so als würde ich so viel python zeug machen

36:09.760 --> 36:15.000
Ach doch ich weiß wofür wir das installiert haben hier für das für das plugin hier oben

36:16.320 --> 36:23.090
Für den für das timer plugin was wir gebaut haben das haben wir ja in python gemacht

36:24.890 --> 36:31.290
Und natürlich haben wir dann auch gleich pie charm professional installiert so als professional hecker man

36:32.730 --> 36:34.730
Professional kann ich installieren weil

36:34.770 --> 36:38.290
Ich habe irgendwann mal so ein old desktop pack von jetbrains geholt

36:38.730 --> 36:44.650
Dementsprechend kann ich jetzt auch pass mal auf ich kann nicht einfach nur intelligent community edition installieren ich kann sogar

36:45.450 --> 36:46.370
intelligent

36:46.370 --> 36:48.370
ultimate installieren

36:49.890 --> 36:51.890
Was ist eigentlich der unterschied dazwischen

36:56.400 --> 36:59.600
Ultimate versus community gucken wir als haben wir uns schon mal angeguckt

37:01.560 --> 37:03.560
Aber ich habe schon wieder vergessen

37:04.560 --> 37:13.790
Okay package updates im hintergrund sind ein wenig laggy kotlin geht in beiden

37:15.150 --> 37:16.630
ultimate

37:16.630 --> 37:17.950
kann auch

37:17.950 --> 37:19.430
ruby

37:19.430 --> 37:20.430
ultimate

37:20.430 --> 37:22.430
rust

37:22.470 --> 37:24.470
Eigentlich brauche ich das nicht

37:26.730 --> 37:33.650
Übrigens chat wir müssen demnächst wieder ein bisschen frontendentwicklung machen und zwar ich habe mich jetzt ich habe mich jetzt endgültig dazu entschieden

37:33.970 --> 37:36.490
Ich werde den fiat champ etwas überarbeiten

37:37.490 --> 37:40.890
Alter wie viele wie viele comments hat das bitteschön

37:41.890 --> 37:51.330
Was irgendjemand offert mir 50 dollar wait a minute was ist da los das habe ich gar nicht gelesen

37:52.410 --> 38:04.220
get rude

38:04.220 --> 38:11.820
Oh shit was hier los

38:12.260 --> 38:32.410
Das ist richtig ich habe es nie mit dem alfa romeo getestet

38:33.450 --> 38:38.230
Oh okay

38:38.550 --> 38:40.870
Ja also was ich jetzt weil ich jetzt sagen wollte

38:40.990 --> 38:46.870
Ich habe mich jetzt dazu entschieden ich werde das ding mal überarbeiten weil ich höchstwahrscheinlich selbst demnächst probleme mit der app

38:46.870 --> 38:53.590
Also ist eines der gründe und es so viele coole sachen gibt immer noch einbauen können könnte und einbauen kann die auch wirklich was bringen

38:53.590 --> 38:58.310
Und man das grundsätzlich auch mal ein bisschen überarbeiten muss aus den aus den sachen die ich jetzt gelernt habe

38:58.870 --> 39:02.950
Und eines der eines der wünsche die user immer geäußert haben ist

39:03.870 --> 39:07.390
Sie wollen das auch stand alone benutzen können eigentlich rewrite in russland

39:07.390 --> 39:10.830
Die wollen das auch stand alone benutzen können und da habe ich mir überlegt ich mache folgendes

39:11.390 --> 39:15.950
Nachdem ich probleme habe wenn ich das einbauen möchte dass es mehrere autos

39:16.430 --> 39:20.550
Gleichzeitig von mehreren herstellern unterstützt weil aktuell unterstützt die app zwar

39:21.270 --> 39:23.270
Fiat jeep dodge

39:24.150 --> 39:29.150
Ram truck dinger und und alfa romeo und so theoretisch zumindest

39:30.230 --> 39:34.270
Ist das problem ist das problem dass man die app nicht einbauen kann

39:34.390 --> 39:36.390
Theoretisch zumindest

39:36.390 --> 39:43.110
Ist das problem wenn du zwei accounts hinzufügen willst weil du autos von zwei unterschiedlichen hersteller zum beispiel irgend so ein ami

39:43.590 --> 39:49.670
Herkommt und sagt hey er hat so einen fetten ram truck und noch einen kleinen fiat dann geht das nicht zusammen und du kannst du

39:49.670 --> 39:56.470
Kannst du das addon nicht doppelt installieren du kannst zwar mehrere autos bei fiat haben aber du kannst nicht zwei autos hier gleichzeitig haben das

39:56.470 --> 40:00.430
Ist eigentlich bescheuerte limitierung die daran liegt dass ich ursprünglich daran gedacht habe dass es ja

40:01.030 --> 40:05.550
Möglich sein kann dass jemanden fiat und jeep hat zum beispiel und das mit der gleichen app machen wird

40:05.870 --> 40:13.270
Es gibt ein paar sachen die man da grundlegend umbauen muss und die konfiguration über home assistant funktioniert auch nicht richtig

40:13.950 --> 40:15.870
in dem fall

40:15.870 --> 40:20.390
Deswegen habe ich mir überlegt wir bauen einfach ein kleines webinterface zum konfigurieren ein

40:21.110 --> 40:25.310
Nein, wir rewriten das nicht in rast leute wie kommen wir darauf warum

40:25.910 --> 40:29.830
Wenn ich nie fertig werden will dann würde ich das in rast rewriten

40:32.440 --> 40:34.440
blazer

40:35.320 --> 40:37.320
Welt

40:37.360 --> 40:39.600
Einfach mal ein spontaner rast rewrite

40:45.340 --> 40:48.180
Chat wir rewriten das nicht in rast

40:49.820 --> 40:52.860
Da können die krustentiere hier noch so viel schreiben

40:55.400 --> 41:00.120
Oder das frontend in rast webassembly ja klar weil ich das auch komplett

41:01.520 --> 41:03.520
Unmaintainable für mich machen will das webfrontend

41:04.520 --> 41:12.480
Warum warum nicht gleich warum nicht gleich das frontend in .NET MAUI in webassembly übersetzt und über

41:14.400 --> 41:23.370
Websockets angebunden oder war irgendwie ganz abgedreht das zeug. Die rewriten das gar nicht

41:36.050 --> 41:39.050
Ich werde von mod gesabotiert guckt euch das an

41:47.530 --> 41:49.530
Wuppdi dankeschön für den sub

41:54.420 --> 41:57.940
Chat es ist vollkommen egal wie oft ihr abstimmt rewrite in rast

41:59.980 --> 42:02.900
Ich werde es im leben nicht in rast rewriten

42:04.500 --> 42:08.460
Ich finde das auch gut wenn ihr das rewritet ich rewrite es nämlich nicht

42:09.260 --> 42:14.930
Ihr könnt rewriten was ihr lustig seid

42:17.250 --> 42:19.890
Rewrite in Haskell natürlich das kommt als nächstes

42:21.130 --> 42:23.130
Mod mod mod giz

42:24.130 --> 42:28.370
Können ja auch wir können eine umfrage umfrage machen rewrite in kobol

42:29.810 --> 42:36.730
Wobei ich gehe mal davon aus selbst wenn ich das wirklich machen möchte ich glaube mit kobol wäre es gar nicht wirklich

42:39.500 --> 42:40.980
krass champ

42:40.980 --> 42:42.980
hört mal bloß auf

42:47.950 --> 42:49.950
Meinung zu nehmen habe ich noch nie benutzt

42:49.950 --> 42:56.430
Ja und da bauen wir dann webfrontend zum konfigurieren dann kann man das nämlich stand alone verwenden und auch so besser konfigurieren gut

42:56.710 --> 43:00.470
Aber erste 45 minuten um jetzt können wir mal zur eigentlichen sache des streams kommen

43:01.830 --> 43:06.910
Wisst ihr was ich installiere einfach nur die community was zu was hier los mit der oberfläche

43:08.710 --> 43:10.710
Habt ihr es gerade gesehen

43:11.070 --> 43:14.110
Auch kommt mal das ding kackt voll ab wenn man über den install button geht

43:21.420 --> 43:34.750
Aber auch nur wenn man eine weile drauf bleibt wenn man schnell drüber geht nicht

43:43.550 --> 43:45.550
so let's go

43:46.070 --> 43:53.510
Ich muss euch ehrlich sagen ich habe absolut gar keine ahnung von kotlin nein habe ich nicht war die jetzt

43:54.510 --> 43:58.510
Das das muss ich mir das muss ich mir aufhören ich muss mir später angucken oder vielleicht können wir es auch noch

43:59.430 --> 44:01.430
Vielleicht können wir es auch noch im stream gucken

44:02.590 --> 44:04.590
Mal schauen mal google

44:05.230 --> 44:19.040
Die community edition ist für geringverdiener

44:20.000 --> 44:23.640
Du meinst du meinst ich muss jetzt ich muss jetzt den den

44:24.520 --> 44:29.880
Aus dem weg geringverdiener move machen und und die wieder an installen

44:33.040 --> 44:35.040
Ultimate okay

44:36.200 --> 44:40.760
Ihr müsst einfach in meine gruppe kommen leute dann könnt ihr euch auch professionelle ideas leisten

44:42.400 --> 44:45.360
So lasst mal was wenn man anfangen will

44:46.360 --> 44:53.840
Sachen zu automatisieren von zum beispiel in sachen in vm plus eine anderen software software verteilung software

44:54.480 --> 44:56.480
Was benutzt man dann am besten

44:57.480 --> 45:00.840
Schwarz 33 ich habe keine ahnung was du meinst

45:02.880 --> 45:04.880
Was genau willst du automatisieren

45:06.760 --> 45:12.640
Ich werde echt nicht schlau draus wahrscheinlich kann ich dir sogar was zu raten aber erst mal muss ich verstehen was du machen willst

45:13.640 --> 45:15.640
Aktuell bin ich eher so im

45:17.000 --> 45:19.000
Dem modus ich verstehe es nicht

45:21.100 --> 45:28.380
Es gibt sehr viele sachen um andere sachen zu automatisieren aber es die fragen welche sachen gemeint sind

45:29.060 --> 45:31.980
So ultimate edition installiert jetzt ist alles gut

45:33.060 --> 45:34.700
intelligent

45:34.700 --> 45:38.140
ultimate

45:38.220 --> 45:44.460
Potential zeug das wäre eine möglichkeit aber es kommt darauf an was für sachen es sind wenn du das unter windows automatisieren willst

45:44.660 --> 45:51.380
Ich meine ich sage nicht dass es nicht geht mit ansonnenpuppet schön ist es auf jeden fall nicht aber willst du irgendwelche ui sachen oder browser

45:52.380 --> 45:55.980
Webseiten oder so automatisieren dann ist das schon mal komplett falschen tools dafür

45:59.520 --> 46:01.520
Das erinnert mich an einen punkt früher

46:03.360 --> 46:05.360
Noch während meiner ausbildung

46:05.920 --> 46:13.640
Oder was heißt noch eigentlich hauptsächlich während meiner ausbildung da wurden die azubis immer verdonnert bei dailies protokollen zu schreiben

46:13.640 --> 46:19.740
Ja das war die zeit wo man auch schon angefangen hat versucht versucht agil zu sein aber dann so

46:20.480 --> 46:27.960
Agilitätskiller gemacht wie protokolle fürs daily schreiben richtig hängen geblieben und die azubis mussten immer protokolle fürs daily schreiben damals und ich war

46:27.960 --> 46:30.640
Damals auch azubi also musste ich öfters protokoll fürs daily schreiben

46:31.480 --> 46:37.600
Und wir hatten einen im team damals der hatte nie bock darauf im daily ordentlich was zu erzählen

46:38.640 --> 46:42.640
Aus meiner sicht heute vollkommen verständlich heute wäre ich wahrscheinlich derjenige gewesen

46:43.000 --> 46:49.400
Der auf diesen kram keinen bock hätte und immer wenn der gefragt wurde was hast du gemacht dann hat er gesagt dinge

46:50.240 --> 46:54.600
Und wenn man ihn dann weiter gefragt hat ja erzähle mal ein bisschen konkret hat gesagt sachen

46:55.160 --> 46:57.160
Und danach hat er gesagt zeug

46:57.560 --> 47:02.420
Du hast aus dem nicht rausgeklickt was er gemacht hat und was er machen will

47:03.300 --> 47:05.300
und irgendwann und jetzt

47:06.940 --> 47:11.100
Story aus meiner azubi zeit ja und irgendwann habe ich mir gedacht weißt du was

47:11.380 --> 47:16.980
Wenn der kerl einfach zu 90 prozent nur das so erzählt schreibst du es einfach ins protokoll rein

47:17.140 --> 47:20.420
Und dann habe ich bei dem ein paar tage lang ins protokoll reingeschrieben

47:21.460 --> 47:23.740
hat gemacht sachen

47:25.140 --> 47:28.700
Und irgendwann hatte ich doch tatsächlich hat irgendjemand dieses protokoll gelesen

47:29.700 --> 47:33.620
Es anscheinend haben da wirklich unsere damaligen chefs sogar die protokolle

47:34.220 --> 47:38.380
überwacht und reingeguckt und irgendwann habe ich dann eine doofe nachricht bekommen über

47:39.380 --> 47:49.860
Kennt das noch jemand hatte hatte jemand mal die ehre damit

47:54.020 --> 48:05.020
Ich frage nur ob jemand die pains champigkeit dieser software kennt habe ich die nachricht bekommen über den lotus notes chat

48:06.860 --> 48:11.700
Übrigens wer ist eigentlich auf die dumme idee gekommen die personalabteilung human resources umzubenennen

48:12.300 --> 48:18.420
Es ist ja schön und gut dass arbeitgeber das so sehen und wenn ich arbeitgeber wäre würde ich es wahrscheinlich auch so sehen aber ich

48:18.420 --> 48:20.660
Finde diesen namen einfach nur maximal unglücklich

48:21.820 --> 48:23.820
so zumindest

48:23.860 --> 48:28.220
habe ich eine nachricht bekommen über über lotus notes same time

48:28.700 --> 48:32.660
warum in dem protokoll nichts ordentliches drin steht für den da habe ich ihm halt gesagt

48:33.740 --> 48:35.580
damals habe ich gesagt ja gut

48:35.580 --> 48:39.020
Ich frage den jedes mal was er macht und der antwortet immer nur mit sachen

48:39.140 --> 48:44.060
Habe gemeint ja aber das können wir da nicht reinschreiben weil das würden ja alle sehen

48:45.060 --> 48:50.540
Aber der kann ich doch nichts machen er sagt halt nix ich kann ihm ja schlecht jetzt

48:51.700 --> 48:54.180
Irgendwie sagen ich werfe dich aus dem fenster

48:56.180 --> 48:59.380
Was soll ich machen wenn er einfach nicht sagen will auf dreimal nachfragen

49:01.100 --> 49:07.380
Da hatte die andere seite auch keine so wirkliche antwort drauf hat er nur zu mir gesagt so nach dem motto ja guckt doch beim nächsten

49:07.380 --> 49:09.380
protokoll dass wenn er was anderes reinschreibt

49:10.060 --> 49:16.540
Und das habe ich dem dann erzählt demjenigen der das der hier immer sachen und dinge gesagt hat und daraufhin hat er gesorgt auch

49:17.220 --> 49:23.660
Ich hatte keinen bock mehr auf den laden ich soll weiterhin sachen rein schreiben habe ich weiter sachen reingeschrieben und danach hat sich nie wieder

49:23.660 --> 49:28.660
Einer beschwert man würde eigentlich davon ausgehen dass sie sich die protokolle besonders konkret angucken

49:29.100 --> 49:31.420
Wenn du schon angerufen würdest dazu

49:34.660 --> 49:37.140
Wir haben dann einfach weiterhin sachen reingeschrieben

49:38.380 --> 49:45.420
Es kann natürlich auch sein dass sie sich wirklich dann bei ihm gemeldet haben und nicht mehr bei mir weil ich meine ich war

49:45.420 --> 49:47.340
Azubi und protokollschreiber

49:47.340 --> 49:50.060
Was soll ich da dran ändern wenn der typ ja nix sagt ja

50:01.070 --> 50:03.070
Sachen machen sind immer effizient

50:03.710 --> 50:13.200
Ach hier okay sorry für die undeutlichkeit dem macht nichts muss das ist nicht schlimm sage ich meinen azubis auch immer das ist nicht wild

50:13.720 --> 50:19.800
Wenn er wenn wenn wenn man es nicht versteht wichtig ist nur das was auf nachfrage hinwegs mal gescheit erklären kann dann das ganze

50:19.800 --> 50:27.120
Klar stellt er kann erwartet keiner dass man von anfang an alle perfekte sachen für alles die die passenden wörter und buzzwords kennt

50:27.360 --> 50:33.480
Bei the way ihr wisst ja cloud anbieter sind keine cloud anbieter mehr sondern hyperscaler also wenn ihr cool sein wollt sagt ihr demnächst

50:33.480 --> 50:39.920
So noch hyperscaler sorry für die undeutlichkeit also zum beispiel neue vm snapshots erstellen und gleichzeitig updates von software draufladen

50:40.120 --> 50:42.440
bisher muss man das ganze von hat man ach so ja

50:43.560 --> 50:49.840
Das würde ich ehrlich gesagt gar nicht so sehr auf vm ebene sehen sondern eine vm ist ja ein virtuell

50:50.280 --> 50:56.960
Virtualisiertes system ob das system da drin jetzt virtualisiert ist oder auf echte hardware läuft ist es ist dem system ja innen drin

50:56.960 --> 51:01.120
Relativ egal also das heißt wenn du dich um paket updates und so kümmern willst

51:01.240 --> 51:05.480
Dann muss das in dem system in drinnen passieren das hat ja nichts mit einer vm lösung zu tun

51:06.000 --> 51:08.000
snapshots erstellen das sieht schon wieder anders aus

51:08.400 --> 51:13.640
snapshots erstellen wenn du vm verwendest und in kombination also esx und

51:13.720 --> 51:19.520
Wie heißt das ganze zeug wie es vier und was es nicht alles gibt da gibt es garantiert lösungen damit kenne ich mich aber nicht

51:19.520 --> 51:27.160
Aus weil ich das nie administrieren musste und auch nie bock drauf hatte wie man automatisch snapshots und backups von vm erstellt gibt es garantiert

51:27.160 --> 51:30.920
Ich kenne ich kenne vm zum beispiel aber ich gehe davon aus dass so sachen wie

51:31.760 --> 51:37.440
Automatisierte snapshots per skript und sowas easy möglich sind mit wie es vier out of the box

51:37.440 --> 51:42.920
Chat gibt ihr wisst vielleicht besser vielleicht jemand von euch vm wer atmen am start oder jemand der das schon gemacht hat

51:44.160 --> 51:45.520
software

51:45.520 --> 51:50.400
Updates da musst du dich vom betriebssystem seite aus drum kümmern da hat die vm ja nichts mitzutun

51:50.680 --> 51:54.800
Ich meine vm wer kann ja schlecht wissen wie du betriebssystem updates machst für alle

51:55.400 --> 52:00.880
150 verschiedene betriebssysteme die du theoretisch in der vm laufen lassen könntest du könntest am mac drinnen laufen haben

52:01.560 --> 52:03.560
Ja, könntest macht kaum einer

52:04.000 --> 52:10.000
linux windows oder meinetwegen dos ja woher soll deine vm wissen deine virtualisierung software

52:10.000 --> 52:16.560
Wie du in den jeweiligen betriebssystemen gescheit updates machst das heißt du brauchst zwei sachen du brauchst einmal eine backup backup

52:17.080 --> 52:23.440
Snapshot lösung oder halt einfach nur ein paar kronen skripts für vm wer sowas geht garantiert vm wer

52:24.080 --> 52:30.240
Out of the box für automatische snapshots erstellen gucke aber dass deine snapshots ordentlich rotiert sonst wird

52:30.360 --> 52:36.520
Ratzfatz ziemlich viel gigabyte verbraten und hier brauchst du irgendwas für das jeweilige betriebssystem was du abdecken willst zum beispiel

52:37.000 --> 52:41.240
Wenn du viele linux betriebssysteme hast dann bietet sich sowas wie ansible an

52:42.520 --> 52:48.080
Oder auch puppet oder chef oder salt stack aber ich persönlich würde sagen ansible

52:49.000 --> 52:54.280
Du kannst aber auch wenn es nur betriebssystem updates sind andere lösungen verwenden kannst zum beispiel

52:55.160 --> 53:02.040
Wenn du nicht viele kisten hast kannst du den skript bauen was sich ein lock psh und update macht wobei ich das tatsächlich dann

53:03.040 --> 53:09.920
Ansible vorziehen würde du kannst auch gucken dass du deine systeme wenn sie alle rettet sind in sowas wie satellite reinsteckt oder

53:10.520 --> 53:12.520
spacewalk hieß das früher

53:12.560 --> 53:14.240
rettet

53:14.240 --> 53:16.240
spacewalk

53:16.360 --> 53:25.820
Ist das noch spacewalk has been discontinued

53:26.900 --> 53:28.900
Heute nennt sich noch satellite

53:29.260 --> 53:31.260
Wir hatten mal bei uns

53:31.500 --> 53:38.340
Jemand der der dokumentation geschrieben hat und der konnte das wort spacewalk das wort spacewalk nicht aussprechen

53:40.380 --> 53:42.380
Der hat immer gesagt spacewalk

53:43.860 --> 53:49.580
Da kann ich mich heute noch dran erinnern wir haben immer richtig gequatscht es ist jetzt ja nicht so als hätte ich die geilste

53:49.580 --> 53:53.740
Englisch aussprache überhaupt aber ich war es ernsthaft spacewalk

53:54.540 --> 53:56.540
anstatt spacewalk

53:57.060 --> 54:02.900
Der Typ war geil, der hat es auch immer so geil ausgesprochen der spacewalk

54:05.740 --> 54:11.740
Mittlerweile nach einer weile hieß das bei uns umgangssprachlich auch bei allen leuten spacewalk

54:15.580 --> 54:17.580
Ein bisschen so wie manche leute

54:17.980 --> 54:23.020
Gyra besonders geil aussprechen müssen wir haben dazu immer noch am ende immer noch spacewalk gesagt

54:24.020 --> 54:26.020
Spacewalk

54:26.260 --> 54:32.740
Gut also du brauchst irgendeine software halt für deinem betriebssystem zu managen und bei der gelegenheit wenn du sowas wie ansible verwendest

54:32.940 --> 54:34.940
bietet sich vielleicht auch an

54:35.140 --> 54:41.660
Die sachen die du customized hast an einem linux also sprich welche packages du installiert hast verzeichnisse eingelegt

54:43.500 --> 54:47.660
Dienste gestartet und gestoppt und sowas das vielleicht auch noch gleich in ansible reinzubringen

54:48.660 --> 54:54.380
Dann hast du nämlich beim nächsten aufbau keine probleme das system wieder herzustellen

54:56.500 --> 55:01.140
Also die zwei sachen du brauchst einmal eine backup snapshot lösung oder einfach nur ein paar

55:01.460 --> 55:04.140
scripts für vmware, vsphere, was auch immer ihr da verwendet

55:04.980 --> 55:08.580
und die möglichkeit software updates zu machen über ansible zum beispiel

55:09.420 --> 55:11.340
und wenn es windows ist

55:11.340 --> 55:15.940
Auf dem ihr unterwegs seid habe ich keine ahnung von weiß ich nicht was es da gutes gibt um windows zu updaten

55:18.750 --> 55:23.150
Komme jetzt ins letzte lehrjahr hast ja bald geschafft viel spaß bei der prüfung

55:24.110 --> 55:38.100
Ja, ja mir ist schon klar warum das so heißt ich finde das aber nur maximal unglücklich dass du das so zu nennen

55:43.080 --> 55:45.080
Uyuni das kenne ich nicht was ist Uyuni?

55:46.000 --> 55:51.740
github

55:51.860 --> 55:53.860
Ah! Fork vom spacewalk

55:54.780 --> 56:01.300
Spacewalk fork habe ich noch nie gehört obs

56:02.380 --> 56:04.380
Ach ne open sooze build

56:05.980 --> 56:10.700
Warum nennen die den kram obs? OBS ist für mich das hier und nicht open sooze build

56:13.650 --> 56:16.290
vor allem open sooze bi- ob- ob- hä?

56:18.250 --> 56:19.770
Oben?

56:19.770 --> 56:21.770
Oben sooze

56:24.470 --> 56:30.590
Oben sooze build und dddd ist dann auch desk driven design oder was?

56:32.110 --> 56:40.320
Von windows software verteilung habe ich so keinen plan da wisst ihr wahrscheinlich im chat mehr

56:41.320 --> 56:52.840
Und umso mehr prime subs umso mehr IQ umso mehr wissen noch was wie schreibt man ansible so

56:55.340 --> 56:57.140
Ansible

56:57.140 --> 57:05.020
Also kann ich dir aber hauptsächlich empfehlen wenn du linux basierte systeme hast wie gut ansible und windows in zusammenhang keine ahnung ansible

57:06.220 --> 57:08.500
Wie gut funktioniert ansible mit windows?

57:12.200 --> 57:14.200
Nichts was man machen will wahrscheinlich

57:17.980 --> 57:32.220
Ach open sooze build system okay ne

57:33.980 --> 57:38.100
Ne also ich wollte ich war gerade kurz dafür zu sagen

57:38.780 --> 57:44.500
Für 50 prime subs überlege ich mir mal die sachen in rust zu rewriten aber das mache ich nicht also kommt nicht auf die idee

57:44.500 --> 57:52.900
Jetzt das vielleicht wirklich zu machen erstens könnt ihr wahrscheinlich eure kohle besser gebrauchen und zweitens ich habe absolut keinen bock den kram in rust zu rewriten

57:52.900 --> 57:58.020
Weil es auch so sinnlos ist weil ich in zukunft auch nicht maintain möchte in rust

58:05.130 --> 58:12.090
Also ich habe mal puppet und windows versucht das war auch komplett für den arsch und ich glaube puppet supportet offiziell sogar windows

58:13.090 --> 58:17.740
ja aber

58:17.940 --> 58:19.940
Das ist nichts was ich empfehlen kann

58:20.500 --> 58:22.780
In rust maintains ich das von alleine

58:23.860 --> 58:27.660
Ja vielleicht vielleicht wenn die mods das dann maintain

58:28.380 --> 58:30.180
aber leute

58:30.180 --> 58:32.460
leute wenn wenn rewrite in rust ja

58:44.190 --> 58:45.830
kenne ich nicht

58:45.830 --> 58:51.430
Ist das ist das für windows oder was was soll das sein?

58:56.440 --> 59:00.580
Aha okay

59:00.580 --> 59:02.580
Was bin ich hier sehend

59:04.820 --> 59:08.710
Avs laptop

59:11.110 --> 59:14.030
Okay das ist das ist eher was für remote support

59:14.910 --> 59:21.850
Na gut aber leute wenn wenn rust rewrite dann dann nicht rust sondern

59:22.490 --> 59:24.130
kreplang oder

59:24.130 --> 59:26.810
chat rust rewrite oder kreplang rewrite

59:28.010 --> 59:31.890
Was was würden die die coolen krustentiere unter euch machen?

59:32.730 --> 59:49.800
Weil das ist ja ein rust pork

59:53.450 --> 59:56.010
Ich sehe schon das wird nichts mit dem rust rewrite

01:00:05.960 --> 01:00:07.880
gut

01:00:07.880 --> 01:00:10.480
So jetzt habe ich eine stunde im kreis gelabert

01:00:11.480 --> 01:00:13.480
Jetzt müssen wir uns das langsam

01:00:15.040 --> 01:00:22.720
Ich ich mag das font rendering in diesen java hilfe dialogen das sieht immer so schön nach 1985 aus

01:00:24.080 --> 01:00:27.880
Falls man damals schon java ui machen konnte ich glaube das war altes java nicht

01:00:46.340 --> 01:00:48.340
Ich muss noch eine sache sagen

01:00:48.620 --> 01:00:55.900
Weil ich doch eben erzählt habe aus zeiten wo ich noch asubi war protokoll geschrieben habe und bei dir jemand gefragt danach windows

01:00:56.260 --> 01:01:02.980
Automatisierung und ich habe ich habe gesagt ich kenne mich mit windows automatisierung nicht aus doch ich kenne eine sache noch aus meiner ausbildung

01:01:03.660 --> 01:01:05.260
zum thema windows

01:01:05.260 --> 01:01:11.580
Automatisierung und das hat mich wieder darin bestärkt dass ich nichts administratives mit windows zu tun haben will hatte jemand von euch schon mal

01:01:11.580 --> 01:01:17.700
Ich weiß gar nicht ob sie software noch gibt ich suche jetzt mal einfach danach hat jemand von euch schon mal mit einer software namens

01:01:19.140 --> 01:01:20.740
Altyris

01:01:20.740 --> 01:01:22.740
Was zu tun gibt es das überhaupt noch

01:01:25.990 --> 01:01:27.590
Altyris

01:01:28.310 --> 01:01:29.990
Softwaremanagement oder sowas

01:01:29.990 --> 01:01:37.080
Ja, so ungefähr sah das aus genau

01:01:39.570 --> 01:01:47.050
Da konnte man dann so start scripts boot scripts für windows hinterlegen und sowas das war ganz ganz abartig

01:01:47.250 --> 01:01:49.250
Ich kann mich nur noch dunkel dran erinnern

01:01:50.690 --> 01:01:58.810
Was wir in der software gemacht machen mussten aber es war eines der ekligsten experiences die ich die ich je mit so einer management software hatte

01:01:59.810 --> 01:02:05.210
Und und seitdem bin ich froh nie wieder was mit windows administrativ zu tun gehabt haben

01:02:05.490 --> 01:02:08.530
Sie nach einer software aus die ein rast rewrite benötigt

01:02:10.250 --> 01:02:15.850
Bestimmt das rettet das rettet es komplett gibt es gibt es das altyris management suite

01:02:21.040 --> 01:02:26.760
Jeden tag werden altyris administratoren angefragt computer aufzuladen neue software zu verteilen probleme zu lösen vieles mehr

01:02:27.600 --> 01:02:34.970
Ja, wenn ich eine robuste management infrastruktur haben will dann nämlich so ein windows client only ding was hier auch noch

01:02:35.650 --> 01:02:39.930
Moment moment leute leute ist das ist das etwa der internet explorer

01:02:40.650 --> 01:02:44.210
Das fällt mir jetzt erst auf ist es ein tab im internet explorer

01:02:48.660 --> 01:02:50.820
Ist das eine silverlight anwendung

01:02:56.420 --> 01:02:59.060
Könnte das eine silverlight anwendung sogar noch sein

01:03:14.930 --> 01:03:16.930
Ja ne ne

01:03:17.970 --> 01:03:19.730
So nicht

01:03:19.730 --> 01:03:25.610
So jetzt widmen wir uns aber wirklich in der kundling geschichte also do not import no pass

01:03:29.670 --> 01:03:31.390
So

01:03:31.390 --> 01:03:37.430
Disclaimer ich habe keine ahnung von java und ich habe keine ahnung von kotlin das heißt als allererstes werden sie

01:03:37.430 --> 01:03:41.510
Mal ein hello world kopie also ich kann euch erzählen was wir versuchen werden zu machen und zwar

01:03:42.110 --> 01:03:49.550
Wir bauen eine cli app und zumindest ist es der der plan dahinter wir bauen eine cli app der über

01:03:50.190 --> 01:03:56.910
Http von irgendeiner wetter api das aktuelle wetter für den standort abfragt oder so was ich brauche ich brauche eine sinnlose

01:03:57.350 --> 01:03:59.750
Sinnlose command line anwendung um ein bisschen auszuprobieren

01:04:01.750 --> 01:04:06.950
Und wir gucken uns an wie man http request macht wie man kommandozeilen argumente passt wie man

01:04:07.390 --> 01:04:10.830
Listen macht schleifen macht vielleicht generics verwendet

01:04:11.910 --> 01:04:13.110
mal gucken

01:04:13.110 --> 01:04:16.550
new project

01:04:17.110 --> 01:04:20.710
Wahrscheinlich habe ich kotlin erstmal garten doch hier kommt mal kotlin no jdk

01:04:21.510 --> 01:04:27.630
MonkaS download jdk moment man kann das direkt in der ide downloaden das finde ich extremly pog

01:04:28.710 --> 01:04:34.590
das finde ich gut leute moment moment für den fall der fälle nur für den fall der fälle dass ich dass ich

01:04:37.950 --> 01:04:39.950
Wenn man ein snapshot

01:04:41.380 --> 01:04:45.860
Und bei der gelegenheit muss ich danach mal alle snapshots löschen sonst wird es ein bisschen viel

01:04:50.560 --> 01:04:52.560
doch was er jetzt gemacht

01:04:55.640 --> 01:05:02.440
Er ist halt doof wenn man kein window manager hatte kein fenster drum was ist das aktuelle jdk 20 wahrscheinlich

01:05:03.440 --> 01:05:05.440
Okay download

01:05:11.270 --> 01:05:18.830
Das ist extrem sick bei datacryp ist das auch kannst treiber für postgres man braucht treiber für postgres das ist mir neu

01:05:23.820 --> 01:05:26.180
Ihr habt es heute mit eurem rust rewrite oder

01:05:28.140 --> 01:05:30.140
Open jdk 20

01:05:31.780 --> 01:05:34.460
21 haben die aber nicht zum download ich glaube es für uns erstmal egal

01:05:35.220 --> 01:05:39.060
example code das ist gut bildsystem intelli j auch gut

01:05:40.060 --> 01:05:43.500
Create git brauche ich jetzt nicht untitled

01:05:45.780 --> 01:05:47.780
Java champ

01:05:48.260 --> 01:05:50.260
Create

01:05:50.420 --> 01:05:53.940
Das muss man den leuten bei kotlin ja bei jetbrains wirklich lassen

01:05:55.700 --> 01:06:01.820
So wie nennt man es schon user experience oder programmer experience

01:06:02.980 --> 01:06:04.980
Das kriegen die gut hin

01:06:05.820 --> 01:06:08.540
Suggested plugins kubernetes terraform und hcl

01:06:10.940 --> 01:06:14.460
Wir müssen erst mal wir müssen erst mal die schrift ein bisschen größer machen

01:06:16.140 --> 01:06:20.160
Und

01:06:21.360 --> 01:06:25.760
Ich will eigentlich die komplette schrift an umstellen wenn ich ehrlich bin vielleicht da

01:06:28.800 --> 01:06:37.620
Appearance general und jetbrains mono 18

01:06:37.740 --> 01:06:41.060
Ja das ist gut oder erkennt man eigentlich jetzt erkennt man gut was

01:06:42.180 --> 01:06:45.220
Programm arguments hello world okay

01:06:47.580 --> 01:06:49.580
Wie starte ich das jetzt

01:06:50.420 --> 01:06:54.020
Also ich meine so ja aber

01:06:59.120 --> 01:07:02.240
Programm aber wie starte ich das jetzt über cli

01:07:03.560 --> 01:07:05.560
Also gehen wir mal gehen wir mal hier

01:07:05.680 --> 01:07:08.160
Hier steht ja der aufruf wie das funktioniert guckt mal

01:07:08.920 --> 01:07:10.920
Alter was was zum

01:07:15.500 --> 01:07:17.980
Was ist das für ein ewig aufruf

01:07:19.020 --> 01:07:27.900
Ich brauche mal kurz den kotlin quick quick start tutorial

01:07:29.020 --> 01:07:31.460
Jet hat sich auf rust geeinigt ja

01:07:34.320 --> 01:07:36.320
schön für den chat

01:07:36.320 --> 01:07:38.320
Create and run an application perfekt

01:07:42.670 --> 01:07:49.870
Kotlin c brauchen wir kotlin c hello kati und jetbrains

01:07:49.910 --> 01:07:53.910
Kotlin c hello kati ok ok aber kotlin c habe ich gar nicht

01:07:56.890 --> 01:08:01.690
Bild wo ist der bildknopf hier ich mache das normalerweise nicht über die idee

01:08:03.010 --> 01:08:10.930
Ihr bild das hat mir jetzt aufgerufen zum bilden

01:08:12.650 --> 01:08:14.650
Und wo hat der kotlin installiert

01:08:17.710 --> 01:08:22.790
Mach einfach alles über die idee ok der beizeugnis java kenner dem glaube ich dass

01:08:23.790 --> 01:08:25.950
shift f10 ist starten

01:08:27.710 --> 01:08:32.430
Nee ich kann das ich will das nicht alles über die idee machen ich will ich will eine command line anwendung bauen das ist

01:08:33.070 --> 01:08:34.550
vergessen

01:08:34.550 --> 01:08:36.830
Aber man konnte doch wenn ich das richtig

01:08:38.150 --> 01:08:40.310
Run with parameters ok

01:08:42.630 --> 01:08:50.310
Moment also man hatte doch früher hier in der idee so eine sache settings edit configurations

01:09:10.410 --> 01:09:12.570
Ok wie heißt das ding kotlin c

01:09:13.570 --> 01:09:39.720
Wo hat dann das installiert das muss er doch irgendwo installiert haben ist das ist das irgendwie bild in in intelli j oder

01:09:40.600 --> 01:09:48.140
Ja das bild tab aber ich weiß nicht ich weiß nicht wo

01:09:53.860 --> 01:09:55.860
Mit rust wäre das nicht passiert

01:09:57.580 --> 01:10:03.140
Eben hatte ich doch hier noch einen anderen output drinne wo ist der ursprüngliche rerun bild

01:10:04.140 --> 01:10:06.300
Ach so das ist weil es im cache ist jetzt

01:10:07.300 --> 01:10:11.460
Ok da kommt jetzt einfach noch ein lehrzeichen rein und dann das bild noch mal laufen lassen

01:10:12.660 --> 01:10:13.940
Ja

01:10:13.940 --> 01:10:20.100
Also der hat kotlin kotlin jvm ausgeführt ich meine das muss ja irgendwie unter jdk liegen

01:10:21.300 --> 01:10:23.900
jdks open jdk bin

01:10:24.900 --> 01:10:27.910
ne

01:10:27.910 --> 01:10:32.310
geht geht schon mal gut los

01:10:32.710 --> 01:10:43.000
Weil irgendwo hier muss es ja liegen

01:10:46.150 --> 01:10:48.030
aha

01:10:48.030 --> 01:10:49.510
What

01:10:50.930 --> 01:10:52.930
Jetzt seriously ja

01:10:56.290 --> 01:10:59.290
Gibt es da gibt es wenigstens eingebautes cli hier

01:11:00.130 --> 01:11:14.810
Wieso ich das über das terminal machen will naja dass ich ich baue ja eine terminal ich baue eine terminalanwendung

01:11:14.810 --> 01:11:21.530
Dass ich dann sowas machen kann am ende ja keine ahnung java gem minus minus blob minus minus

01:11:22.010 --> 01:11:26.250
So was man kann zwar hier auch einstellen parameters aber das doch

01:11:28.010 --> 01:11:29.770
Ist doch nix

01:11:29.770 --> 01:11:35.490
na gut

01:11:35.490 --> 01:11:37.490
Anscheinend anscheinend müssen wir es wirklich

01:11:38.450 --> 01:11:42.590
der java champ

01:11:42.750 --> 01:11:44.750
Anscheinend müssen wir es wirklich so machen

01:11:45.310 --> 01:11:51.890
ja

01:11:57.550 --> 01:11:59.550
Local share

01:11:59.950 --> 01:12:10.340
Ja und jetzt hello gibt es da nicht sowas wie run

01:12:12.420 --> 01:12:14.580
Gibt es gibt es nicht run

01:12:18.170 --> 01:12:20.170
Ich glaube ich mache es doch über die ide das

01:12:20.370 --> 01:12:26.130
Das regt mich schon auf dass das so jetzt hatte ich meinen helft nicht meine hilfe alle ach in der java macht java welt macht man

01:12:26.130 --> 01:12:28.130
nicht minus minus

01:12:34.420 --> 01:12:37.380
Okay leute ich ich sehe schon ich macht es doch über die ide

01:12:39.020 --> 01:12:51.390
Ich werde ich werde es doch über die ide machen so und wo finde ich jetzt den output davon out hier

01:12:55.510 --> 01:12:57.270
Moment

01:12:57.270 --> 01:13:07.000
Okay es geht schon es geht schon gut los und dann muss ich das hier starten monka giga alda

01:13:12.310 --> 01:13:18.110
Wie kompiliere ich das denn jetzt zu irgendwas was ich ausführen kann zu irgendeiner selbst self-contained sache wie mit dort net

01:13:18.870 --> 01:13:20.870
Wahrscheinlich wahrscheinlich gar nicht so ohne weiteres

01:13:23.030 --> 01:13:29.150
Du musst das zu einer java datei machen kann man kann man ok kotlin self-contained

01:13:31.380 --> 01:13:33.220
machen kein rast

01:13:33.220 --> 01:13:34.900
kotlin native

01:13:34.900 --> 01:13:37.260
Ja jetzt kommen gleich die advancen themen

01:13:38.860 --> 01:13:42.780
How to get started get started with kotlin multiplattform

01:13:48.050 --> 01:13:54.930
Include run time ja aber da kommt eine java datei raus eine java datei kann man doch nicht einfach ausführen eine java datei kann man ausführen mit

01:13:55.250 --> 01:13:57.250
wenn wenn java installiert ist

01:13:57.770 --> 01:13:59.770
Nein wir machen kein rast chat

01:14:00.210 --> 01:14:02.210
Ist ja schlimm heute

01:14:11.140 --> 01:14:13.380
Intelli j benutzen wir ok ok

01:14:14.980 --> 01:14:28.670
Aber wir müssen kotlin multiplattform auswählen warum ist das schon wieder so eine wissenschaft für sich

01:14:31.140 --> 01:14:32.460
Irgendwas

01:14:32.460 --> 01:14:33.660
dort

01:14:33.660 --> 01:14:35.580
überhaupt zu kompilieren

01:14:35.580 --> 01:14:50.460
Für kotlin brauchst du immer noch ja aber kann man die run time irgendwie embedden dass man java nicht mehr braucht

01:14:51.180 --> 01:15:02.260
Die haben hier irgendwas irgendwas stand damit include run time aber aber include run time

01:15:03.260 --> 01:15:16.530
Ja das ist die kotlin run time die die included ist das ist nicht die java run also nicht da ist nicht die

01:15:16.850 --> 01:15:18.850
Jvm geschichten da braucht man immer noch java

01:15:19.010 --> 01:15:23.570
Na gut ich meine wie dem auch sei da machen wir das ganze halt rein über die ide

01:15:24.370 --> 01:15:28.450
Aber das schon mal nicht so nicht so klar wie ich das gerne hätte

01:15:29.290 --> 01:15:36.700
Ja genau und die jar kannst du ja nur mit java ausführen ich hätte gerne so komplett komplett self-contained anwendung

01:15:37.700 --> 01:15:46.420
Okay also wo woher dann meine erste frage die ich habe woher kommt überhaupt print line ist das so eine globale

01:15:50.080 --> 01:15:52.080
kotlin internal inline only

01:15:52.960 --> 01:15:56.840
Alles okay print line alias zu system out print line

01:15:57.600 --> 01:16:01.840
Okay, das ist gar nicht. So übel ich finde es gar nicht. So blöd dass das included ist

01:16:03.760 --> 01:16:05.400
Weil

01:16:05.400 --> 01:16:07.400
ansonsten hast du

01:16:07.720 --> 01:16:12.040
Die scharfeste console right line und du hast es auch immer included also insofern

01:16:13.360 --> 01:16:37.600
So also probieren wir es mal aus hier

01:16:38.200 --> 01:16:39.400
print

01:16:39.400 --> 01:16:46.610
brindeln

01:16:46.610 --> 01:16:48.610
wisst ihr eine sache

01:16:49.930 --> 01:16:52.570
Die ich extrem nice finden würde wenn

01:16:53.930 --> 01:16:56.930
Programmiersprachen und standard und libraries die

01:16:58.170 --> 01:17:03.170
Mit dieser print print line und sowas geschichte anfangen dass so ein bisschen eher so z

01:17:03.810 --> 01:17:08.730
Go zum beispiel ist glaube ich so was oder heißt es heißt es in go auch

01:17:09.450 --> 01:17:10.930
print f

01:17:10.930 --> 01:17:14.050
Die format ist aber format print f genau also

01:17:14.410 --> 01:17:22.010
Was ich was ich cool finden würde ist wenn libraries die print f mitbringen auch print f mitbringen würden klingt jetzt bescheuert

01:17:22.090 --> 01:17:24.090
Ich glaube es gibt kaum was

01:17:25.250 --> 01:17:30.650
Was das hat aber mich nervt es immer ungemein von hand new lines schreiben zu müssen

01:17:31.650 --> 01:17:37.490
Und warum warum warum kein print f effeln wenn man schon printen hat

01:17:41.030 --> 01:17:48.870
Okay, auto complete und das ganze zeug fühlt sich natürlich mal wieder richtig richtig nice an ich meine es ist von von jet brains für

01:17:48.870 --> 01:17:50.230
jet brains

01:17:50.230 --> 01:17:56.300
So wie kann man sich jetzt anzeigen lassen

01:17:59.620 --> 01:18:01.620
Message ahja

01:18:02.620 --> 01:18:04.620
Kecke

01:18:04.700 --> 01:18:06.700
Komma

01:18:06.780 --> 01:18:11.380
Okay und weitere sachen hat moment kann jetzt haben wir schon mal das erste kann

01:18:11.900 --> 01:18:19.300
Kann kotlin string interpolation also war blubb gleich 1 ich gehe nicht davon aus dass wie das funktioniert

01:18:19.940 --> 01:18:23.500
Legt man wirklich so variablen an den kotlin das war jetzt einfach mal

01:18:24.300 --> 01:18:26.300
first try okay

01:18:26.340 --> 01:18:28.340
So geht jetzt sowas wie kecke

01:18:29.660 --> 01:18:31.660
Blubb nee

01:18:32.540 --> 01:18:34.620
Kecke blubb nee

01:18:36.700 --> 01:18:38.700
Was könnte es denn sonst noch sein

01:18:39.580 --> 01:18:41.580
Kotlin string interpolation

01:18:52.010 --> 01:18:53.810
Machst wie in zeile 8

01:18:53.810 --> 01:18:55.890
Ach hier ich bin ja

01:18:56.450 --> 01:19:00.290
Bin blind oder sogar unten drunter ein beispiel am start

01:19:03.240 --> 01:19:07.530
weg damit

01:19:07.530 --> 01:19:09.530
Okay, nicht schlecht finde ich ganz nice

01:19:12.090 --> 01:19:14.090
Redundant curly braces

01:19:15.690 --> 01:19:17.690
Auch so einfach

01:19:18.690 --> 01:19:24.850
Okay und wenn ich und wenn ich dann wirklich den dollar haben will dann es käbe ich das wahrscheinlich

01:19:27.050 --> 01:19:29.330
Warum nicht finde ich eigentlich ganz schick

01:19:31.010 --> 01:19:33.010
Chat ist heute wieder richtig high IQ ja

01:19:33.610 --> 01:19:35.770
Finde ich eigentlich ganz gut okay

01:19:36.450 --> 01:19:39.650
So als nächstes wie machen wir eine liste

01:19:40.170 --> 01:19:44.730
War list gleich und es ist es ist bestimmt nicht new list gehe ich mal von aus

01:19:45.330 --> 01:19:47.210
list

01:19:47.210 --> 01:19:49.210
kotlin collections

01:19:49.570 --> 01:19:51.570
list of

01:19:52.970 --> 01:19:54.970
Nee so funktioniert es schon mal nicht

01:19:56.530 --> 01:19:58.530
List of

01:20:03.530 --> 01:20:05.530
Kotlin list example

01:20:08.780 --> 01:20:10.780
Kottel ist exampel

01:20:16.270 --> 01:20:23.280
Wort

01:20:23.280 --> 01:20:31.060
list of

01:20:31.060 --> 01:20:34.020
Warum nicht ist gewöhnungssache ja okay

01:20:35.020 --> 01:20:40.930
Ich finde es immer ein bisschen komisch wenn es so eigene

01:20:41.610 --> 01:20:47.090
sagen so eigene bild in sachen gibt zum erstellen von typen anstatt

01:20:47.690 --> 01:20:49.850
irgendwas mit den typen selbst

01:20:50.770 --> 01:20:53.130
Aber es ist wahrscheinlich gewöhnungssache

01:20:54.890 --> 01:21:00.250
Komma der erkennt sogar gleich dass es eine liste auf in sein soll das finde ich gut das gefällt mir das finde ich schick

01:21:01.650 --> 01:21:05.890
Und jetzt bin ich mal gespannt wenn ich eine liste ausgebe was macht er dann

01:21:06.290 --> 01:21:13.250
In c sharp würde der jetzt ausgeben dass es hier instance of list quasi macht er in kotlin wahrscheinlich das gleiche

01:21:14.050 --> 01:21:16.050
hallo shift f10

01:21:17.890 --> 01:21:24.330
Nee oh guck mal der ist richtig schlau der macht aus der liste gleich einen debug baren string

01:21:26.330 --> 01:21:28.330
Das ist nice das finde ich gut

01:21:29.330 --> 01:21:34.650
Also in internet ich muss euch das jetzt mal zum vergleich das finde ich wirklich cool dass er stand hat mich sowas eingebaut hat

01:21:34.650 --> 01:21:36.650
Ich muss es jetzt mal zum vergleich zeigen

01:21:38.570 --> 01:21:40.570
Konsole app 2 bester name überhaupt

01:21:42.330 --> 01:21:49.590
Ist cute cute chatter app ja also in

01:21:55.310 --> 01:21:57.310
Alter

01:21:57.750 --> 01:21:59.750
Rider kriegt ich mal ein

01:22:01.070 --> 01:22:03.270
Wo ist das problem unload

01:22:04.150 --> 01:22:10.680
load

01:22:10.680 --> 01:22:15.730
aus

01:22:16.370 --> 01:22:20.930
Irgendwelchen gründen ist das total kaputt aber das ist eh nix was wir brauchen deswegen schmeiß ich mal wieder weg

01:22:22.690 --> 01:22:24.690
Konsole right line

01:22:25.610 --> 01:22:30.330
So und das ding ist halt in c sharp müsste ich sowas machen

01:22:31.010 --> 01:22:35.970
Also mal angenommen ich habe ich mache ich mache hier genau ich mache quasi mal genau das gleiche in c sharp

01:22:39.560 --> 01:22:43.440
Also mal sowas hier war list da müsste ich gleich eine new list

01:22:43.840 --> 01:22:48.760
Hier muss ich auf jeden fall schon mal angeben list von ind 1 2 3 5 6 7 oder 1 2 3 4

01:22:50.640 --> 01:22:55.920
Siehste siehste schon wieder gebetet worden so 1 2 3 4

01:22:57.360 --> 01:22:59.360
Und ich glaube den kann man weglassen mittlerweile

01:23:01.040 --> 01:23:08.240
Und wenn ich das jetzt wenn ich hier das gleiche sagen will dann müsste ich sowas hier machen hecke doppelpunkt und jetzt könnte ich sagen

01:23:09.240 --> 01:23:16.160
List in dort net passiert jetzt aber folgendes muss man kurz hier rein rider projects console app 2

01:23:17.960 --> 01:23:21.780
. net

01:23:21.780 --> 01:23:23.220
. net run

01:23:23.220 --> 01:23:25.220
Ja, ich bin im falschen ordner ok

01:23:25.700 --> 01:23:27.180
. net run

01:23:27.180 --> 01:23:31.740
Guck der würde jetzt sagen kecke und das ist der typ und nicht die liste an sich

01:23:34.100 --> 01:23:38.380
Und nein und selbst to string hilft nicht das ist ja nämlich das was hier was hier nicht

01:23:38.980 --> 01:23:45.860
To string hilft nicht das ist genau das gleiche da kommt nichts aus wenn ich wirklich wenn ich wirklich die zahlen hier

01:23:46.220 --> 01:23:49.620
Ausgeben will dann müsste ich jetzt sowas machen wie

01:23:52.540 --> 01:23:54.540
String join

01:23:55.820 --> 01:23:57.380
Liste

01:23:57.380 --> 01:23:59.380
nie zuerst separator

01:24:01.800 --> 01:24:03.800
separator liste

01:24:04.160 --> 01:24:06.160
So wenn ich glück habe funktioniert es jetzt

01:24:06.560 --> 01:24:08.320
ja hier guck

01:24:08.360 --> 01:24:13.640
Das ist da muss ich ehrlich sagen da ist es deutlich cooler gelöst in kotlin an der stelle

01:24:14.600 --> 01:24:19.680
dass er so basic basic sachen direkt in debug bares strings zurück übersetzt

01:24:22.120 --> 01:24:27.240
Go hat aber das problem dass go keine string interpolation gescheit unterstützt oder kann es

01:24:27.480 --> 01:24:32.440
Mittlerweile ich glaube nicht go hat immer noch dieses eklige print f zeug überall

01:24:36.940 --> 01:24:38.940
Okay, das gefällt mir schon mal ganz gut

01:24:39.940 --> 01:24:41.940
Das ist

01:24:42.060 --> 01:24:47.900
Es ist jetzt nicht so als wäre das hier wahnsinnig unlesbar und unverwendbar aber ganz gut hier, okay

01:24:49.100 --> 01:24:51.100
nächster punkt

01:24:51.180 --> 01:24:53.260
Wie macht man eine schleife in go

01:24:54.340 --> 01:24:56.900
Ähnlich in go wie komme ich auf go in kotlin vor

01:24:59.550 --> 01:25:02.670
Hat man da auch irgendwelche hilfen vielleicht vor

01:25:04.190 --> 01:25:07.070
Ich probiere jetzt mal was vor i in list

01:25:07.310 --> 01:25:11.390
Okay die sprache ist intuitiv

01:25:13.390 --> 01:25:15.070
Sind

01:25:15.070 --> 01:25:22.210
Die sprache ist intuitiv ich wusste nicht wie das aussehen muss und ich bin gleich drauf gekommen

01:25:23.330 --> 01:25:25.330
nice

01:25:25.330 --> 01:25:27.330
Und jetzt ist die frage

01:25:27.890 --> 01:25:29.890
Wie würde man eine ganz normale

01:25:35.190 --> 01:25:38.310
Kann man in kotlin die schleife die klammern weglassen

01:25:38.430 --> 01:25:40.430
Wahrscheinlich auch nur wenn es einzeilig ist

01:25:41.230 --> 01:25:52.420
Wie machst du eine normale schleife die zählt ja das das das frage ich mich auch gerade ich meine vielleicht

01:25:52.860 --> 01:25:59.740
Vielleicht kann kotlin auch die standard syntakt sowas wie war ich probiert es jetzt einfach mal ich habe keine ahnung wie das aussieht

01:26:00.260 --> 01:26:02.260
war i gleich 0

01:26:03.980 --> 01:26:07.820
Komma i kleiner 10 plus plus

01:26:08.500 --> 01:26:11.500
I kleiner 10 i plus plus

01:26:13.700 --> 01:26:22.580
Okay kotlin kauen mit ranges

01:26:24.380 --> 01:26:26.380
Guckte mal

01:26:27.300 --> 01:26:31.580
Vor i in 0 until ok

01:26:33.900 --> 01:26:41.390
Vor also i in 0 until und jetzt 10 oder wie

01:26:43.830 --> 01:26:45.830
Was sagt okay

01:26:50.950 --> 01:26:55.590
Was sagt rider dazu until can be replaced

01:26:59.500 --> 01:27:01.900
Okay das ist cool

01:27:07.210 --> 01:27:10.970
Okay, da sagt man okay vor i in 0

01:27:12.050 --> 01:27:14.050
bis kleiner 10

01:27:14.410 --> 01:27:16.930
Das ist eigentlich ziemlich coole syntakt dafür

01:27:17.930 --> 01:27:24.730
Und wenn ich das weglassen ist es wahrscheinlich inklusive 10 ja sie sieht man ja auch hier inklusive 10

01:27:26.370 --> 01:27:28.890
Und was ist wenn ich hier sowas dran machen da geht es natürlich

01:27:31.410 --> 01:27:33.410
Oder gleich da man gleich machen

01:27:37.980 --> 01:27:42.540
Das ist das ist cool warum du noch java schreibst das weiß ich auch nicht

01:27:45.480 --> 01:27:48.360
Vielleicht weil du alte projekte hast die halt komplett in java sind

01:27:48.720 --> 01:27:53.200
Ich weiß nicht wie es mit der kompatibilität zwischen kotlin und java aussieht also ich vermute mal dass

01:27:53.680 --> 01:28:01.160
Alles gültige in java also nicht synthax aber libraries und so auch gültiges kotlin sind

01:28:01.920 --> 01:28:06.880
Und ich vermute umgedreht gilt das auch weil das letztendlich ja alles auf der jvm läuft also

01:28:09.160 --> 01:28:13.600
Wahrscheinlich sind die dinge eins zu eins austauschbar jetzt halt nicht source code mäßig sondern nur

01:28:14.680 --> 01:28:16.680
auf der ebene untendrunter

01:28:17.080 --> 01:28:21.660
Ja wenn es kobold für jvm gebe dann auch

01:28:24.240 --> 01:28:28.960
Mal eine frage hast du schon design patterns wie mvvm oder mvc und das ja habe ich

01:28:29.520 --> 01:28:36.920
Allerdings ich habe noch nie eine mvvm app gebaut die ein bisschen größer war und ich fand es auch immer extrem

01:28:38.000 --> 01:28:39.160
anstrengend

01:28:39.160 --> 01:28:40.840
in wpf

01:28:40.840 --> 01:28:48.960
Wpf ist schon ziemlich blutet und mit der ganzen viewmodel geschichte ist das wahrscheinlich eher was für business enterprise enterprise apps

01:28:49.720 --> 01:28:59.450
Wenn ich was in wpf gemacht habe muss ich ganz ehrlich sagen code behind datei und gut ist also zur erklärung

01:29:00.290 --> 01:29:02.290
mvvm ist model

01:29:02.650 --> 01:29:04.650
view viewmodel

01:29:05.330 --> 01:29:12.250
Und mvc ist model viewcontroller also mvc selber habe ich schon total oft verwendet auch mit asp.net core

01:29:13.930 --> 01:29:20.290
Oder mit ruby on rails damals schon so ziemlich jedes halbwegs modernere back-end web framework unterstützt mvc

01:29:21.850 --> 01:29:29.210
Die sind bei asp.net core ein bisschen davon weggekommen vom klassischen mvc aber ist immer noch sehr verbreitet und mvvm ist eher was für

01:29:29.650 --> 01:29:34.100
ui

01:29:34.100 --> 01:29:35.820
ui frameworks

01:29:35.820 --> 01:29:37.820
Da kenne ich mich aber nicht so wirklich aus

01:29:40.390 --> 01:29:48.270
Also ich weiß nur dass man sagt gerade was wpf angeht dass man sagt mvvm ist dort relativ beliebt

01:29:48.910 --> 01:29:53.110
wegen data bindings und dynamischen ui

01:29:54.470 --> 01:29:56.470
also dass du quasi

01:29:56.670 --> 01:30:02.030
in deinem model quasi so die unterliegende nennen wir es mal logik hast

01:30:02.510 --> 01:30:07.470
So die business logik wie man das glaube ich so schön nennt von deiner anwendung dann hast du einen view

01:30:08.110 --> 01:30:11.110
Das ist die reine ui und mit dem viewmodel

01:30:11.750 --> 01:30:19.510
Bereitest du quasi das was du hier in deiner business logik drin hast so auf dass es dein view ordentlich verwalten und ordentlich

01:30:19.870 --> 01:30:21.430
verwenden kann

01:30:21.430 --> 01:30:26.430
Also mal angenommen mal ein simples beispiel ja du hast irgendeine logik für geld

01:30:28.870 --> 01:30:32.270
Rein mit irgendwie einem float, anzeige

01:30:32.630 --> 01:30:38.550
Geld kann das ui nichts anfangen dann würdest du den viewmodel dazwischen packen was aus

01:30:41.940 --> 01:30:44.380
Diesem betrag hier ja keine ahnung

01:30:45.260 --> 01:30:51.580
ein betrag gerundet in euro macht mit einem euro zeichen schön das display bar dahinter

01:30:52.060 --> 01:30:56.860
Und ein dein view würde das einfach nur binden das viewmodel und eins zu eins

01:30:57.740 --> 01:31:02.020
Durchreichen mit kleinen ui anpassungen so soweit ist glaube ich der gedanke hinter mvvm

01:31:05.160 --> 01:31:07.680
Ohne es jetzt bei größeren apps selbst verwendet zu haben

01:31:19.120 --> 01:31:21.200
Oder snibbi was sagst du dazu?

01:31:22.880 --> 01:31:36.190
Gut widmen wir uns zwar weiter kotlin es gibt es gibt ein paar ganz gute bücher dazu

01:31:38.390 --> 01:31:40.390
Ich habe

01:31:41.390 --> 01:31:45.710
Irgendwo auch eins für wpf wartet mal lasst mich mal um die ecke

01:31:57.250 --> 01:32:04.970
Ich habe ich habe es gefunden das ist ein buch mit irgendwie 3000 seiten oder so ohne übertreibung das heißt wpf das ultimative

01:32:07.090 --> 01:32:09.090
Ich habe ich habe schon wieder vergessen

01:32:18.330 --> 01:32:20.170
Das

01:32:20.170 --> 01:32:22.170
umfassende handbuch

01:32:22.250 --> 01:32:23.410
so

01:32:23.410 --> 01:32:25.330
mega fettes ding

01:32:25.370 --> 01:32:27.410
Keine ahnung ob das noch aktualisiert wird

01:32:29.450 --> 01:32:34.210
Das umfassende handbuch auch hier da gibt es ein bisschen was neues das hat einfach mal

01:32:37.050 --> 01:32:39.050
1218 seiten

01:32:39.610 --> 01:32:45.210
Wpf und irgendwo da wird auch auf mvvm eingegangen weil ich das richtig in erinnerung habe

01:32:45.850 --> 01:32:52.210
Ich habe mir das buch damals gekauft weil ich damals noch scharf drauf war wpf zu laufen die die erste ausgabe ist von keiner

01:32:52.770 --> 01:32:57.250
2006 oder so weil ich da noch irgendwie scharf drauf war wpf zu lernen ich habe es nie gelesen

01:33:01.520 --> 01:33:12.870
Ich habe es nie gelesen habe ich auch keinen bock drauf bin ich gar nicht dass

01:33:14.030 --> 01:33:17.790
das buchform zum lernen von solchen basics

01:33:18.590 --> 01:33:24.750
Unsinnig ist dass den riesen vorteil in buchform hast ist dass es oftmals ordentlich durchdacht und gescheit aufbereitet ist

01:33:27.070 --> 01:33:30.390
Nee das erklärt dir wirklich dass das ist kein nachschlag

01:33:30.950 --> 01:33:35.030
Referenz nachschlag ist sinnlos in buchform da gebe ich dir recht das ist was zum lernen

01:33:35.990 --> 01:33:38.510
Da kriegst du die unterschiedlichen wpf konzepte erklärt

01:33:39.270 --> 01:33:42.310
Aber wie gesagt ich habe das buch nie gelesen ich weiß nicht ob es was taugt

01:33:43.870 --> 01:33:45.870
Und für mvvm im

01:33:46.390 --> 01:33:52.750
mit wpf ich gehe mal davon aus sie sollte das in wpf machen weil das wpf ist so ziemlich das einzige desktop

01:33:52.790 --> 01:33:59.030
Was mir einfällt vielleicht aber lohnt ja noch weil es wpf bisschen nachempfunden ist wo mvvm so ein ding ist

01:33:59.910 --> 01:34:07.470
Okay weiter wir eigentlich sind wir nicht hier um auf wpf zu lässt ansonsten uns kotlin anzugucken so also pokers schleife gemacht nächster punkt

01:34:08.310 --> 01:34:14.990
Wenn wir okay lass noch mal eine andere sache ausprobieren ich gehe mal davon aus wenn wir eine schleife machen können

01:34:15.750 --> 01:34:17.750
aus

01:34:17.750 --> 01:34:22.960
Jetzt bin ich ja mal gespannt das gibt kein fehler

01:34:24.320 --> 01:34:26.320
Was ist denn das jetzt

01:34:26.800 --> 01:34:28.800
Das kann ja kein list of int mehr sein

01:34:30.920 --> 01:34:37.760
Das ist ein list of ein moment ein ein was ein list of comparable sternchen

01:34:39.440 --> 01:34:43.400
What jetzt jetzt wird es interessant was ist das jetzt

01:34:45.400 --> 01:34:47.400
Und was ist mein i

01:34:48.280 --> 01:34:50.280
Mein is ein

01:34:50.560 --> 01:34:52.560
comparable sternchen auf

01:34:53.080 --> 01:34:55.080
javas serial labels

01:34:55.880 --> 01:34:57.880
What the fuck

01:34:58.720 --> 01:35:04.360
Ist das ist das quasi jetzt list of object im endeffekt ist das im endeffekt sowas hier

01:35:09.060 --> 01:35:11.060
Moment wie kann das jetzt eine list of int sein

01:35:16.060 --> 01:35:18.060
Weil das kompiliert das

01:35:22.710 --> 01:35:24.710
Object

01:35:30.160 --> 01:35:32.160
Interessant dass es funktioniert

01:35:35.610 --> 01:35:40.170
Das das macht unter der haube ja aber aber was aber was ist das denn jetzt

01:35:41.330 --> 01:35:43.810
Das ist sowas wie ein objekt im endeffekt oder

01:35:44.690 --> 01:35:46.770
Kann ich kann ich das kasten zu einem objekt

01:35:47.610 --> 01:35:49.770
gibt gibt es überhaupt ein objekt in

01:35:50.890 --> 01:35:52.890
Und wie kastet man

01:35:54.970 --> 01:35:56.970
Fragen überfragen

01:36:00.180 --> 01:36:04.900
Kann man denn okay jetzt jetzt probieren wir mal was jetzt okay das ist vielleicht ein bisschen

01:36:05.020 --> 01:36:11.380
Advanceres topic aber das müssen wir jetzt mal ausprobieren also wir haben jetzt hier quasi so eine liste auf objekt sowas in der richtung

01:36:13.780 --> 01:36:16.380
Und wir haben jetzt nur von diesem interface

01:36:18.420 --> 01:36:21.140
Das war item sonst haben wir jetzt zwar nicht wirklich

01:36:21.740 --> 01:36:23.740
Die item ist vom typ comparable

01:36:25.020 --> 01:36:28.020
Gibt es jetzt sowas wie dass ich checken kann

01:36:30.550 --> 01:36:32.910
Ich vermute mal dass hier sind list

01:36:33.550 --> 01:36:39.470
To let run das sind wahrscheinlich sachen was alle listen haben nehmen wenn das ja gar keine liste

01:36:42.260 --> 01:36:44.260
Okay, wie kastet man sachen in

01:36:45.540 --> 01:36:47.540
kotlin cast

01:36:47.580 --> 01:36:49.580
any to object

01:36:50.380 --> 01:36:52.380
Jetzt okay

01:36:56.040 --> 01:37:03.180
Aha

01:37:03.180 --> 01:37:05.180
Aha man macht das

01:37:07.920 --> 01:37:14.160
Das ist so ein bisschen wie ein bisschen wie die pattern matching if geschichte in c sharp würde ich mal sagen

01:37:19.700 --> 01:37:23.500
Okay, das ist gar nicht. Das ist eigentlich relativ cool gemacht

01:37:24.780 --> 01:37:26.780
Also ich würde jetzt ich würde jetzt quasi sagen

01:37:27.740 --> 01:37:30.980
Wir nennen das mal item und nicht ich würde jetzt quasi sagen

01:37:33.580 --> 01:37:36.620
Item ist string string groß oder klein

01:37:40.620 --> 01:37:42.620
string groß

01:37:43.220 --> 01:37:44.580
Brindeln

01:37:44.580 --> 01:37:47.940
Was mich ein bisschen verwirrt ist warum setzt er mich hier eigentlich nicht in die mitte rein

01:37:48.460 --> 01:37:51.420
Und jetzt ist item an der stelle ist item ein string

01:37:54.380 --> 01:37:57.140
Doch jetzt ist item den string an der stelle guckt mal

01:37:59.850 --> 01:38:04.250
Jetzt habe ich nämlich auch längst und und jazz und alles mögliche am start

01:38:06.210 --> 01:38:13.050
Das ist wirklich cool was ist wenn ich jetzt in der b gleich item ist dann benen string auch comparable deshalb komisch

01:38:14.610 --> 01:38:19.890
Aber wie kastet man dann ist nämlich danke für den start wie kastet man denn von hand

01:38:21.690 --> 01:38:23.690
Außer mit

01:38:24.610 --> 01:38:29.890
Wenn expressions okay, das ist jetzt die pattern matching geschichte das muss uns auch gleich angucken es

01:38:32.640 --> 01:38:34.280
also quasi

01:38:34.280 --> 01:38:37.640
Okay, war blubb gleich item s

01:38:38.480 --> 01:38:40.320
string

01:38:40.320 --> 01:38:42.320
Und blubb ist jetzt ein swing, okay

01:38:43.320 --> 01:38:45.960
Das müsste jetzt eigentlich crashen weil du

01:38:46.720 --> 01:38:55.140
Ind nicht so quasi implizit casten kannst zu einem string oder kann kotlin das ruft es dann zu string auf

01:38:57.600 --> 01:38:59.000
Ja

01:38:59.000 --> 01:39:01.920
Integer cannot be cast to string das fällt mich jetzt auch gewundert wenn das geht

01:39:05.110 --> 01:39:11.910
Irgendwie triggert sich der gnu in den style ich weiß nicht ob es der gnu in den style ist ich finde den aber viel nicer

01:39:12.350 --> 01:39:15.550
Als die go geschichte in go würde das ganze ja also in go

01:39:15.910 --> 01:39:22.150
Also nur mal so zum vergleich check wenn wir jetzt in go also so würde das ganze auch in c sharp by the way aussehen ja

01:39:22.270 --> 01:39:24.270
in go in go

01:39:24.390 --> 01:39:30.430
Würde ihr könnt mir mal sagen gleich was ihr schöner findet so das ist ja so der normale style in anscheinend kotlin auch

01:39:30.750 --> 01:39:32.990
preferred und und c sharp standartmäßig auch

01:39:33.710 --> 01:39:35.710
In go würde das ganze so aussehen

01:39:40.820 --> 01:39:44.380
Das ist zwar kürzer, aber ich muss ehrlich sagen ich finde es eklig

01:39:58.580 --> 01:40:02.240
Viel besser

01:40:02.240 --> 01:40:14.610
Ich bin klammer in eigener zeile auch besser so wir müssen übrigens noch eine sache einstellen die mich nervt und zwar

01:40:15.690 --> 01:40:20.290
Wir wollen nicht wir wollen nicht vor spaces haben wir wollen to spaces haben

01:40:21.850 --> 01:40:24.410
Und jetzt wollen wir reformat machen

01:41:24.530 --> 01:41:27.170
Also zwei sachen irritieren mich hier schon mal

01:41:28.130 --> 01:41:31.770
Erstens warum hat kotlin diesen hässlichen klammer style standardmäßig

01:41:32.770 --> 01:41:34.610
und zweitens

01:41:34.610 --> 01:41:36.610
warum entdeckte das nicht mit

01:41:37.010 --> 01:41:39.010
nicht mit vier spaces

01:41:41.180 --> 01:41:56.590
mit zwei spaces

01:41:56.590 --> 01:41:58.390
Aber hier geht es doch auch

01:41:58.390 --> 01:42:04.200
Hä was ist das für ein scheiß?

01:42:05.240 --> 01:42:08.320
Ich es gibt ein menü und es passiert nichts wenn ich umstelle

01:42:11.180 --> 01:42:14.580
Ich an in dente das einfach mal alles und jetzt bin ich mal gespannt was es da

01:42:15.580 --> 01:42:17.580
Eins passt mal auf eins

01:42:21.300 --> 01:42:23.300
Das juckt es juckt es einfach nicht

01:42:23.940 --> 01:42:28.720
Juckt es juckt es einfach nicht

01:42:28.800 --> 01:42:35.760
Muss neu formatieren habe ich doch schon 500 mal gemacht

01:42:47.010 --> 01:42:49.410
Also ich meine ich kann es jetzt so lassen aber

01:42:50.610 --> 01:42:56.190
Vielleicht steht das im projekt so konfiguriert drinne

01:42:57.070 --> 01:43:08.290
aber

01:43:08.290 --> 01:43:13.390
Okay kotlin change indentation

01:43:19.140 --> 01:43:21.140
Intelligent

01:43:21.660 --> 01:43:25.020
Also in rider ist das gar kein ding guck hier leute

01:43:28.630 --> 01:43:30.630
Ich habe das

01:43:31.790 --> 01:43:33.550
Club

01:43:33.550 --> 01:43:35.870
Guckt ich habe das gleich so umgestellt dass das hier

01:43:37.150 --> 01:43:39.150
to spaces

01:43:39.590 --> 01:43:41.590
Gar kein gar kein problem gewesen

01:43:44.650 --> 01:44:05.580
Moment sieht ja anders aus bomben also anscheinend anscheinend geht das geht das nicht

01:44:13.620 --> 01:44:20.840
anscheinend

01:44:21.720 --> 01:44:53.640
Also ich meine das muss aber das muss doch möglich sein schau mal ganz unten rechts meinst das hier

01:44:55.120 --> 01:44:57.120
Da habe ich doch von 500 marken geklickt

01:45:02.310 --> 01:45:04.310
Coding style

01:45:15.900 --> 01:45:23.300
Wo ist kotlin hier zur auswahl gar nicht ja meine güte

01:45:23.980 --> 01:45:25.100
general

01:45:25.100 --> 01:45:38.380
Deswegen gibt es hier kotlin gar nicht zur auswahl

01:45:39.940 --> 01:45:49.010
Bei coding style doch da kotlin so jetzt bin ich mal gespannt

01:45:50.210 --> 01:45:52.210
Da habe ich den coding style umgestellt

01:45:55.170 --> 01:45:56.290
Reformat

01:45:56.290 --> 01:46:00.940
Nein das juckt es einfach nicht

01:46:06.010 --> 01:46:11.650
Okay, bevor wir uns jetzt mit dem kram aufhalten dann bleibt es halt eben bei vier spaces

01:46:14.420 --> 01:46:29.310
Vielleicht ist es auch verbuggt

01:46:29.350 --> 01:46:31.350
Vielleicht kotlin vorgabe das würde mich wundern

01:46:33.430 --> 01:46:35.870
Mich nervt übrigens auch dass es das ist das

01:46:37.390 --> 01:46:41.670
Kompiliert kotlin wenigstens ja man nicht schlecht wenn man die klammern so macht im vergleich zu go

01:46:43.990 --> 01:46:45.990
Ja gut das kann nicht funktionieren

01:46:50.550 --> 01:46:56.310
Okay, wenigstens wenigstens kompiliert kotlin go sagt ja bei sowas wenn die klammern falsch gesagt falsch gesetzt sind

01:46:56.310 --> 01:46:58.790
Oh, nee das geht überhaupt nicht dass da kann ich nicht kompilieren

01:47:01.280 --> 01:47:07.000
Was ist das eigentliche ding was ich was ich was ich ausprobieren wollte genau also guck mal also wir können implizit

01:47:07.560 --> 01:47:13.640
Quasi item zu string casten das finde ich schon mal eine coole sache wir probieren das jetzt noch mal noch mal anders aus wir

01:47:13.640 --> 01:47:17.400
Machen jetzt ein int rein wir machen jetzt ein float rein und wir machen jetzt

01:47:18.200 --> 01:47:23.600
Hat das sowas wie null oh nee damit will ich nicht anfangen

01:47:24.920 --> 01:47:28.600
Buhl genau true true lul weh machen wir da jetzt rein

01:47:30.200 --> 01:47:33.080
Das ist die einzige ausgabe die jetzt kommt ist bei

01:47:34.080 --> 01:47:41.680
1 weil das das einzige ist was mit string hat jetzt ist die frage hat link sowas hat hat kotlin sowas wie link

01:47:41.800 --> 01:47:45.080
dass ich sage wer oder oder filter oder

01:47:47.800 --> 01:47:49.800
Interessant filter

01:47:51.950 --> 01:47:56.630
Jetzt kommt das ding wie sieht die lambda sündags für kotlin aus

01:47:57.870 --> 01:47:59.870
kotlin list filter

01:48:04.750 --> 01:48:07.150
Kotlin gibt das vor ernsthaft

01:48:10.340 --> 01:48:17.100
Mann also ich mag zwei space ist einfach deutlich mehr als vier mit filtering collections

01:48:18.420 --> 01:48:20.420
Sieht wie aus

01:48:21.180 --> 01:48:25.660
Achso guck mal man muss gar nicht selbst parameter das finde ich schick

01:48:29.200 --> 01:48:31.960
Also wenn man einfach nur ein parametern kann man nicht nehmen

01:48:33.160 --> 01:48:36.360
Ansonsten kann man relativ ähnlich zur c sharp syntax

01:48:37.720 --> 01:48:39.720
Das nehmen okay

01:48:41.260 --> 01:48:43.260
Also ich kann es in dem fall sagen

01:48:44.820 --> 01:48:49.300
Type die it is string geht sowas

01:48:52.260 --> 01:48:55.260
Jetzt sagt er filter call could be simplified

01:48:58.340 --> 01:49:00.340
So

01:49:00.340 --> 01:49:04.500
Okay, also das muss man da sagen da merkt man dass jetbrains die sprache

01:49:05.380 --> 01:49:11.140
Und die idee macht dass das so gut funktioniert dass sie die alternative vorschlagen können

01:49:11.660 --> 01:49:16.300
Okay, das bedeutet nämlich auch wenn ich das so machen das war mal eine probabler schleife war mal print

01:49:16.980 --> 01:49:18.060
brindeln

01:49:18.060 --> 01:49:21.380
Und dann sage ich wie count oder sowas count

01:49:21.900 --> 01:49:23.900
Wenn das hier auch geht count

01:49:24.540 --> 01:49:29.420
Da sollte jetzt rauskommen eins obwohl ja eigentlich vier elemente drin sind

01:49:30.460 --> 01:49:38.060
Nice okay gut das heißt die haben so ein bisschen link light nennen wir es mal mit in kotlin drinne

01:49:39.060 --> 01:49:41.980
Das finde ich ganz geil mach mal eine nested list

01:49:43.500 --> 01:49:46.220
Jetzt sowas hier list of

01:49:47.380 --> 01:49:51.650
So geht doch

01:49:51.650 --> 01:49:53.650
Das ist jetzt das ist jetzt eine nested list

01:49:54.490 --> 01:50:00.380
Ich meine den string wird er natürlich aus der nested list nicht erkennen

01:50:01.260 --> 01:50:21.050
Ich meine was was wir jetzt in c sharp machen könnte ist select many neben bei mir das wieder

01:50:21.050 --> 01:50:26.970
Und das würde an der stelle gar nicht funktionieren weil das weiß er nicht welches objekt das ist okay da müssen wir jetzt

01:50:26.970 --> 01:50:31.770
Okay da müssen wir noch mal eine schleife ich finde es aber ganz also ich muss ehrlich sagen das wirkt auf mich

01:50:32.210 --> 01:50:34.610
bis jetzt relativ durchdacht alles

01:50:35.210 --> 01:50:41.400
Ja, habe ich auch schon gerade dran gedacht

01:50:41.800 --> 01:50:43.800
flat 8 tatsächlich

01:50:45.000 --> 01:50:46.880
Flat map

01:50:46.880 --> 01:50:51.400
Eine sache die mir noch ein bisschen fehlt ist ein hilfetext was das eigentlich macht

01:50:54.690 --> 01:50:57.090
Oder kann man sich mit dem hilfetext anzeigen lassen

01:50:59.360 --> 01:51:01.360
quick doch a control q

01:51:01.360 --> 01:51:05.840
Control q da kriegt man sogar eine hilfe

01:51:11.360 --> 01:51:19.600
Returns a single list of all elements yield from result of transform function ja okay das könnte man an der stelle natürlich

01:51:19.920 --> 01:51:25.490
machen

01:51:25.490 --> 01:51:26.850
das tatsächlich

01:51:26.850 --> 01:51:28.850
Das ist gar nicht gar nicht so

01:51:30.770 --> 01:51:33.250
Blöde an der stelle okay machen wir noch mal print

01:51:34.130 --> 01:51:36.130
Print l item

01:51:37.770 --> 01:51:39.770
Ja so und jetzt geht

01:51:42.500 --> 01:51:44.500
zu string das

01:51:45.740 --> 01:51:47.740
Im moment was mache ich hier überhaupt

01:51:50.010 --> 01:51:53.450
Aber ich will ich will ja eigentlich gar nicht flat map oder platt

01:51:54.890 --> 01:51:56.890
Returns a single list of all elements

01:51:57.810 --> 01:52:07.140
Ne das müsste doch müsste schon funktionieren

01:52:10.770 --> 01:52:12.770
da muss nun

01:52:13.770 --> 01:52:21.880
Iterable rauskommen also quasi wie list of it

01:52:23.880 --> 01:52:27.080
Okay das funktioniert es kann aber nicht den uns weg der sache sein oder

01:52:35.500 --> 01:52:40.660
Ich bin mir nicht sicher wie ich den krempel verhalten muss aber ich finde die funktion schon mal so und jetzt hier müsste ich jetzt

01:52:40.660 --> 01:52:42.660
quasi checken

01:52:42.780 --> 01:52:45.780
Kann man hier kann man hier multiline drinnen machen

01:52:46.620 --> 01:52:51.620
Ja, okay, also hier müsste ich jetzt quasi drin

01:52:52.820 --> 01:52:55.860
Drinnen checken wenn das eine liste ist

01:52:57.940 --> 01:53:00.740
Also quasi if kann man den if drinnen machen

01:53:04.260 --> 01:53:06.260
if

01:53:07.060 --> 01:53:13.100
Ne da muss man muss man vielleicht noch mal klammern

01:53:16.940 --> 01:53:22.380
Wie macht man mehrere zeilen damit

01:53:24.780 --> 01:53:26.780
Kotlin multiline

01:53:27.540 --> 01:53:30.340
Wir sind wir haben jetzt leider die isi themen übersprungen

01:53:34.560 --> 01:53:37.320
Ach da muss man das mit function direkt machen

01:53:38.840 --> 01:53:40.920
Also anstatt so quasi

01:53:56.100 --> 01:54:10.290
What ne man muss das mit so einem komischen pfeil machen hat okay

01:54:14.870 --> 01:54:18.630
Moment dass das das überfordert mich jetzt

01:54:20.430 --> 01:54:23.030
List zwei besser besser name überhaupt

01:54:27.700 --> 01:54:31.940
Dass das überfordert mich jetzt irgendwie dies was sie mir hier mitteilen wollen

01:54:38.800 --> 01:54:40.960
Das muss jetzt in mehrere zeilen sein oder

01:54:49.310 --> 01:54:51.310
Return oder

01:54:54.550 --> 01:55:04.590
Okay das checken wir das funktionieren soll list of

01:55:05.590 --> 01:55:07.590
Und

01:55:08.510 --> 01:55:10.510
Ohne return

01:55:10.510 --> 01:55:16.190
Also geht das okay, okay, das erinnert mich ein bisschen an die gruvi sündags die finde ich aber nicht so schön jetzt

01:55:20.390 --> 01:55:26.190
Also gar nicht so schlecht so und dann haben wir noch eine alternative multiline da macht man das mit function okay

01:55:26.470 --> 01:55:28.470
Also da würde ich jetzt quasi sagen

01:55:34.300 --> 01:55:37.060
Dann würde ich so sagen und dann fangt schon

01:55:37.860 --> 01:55:39.860
E

01:55:42.900 --> 01:55:44.900
List of

01:55:46.100 --> 01:55:48.100
Return

01:55:53.540 --> 01:55:56.500
List for each function wieso ist doch richtig so

01:56:12.610 --> 01:56:16.050
Dann check ich die sündags nicht das habe ich doch richtig gemacht

01:56:19.540 --> 01:56:23.460
Wir machen es mal so wie es funktioniert hat weil eigentlich wollte ich was anderes ausprobieren und zwar

01:56:24.180 --> 01:56:28.540
Und eigentlich wollte der chat da ich was anderes ausprobieren so also wir müssen jetzt gucken

01:56:32.980 --> 01:56:40.280
Ist eine liste oder

01:56:41.920 --> 01:56:43.920
Ihn innamorabel

01:56:45.400 --> 01:56:47.400
Collection muss ich wahrscheinlich gucken oder

01:56:50.740 --> 01:56:52.740
Wenn es eine collection ist

01:56:53.500 --> 01:57:00.460
Ne das funktioniert so nicht und das haben wir so else

01:57:01.460 --> 01:57:03.460
Return

01:57:03.740 --> 01:57:07.180
List of

01:57:07.220 --> 01:57:08.940
List of e

01:57:08.940 --> 01:57:16.530
Warum ist es jetzt warum ist es jetzt problem?

01:57:19.720 --> 01:57:21.720
So funktioniert es doch

01:57:22.040 --> 01:57:23.960
Das ist nicht

01:57:23.960 --> 01:57:26.520
Ich ich returne doch in beiden fällen was

01:57:27.200 --> 01:57:32.400
Ach, nee, ich habe nicht in beiden fällen was okay, also das wird das wird so funktionieren

01:57:32.400 --> 01:57:36.800
Nur das wird nicht hier checken sondern hier müssen wir auf collection checken das funktioniert so nicht

01:57:37.800 --> 01:57:39.800
Use collections

01:57:41.480 --> 01:57:45.050
Sternchen aha

01:57:47.650 --> 01:57:53.810
Interessant so da sollte jetzt noch nichts machen aber sollte immer noch funktionieren so und das heißt wenn das jetzt eine collection ist

01:57:53.890 --> 01:57:57.730
Dann gebe ich nicht list auf zurück sondern direkt die collection

01:58:00.020 --> 01:58:01.260
cool

01:58:01.260 --> 01:58:06.260
Okay, nice. Also ich muss sagen die haben das recht intuitiv gestaltet

01:58:06.300 --> 01:58:12.260
Ich habe noch nie was mit kotlin vorher gemacht und komme eigentlich relativ intuitiv mit mit den sachen klar

01:58:13.340 --> 01:58:15.940
Das spricht für die sprache muss man sagen

01:58:16.980 --> 01:58:27.710
So und wie sie wie würde das korrekt formatiert aussehen so na ja

01:58:28.430 --> 01:58:31.430
Man kann an der stelle wahrscheinlich übrigens auch die klammern ups

01:58:32.830 --> 01:58:36.270
Man kann an der stelle wahrscheinlich sogar die ganzen klammern auch

01:58:37.670 --> 01:58:39.670
Vermutlich weglassen

01:58:40.670 --> 01:58:42.670
Weil es ist ja nur

01:58:44.710 --> 01:58:46.710
Online

01:58:47.430 --> 01:58:49.430
Kann man nicht

01:58:50.430 --> 01:58:57.350
Dann weiß er nicht wo doch doch das kapiert aber das sieht jetzt schon ziemlich hässlich aus oder

01:59:01.110 --> 01:59:03.670
Das das sieht jetzt da sieht er schon ziemlich hässlich aus

01:59:05.470 --> 01:59:10.950
Ich meine wir könnten auch so was machen hier mal gucken ob das mal gucken ob das funktioniert

01:59:11.470 --> 01:59:17.710
Das da also wenn das eine collection ist dann eh ansonsten list auf

01:59:24.610 --> 01:59:29.410
Nee kotlin ternary operator hat kotlin sowas

01:59:39.860 --> 01:59:42.140
Nee nee

01:59:43.860 --> 01:59:51.590
Okay macht aber nix in der elvis operator

01:59:57.380 --> 02:00:00.340
Nee nee das ist was anderes das ist was anderes

02:00:01.220 --> 02:00:15.830
Der checkt ob der er checkt ob das null ist wenn das nicht null ist gibt es dann dafür den das quasi ein null check im

02:00:15.830 --> 02:00:19.980
Endeffekt

02:00:19.980 --> 02:00:25.820
Also sprich aber wir können if kann man aber auch online mäßig benutzen anscheinend

02:00:27.780 --> 02:00:30.020
Warum braucht man eigentlich keinen return hier davor

02:00:30.980 --> 02:00:35.450
der benutzt weil der weil der immer

02:00:35.810 --> 02:00:38.530
ist

02:00:38.530 --> 02:00:43.170
Das das letztmögliche aus dem execution so fahrt quasi

02:00:45.210 --> 02:00:47.450
Hä na gut

02:00:49.450 --> 02:00:54.330
Was soll es ja auch sonst sein wenn es einzeln dasteht als den return du machst ja sonst nix damit

02:00:56.010 --> 02:00:58.890
So aber ich könnte es ich könnte es wahrscheinlich so schreiben

02:01:04.220 --> 02:01:05.820
Ja

02:01:05.820 --> 02:01:07.820
Das das geht doch eigentlich voll klar

02:01:08.820 --> 02:01:12.740
Und jetzt bräuchte ich wahrscheinlich noch nicht mal die multiline geschichte

02:01:14.300 --> 02:01:17.420
Wenn ich anstatt e it verwende

02:01:24.380 --> 02:01:26.380
Geht doch eigentlich echt klar

02:01:30.010 --> 02:01:40.340
Und jetzt könnte man das sogar an der stelle hier reinschreiben oder auch nicht warum nicht doch geht doch

02:01:41.340 --> 02:01:44.980
Ah ja ich habe schon hässlicheres gesehen

02:01:46.260 --> 02:01:54.140
Das mit dem sternchen finde ich vielleicht ein bisschen gewöhnungsbedürftig aber so siehst du wenigstens gleich dass das irgendein generic type ist

02:01:55.340 --> 02:01:58.580
Was wird hier erstellt gar nix wir gucken uns kotlin an

02:02:01.920 --> 02:02:09.260
sonst nix weiter

02:02:09.260 --> 02:02:11.780
Ja, also ich muss sagen finde ich finde das

02:02:14.120 --> 02:02:17.280
Ich finde das bis jetzt eigentlich ganz ganz nice

02:02:34.270 --> 02:02:36.570
Ich finde ich finde das mit dem sternchen auch nicht so schlecht

02:02:37.350 --> 02:02:42.870
Okay, da haben wir uns jetzt schon mal so ein bisschen die basics angeguckt finde ich bis ich finde es wirklich nicht übel bis

02:02:42.870 --> 02:02:44.870
Jetzt muss ich sagen es hat was hat was

02:02:46.110 --> 02:02:51.510
Okay, wir können schleifen wir können listen wie ändert man dann was in der liste das soll man vielleicht auch noch list

02:02:53.750 --> 02:02:55.750
Push auch Gott sei dank nicht

02:02:56.590 --> 02:03:01.350
Zum glück zum glück ist nicht push das hat mich ja viel zu fair als sie bloß bloß erzielt das bloß erinnert

02:03:08.790 --> 02:03:17.320
Ändert man überhaupt was oder ist es im mutable und ich muss eine neue liste machen

02:03:23.030 --> 02:03:26.270
ich brauche eine mutable list of list of

02:03:28.750 --> 02:03:33.920
Mutable list

02:03:34.040 --> 02:03:36.040
Warum nicht okay

02:03:36.920 --> 02:03:38.920
Jetzt gibt es auch

02:03:39.600 --> 02:03:42.840
Ich vermute mal man kann den index weglassen

02:03:43.520 --> 02:03:46.800
Ja, das haben die wirklich leute wisst ihr was

02:03:47.600 --> 02:03:52.520
Bei c++ wäre es jetzt so gewesen du kannst den index nicht nicht wenn ich kann ich den index weglassen

02:03:52.640 --> 02:03:56.800
Ja kann ich bei c++ wäre es jetzt so gewesen ich kann den index nicht weglassen

02:03:59.380 --> 02:04:04.860
Und c++ hätte dann so sachen wie pushback push push front und sowas

02:04:05.660 --> 02:04:08.820
Weil hat was heißt hätte c++ hat sowas

02:04:10.060 --> 02:04:17.420
Das gefällt mir das hat was das ist gut durchdacht also dann da merkst du dass das jemand designt hat der ein bisschen ein bisschen

02:04:17.940 --> 02:04:19.300
entwickler

02:04:19.300 --> 02:04:21.300
freundlichkeit im hinterkopf hatte

02:04:22.020 --> 02:04:24.660
Also nicht wie c++ sondern das c++ gremium

02:04:26.180 --> 02:04:29.940
So gucken wir uns jetzt mal was anderes an wie macht man http requests

02:04:30.460 --> 02:04:35.780
Mal gleich mal mal mal gleich mal in einen sprung http client nein doch

02:04:39.280 --> 02:04:45.600
Jetzt kommen java shit aber das kann kotlin http request die haben doch bestimmt aber was besseres eingebaut

02:04:46.600 --> 02:04:49.960
Kotlin http requests jawohl http get

02:04:50.760 --> 02:04:53.960
Ne das ist irgendeine custom library die ich nicht haben will oder

02:04:54.920 --> 02:05:00.020
ne

02:05:00.580 --> 02:05:06.780
Http client ist doch richtig ne ne ne man muss das java zeug verwenden anscheinend

02:05:16.510 --> 02:05:30.660
Http client es gibt noch ein paar extra libraries aber das muss ja muss ja nicht sein es gibt tausend

02:05:35.080 --> 02:05:40.440
Extra libraries ok probieren wir mal ok wir probieren mal den http client zu verwenden

02:05:42.120 --> 02:05:44.480
Http client new http client ok

02:05:49.950 --> 02:05:53.750
Was will der hier von mir das remove http client nee warum?

02:05:55.070 --> 02:05:59.550
Http client get nee so einfach ist es schon mal nicht

02:06:03.420 --> 02:06:09.260
send

02:06:09.260 --> 02:06:11.700
Moment send vielleicht

02:06:11.700 --> 02:06:13.700
Jetzt

02:06:13.820 --> 02:06:21.490
Jetzt hört schon auf http get request kotlin

02:06:23.450 --> 02:06:25.450
Okay guckt man sich das beispiel noch mal an

02:06:27.980 --> 02:06:29.420
ja

02:06:29.420 --> 02:06:36.500
Request ok man braucht ein extra request man kann nicht einfach http client get machen kann man vielleicht http client get so

02:06:37.820 --> 02:06:39.820
Da braucht man ein request

02:06:40.700 --> 02:06:43.700
New nee request oder was

02:06:45.300 --> 02:06:50.180
Ups ich fand es das

02:06:51.900 --> 02:06:54.780
Http request http request

02:07:11.980 --> 02:07:13.980
Nehmen wir mal wetter.in

02:07:16.960 --> 02:07:23.240
Da will ich jetzt http requesten oder hatten die nicht wetter.in hatten die nicht auch irgendeine jason api

02:07:26.400 --> 02:07:28.400
jason

02:07:31.680 --> 02:07:33.680
Detroit das wollen wir haben

02:07:34.680 --> 02:07:36.680
Oder nicht detroit komm

02:07:37.920 --> 02:07:41.490
Frankfurt frankfurt

02:07:43.370 --> 02:07:46.250
Checkt er dass ich das in deutschland mein frankfurter meine alles checkt da

02:07:48.130 --> 02:07:50.530
So funktioniert es schon mal nicht alles klar

02:07:53.230 --> 02:07:55.230
Uri create

02:08:05.700 --> 02:08:09.070
Uri

02:08:09.230 --> 02:08:12.940
Uri

02:08:12.940 --> 02:08:14.940
create

02:08:15.420 --> 02:08:17.420
String

02:08:17.420 --> 02:08:20.540
Okay das funktioniert was ich hier versuche war

02:08:21.420 --> 02:08:23.220
was zu

02:08:23.220 --> 02:08:25.220
war request gleich

02:08:26.820 --> 02:08:29.260
War das jetzt auto rename to

02:08:30.300 --> 02:08:35.160
request

02:08:35.160 --> 02:08:37.600
Warum mache ich da eigentlich ist die kolons hinten dran

02:08:38.440 --> 02:08:49.820
so request

02:08:50.540 --> 02:08:52.540
Kunstnet warum nicht

02:08:52.820 --> 02:08:54.260
weil

02:08:54.260 --> 02:08:58.500
Type mismatch ach so muss ich da irgendwie noch die bild sagen hinten dran

02:09:09.600 --> 02:09:15.320
Also die marken http request http response body handlers of

02:09:17.680 --> 02:09:45.780
What was soll das sein was ist das sind http

02:09:47.300 --> 02:09:49.660
Responses nicht einfach immer bytes

02:09:51.580 --> 02:09:59.580
Ach so das ist okay jetzt verstehe ich könnte das ich könnte quasi das automatisch pausen lassen schon in irgendwas

02:10:00.660 --> 02:10:07.620
Also standardmäßig kriegst du ja bytes zurück so und das kann ich das quasi als utf-8 string interpretieren lassen

02:10:07.700 --> 02:10:12.860
Ich könnte es aber wahrscheinlich auch als irgendein strukt oder oder vielleicht so vielleicht sogar irgendwelche

02:10:13.020 --> 02:10:18.860
Irgendwelches jason pausen lassen an der stelle keine ahnung aber zumindest ich finde ich finde es ein bisschen

02:10:20.340 --> 02:10:22.340
Ja bis ich undurchsichtig

02:10:23.380 --> 02:10:25.380
So jetzt haben wir das gesendet

02:10:25.700 --> 02:10:32.540
Und jetzt okay ganz ehrlich da finde ich den den dort net hat http klein sogar ein bisschen angenehmer in der handhabung

02:10:33.100 --> 02:10:38.380
Weil da kriege ich hier kann ich kann ich euch gleich zeigen da kriege ich hier ein ordentliches response objekt

02:10:38.540 --> 02:10:41.380
Wenn wenn der auch nicht dabei ist als letzter schluss ist ja

02:10:43.460 --> 02:10:45.460
okay brindeln

02:10:45.860 --> 02:10:52.690
brindeln

02:10:52.770 --> 02:10:54.330
Request

02:10:54.330 --> 02:10:56.330
und jetzt kann ich sowas sagen wie

02:10:56.930 --> 02:11:07.280
Anni nicht wie response ja doch doch dann ist es ja ähnlich zu dem dort net klein response

02:11:08.640 --> 02:11:11.880
Body und er ist jetzt ist schon ein string oder wie

02:11:13.840 --> 02:11:22.200
Hä aber wenn man body doch keins dann verstehe ich den sinn davon nicht oder ist checkt er jetzt dass das ein string ist

02:11:23.760 --> 02:11:27.920
Weil ich weiß nicht ob wo er soll ich woher soll ich wissen was body für einen typ ist

02:11:28.920 --> 02:11:33.080
Das sagt mir es ist ein generic type aber nicht was es in diesem fall ist

02:11:34.360 --> 02:11:37.240
Okay, was ist blob für das ist ein string

02:11:37.880 --> 02:11:39.240
okay

02:11:39.240 --> 02:11:43.160
Also er checkt schon dass es ein string ist aber er zeigt es mir hier an der stelle

02:11:44.880 --> 02:11:46.880
Nicht an dass es ein string ist

02:11:47.880 --> 02:11:53.600
Ich weiß woher das kommt also gehe ich mal statt dass es von der aber warum zeigt mir das meine idee nicht an

02:11:53.720 --> 02:11:58.680
Wenn man hier jetzt eigentlich erwartet returns the body beste hilfe fehlermeldung überhaupt

02:11:59.680 --> 02:12:01.680
returns the body

02:12:01.960 --> 02:12:07.190
Also leute es gibt den körper zurück auf gut deutsch

02:12:09.670 --> 02:12:13.630
Ja ich finde körper zurück zurückgebende funktionen sind die besten

02:12:14.630 --> 02:12:16.630
hat nicht funktionierend

02:12:16.630 --> 02:12:22.070
Uri will undy feinski ach so ich muss

02:12:22.150 --> 02:12:26.750
Undy feinski ach so ich muss http ist https

02:12:32.070 --> 02:12:35.430
https

02:12:35.430 --> 02:12:37.430
https

02:12:37.430 --> 02:12:43.070
Chat meinte es funktioniert jetzt muss man kurz ich muss mal kurz was in die e-mails gucken bei mir am zweiten monitor

02:12:47.860 --> 02:12:52.580
Abchecken

02:13:16.470 --> 02:13:22.060
Okay fertig okay check mal was funktioniert

02:13:24.660 --> 02:13:26.660
Funktioniert okay nice

02:13:28.220 --> 02:13:33.260
Jetzt haben wir jetzt haben wir die http response also ich muss sagen ich finde ich finde es aber trotzdem noch ein bisschen ekelig in

02:13:33.260 --> 02:13:38.520
Der bedienung ich zeige euch das jetzt mal parallel wie man das in c-sharp machen würde da würde ich sagen war

02:13:38.860 --> 02:13:43.540
Http wir machen das mal so ähnlich wie hier jetzt http klang new http client

02:13:44.340 --> 02:13:51.180
So hier könnte ich jetzt irgendwelche basics sachen noch setzen am http kleinen standard header oder sowas aber lassen wir das mal lassen wir das mal

02:13:51.180 --> 02:13:53.180
außen vor

02:13:53.180 --> 02:13:58.140
So und jetzt sage ich in dort net einfach http klein get async

02:14:00.020 --> 02:14:02.020
Und dann

02:14:04.140 --> 02:14:06.140
Und dann meine url

02:14:07.140 --> 02:14:09.140
Response so

02:14:09.740 --> 02:14:15.660
Das finde ich doch irgendwie etwas angenehmer und wenn ich das ausgeben will sage ich war

02:14:16.060 --> 02:14:18.060
Ups

02:14:20.540 --> 02:14:26.500
Response ich glaube hier geht es da auch mit content und dann string read as string

02:14:27.540 --> 02:14:31.660
Meine es könnte bestimmt auch noch ein bisschen schöner sein aber insgesamt muss ich sagen

02:14:33.860 --> 02:14:40.700
Oder ja was denkt ihr leute was ist einfach oder was ist angenehmer zu entwickeln so hier oder

02:14:41.700 --> 02:14:44.780
So hier ich meine es ist im prinzip nur eine zeile mehr

02:14:45.940 --> 02:14:49.180
Nimmt sich jetzt nicht viel aber ich finde es von der klarheit her

02:14:49.860 --> 02:14:53.940
In c-sharp tatsächlich ein bisschen angenehmer als hier java standard zeug

02:14:54.820 --> 02:15:00.530
Du kannst noch eine extension function für den http klein schreiben

02:15:01.370 --> 02:15:07.820
die essig

02:15:08.180 --> 02:15:11.300
Du musst nicht essen gewählt machen du könntest theoretisch auch

02:15:12.420 --> 02:15:14.420
so machen

02:15:14.780 --> 02:15:17.620
Wenn du es ohne essen gewählt machen willst kannst du so machen

02:15:19.580 --> 02:15:21.860
Aber es ist halt dafür ausgelegt das stimmt schon

02:15:28.220 --> 02:15:30.940
Macht das ganze mal synchron. Ja hier jetzt ist synchron

02:15:31.820 --> 02:15:42.870
Die zwar ein bisschen ekliger aus gut. Ich meine die ap ist halt rein für s und ausgelegt was wir da machen

02:15:49.020 --> 02:15:52.300
Ich verstehe dieses ganze single welt konzept irgendwie nicht okay

02:15:52.820 --> 02:15:58.180
Also, dann versuche ich das mal ganz kurz zu erklären in java script ist es tatsächlich einfach

02:15:59.140 --> 02:16:03.260
einfacher mit essen gewählt weil in java script

02:16:05.260 --> 02:16:07.260
Hast du nur einen thread

02:16:09.200 --> 02:16:14.920
Jetzt mal du musst dir du musst dir keine gedanken drüber machen ob das irgendwie sich in die quere kommt

02:16:15.160 --> 02:16:21.840
In c-sharp hast du einen thread pool und essen gewählt was du hast quasi beides so ein bisschen kombiniert

02:16:22.320 --> 02:16:24.320
also was das hier macht

02:16:24.360 --> 02:16:28.960
Wir müssten das vielleicht ein bisschen umschreiben nur so zur erklärung was was das hier macht ist folgendes

02:16:29.880 --> 02:16:31.880
Man könnte es vielleicht auch eher

02:16:32.240 --> 02:16:34.240
return await oder so nennen

02:16:38.900 --> 02:16:41.900
also gedacht ist es in der welt dafür dass du

02:16:42.900 --> 02:16:46.900
Asynchronen code schreiben kannst wie synchron

02:16:48.380 --> 02:16:54.020
Und ich nicht selbst um callbacks kümmern musst also ich ich zeig dir das mal ich zeig dir mal was

02:16:55.980 --> 02:16:57.980
Anstatt das mit essen zu machen

02:16:58.260 --> 02:17:03.460
Machen wir mal ein beispiel ich weiß ich hatte ja war auch so was in der richtung wenn ich wenn ich kann man sich das

02:17:03.460 --> 02:17:05.580
Gleiche für java script denken also

02:17:06.180 --> 02:17:09.780
Wir machen das ganze mal ohne essen gewählt okay und auch ohne

02:17:10.700 --> 02:17:17.500
Forciertes synchron sein du könntest ohne await auch sagen continue with

02:17:20.420 --> 02:17:22.420
Response da müssen wir das hier aber wegmachen

02:17:25.540 --> 02:17:28.730
Response

02:17:28.730 --> 02:17:35.610
So das wird ein bisschen ekliger zu lesen aber dann siehst du wahrscheinlich was passiert ja und dann wird zu sagen response

02:17:38.180 --> 02:17:52.220
Hab ich mich irgendwo vertan? ach result muss ich machen ja okay weil es ein task ist

02:17:55.170 --> 02:17:58.170
Response nennen wir es mal so hier irgendwie keine ahnung

02:18:01.530 --> 02:18:04.010
Task wenn es einfach task mal so ist so

02:18:05.010 --> 02:18:08.450
Result response dann würde ich sagen response

02:18:09.930 --> 02:18:11.930
Content

02:18:12.050 --> 02:18:14.050
Response

02:18:14.530 --> 02:18:16.530
Content

02:18:17.610 --> 02:18:21.490
Read a string äh sing und dann würde ich wieder sagen continue with

02:18:23.490 --> 02:18:25.490
Es ist halt ein bisschen eklig

02:18:31.460 --> 02:18:33.460
Cw task 2

02:18:34.540 --> 02:18:35.740
Result

02:18:35.740 --> 02:18:41.620
Oder war output dass man noch besser lesen kann ich kann auch nicht schreiben output gleich

02:18:41.980 --> 02:18:43.980
Task 2 result

02:18:44.220 --> 02:18:48.900
So das ist die synchrone variante ich glaube die versteht man prinzipiell ganz gut

02:18:49.340 --> 02:18:52.380
Was an der stelle die nicht die synchrone die callback variante

02:18:53.100 --> 02:19:00.580
Ich glaube da versteht man relativ gut was von was da ach so ja das könnte tatsächlich auch sein das kann man das machen

02:19:01.180 --> 02:19:07.890
Und was ist task 2 dann ist das gleiche macht keinen unterschied oder

02:19:07.890 --> 02:19:13.130
Also ich glaube dass das ist die die callback variante die versteht man glaube ich ganz gut oder

02:19:14.530 --> 02:19:16.530
Also der macht einen get request

02:19:17.450 --> 02:19:21.370
Wenn der get request fertig ist wird das continue mit aufgerufen

02:19:21.890 --> 02:19:26.770
Dann holen wir uns das result aus dem get request was unsere response ist

02:19:27.730 --> 02:19:29.250
und

02:19:29.250 --> 02:19:31.770
response holen wir uns den content raus

02:19:31.810 --> 02:19:33.810
Holen wir uns den content raus

02:19:34.210 --> 02:19:38.850
Und wollen den als string auslesen allerdings machen wir das auch asynchron mit callback

02:19:38.970 --> 02:19:40.730
Weil es kann ja durchaus sein

02:19:40.730 --> 02:19:43.930
Dass es ein bisschen länger ist und ein bisschen länger dauert oder vielleicht noch zusätzlich

02:19:44.170 --> 02:19:48.650
Sachen geladen werden gerade nachgeladen werden was auch immer das heißt wenn das fertig ist

02:19:50.330 --> 02:19:57.650
Dann sagen wir okay continue with holen wir uns das result und geben es aus ich glaube dark wäre das geschrieben

02:19:58.650 --> 02:20:04.930
Dark side dark side hd also ich glaube in der callback schreibweise versteht man das eigentlich ganz gut was passiert

02:20:05.570 --> 02:20:10.690
Das ist immer wenn fertig dann macht weiter und wenn fertig dann macht weiter ja so

02:20:11.330 --> 02:20:16.650
Und im prinzip ist die ganze s und wait geschehen in dem fall nicht die in dem fall ist es ja

02:20:17.050 --> 02:20:21.530
Brauchst du das s und keyboard nicht sondern nur wait weil das selbst mit s und implementiert ist

02:20:22.090 --> 02:20:24.090
wait macht im prinzip das

02:20:24.450 --> 02:20:29.090
Hier hast du ganz viele callbacks und stelle dir mal vor du machst jetzt hier noch drei weitere asynchrone sachen drinne

02:20:30.850 --> 02:20:34.910
Dann hast du hier ein rückungstiefe bis zum mond

02:20:36.450 --> 02:20:42.770
Eine sache ist in beiden beiden gleich egal ob du das mit wait machst oder mit continue with also in dem fall

02:20:43.210 --> 02:20:49.770
Irgendwann irgendwann hängt das ja also wir sind uns jetzt ja einig wenn ich das hier ausführe ja wenn ich hier unten 123 schreibe

02:20:50.170 --> 02:20:53.450
Dann wird das hier schon ausgeführt wofür das hier fertig ist

02:20:54.210 --> 02:20:58.620
Weil hier das blockt ja nicht

02:21:00.540 --> 02:21:02.540
Und damit das nicht blockt

02:21:03.140 --> 02:21:10.860
Muss im hintergrund ja irgendwas passieren also das kann es also ich muss das anders erklären wenn das hier synchron wäre

02:21:12.100 --> 02:21:15.860
Dann würde jetzt wir machen das mal so hier console readline

02:21:17.740 --> 02:21:19.460
Du wirst jetzt feststellen

02:21:19.460 --> 02:21:26.260
Der wird als erstes ausgeben 1 2 3 hast du es gesehen da gibt als erstes 1 2 3 aus und erst danach

02:21:27.300 --> 02:21:33.440
Gibt er die response aus ist ja logisch weil was passiert an der stelle an der stelle

02:21:33.980 --> 02:21:41.540
Gibt es einen background job der losläuft und den get macht dass das jetzt den get request macht und erst wenn der fertig ist wird

02:21:41.540 --> 02:21:47.220
Dann asynchron kontinuier ist kontinuier ist gemacht das heißt hier wird es quasi geqt die arbeit

02:21:48.140 --> 02:21:52.900
Und dann geht das program ganz normal linear weiter und dann kommt das printline und dann

02:21:53.220 --> 02:21:58.620
Irgendwann ist das fertig und dann geht es weiter mit dem kontinuier das heißt es wird im hintergrund geqt

02:21:58.980 --> 02:22:04.580
Das jetzt hier in der http get request läuft also für quasi also eine asynchrone io operation gemacht

02:22:05.460 --> 02:22:10.700
In javascript ist es relativ einfach weil da gibt es nur einen thread da musst du dir keine gedanken machen ob das jetzt

02:22:11.300 --> 02:22:13.980
Asynchron ist ob das background queues sind ob das

02:22:14.580 --> 02:22:20.500
Tasks und threads und was auch immer sind in c-sharp ist das meistens so dass das ein

02:22:21.020 --> 02:22:23.460
background in backgrounds threadpool gibt

02:22:24.020 --> 02:22:31.340
Und das quasi so eine warteschlange mit ganz vielen threads drinnen die nur warten dass sie was erledigen können für dich im hintergrund

02:22:31.340 --> 02:22:33.340
Und da wird das reingeschmissen

02:22:34.300 --> 02:22:38.300
Und wenn das fertig ist das program läuft da ganz normal weiter und wenn das fertig ist

02:22:38.700 --> 02:22:44.740
Wird dann an der stelle hat continuous und noch mal continuous aufgerufen also ich glaube das versteht man an der stelle ganz gut jetzt ist

02:22:44.740 --> 02:22:45.980
halt das ding

02:22:45.980 --> 02:22:50.300
Dass das ziemlich eklig aussieht und dass das komplett aus dem ruder läuft mit

02:22:50.540 --> 02:22:56.260
Einrückungstiefe wenn ich hier noch mehr solche dinger hättest in javascript sieht das übrigens genau so aus ich bin mir gerade nicht sicher wie das

02:22:56.260 --> 02:22:58.540
in javascript ausschaut wenn man es von hand aufruft

02:23:00.260 --> 02:23:06.850
Denn ist das glaube ich ja hier so mit javascript wäre das so so

02:23:07.730 --> 02:23:15.610
Und erwähnt macht jetzt im prinzip was ähnliches wir kürzen wir kürzen das ganze mal wir geben uns mal wir geben uns mal hiermit

02:23:15.610 --> 02:23:17.610
zufrieden okay

02:23:18.050 --> 02:23:21.050
Wobei ich mache es einfach rückgängig haben wir es ja wieder

02:23:22.770 --> 02:23:25.930
Oh, nee ich kann nicht weiter rückgängig machen das ist hässlich

02:23:27.130 --> 02:23:29.130
monkaS

02:23:33.700 --> 02:23:38.740
Also haben wir das hier await war response gleich

02:23:39.060 --> 02:23:41.060
zack so

02:23:41.060 --> 02:23:45.380
Hier wirst du jetzt auch sehen das erste was passiert, äh quatsch nicht das erste was passiert plötzlich

02:23:48.580 --> 02:23:51.980
Achso ich geb's ja, ich kack noob alter, ich geb's ja gar nicht aus

02:23:53.540 --> 02:23:55.540
Okay da muss man doch mal anwarten, war also hier

02:23:57.660 --> 02:24:02.460
response content read as string

02:24:04.100 --> 02:24:06.820
Await so und jetzt wird dir vielleicht was auffallen

02:24:08.970 --> 02:24:16.170
Tja guck mal da jetzt ist die reihenfolge ja auf einmal so wie wir es dahin geschrieben haben

02:24:17.970 --> 02:24:24.330
Ich glaube du erkennst den unterschied also jetzt passiert wirklich zuerst das und dann das

02:24:25.810 --> 02:24:28.010
Obwohl das eigentlich asynchron sein soll

02:24:29.250 --> 02:24:35.130
Und das ist das was await im endeffekt macht das hier wird ganz normal im background gequeued aber

02:24:35.690 --> 02:24:40.490
Weil der await davor steht passiert an der stelle eigentlich so eine art return

02:24:42.690 --> 02:24:45.890
Ich würde es dir gerne zeigen, aber ich habe keinen decompiler hier

02:24:48.130 --> 02:24:50.330
Ich nenne es mal der whoops

02:24:52.050 --> 02:24:57.970
Der pausiert quasi an der stelle bis der asynchrone call fertig ist deswegen heißt das auch await

02:24:58.410 --> 02:25:01.330
Ich meine return await wäre vielleicht ein bisschen klarer

02:25:02.330 --> 02:25:07.550
Der hört einfach hier nach auf oder der hört quasi an der stelle auf

02:25:08.150 --> 02:25:10.070
führt das im hintergrund aus

02:25:10.070 --> 02:25:16.070
Und wenn das hier fertig ist dann springt er an der stelle wieder rein und macht das weiter das heißt du kannst du kannst

02:25:16.270 --> 02:25:18.270
asynchronen code basteln

02:25:19.230 --> 02:25:24.070
Der sich ein bisschen verhält wie synchroner code in dem beispiel ist es jetzt nicht so

02:25:26.800 --> 02:25:30.360
Nicht so offensichtlich warum das warum das sinnvoll ist

02:25:30.360 --> 02:25:33.440
Wenn du dir jetzt aber vorstellst du hast eine ui anwendung

02:25:34.440 --> 02:25:43.280
Und ui anwendung frieren mal ganz gerne ein wenn die für 20 30 sekunden hängen

02:25:44.600 --> 02:25:50.920
Dann ist das hier natürlich wieder sinnvoll weil dann hängt eine ui anwendung nicht sondern an der stelle hört er einfach mit dem ausführen

02:25:50.920 --> 02:25:52.920
dieser funktion auf

02:25:53.240 --> 02:26:01.370
Aber die ui anwendung kann weiterhin nachrichten empfangen von windows und verarbeiten und hängt dadurch nicht das müssen wir jetzt eigentlich mal demonstrieren

02:26:01.690 --> 02:26:06.170
Man müsste sich es wahrscheinlich wirklich mal in sharp lab angucken da sieht man es vielleicht ganz gut

02:26:07.170 --> 02:26:13.980
Ich glaube da können wir das ganze hier copy paste in dem moment das ist kotten das können wir nicht rein copy pasten

02:26:16.140 --> 02:26:18.140
Das da

02:26:19.340 --> 02:26:22.700
Gucken wir mal ich hoffe man man sieht das man erkennt das gescheit

02:26:25.820 --> 02:26:39.740
Chat ich habe mal eine dumme frage warum muss ich http-client nicht inkluden

02:26:39.740 --> 02:26:50.090
Wo kommt der her ist es ein global using das könnte sein

02:26:51.850 --> 02:27:04.070
Ist das vielleicht auch gott.net macht mir viel zu viel magic in letzter zeit wartet mal

02:27:06.230 --> 02:27:09.110
Nee ist es nicht wo kommt das her

02:27:10.230 --> 02:27:13.270
Ist global import nicht nicht hier drinne mittlerweile

02:27:14.230 --> 02:27:18.550
Na gut was muss ich was muss ich importieren dafür

02:27:19.110 --> 02:27:28.020
Was ist denn system.net

02:27:34.900 --> 02:27:37.860
Okay das ist using system

02:27:44.730 --> 02:27:47.850
Wo ist wo ist wo ist console drinne

02:27:48.970 --> 02:27:55.580
In system console okay okay jetzt haben wir es also das ist jetzt natürlich

02:27:56.620 --> 02:28:01.080
das ist jetzt natürlich

02:28:01.080 --> 02:28:03.080
Kann man das vielleicht groß machen

02:28:04.600 --> 02:28:08.680
Zumindest wird das ganze essen gewählt zeug kann ich oh nee nee oh falscher

02:28:10.520 --> 02:28:12.520
Kann man hier nicht

02:28:12.760 --> 02:28:20.760
Das essen gewählt zeug macht keine großartige also das ist nichts was direkt in der runtime drinne ist unter der haube wird das umgebaut

02:28:21.320 --> 02:28:23.320
Zu das ist jetzt nicht so gut

02:28:23.320 --> 02:28:26.360
Hier wird das hier wird dass geköz

02:28:28.280 --> 02:28:32.360
But the pick lined get get a cent und hier ist die frage

02:28:34.680 --> 02:28:51.210
Weil finde ich falsch

02:28:51.210 --> 02:28:53.210
und hier ist die frage

02:28:53.210 --> 02:28:55.210
if

02:28:55.210 --> 02:28:57.210
der hört hier wirklich auf

02:28:57.210 --> 02:28:59.210
an der stelle

02:28:59.210 --> 02:29:01.210
if not completed

02:29:01.210 --> 02:29:03.210
dann geht der einfach

02:29:03.210 --> 02:29:05.210
raus aus der funktion

02:29:05.210 --> 02:29:11.460
also der hat

02:29:11.460 --> 02:29:13.460
meine main funktion umgebaut

02:29:13.460 --> 02:29:15.460
in was immer wieder aufgerufen

02:29:15.460 --> 02:29:17.460
werden kann

02:29:17.460 --> 02:29:19.460
da musst du dir mal ein video angucken wie das genau

02:29:19.460 --> 02:29:21.460
funktioniert aber ich finde hier sieht man es

02:29:21.460 --> 02:29:23.460
eigentlich schon ganz gut

02:29:23.460 --> 02:29:25.460
das ist ja eindeutig meine main funktion

02:29:25.460 --> 02:29:27.460
die umgebaut wurde zu so einer Art

02:29:27.460 --> 02:29:29.460
async task state machine

02:29:29.460 --> 02:29:31.460
hier passiert

02:29:31.460 --> 02:29:33.460
der eigentliche get request

02:29:33.460 --> 02:29:35.460
so und dann guckt der danach nach

02:29:35.460 --> 02:29:37.460
ist der fertig, es kann ja sein dass der instant fertig ist

02:29:37.460 --> 02:29:39.460
wenn der instant fertig ist kann er weitermachen

02:29:39.460 --> 02:29:41.460
aber in der regel hängt das

02:29:41.460 --> 02:29:43.460
erstmal eine weile, dieser get request

02:29:43.460 --> 02:29:45.460
der braucht eine weile, der guckt

02:29:45.460 --> 02:29:47.460
ist der fertig, ok nein

02:29:47.460 --> 02:29:49.460
der ist höchstwahrscheinlich nicht fertig

02:29:49.460 --> 02:29:51.460
und jetzt

02:29:51.460 --> 02:29:53.460
queter quasi

02:29:53.460 --> 02:29:56.840
den callback

02:29:56.840 --> 02:29:58.840
hierfür wieder und dann returnt er

02:29:58.840 --> 02:30:00.840
das ist auch der grund warum in UI nicht hängen

02:30:00.840 --> 02:30:02.840
bleiben würde

02:30:02.840 --> 02:30:04.840
weil die funktion wird hier an der stelle

02:30:04.840 --> 02:30:06.840
an dem await wirklich, deswegen sag ich ja

02:30:06.840 --> 02:30:08.840
return await wäre ein bisschen klarer

02:30:08.840 --> 02:30:10.840
an der stelle

02:30:10.840 --> 02:30:12.840
das wird tatsächlich

02:30:12.840 --> 02:30:14.840
nicht unterbrochen

02:30:14.840 --> 02:30:16.840
also die wird beendet, das ausführen

02:30:16.840 --> 02:30:18.840
dieser funktion

02:30:18.840 --> 02:30:20.840
und sobald der hier fertig ist

02:30:20.840 --> 02:30:22.840
dann wird das wieder

02:30:22.840 --> 02:30:24.840
aufgerufen

02:30:24.840 --> 02:30:26.840
dann wird wieder move next aufgerufen

02:30:26.840 --> 02:30:28.840
und dann ist es allerdings

02:30:28.840 --> 02:30:30.840
an der stelle so, num ist dann

02:30:30.840 --> 02:30:32.840
ungleich 0, weil das der state

02:30:32.840 --> 02:30:34.840
wahrscheinlich dann 1 ist

02:30:34.840 --> 02:30:36.840
oder sonst was und dann siehst du

02:30:36.840 --> 02:30:38.840
ok, wenn er das nächste mal

02:30:38.840 --> 02:30:40.840
in diese funktion rein springt

02:30:40.840 --> 02:30:42.840
dann wird nicht mehr das hier ausgeführt

02:30:42.840 --> 02:30:44.840
sondern es wird der nächste

02:30:44.840 --> 02:30:46.840
schritt ausgeführt, nämlich

02:30:46.840 --> 02:30:48.840
http response message

02:30:48.840 --> 02:30:50.840
und aus der http response message

02:30:50.840 --> 02:30:52.840
holt er sich den String raus

02:30:52.840 --> 02:30:54.840
das queute er wieder im Hintergrund, er returnt

02:30:54.840 --> 02:30:56.840
aus der Funktion, wenn

02:30:56.840 --> 02:30:58.840
das hier fertig ist, das ist quasi so eine Art

02:30:58.840 --> 02:31:00.840
callback

02:31:00.840 --> 02:31:02.840
wenn der background

02:31:02.840 --> 02:31:04.840
job fertig ist, dann springt er wieder

02:31:04.840 --> 02:31:06.840
hier rein zu move next

02:31:06.840 --> 02:31:08.840
dann ist der state diesmal halt

02:31:08.840 --> 02:31:10.840
nicht num und nicht das hier und das hier

02:31:10.840 --> 02:31:12.840
sondern der state ist dann

02:31:12.840 --> 02:31:14.840
das hier

02:31:14.840 --> 02:31:16.840
oder immer hier, get result

02:31:16.840 --> 02:31:18.840
und hier wird es dann ausgegeben

02:31:18.840 --> 02:31:24.840
also im Prinzip ist das wie die mit den callbacks

02:31:24.840 --> 02:31:26.840
nur

02:31:26.840 --> 02:31:28.840
dass der sich im Hintergrund

02:31:28.840 --> 02:31:30.840
drum kümmert und dafür sorgt

02:31:30.840 --> 02:31:32.840
dass es so aussieht als wäre

02:31:32.840 --> 02:31:34.840
es synchron vom

02:31:34.840 --> 02:31:36.840
eigentlichen Ablauf her

02:31:36.840 --> 02:31:38.840
aber im Hintergrund ist es tatsächlich

02:31:38.840 --> 02:31:40.840
ein background task

02:31:40.840 --> 02:31:42.840
sodass deine UIs nicht

02:31:42.840 --> 02:31:44.840
einfrieren, hab ich jetzt

02:31:44.840 --> 02:31:46.840
beschissen erklärt, aber

02:31:46.840 --> 02:31:48.840
es ist spontan recht

02:31:48.840 --> 02:32:00.410
schwierig zu erklären

02:32:00.410 --> 02:32:02.410
so weiter mit kotlin

02:32:02.410 --> 02:32:04.410
wir müssen jetzt hier mal einen get request machen

02:32:04.410 --> 02:32:06.410
jetzt kommt die

02:32:06.410 --> 02:32:08.410
nächste Frage

02:32:08.410 --> 02:32:10.410
wie passt man jason

02:32:10.410 --> 02:32:12.410
in kotlin

02:32:12.410 --> 02:32:14.410
kotlin jason parser

02:32:14.410 --> 02:32:16.410
how to parse jason in kotlin

02:32:16.410 --> 02:32:18.410
stackoverflow beste

02:32:18.410 --> 02:32:20.410
kotlins

02:32:20.410 --> 02:32:22.410
ne

02:32:22.410 --> 02:32:24.410
ich will eigentlich

02:32:24.410 --> 02:32:26.410
keine Objekte anlegen dafür

02:32:26.410 --> 02:32:30.490
ich weiß gar nicht ob kotlin

02:32:30.490 --> 02:32:32.490
unterstützt, wahrscheinlich

02:32:32.490 --> 02:32:34.490
aber ich weiß nicht wie man das da macht

02:32:34.490 --> 02:32:36.490
die haben bestimmt auch

02:32:36.490 --> 02:32:38.490
sowas in der Richtung

02:32:38.490 --> 02:32:40.490
composing suspending

02:32:40.490 --> 02:32:47.320
functions

02:32:47.320 --> 02:32:49.320
ok, das ist hiq

02:32:49.320 --> 02:32:51.320
shit, ok, aber komm mal

02:32:51.320 --> 02:32:53.320
zu kotlin wieder, wie parse ich

02:32:53.320 --> 02:32:55.320
das denn jetzt als jason

02:32:55.320 --> 02:32:57.320
j object

02:32:57.320 --> 02:32:59.320
hab ich da grad schon gesehen

02:32:59.320 --> 02:33:01.320
netscape

02:33:01.320 --> 02:33:03.320
javascript, moment

02:33:03.320 --> 02:33:05.320
was bin ich denn hier

02:33:05.320 --> 02:33:10.940
sehend, ich glaube nicht

02:33:10.940 --> 02:33:14.310
dass man das braucht, oder

02:33:14.310 --> 02:33:16.310
nee, nee, nee

02:33:16.310 --> 02:33:18.310
kotlin

02:33:18.310 --> 02:33:20.310
parse, ok, da ist doch

02:33:20.310 --> 02:33:22.310
standard library irgendwas eingebaut, oder

02:33:22.310 --> 02:33:24.310
how to parse jason

02:33:24.310 --> 02:33:26.310
in kotlin

02:33:26.310 --> 02:33:28.310
example

02:33:28.310 --> 02:33:30.310
jason serialization

02:33:30.310 --> 02:33:32.310
vielleicht groß geschrieben, ja

02:33:32.310 --> 02:33:34.310
jason, nee, auch nicht

02:33:34.310 --> 02:33:37.620
tchatke, ich guck mal was ihr hier schreibt

02:33:37.620 --> 02:33:41.900
example

02:33:41.900 --> 02:33:43.900
serialization, nee

02:33:43.900 --> 02:33:45.900
ich will es nicht serializen

02:33:45.900 --> 02:33:47.900
ich will es ja, eigentlich will ich

02:33:47.900 --> 02:33:49.900
es noch nicht mal deserializen

02:33:49.900 --> 02:33:54.810
ehrlich gesagt

02:33:54.810 --> 02:33:58.950
ich will es

02:33:58.950 --> 02:34:00.950
eigentlich

02:34:00.950 --> 02:34:05.160
nur parsen und dann

02:34:05.160 --> 02:34:07.160
auf irgendwie ein, zwei Felder

02:34:07.160 --> 02:34:09.160
zugreifen, ich will gar keine extra Klassen oder so

02:34:09.160 --> 02:34:11.160
erstellen

02:34:11.160 --> 02:34:13.160
kotlin x serialization

02:34:13.160 --> 02:34:17.370
serialization

02:34:17.370 --> 02:34:19.370
serializable, dataclass

02:34:19.370 --> 02:34:21.370
data, nee da muss ich das

02:34:21.370 --> 02:34:23.370
jetzt ja nachbauen, das ist jetzt nicht so

02:34:23.370 --> 02:34:25.370
sinn und zweck der Sache

02:34:25.370 --> 02:34:30.920
jason, decode

02:34:30.920 --> 02:34:32.920
from string als data

02:34:32.920 --> 02:34:34.920
gibt das nicht sowas wie dynamic

02:34:34.920 --> 02:34:36.920
object, oder irgendwas

02:34:36.920 --> 02:34:38.920
oder sagen wir mal

02:34:38.920 --> 02:34:46.390
java

02:34:46.390 --> 02:34:48.390
parse jason

02:34:48.390 --> 02:34:50.390
gucken wir wie die das machen

02:34:50.390 --> 02:34:52.390
von 2010 ist vielleicht ein bisschen

02:34:52.390 --> 02:34:56.220
bisschen

02:34:56.220 --> 02:35:00.550
übertrieben

02:35:00.550 --> 02:35:02.550
introduction zu jason java

02:35:02.550 --> 02:35:04.550
dann

02:35:04.550 --> 02:35:06.550
introdukte mich mal

02:35:06.550 --> 02:35:08.550
ich bin immer wieder überrascht wie kompliziert

02:35:08.550 --> 02:35:10.550
wie kompliziert so Sachen manchmal sind

02:35:10.550 --> 02:35:12.550
wenn was

02:35:12.550 --> 02:35:14.550
nicht in der standard library drin ist

02:35:14.550 --> 02:35:18.120
jason object

02:35:18.120 --> 02:35:20.120
ok aber das hab ich doch gar nicht

02:35:20.120 --> 02:35:23.500
was

02:35:23.500 --> 02:35:25.500
yes

02:35:25.500 --> 02:35:29.700
nee

02:35:29.700 --> 02:35:31.700
moment

02:35:31.700 --> 02:35:33.700
hab ich da, wall

02:35:33.700 --> 02:35:35.700
moment was ist der unterschied

02:35:35.700 --> 02:35:39.210
zwischen war und wall

02:35:39.210 --> 02:35:41.210
aha wall

02:35:41.210 --> 02:35:43.210
ist quasi nicht mutable

02:35:43.210 --> 02:35:45.210
und war ist

02:35:45.210 --> 02:35:47.210
ich

02:35:47.210 --> 02:35:49.210
muss sagen ohne scheiß

02:35:49.210 --> 02:35:51.210
ich find das gut

02:35:51.210 --> 02:35:53.210
die kotlin leute haben sich wirklich was

02:35:53.210 --> 02:35:55.210
beigedacht, weil well für value

02:35:55.210 --> 02:35:57.210
kann ich irgendwie verstehen, ändert sich

02:35:57.210 --> 02:35:59.210
nicht, und war für

02:35:59.210 --> 02:36:01.210
variable kann sich ändern

02:36:01.210 --> 02:36:03.210
ist doch eigentlich gar nicht doof oder

02:36:03.210 --> 02:36:12.860
in rust

02:36:12.860 --> 02:36:14.860
muss man glaube ich machen

02:36:14.860 --> 02:36:16.860
also in rust macht man glaube ich

02:36:16.860 --> 02:36:18.860
let blub

02:36:18.860 --> 02:36:20.860
u in 32

02:36:20.860 --> 02:36:22.860
gleich 1 oder so

02:36:22.860 --> 02:36:24.860
korrigiert mich wenn mein rust nicht so

02:36:24.860 --> 02:36:26.860
5 header ist im kopf, aber ich glaube das ist

02:36:26.860 --> 02:36:28.860
in rust, muss man das so machen

02:36:28.860 --> 02:36:30.860
und wenn man das mutable haben will

02:36:30.860 --> 02:36:32.860
muss man das glaube ich in rust sogar so machen

02:36:32.860 --> 02:36:34.860
oder

02:36:34.860 --> 02:36:36.860
oder anstatt let mut

02:36:36.860 --> 02:36:41.510
nee

02:36:41.510 --> 02:36:43.510
so

02:36:43.510 --> 02:36:45.510
dann finde ich das hier

02:36:45.510 --> 02:36:47.510
sogar ansprechender ehrlich gesagt

02:36:47.510 --> 02:36:51.460
so aber

02:36:51.460 --> 02:36:53.460
wie parse ich denn jetzt

02:36:53.460 --> 02:36:55.460
fucking jason, so kompliziert kann das doch nicht sein

02:36:55.460 --> 02:37:02.100
und was soll

02:37:02.100 --> 02:37:19.560
das überhaupt sein

02:37:19.560 --> 02:37:21.560
ja das interessiert mich, parse jason without

02:37:21.560 --> 02:37:25.450
dataclass

02:37:25.450 --> 02:37:27.450
ok das ist ganz gut

02:37:27.450 --> 02:37:29.450
kotlin x serialization

02:37:29.450 --> 02:37:33.590
ja

02:37:33.590 --> 02:37:35.590
das will ich haben, ok

02:37:35.590 --> 02:37:37.590
jason

02:37:37.590 --> 02:37:39.590
parse to jason element

02:37:39.590 --> 02:37:45.080
ok top

02:37:45.080 --> 02:37:49.610
jason

02:37:49.610 --> 02:37:51.610
parse to jason element, response

02:37:51.610 --> 02:37:53.610
body

02:37:53.610 --> 02:37:55.610
die preisfrage ist nur

02:37:55.610 --> 02:37:57.610
woher bekomme ich diese lab

02:37:57.610 --> 02:37:59.610
jetzt, weil

02:37:59.610 --> 02:38:04.780
ja dabei ist die ja anscheinend

02:38:04.780 --> 02:38:10.780
nicht

02:38:10.780 --> 02:38:12.780
kotlin x serialization

02:38:12.780 --> 02:38:18.900
wieso ist der funktionsname

02:38:18.900 --> 02:38:22.540
groß

02:38:22.540 --> 02:38:24.540
wahrscheinlich weil das irgendein objekt ist oder

02:38:24.540 --> 02:38:26.540
und die schreibt man halt so

02:38:26.540 --> 02:38:28.540
wie http klein und halt mit groß

02:38:28.540 --> 02:38:30.540
gibt es denn package

02:38:30.540 --> 02:38:32.540
ja da bin ich gerade am überlegen

02:38:32.540 --> 02:38:34.540
wie geht das

02:38:34.540 --> 02:38:40.540
cradle

02:38:40.540 --> 02:38:47.180
hier is a small example

02:38:47.180 --> 02:38:49.180
ich hätte jetzt gedacht das ist sowas wie standard library

02:38:49.180 --> 02:38:55.620
aber nee anscheinend nicht

02:38:55.620 --> 02:38:57.620
ach mein projekt ist im falschen

02:38:57.620 --> 02:39:02.600
format oder wie

02:39:02.600 --> 02:39:04.600
hä

02:39:04.600 --> 02:39:10.150
what

02:39:10.150 --> 02:39:18.780
no god

02:39:18.780 --> 02:39:20.780
ist jetzt nicht euer ernst oder

02:39:20.780 --> 02:39:22.780
das kann

02:39:22.780 --> 02:39:27.560
kein package manager

02:39:27.560 --> 02:39:29.560
ok das gefällt mir schon mal nicht

02:39:29.560 --> 02:39:34.340
rechtsklick auf dein

02:39:34.340 --> 02:39:36.340
projekt und dann framework hinzufügen

02:39:36.340 --> 02:39:42.150
äh wo

02:39:42.150 --> 02:39:45.590
oder ist das

02:39:45.590 --> 02:39:47.590
was ist überhaupt mein projekt, das hier

02:39:47.590 --> 02:39:50.900
ja ne

02:39:50.900 --> 02:39:52.900
ähm module setting

02:39:52.900 --> 02:39:54.900
libraries

02:39:54.900 --> 02:40:00.390
nee

02:40:00.390 --> 02:40:04.280
nee nee das ist irgendwas anderes

02:40:04.280 --> 02:40:10.540
da gehts jetzt schon los

02:40:10.540 --> 02:40:17.180
was ist denn

02:40:17.180 --> 02:40:19.180
in source, gute frage

02:40:19.180 --> 02:40:21.180
kotlin

02:40:21.180 --> 02:40:25.770
zeug

02:40:25.770 --> 02:40:27.770
nee mein source code ist in source

02:40:27.770 --> 02:40:29.770
würd sagen das hier

02:40:29.770 --> 02:40:31.770
ist mein program

02:40:31.770 --> 02:40:33.770
so

02:40:33.770 --> 02:40:35.770
package manager, structure

02:40:35.770 --> 02:40:37.770
nee wie geht das hier

02:40:37.770 --> 02:40:39.770
bookmarks

02:40:39.770 --> 02:40:41.770
find end, end point

02:40:41.770 --> 02:40:43.770
nee, services

02:40:43.770 --> 02:40:45.770
build, terminal

02:40:45.770 --> 02:40:47.770
es gibt kein, das hat doch

02:40:47.770 --> 02:40:49.770
ein package manager

02:40:49.770 --> 02:40:51.770
java hat doch sowas wie ein package manager

02:40:51.770 --> 02:40:53.770
hab ich das falsche

02:40:53.770 --> 02:40:55.770
vielleicht hab ich auch das falsche

02:40:55.770 --> 02:40:57.770
projekt erstellt

02:40:57.770 --> 02:40:59.770
lass mal kurz gucken

02:40:59.770 --> 02:41:01.770
new, project

02:41:01.770 --> 02:41:11.860
ah ich hab build system

02:41:11.860 --> 02:41:13.860
intelliJ genannt, ich muss build system cradle

02:41:13.860 --> 02:41:15.860
nehmen wahrscheinlich

02:41:15.860 --> 02:41:17.860
oder maven oder

02:41:17.860 --> 02:41:19.860
wo immer

02:41:19.860 --> 02:41:21.860
aber das kann man doch bestimmt

02:41:21.860 --> 02:41:29.910
konverten

02:41:29.910 --> 02:41:31.910
das kann man doch bestimmt konvertieren hier mein

02:41:31.910 --> 02:41:33.910
ich seh aber

02:41:33.910 --> 02:41:35.910
nix dafür, ja da sieht man halt

02:41:35.910 --> 02:41:37.910
dass ich keine ahnung von java zeug hab ne

02:41:37.910 --> 02:41:39.910
gut wir machen das anders

02:41:39.910 --> 02:41:41.910
wir copypasten uns das einfach

02:41:41.910 --> 02:41:43.910
ich mein easy und sagen

02:41:43.910 --> 02:41:50.740
jetzt hier zack

02:41:50.740 --> 02:41:55.780
was, package manager

02:41:55.780 --> 02:41:57.780
äh

02:41:57.780 --> 02:41:59.780
vielleicht konvert

02:42:01.780 --> 02:42:03.780
äh, ich leg das

02:42:03.780 --> 02:42:05.780
jetzt einfach neu an

02:42:05.780 --> 02:42:07.780
new, project

02:42:07.780 --> 02:42:09.780
der real

02:42:09.780 --> 02:42:11.780
java champ

02:42:11.780 --> 02:42:13.780
und jetzt wollen wir kotlin haben

02:42:13.780 --> 02:42:15.780
wir wollen das da haben

02:42:15.780 --> 02:42:20.760
ach guck mal der wählt sogar

02:42:20.760 --> 02:42:22.760
ihr sagt cradle ist für

02:42:22.760 --> 02:42:24.760
die cooleren leute oder wie

02:42:24.760 --> 02:42:26.760
unsupported module

02:42:26.760 --> 02:42:28.760
jdk cradle supports

02:42:28.760 --> 02:42:30.760
jdk

02:42:30.760 --> 02:42:32.760
no

02:42:32.760 --> 02:42:34.760
das ist zu neu

02:42:34.760 --> 02:42:36.760
was ich hab

02:42:36.760 --> 02:42:42.790
maven

02:42:42.790 --> 02:42:48.410
this window

02:42:48.410 --> 02:42:50.410
so und jetzt

02:42:50.410 --> 02:42:52.410
hab ich package manager zeug

02:42:52.410 --> 02:42:56.100
oh, wow

02:42:56.100 --> 02:43:03.900
ist ja gut

02:43:03.900 --> 02:43:15.910
äh

02:43:15.910 --> 02:43:17.910
was hat der jetzt für schmerzen das ging doch eben noch

02:43:17.910 --> 02:43:24.810
hä, das geht doch auch

02:43:24.810 --> 02:43:28.380
hä

02:43:28.380 --> 02:43:30.380
ich benutze das irgendwie falsch

02:43:30.380 --> 02:43:39.260
und wie kriege ich jetzt hier

02:43:39.260 --> 02:43:41.260
package manager mäßig

02:43:41.260 --> 02:43:43.260
add maven dependency

02:43:43.260 --> 02:43:46.570
aha

02:43:48.570 --> 02:43:50.570
und nach was muss ich jetzt tun

02:43:50.570 --> 02:43:52.570
kotlin x serialization

02:43:52.570 --> 02:44:13.900
hä

02:44:13.900 --> 02:44:15.900
ok, ich hab keine ahnung wie das funktioniert

02:44:15.900 --> 02:44:17.900
ja, is shipped with a

02:44:17.900 --> 02:44:19.900
kotlin compiler distribution

02:44:19.900 --> 02:44:21.900
ja

02:44:21.900 --> 02:44:23.900
ja, ja schön

02:44:23.900 --> 02:44:35.530
oh

02:44:35.530 --> 02:44:37.530
machen wir jetzt nochmal das andere auf

02:44:37.530 --> 02:44:39.530
recent projects java champ this window

02:44:39.530 --> 02:44:41.530
guck der funktioniert, da hast du gar keine schmerzen mit

02:44:41.530 --> 02:44:43.530
also was muss ich

02:44:43.530 --> 02:44:53.560
sagen

02:44:53.560 --> 02:44:55.560
auf der einen seite schreiben die hier nur irgendwas von

02:44:55.560 --> 02:44:57.560
vielleicht, vielleicht, vielleicht hier so

02:44:57.560 --> 02:45:06.180
create a project

02:45:06.180 --> 02:45:08.180
ja aber das

02:45:08.180 --> 02:45:10.180
kann ich ja nicht verwenden

02:45:10.180 --> 02:45:12.180
da bin ich, da bin ich zu pp-ger

02:45:12.180 --> 02:45:14.180
für, für

02:45:14.180 --> 02:45:16.180
ach hier ist doch ein setup guide drin

02:45:16.180 --> 02:45:18.180
ok

02:45:18.180 --> 02:45:23.990
was zum

02:45:23.990 --> 02:45:27.750
what

02:45:27.750 --> 02:45:29.750
ok dann öffnen wir das andere, den real java champ

02:45:31.750 --> 02:45:33.750
der aus irgendwelchen gründen mit exakt

02:45:33.750 --> 02:45:35.750
dem gleichen source code hier als rot angezeigt

02:45:35.750 --> 02:45:37.750
wird, ok

02:45:37.750 --> 02:45:39.750
nice

02:45:39.750 --> 02:45:43.960
warum

02:45:43.960 --> 02:45:45.960
wo ist das problem

02:45:45.960 --> 02:45:49.340
ach set language version

02:45:49.340 --> 02:45:51.340
steht das hier, steht das vielleicht hier drin

02:45:51.340 --> 02:45:53.340
soll ich jetzt ernsthaft

02:45:53.340 --> 02:45:55.340
xml bearbeiten um pakete installieren

02:45:55.340 --> 02:45:57.340
zu können

02:45:57.340 --> 02:45:59.340
monkaW

02:45:59.340 --> 02:46:01.340
monkaW

02:46:01.340 --> 02:46:03.340
monkaW

02:46:03.340 --> 02:46:19.640
monkaW

02:46:19.640 --> 02:46:26.600
ich glaubs ja jetzt nicht

02:46:26.600 --> 02:46:29.980
project settings

02:46:29.980 --> 02:46:31.980
tja, wenn ich die finden würde

02:46:31.980 --> 02:46:40.860
so, wo steht hier

02:46:40.860 --> 02:46:42.860
die language version jetzt

02:46:42.860 --> 02:46:44.860
hier

02:46:44.860 --> 02:46:46.860
ne

02:46:46.860 --> 02:46:48.860
wo hat er denn diese language version

02:46:48.860 --> 02:46:50.860
jetzt umgestellt

02:46:50.860 --> 02:46:52.860
boah da hab ich keinen bock drauf man

02:46:52.860 --> 02:46:54.860
ich will kein xml bearbeiten

02:46:54.860 --> 02:46:56.860
ich will einen ordentlichen package manager

02:46:56.860 --> 02:46:58.860
guck mal, ich mein

02:46:58.860 --> 02:47:00.860
man kann sich jetzt drüber streiten

02:47:00.860 --> 02:47:02.860
nougat ist bestimmt nicht der geilste

02:47:02.860 --> 02:47:04.860
package manager auf der welt, aber hier kann ich zum

02:47:04.860 --> 02:47:06.860
beispiel einfach suchen nach

02:47:06.860 --> 02:47:08.860
jason oder so

02:47:08.860 --> 02:47:10.860
und was installieren und dann wird es automatisch

02:47:10.860 --> 02:47:12.860
hinzugefügt und gut ist, was ist das für ein kack

02:47:12.860 --> 02:47:14.860
cargo ist auch nice

02:47:14.860 --> 02:47:22.330
ja, wie kann ich denn

02:47:22.330 --> 02:47:24.330
jetzt überhaupt was hinzufügen

02:47:24.330 --> 02:47:26.330
ich hab jetzt schon gelernt, ich kann jetzt hier hingehen und sagen

02:47:26.330 --> 02:47:28.330
add maven dependency

02:47:28.330 --> 02:47:30.330
ja das ist ja schön und gut

02:47:30.330 --> 02:47:38.380
aber

02:47:38.380 --> 02:47:40.380
ich check das net, was muss ich

02:47:40.380 --> 02:47:42.380
jetzt machen, hier das da

02:47:42.380 --> 02:47:44.380
das da

02:47:44.380 --> 02:47:51.530
das gibt's nicht

02:47:51.530 --> 02:47:58.810
das gibt's nicht

02:47:58.810 --> 02:48:00.810
ne artefact gibt's

02:48:00.810 --> 02:48:02.810
auch nicht

02:48:02.810 --> 02:48:04.810
ach moment

02:48:04.810 --> 02:48:06.810
warum findet er das nicht, wenn ich hier nach suche

02:48:06.810 --> 02:48:08.810
ach doch

02:48:08.810 --> 02:48:10.810
der ist einfach nur, ich bin einfach nur zu langsam

02:48:10.810 --> 02:48:21.030
ja aber das ist doch was anderes

02:48:21.030 --> 02:48:23.030
jetzt, das ist doch nicht das was ich

02:48:23.030 --> 02:48:29.100
haben will

02:48:29.100 --> 02:48:31.100
ah, das was exakt

02:48:31.100 --> 02:48:33.100
guck mal

02:48:33.100 --> 02:48:35.100
das was exakt matcht, steht weiter unten

02:48:35.100 --> 02:48:37.100
das macht jetzt

02:48:37.100 --> 02:48:39.100
gerade keine pluspunkte bei mir

02:48:39.100 --> 02:48:41.100
kann man das quoten oder so

02:48:41.100 --> 02:48:46.010
plus davor

02:48:46.010 --> 02:48:48.010
das geht mir auf den sack

02:48:48.010 --> 02:48:50.010
da hab ich echt kein nerv drauf

02:48:50.010 --> 02:48:52.010
warum eigentlich quoten, weil ich mir mal angucken wollte

02:48:52.010 --> 02:48:59.860
wo ist es denn hier

02:48:59.860 --> 02:49:01.860
serialization

02:49:01.860 --> 02:49:03.860
heißt der krempel doch

02:49:03.860 --> 02:49:05.860
ach hier artefakt id

02:49:05.860 --> 02:49:10.010
ja

02:49:10.010 --> 02:49:12.010
serialization

02:49:12.010 --> 02:49:14.010
jason

02:49:14.010 --> 02:49:16.010
dann, nein jetbrains

02:49:16.010 --> 02:49:20.730
da muss er auch gucken, dass

02:49:20.730 --> 02:49:22.730
er echt das richtige erwischt, ok add

02:49:22.730 --> 02:49:26.550
hat das jetzt funktioniert

02:49:26.550 --> 02:49:33.580
ja nice

02:49:33.580 --> 02:49:35.580
aber oh

02:49:35.580 --> 02:49:44.010
reload maven

02:49:44.010 --> 02:49:49.940
und geht das jetzt auf

02:49:49.940 --> 02:49:51.940
magische art und weise

02:49:51.940 --> 02:49:53.940
ah

02:49:53.940 --> 02:49:55.940
boah ist das eklig man

02:49:55.940 --> 02:49:57.940
aber

02:49:57.940 --> 02:49:59.940
ich mein, wenn man es weiß

02:49:59.940 --> 02:50:01.940
ich glaube man kommt mit klar

02:50:01.940 --> 02:50:03.940
ich mein

02:50:03.940 --> 02:50:05.940
nugget ist nicht so viel anders

02:50:05.940 --> 02:50:07.940
aber schöner integriert, guck mal

02:50:07.940 --> 02:50:09.940
mal angenommen

02:50:09.940 --> 02:50:11.940
da sag ich hier nugget

02:50:11.940 --> 02:50:13.940
und da installieren wir jetzt

02:50:13.940 --> 02:50:15.940
newton soft

02:50:15.940 --> 02:50:17.940
jason zum beispiel

02:50:17.940 --> 02:50:19.940
third party jason

02:50:19.940 --> 02:50:21.940
so und da klick ich hier auf das plus

02:50:21.940 --> 02:50:23.940
hinzufügen install

02:50:23.940 --> 02:50:25.940
und dann ist es da und dann kann ich hier sagen

02:50:25.940 --> 02:50:27.940
j object bla bla bla

02:50:27.940 --> 02:50:29.940
so, das funktioniert

02:50:29.940 --> 02:50:31.940
aber unter der haube, also es ist halt einfach

02:50:31.940 --> 02:50:33.940
schön integriert in die ide

02:50:33.940 --> 02:50:35.940
unter der haube ist das tatsächlich ähnlich

02:50:35.940 --> 02:50:37.940
wie in java gelöst, wenn ich mir das jetzt so überlege

02:50:37.940 --> 02:50:41.510
weil

02:50:41.510 --> 02:50:43.510
das wird auch hier als dependency

02:50:43.510 --> 02:50:45.510
in so einer xml datei geschrieben

02:50:45.510 --> 02:50:47.510
nur dass ich da normalerweise nie reingucken muss

02:50:47.510 --> 02:50:49.510
und es einfach funktioniert

02:50:49.510 --> 02:50:51.510
also

02:50:51.510 --> 02:50:53.510
da gefällt mir ja wirklich alles an

02:50:53.510 --> 02:50:55.510
da gefällt mir ja sogar npm besser

02:50:55.510 --> 02:50:57.510
npm oder ruby gems

02:50:57.510 --> 02:51:01.400
gut zumindest

02:51:01.400 --> 02:51:08.360
wir haben es hinbekommen

02:51:08.360 --> 02:51:10.360
wir haben das jetzt als jason element gepasst

02:51:10.360 --> 02:51:13.800
da ist es doch

02:51:13.800 --> 02:51:15.800
nice

02:51:15.800 --> 02:51:17.800
kann man jetzt hiermit weiter

02:51:17.800 --> 02:51:19.800
kann man jetzt hier so auf elemente zugreifen

02:51:19.800 --> 02:51:21.800
nein natürlich nicht

02:51:21.800 --> 02:51:23.800
das wäre jetzt ja auch zu einfach wenn das

02:51:23.800 --> 02:51:38.380
funktioniert

02:51:38.380 --> 02:51:40.380
und was

02:51:40.380 --> 02:51:44.650
und dann jason object

02:51:44.650 --> 02:51:46.650
und da kann man jetzt

02:51:46.650 --> 02:51:48.650
ah da kann man jetzt drauf zugreifen

02:51:48.650 --> 02:51:53.050
also heißt es im prinzip

02:51:53.050 --> 02:51:55.050
wenn ich sowas wie current condition

02:51:55.050 --> 02:51:57.050
da rausholen will, dann geht das

02:51:57.050 --> 02:52:02.860
ok gut

02:52:02.860 --> 02:52:07.640
current condition pressure

02:52:07.640 --> 02:52:09.640
temperature in Celsius

02:52:09.640 --> 02:52:13.080
ok

02:52:13.080 --> 02:52:15.080
das heißt jetzt will ich sowas hier haben

02:52:15.080 --> 02:52:17.080
temp c

02:52:17.080 --> 02:52:19.080
wie das

02:52:19.080 --> 02:52:21.080
funktioniert nicht

02:52:21.080 --> 02:52:23.080
ich muss jetzt nicht ernsthaft

02:52:23.080 --> 02:52:25.080
nochmal jason object machen oder

02:52:25.080 --> 02:52:29.420
äh

02:52:29.420 --> 02:52:34.140
jetzt habe ich das jetzt aber kaputt

02:52:34.140 --> 02:52:38.220
warum ist es jetzt kaputt

02:52:38.220 --> 02:52:48.950
only safe

02:52:48.950 --> 02:52:50.950
or non null

02:52:50.950 --> 02:52:52.950
assert calls

02:52:52.950 --> 02:52:54.950
are allowed on a nullable

02:52:54.950 --> 02:53:02.940
receive

02:53:02.940 --> 02:53:04.940
kann print line kein null ausgeben

02:53:04.940 --> 02:53:10.940
oder was

02:53:10.940 --> 02:53:14.950
dann verstehe ich es ehrlich gesagt

02:53:14.950 --> 02:53:23.450
gar nicht

02:53:23.450 --> 02:53:29.900
du hast ein array

02:53:29.900 --> 02:53:33.720
du hast recht

02:53:33.720 --> 02:53:35.720
ich habe ein array

02:53:35.720 --> 02:53:37.720
aber das ist richtig

02:53:37.720 --> 02:53:39.720
aber das weiß das ding ja nicht

02:53:39.720 --> 02:53:41.720
an der stelle

02:53:41.720 --> 02:53:43.720
der weiß ja nicht wie die struktur aussieht

02:53:43.720 --> 02:53:45.720
also es würde

02:53:45.720 --> 02:53:47.720
ja aber zu

02:53:47.720 --> 02:53:49.720
kann es daran ja nicht liegen

02:53:49.720 --> 02:54:07.300
ok ich sag

02:54:07.300 --> 02:54:09.300
explizit

02:54:09.300 --> 02:54:11.300
scheiß auf null

02:54:11.300 --> 02:54:13.300
ok gut

02:54:13.300 --> 02:54:15.300
das muss jetzt crashen wahrscheinlich

02:54:15.300 --> 02:54:17.300
weil es das nicht gibt

02:54:17.300 --> 02:54:19.300
ja

02:54:19.300 --> 02:54:21.300
is not

02:54:21.300 --> 02:54:27.560
is not a jason object

02:54:27.560 --> 02:54:29.560
ja ok dann ist richtig

02:54:29.560 --> 02:54:31.560
es ist ein jason array

02:54:31.560 --> 02:54:33.560
und dann den

02:54:33.560 --> 02:54:35.560
index hoffen wir mal dass das jetzt funktioniert

02:54:35.560 --> 02:54:37.560
jawoll

02:54:37.560 --> 02:54:39.560
und da drin kann ich jetzt wieder

02:54:39.560 --> 02:54:41.560
sagen jason das ist ja maximal

02:54:41.560 --> 02:54:43.560
eklig

02:54:43.560 --> 02:54:45.560
kann ich nicht

02:54:45.560 --> 02:54:47.560
temp

02:54:47.560 --> 02:54:49.560
c so machen

02:54:49.560 --> 02:54:51.560
vielleicht so

02:54:51.560 --> 02:54:53.560
so

02:54:53.560 --> 02:54:55.560
och man

02:54:55.560 --> 02:55:01.660
hä

02:55:01.660 --> 02:55:03.660
und da darf ich das wieder machen

02:55:03.660 --> 02:55:05.660
das könnte

02:55:05.660 --> 02:55:07.660
doch genauso gut

02:55:07.660 --> 02:55:09.660
ne das könnte nicht sein weil ich explizit sage

02:55:09.660 --> 02:55:11.660
gib mir den nullten index

02:55:11.660 --> 02:55:13.660
und es würde vorher schon crashen das ist auf jeden fall garantiert

02:55:13.660 --> 02:55:15.660
nicht null

02:55:15.660 --> 02:55:19.990
23

02:55:19.990 --> 02:55:30.090
aber was macht

02:55:30.090 --> 02:55:32.090
denn dann

02:55:32.090 --> 02:55:42.180
punkt

02:55:42.180 --> 02:55:44.180
und wenn es das nicht gibt passiert was

02:55:44.180 --> 02:55:50.440
dann crashed es

02:55:50.440 --> 02:55:52.440
mit ner null pointer exception

02:55:52.440 --> 02:55:54.440
ok mit ner ziemlich miesen

02:55:54.440 --> 02:55:56.440
exception wo keiner weiß was sache ist

02:55:56.440 --> 02:56:01.610
ich mein wie soll ich von der

02:56:01.610 --> 02:56:03.610
exception darauf kommen dass ich hier ein falsches

02:56:03.610 --> 02:56:05.610
jason eingegeben hab

02:56:05.610 --> 02:56:17.240
also ganz ehrlich

02:56:17.240 --> 02:56:19.240
ich

02:56:19.240 --> 02:56:21.240
weiß immer wieder die standard.net library

02:56:21.240 --> 02:56:23.240
und das ökosystem zu schätzen

02:56:23.240 --> 02:56:25.240
da funktioniert vieles einfach so wie man es denkt

02:56:25.240 --> 02:56:27.240
insgesamt finde ich

02:56:27.240 --> 02:56:29.240
ist kotlin wirklich gut durchdacht

02:56:29.240 --> 02:56:31.240
das was wir bis jetzt ausprobiert haben

02:56:31.240 --> 02:56:33.240
das dürften wahrscheinlich eher irgendwelche java

02:56:33.240 --> 02:56:35.240
eigenheiten über plyapsel sein

02:56:35.240 --> 02:56:37.240
ich sag dass es nicht null ist

02:56:37.240 --> 02:56:39.240
ja ich will das gar nicht sagen

02:56:39.240 --> 02:56:41.240
ich will das gar nicht sagen

02:56:41.240 --> 02:56:43.240
ich hätte

02:56:43.240 --> 02:56:45.240
hiermit auch kein problem aber das darf ich ja

02:56:45.240 --> 02:56:47.240
nicht also es wäre durchaus

02:56:47.240 --> 02:56:49.240
ok wenn output null werden kann

02:56:49.240 --> 02:56:53.260
und er sagt ja sogar

02:56:53.260 --> 02:56:55.260
auch output kann theoretisch null sein

02:56:55.260 --> 02:56:59.460
so

02:56:59.460 --> 02:57:01.460
an der stelle hier dann natürlich nicht mehr

02:57:01.460 --> 02:57:05.220
dann crashed es

02:57:05.220 --> 02:57:07.220
das ist trotzdem nicht verkehrt jetzt haben wir die aktuelle

02:57:07.220 --> 02:57:09.220
temperatur da haben wir schon mal

02:57:09.220 --> 02:57:11.220
ein unserer sachen

02:57:11.220 --> 02:57:13.220
jetzt ist die frage wie würde ich beispielsweise

02:57:15.220 --> 02:57:17.220
machen wir mal eine klasse

02:57:17.220 --> 02:57:19.220
klasse

02:57:19.220 --> 02:57:21.220
klasse nennen wir es mal irgendwie

02:57:23.220 --> 02:57:25.220
oder so

02:57:25.220 --> 02:57:27.220
ok das geht

02:57:27.220 --> 02:57:31.690
jetzt wird

02:57:31.690 --> 02:57:33.690
spannend

02:57:33.690 --> 02:57:35.690
kopieren wir das mal kurz

02:57:35.690 --> 02:57:39.640
so

02:57:39.640 --> 02:57:41.640
public

02:57:41.640 --> 02:57:44.950
ich tue jetzt einfach

02:57:44.950 --> 02:57:46.950
einfach mal so als wüsste ich was ich mache

02:57:46.950 --> 02:57:48.950
current

02:57:48.950 --> 02:57:50.950
mach wahrscheinlich get

02:57:50.950 --> 02:57:52.950
current

02:57:52.950 --> 02:57:57.030
temp

02:57:57.030 --> 02:57:59.030
string

02:57:59.030 --> 02:58:03.940
string

02:58:03.940 --> 02:58:05.940
ok so geht das schon mal

02:58:05.940 --> 02:58:07.940
class kotlin

02:58:07.940 --> 02:58:09.940
dann müssen wir uns das in der doku mal

02:58:09.940 --> 02:58:11.940
angucken

02:58:11.940 --> 02:58:13.940
constructor person

02:58:13.940 --> 02:58:15.940
ich hab kein constructor

02:58:15.940 --> 02:58:17.940
init

02:58:17.940 --> 02:58:23.780
nee

02:58:23.780 --> 02:58:25.780
nee ich will ne ganz normale methode bauen

02:58:25.780 --> 02:58:31.140
functions

02:58:31.140 --> 02:58:33.140
muss man ok

02:58:33.140 --> 02:58:35.140
es geht an fun

02:58:35.140 --> 02:58:37.140
fun

02:58:37.140 --> 02:58:39.140
fun

02:58:39.140 --> 02:58:41.140
fun

02:58:41.140 --> 02:58:43.140
und dann den return type

02:58:43.140 --> 02:58:45.140
doppelpunkt

02:58:45.140 --> 02:58:47.140
string

02:58:47.140 --> 02:58:49.140
schon besser

02:58:49.140 --> 02:58:54.570
ist das kein string

02:58:54.570 --> 02:58:56.570
nee das ist

02:58:56.570 --> 02:58:58.570
ein jason element

02:58:58.570 --> 02:59:01.940
nee

02:59:01.940 --> 02:59:03.940
da brauche ich jetzt return

02:59:03.940 --> 02:59:07.770
string

02:59:07.770 --> 02:59:11.140
ok

02:59:11.140 --> 02:59:13.140
wie würden

02:59:13.140 --> 02:59:15.140
properties funktionieren

02:59:15.140 --> 02:59:20.760
achso

02:59:20.760 --> 02:59:22.760
nee das ist schon ok

02:59:22.760 --> 02:59:24.760
also get current temp

02:59:24.760 --> 02:59:26.760
das heißt wir würden hier sowas machen

02:59:26.760 --> 02:59:28.760
war oder hier

02:59:28.760 --> 02:59:30.760
output gleich

02:59:30.760 --> 02:59:32.760
hier nochmal kurz zurück

02:59:32.760 --> 02:59:37.860
classes

02:59:37.860 --> 02:59:39.860
instance

02:59:39.860 --> 02:59:41.860
create instances

02:59:41.860 --> 02:59:43.860
of classes

02:59:43.860 --> 02:59:45.860
ach einfach so ohne new oder irgendwie sowas

02:59:45.860 --> 02:59:47.860
davor einfach groß schreiben

02:59:47.860 --> 02:59:49.860
ok

02:59:49.860 --> 02:59:51.860
also war output

02:59:51.860 --> 02:59:53.860
weather forecast

02:59:53.860 --> 02:59:55.860
so

02:59:55.860 --> 02:59:57.860
und können wir gleich get current temp machen

02:59:57.860 --> 03:00:03.480
wobei

03:00:03.480 --> 03:00:05.480
ich muss mal kurz gucken ob die

03:00:05.480 --> 03:00:07.480
intellij den namen vorschlagen könnte dafür

03:00:07.480 --> 03:00:09.480
nee

03:00:09.480 --> 03:00:21.300
aber das ist ja doof

03:00:21.300 --> 03:00:23.300
ok get current temp output 23

03:00:23.300 --> 03:00:25.300
zack

03:00:25.300 --> 03:00:29.260
nice

03:00:29.260 --> 03:00:31.260
das ist doch naming convention oder

03:00:31.260 --> 03:00:36.490
klein

03:00:36.490 --> 03:00:38.490
ok

03:00:38.490 --> 03:00:40.490
das ist tatsächlich auch wenn es hier

03:00:40.490 --> 03:00:42.490
function heißt

03:00:42.490 --> 03:00:44.490
rename

03:00:44.490 --> 03:00:46.490
warum sollte ich das rename

03:00:46.490 --> 03:00:48.490
was hat er für schmerzen

03:00:48.490 --> 03:00:50.490
function name should start with lowercase

03:00:50.490 --> 03:00:54.120
achso

03:00:54.120 --> 03:00:56.120
aber ich kann es doch bestimmt refactoren

03:00:56.120 --> 03:01:03.210
lassen

03:01:03.210 --> 03:01:05.210
jetzt hat es überall unbenannt

03:01:05.210 --> 03:01:07.210
und es funktioniert auch immer noch

03:01:07.210 --> 03:01:09.210
ja ok gut

03:01:09.210 --> 03:01:11.210
alles klar so haben wir schon die erste

03:01:11.210 --> 03:01:13.210
klasse erstellt

03:01:13.210 --> 03:01:15.210
theoretisch können wir das natürlich noch

03:01:15.210 --> 03:01:17.210
ein bisschen besser machen und zwar

03:01:17.210 --> 03:01:19.210
wir machen ein

03:01:19.210 --> 03:01:24.120
konstruktor

03:01:24.120 --> 03:01:26.120
der

03:01:26.120 --> 03:01:28.120
initialisiert

03:01:28.120 --> 03:01:30.120
das ganze allerdings zu einer

03:01:30.120 --> 03:01:32.120
create

03:01:32.120 --> 03:01:34.120
create property

03:01:34.120 --> 03:01:37.430
macht

03:01:37.430 --> 03:01:46.180
ach das geht auch so

03:01:46.180 --> 03:01:50.200
direkt ok

03:01:50.200 --> 03:01:53.640
nicht schlecht

03:01:53.640 --> 03:01:59.190
ja ist ok

03:01:59.190 --> 03:02:01.190
kann ich mit leben

03:02:01.190 --> 03:02:03.190
falls wir noch mehr Sachen

03:02:03.190 --> 03:02:08.040
damit abfragen

03:02:08.040 --> 03:02:10.040
wollen ist das wahrscheinlich gar nicht so blöd

03:02:10.040 --> 03:02:13.610
ja

03:02:13.610 --> 03:02:15.610
ok ja why not

03:02:15.610 --> 03:02:22.440
gut

03:02:22.440 --> 03:02:24.440
so und jetzt kommt die eigentliche Sache

03:02:24.440 --> 03:02:26.440
wie machen wir ordentliches

03:02:26.440 --> 03:02:28.440
command line parsing mit

03:02:28.440 --> 03:02:34.890
kotlin

03:02:34.890 --> 03:02:36.890
also http requests und so weiß ich

03:02:36.890 --> 03:02:38.890
aber was gibt es

03:02:38.890 --> 03:02:40.890
ok kotlin

03:02:40.890 --> 03:02:42.890
cli parser

03:02:42.890 --> 03:02:44.890
kotlin

03:02:44.890 --> 03:02:46.890
xcli ah das ist auch wieder sowas

03:02:46.890 --> 03:02:50.840
offizielles

03:02:50.840 --> 03:02:52.840
pure kotlin implementation with generic cli parser

03:02:52.840 --> 03:02:54.840
i

03:02:54.840 --> 03:02:59.300
wieder so

03:02:59.300 --> 03:03:11.130
komische dinger

03:03:11.130 --> 03:03:13.130
ok das sieht abfuck kompliziert aus

03:03:13.130 --> 03:03:17.140
aber es

03:03:17.140 --> 03:03:19.140
generiert hilfe texten

03:03:19.140 --> 03:03:25.460
automatisch

03:03:25.460 --> 03:03:27.460
wir brauchen erstmal

03:03:27.460 --> 03:03:29.460
ach nee haben wir schon

03:03:29.460 --> 03:03:31.460
ok parser

03:03:31.460 --> 03:03:35.100
arc parser

03:03:35.100 --> 03:03:37.100
dann probieren wir das nochmal

03:03:37.100 --> 03:03:39.100
arc parser

03:03:39.100 --> 03:03:41.100
add maven dependency

03:03:41.100 --> 03:03:43.100
und unsere

03:03:43.100 --> 03:03:45.100
dependency ist kotlin

03:03:45.100 --> 03:03:47.100
xcli jvm

03:03:47.100 --> 03:03:49.100
nee

03:03:49.100 --> 03:03:52.790
nice

03:03:52.790 --> 03:03:56.620
es doch

03:03:56.620 --> 03:03:58.620
ok ich

03:03:58.620 --> 03:04:00.620
lerne langsam java package manager

03:04:00.620 --> 03:04:05.140
und jetzt

03:04:05.140 --> 03:04:07.140
muss ich sagen maven

03:04:07.140 --> 03:04:09.140
reload

03:04:09.140 --> 03:04:11.140
und dann

03:04:11.140 --> 03:04:13.140
ach leute so schlimm ist das doch gar

03:04:13.140 --> 03:04:15.140
nicht mit dem package manager

03:04:15.140 --> 03:04:17.140
das geht doch sogar halbwegs

03:04:17.140 --> 03:04:19.140
wenn man sich daran gewöhnt hat

03:04:19.140 --> 03:04:21.140
da habe ich schon schlimmeres gesehen

03:04:21.140 --> 03:04:26.120
zb c++ header files

03:04:26.120 --> 03:04:28.120
ok proc name ist natürlich der

03:04:28.120 --> 03:04:30.120
real java champ

03:04:30.120 --> 03:04:32.120
meckert er jetzt schon

03:04:32.120 --> 03:04:34.120
gleich wenn ich das hier ausführe? nee

03:04:36.120 --> 03:04:38.120
intelligent integriert das ganz gut

03:04:38.120 --> 03:04:40.120
ja finde ich auch

03:04:40.120 --> 03:04:42.120
ok und wie funzt das jetzt

03:04:42.120 --> 03:04:44.120
parser parse input

03:04:44.120 --> 03:04:46.120
option option option

03:04:46.120 --> 03:04:48.120
parser parse arcs

03:04:48.120 --> 03:04:50.120
das ist das was ich machen will

03:04:52.120 --> 03:04:54.120
es gibt zwar keine arcs zu parsen

03:04:54.120 --> 03:04:56.120
bisher aber das macht ja nix

03:04:56.120 --> 03:04:58.120
haben wir hier mal

03:04:58.120 --> 03:05:14.740
einen return drunter

03:05:14.740 --> 03:05:16.740
ja im vergleich zu c++ geht das wirklich noch klar

03:05:16.740 --> 03:05:18.740
so

03:05:18.740 --> 03:05:20.740
jetzt ist natürlich die preisfrage

03:05:20.740 --> 03:05:22.740
wie kriege ich das gestartet mit

03:05:22.740 --> 03:05:24.740
hier

03:05:24.740 --> 03:05:26.740
run with parameters

03:05:26.740 --> 03:05:30.440
das ist halt dumm

03:05:30.440 --> 03:05:32.440
deswegen würde ich es halt gerne über cli direkt starten

03:05:34.440 --> 03:05:36.440
program arguments

03:05:36.440 --> 03:05:38.440
minus minus blub

03:05:38.440 --> 03:05:40.440
oder sag mal so

03:05:40.440 --> 03:05:42.440
minus minus temp

03:05:49.210 --> 03:05:51.210
local

03:05:51.210 --> 03:05:53.210
es ist jetzt nicht als würde ich wirklich was

03:05:53.210 --> 03:05:55.210
sinnvolles machen damit

03:05:55.210 --> 03:05:57.210
so

03:05:57.210 --> 03:05:59.210
parse

03:05:59.210 --> 03:06:01.210
ach guck mal jetzt sagt er mir auch

03:06:01.210 --> 03:06:03.210
anon option minus minus local

03:06:03.210 --> 03:06:05.210
da funktioniert schon mal prinzipiell

03:06:05.210 --> 03:06:07.210
der

03:06:07.210 --> 03:06:09.210
parser champ

03:06:09.210 --> 03:06:11.210
jetzt kann ich eine neue option

03:06:11.210 --> 03:06:13.210
hinzufügen

03:06:13.210 --> 03:06:15.210
die minus minus local heisst

03:06:15.210 --> 03:06:17.210
weil

03:06:17.210 --> 03:06:19.210
input by parser option

03:06:21.210 --> 03:06:23.210
arc type string import

03:06:23.210 --> 03:06:25.210
required

03:06:27.210 --> 03:06:29.210
single nullable option required

03:06:29.210 --> 03:06:31.210
alles klar

03:06:31.210 --> 03:06:33.210
input by

03:06:33.210 --> 03:06:35.210
by

03:06:35.210 --> 03:06:37.210
ok die syntax verwirrt mich jetzt

03:06:37.210 --> 03:06:39.210
input by

03:06:39.210 --> 03:06:41.210
ist das sowas wie ein using

03:06:41.210 --> 03:06:50.470
so ein bisschen

03:06:50.470 --> 03:06:53.780
what does by keyword mean

03:06:53.780 --> 03:06:55.780
you can understand by

03:06:55.780 --> 03:06:57.780
as provided by

03:06:57.780 --> 03:07:02.060
ja ach

03:07:02.060 --> 03:07:06.010
aber warum nicht so

03:07:06.010 --> 03:07:11.500
moment

03:07:11.500 --> 03:07:16.220
ist das etwa das gleiche

03:07:16.220 --> 03:07:19.530
oder ist das was anderes

03:07:19.530 --> 03:07:21.530
dann check ich es nicht so

03:07:21.530 --> 03:07:28.550
ganz

03:07:32.180 --> 03:07:35.560
dann check ich es nicht so ganz

03:07:35.560 --> 03:07:37.560
nun gut wir nehmen das einfach mal zur

03:07:37.560 --> 03:07:44.650
kenntnis

03:07:44.650 --> 03:07:46.650
short name minus l

03:07:46.650 --> 03:07:48.650
aber wo kann ich

03:07:48.650 --> 03:07:50.650
moment

03:07:50.650 --> 03:07:52.650
wo kann ich denn sagen long

03:07:54.650 --> 03:07:56.650
wenn ich nicht short name haben will

03:07:56.650 --> 03:07:58.650
sondern tatsächlich

03:07:58.650 --> 03:08:00.650
ach full name

03:08:00.650 --> 03:08:02.650
hier

03:08:02.650 --> 03:08:04.650
local

03:08:04.650 --> 03:08:13.340
jetzt sollte er es ja eigentlich checken

03:08:13.340 --> 03:08:15.340
no value for local

03:08:15.340 --> 03:08:17.340
ok

03:08:17.340 --> 03:08:19.340
da muss ich ihm jetzt noch sagen

03:08:19.340 --> 03:08:21.340
dass der arc type

03:08:21.340 --> 03:08:23.340
bool ist

03:08:23.340 --> 03:08:25.340
vermutlich

03:08:25.340 --> 03:08:27.340
dass er nicht eine option

03:08:27.340 --> 03:08:29.340
haben will

03:08:29.340 --> 03:08:31.340
ja nice

03:08:31.340 --> 03:08:39.260
ok

03:08:39.260 --> 03:08:41.260
bin mir nicht so ganz sicher ob das alles

03:08:41.260 --> 03:08:43.260
so

03:08:43.260 --> 03:08:45.260
eifertig ist wie ich das mache

03:08:45.260 --> 03:08:47.260
formatieren wir mal

03:08:47.260 --> 03:08:49.260
neu

03:08:49.260 --> 03:08:51.260
reformat

03:08:53.260 --> 03:08:55.260
so jetzt haben wir den ganzen

03:08:55.260 --> 03:08:57.260
gepasst

03:08:57.260 --> 03:08:59.260
und jetzt kann ich gucken

03:08:59.260 --> 03:09:01.260
letztendlich will ich ja nichts sinnvolles machen

03:09:01.260 --> 03:09:03.260
ich will es ja einfach nur mal ausprobieren

03:09:03.260 --> 03:09:05.260
aber da machen wir den ganzen

03:09:05.260 --> 03:09:07.260
mit den Listen mal weg

03:09:07.260 --> 03:09:09.260
das brauchen wir nicht

03:09:09.260 --> 03:09:11.260
local

03:09:11.260 --> 03:09:15.020
option

03:09:15.020 --> 03:09:17.020
so dann geben wir das für frankfurt

03:09:17.020 --> 03:09:23.020
an

03:09:23.020 --> 03:09:25.020
klammern drum herum

03:09:25.020 --> 03:09:27.020
ne

03:09:27.020 --> 03:09:29.020
was ist zeile verschieben in intellij

03:09:29.020 --> 03:09:31.020
standardmäßig

03:09:31.020 --> 03:09:33.020
so jetzt sollte

03:09:33.020 --> 03:09:35.020
wieder die gleiche ausgabe kommen wie eben

03:09:35.020 --> 03:09:37.020
ja 26 26 grad hier ok

03:09:37.020 --> 03:09:39.020
nice

03:09:39.020 --> 03:09:41.020
moin

03:09:41.020 --> 03:09:43.020
wie gehts

03:09:43.020 --> 03:09:45.020
sauber

03:09:45.020 --> 03:09:47.020
aber es ist nicht so schlecht

03:09:47.020 --> 03:09:49.020
bis jetzt überzeugts mich

03:09:51.020 --> 03:09:51.860
also was geht ist es

03:09:51.860 --> 03:09:53.860
sehr gut

03:09:57.190 --> 03:09:57.910
warum

03:09:57.910 --> 03:09:58.870
quote der überhaupt

03:09:58.870 --> 03:10:00.350
die sonst

03:10:00.350 --> 03:10:01.350
hier das soll der gar nicht

03:10:01.350 --> 03:10:07.030
machen

03:10:07.030 --> 03:10:13.100
auf dem

03:10:13.100 --> 03:10:15.100
freeze

03:10:15.100 --> 03:10:17.100
blanch

03:10:17.100 --> 03:10:19.100
das blau

03:10:19.100 --> 03:10:25.420
warum kommt

03:10:25.420 --> 03:10:27.420
Wo kommen die Quotes her?

03:10:27.420 --> 03:10:42.180
Muss ich vielleicht nochmal sagen,

03:10:42.180 --> 03:10:44.180
JSON Object to String?

03:10:44.180 --> 03:10:46.180
Das ist dann, dass es weg ist?

03:10:46.180 --> 03:10:48.180
Naja, du bist null.

03:10:58.790 --> 03:11:00.790
Es ist auch kein JSON Object,

03:11:00.790 --> 03:11:02.790
sondern JSON Value.

03:11:02.790 --> 03:11:06.230
JSON Primitive.

03:11:06.230 --> 03:11:08.230
Ne.

03:11:08.230 --> 03:11:10.230
Okay, aus irgendwelchen Gründen ist da der Meinung,

03:11:10.230 --> 03:11:12.230
dass in dem Response

03:11:12.230 --> 03:11:14.230
weiter gequotet sein muss.

03:11:14.230 --> 03:11:17.860
Meinst du, es steht einfach so im JSON drin?

03:11:17.860 --> 03:11:19.860
Wollen wir mal.

03:11:19.860 --> 03:11:21.860
Bam. Ups.

03:11:21.860 --> 03:11:23.860
Bam.

03:11:23.860 --> 03:11:25.860
Grab minus I.

03:11:25.860 --> 03:11:27.860
Temp.

03:11:27.860 --> 03:11:29.860
Temp C.

03:11:29.860 --> 03:11:31.860
Nö, steht's nicht drin.

03:11:31.860 --> 03:11:33.860
Das ist ganz normal, dass JSON,

03:11:33.860 --> 03:11:35.860
wenn das gepasst wird als String,

03:11:35.860 --> 03:11:37.860
dann ist das der Value.

03:11:37.860 --> 03:11:39.860
Und die Quotes sind vom...

03:11:39.860 --> 03:11:41.860
Ja, von der Syntax.

03:11:41.860 --> 03:11:43.860
Also eigentlich müsste

03:11:43.860 --> 03:11:45.860
nur 26 drin stehen.

03:11:45.860 --> 03:11:47.860
Ach, muss man sagen,

03:11:47.860 --> 03:11:49.860
S-String?

03:11:49.860 --> 03:11:53.560
Ist das überhaupt ein Unterschied?

03:11:53.560 --> 03:11:55.560
Das wird kein Int.

03:11:55.560 --> 03:11:57.560
Cannot be cast.

03:11:57.560 --> 03:11:59.560
Ja. Nope.

03:11:59.560 --> 03:12:03.900
Genau.

03:12:03.900 --> 03:12:05.900
Wenn's ein Int wäre, könnte in JSON auch

03:12:05.900 --> 03:12:10.300
ohne Quotes stehen.

03:12:10.300 --> 03:12:12.300
Aber ist es nicht. Aber trotzdem ist es falsch.

03:12:12.300 --> 03:12:14.300
Das ist nicht das, was ich haben will.

03:12:14.300 --> 03:12:16.300
Ich will den Wert haben

03:12:16.300 --> 03:12:18.300
als String 26

03:12:18.300 --> 03:12:20.300
ohne die Quotes. Die Quotes gehören da auf jeden Fall

03:12:20.300 --> 03:12:22.300
nicht dabei. Ich vermute mal,

03:12:22.300 --> 03:12:24.300
dass toString eine...

03:12:24.300 --> 03:12:26.300
Ja, wie soll man sagen? Eine...

03:12:28.300 --> 03:12:30.300
Kommandla... Also eine lockbare

03:12:30.300 --> 03:12:32.300
Repräsentation davon

03:12:32.300 --> 03:12:34.300
sein soll. Und nicht

03:12:34.300 --> 03:12:36.300
den Wert. Das heißt, ich brauche jetzt

03:12:36.300 --> 03:12:38.300
eigentlich den Value. Gibt es hier Value oder

03:12:38.300 --> 03:12:40.300
sowas?

03:12:40.300 --> 03:12:42.300
Was ich bauen will? Nichts. Großartig.

03:12:42.300 --> 03:12:46.120
Ich will einfach nur ein bisschen rumprobieren.

03:12:46.120 --> 03:12:55.320
Hm.

03:12:55.320 --> 03:13:00.420
Long is String?

03:13:00.420 --> 03:13:02.420
Content. Das will ich vielleicht

03:13:02.420 --> 03:13:04.420
haben. Das könnte

03:13:04.420 --> 03:13:11.510
sein. Aha!

03:13:13.510 --> 03:13:15.510
Sehr schön.

03:13:15.510 --> 03:13:17.510
So muss man das machen.

03:13:17.510 --> 03:13:19.510
Da sind auch keine Quotes dabei. Siehste?

03:13:19.510 --> 03:13:21.510
Mal kurz drüber nachgedacht.

03:13:21.510 --> 03:13:23.510
Easy.

03:13:23.510 --> 03:13:26.820
So, if local?

03:13:26.820 --> 03:13:28.820
Ja gut. Also, das mit dem... Ich muss sagen,

03:13:28.820 --> 03:13:30.820
der Commandline-Parser, der macht so schon mal

03:13:30.820 --> 03:13:32.820
gar keinen so üblen Eindruck.

03:13:32.820 --> 03:13:38.310
Ich hab ne Idee.

03:13:38.310 --> 03:13:40.310
Wir sind blöd.

03:13:40.310 --> 03:13:42.310
Wir sagen hier nicht isBool, sondern wir sagen

03:13:42.310 --> 03:13:44.310
isString.

03:13:44.310 --> 03:13:54.340
Und...

03:13:54.340 --> 03:13:56.340
Ja. Genau, so machen wir das.

03:13:56.340 --> 03:13:58.340
Und wenn

03:13:58.340 --> 03:14:02.550
ungleich null...

03:14:02.550 --> 03:14:04.550
Also ich geh mal davon aus...

03:14:04.550 --> 03:14:06.550
isAlwaysTrue?

03:14:06.550 --> 03:14:08.550
Wie ist

03:14:08.550 --> 03:14:16.340
alwaysTrue?

03:14:16.340 --> 03:14:18.340
Ach, ich sag ja required da hinten.

03:14:18.340 --> 03:14:20.340
Ist ja gar nicht required.

03:14:20.340 --> 03:14:22.340
Ja. Genau.

03:14:22.340 --> 03:14:24.340
Also, wenn localOption

03:14:24.340 --> 03:14:26.340
gesetzt ist, dann

03:14:26.340 --> 03:14:28.340
will ich das

03:14:28.340 --> 03:14:30.340
übergeben als

03:14:30.340 --> 03:14:32.340
Ort. Da können wir nämlich aber gleich gucken,

03:14:32.340 --> 03:14:34.340
wie man Parameter

03:14:34.340 --> 03:14:36.340
übergibt. Jetzt will

03:14:36.340 --> 03:14:38.340
ich currentTemperature haben für...

03:14:38.340 --> 03:14:42.170
Theoretisch ist das

03:14:42.170 --> 03:14:44.170
sogar im Constructor besser aufgehoben.

03:14:44.170 --> 03:14:47.930
Constructor

03:14:47.930 --> 03:14:49.930
für...

03:14:49.930 --> 03:14:51.930
Moment,

03:14:51.930 --> 03:14:53.930
das ging doch anders. Das ging doch hier oben schon

03:14:53.930 --> 03:14:55.930
irgendwie drin.

03:14:55.930 --> 03:14:57.930
String. Ja, genau.

03:14:57.930 --> 03:14:59.930
Also quasi

03:14:59.930 --> 03:15:01.930
Location.

03:15:01.930 --> 03:15:06.260
Und jetzt

03:15:06.260 --> 03:15:14.760
machen wir hier

03:15:14.760 --> 03:15:16.760
DollarLocation. Ne, so funktioniert das nicht.

03:15:16.760 --> 03:15:26.470
Hm.

03:15:26.470 --> 03:15:28.470
Was? Wall?

03:15:28.470 --> 03:15:34.540
Ach ja.

03:15:34.540 --> 03:15:36.540
Übrigens, das wollen die in der nächsten C-Sharp

03:15:36.540 --> 03:15:38.540
Version auch einführen. So was ähnliches wie

03:15:38.540 --> 03:15:46.390
das hier. Aber okay.

03:15:46.390 --> 03:15:52.520
Besser wäre

03:15:52.520 --> 03:15:54.520
ein was? Required?

03:15:54.520 --> 03:15:58.020
Ah ne, ein

03:15:58.020 --> 03:16:00.020
was? Ein Default

03:16:00.020 --> 03:16:02.020
Pulse.

03:16:02.020 --> 03:16:04.020
Ne, ein Default

03:16:04.020 --> 03:16:06.020
0, oder?

03:16:06.020 --> 03:16:08.020
Ne.

03:16:08.020 --> 03:16:13.130
Das ist doch ein String jetzt.

03:16:13.130 --> 03:16:16.820
Ich will das doch nicht bool machen.

03:16:16.820 --> 03:16:18.820
Ich will, dass man

03:16:18.820 --> 03:16:20.820
Parameter übergeben kann. Ne, das erscheint

03:16:20.820 --> 03:16:22.820
mir so schon...

03:16:22.820 --> 03:16:24.820
Was hat er jetzt für Schmerzen?

03:16:24.820 --> 03:16:31.020
Ah! Kann ich jetzt

03:16:31.020 --> 03:16:33.020
sowas hier machen?

03:16:33.020 --> 03:16:35.020
Hm.

03:16:35.020 --> 03:16:37.020
Und wie war das? So?

03:16:37.020 --> 03:16:39.020
Ah, guck mal, ich hab was

03:16:39.020 --> 03:16:41.020
gelernt. Null. Also, wenn das

03:16:41.020 --> 03:16:43.020
Null ist, dann

03:16:43.020 --> 03:16:45.020
soll das auf

03:16:45.020 --> 03:16:47.020
was weiß ich

03:16:47.020 --> 03:16:49.020
Berlin

03:16:49.020 --> 03:16:51.020
oder so gehen. Okay.

03:16:51.020 --> 03:16:53.020
Es muss ja keinen großen Sinn ergeben,

03:16:53.020 --> 03:17:02.600
was wir hier bauen.

03:17:02.600 --> 03:17:04.600
Ach so, ja. Hä?

03:17:04.600 --> 03:17:06.600
Ach so, ja.

03:17:06.600 --> 03:17:08.600
Ach so, ja. Ich hab's ja angegeben.

03:17:08.600 --> 03:17:10.600
Okay, Input File hier.

03:17:10.600 --> 03:17:16.920
Location. Kann man

03:17:16.920 --> 03:17:18.920
sagen Default?

03:17:18.920 --> 03:17:20.920
Irgendwie so?

03:17:20.920 --> 03:17:22.920
Oder Default Frankfurt?

03:17:22.920 --> 03:17:24.920
Ja, Berlin ist so ein Drecksloch.

03:17:24.920 --> 03:17:26.920
Da will man

03:17:26.920 --> 03:17:28.920
nicht als Default haben.

03:17:28.920 --> 03:17:32.740
Okay, so geht das auch.

03:17:32.740 --> 03:17:34.740
So, jetzt hab ich natürlich Location angegeben.

03:17:34.740 --> 03:17:36.740
Was ja keinen Sinn macht.

03:17:36.740 --> 03:17:38.740
Also, gehen wir mal Location an.

03:17:38.740 --> 03:17:42.890
Local. Tja.

03:17:42.890 --> 03:17:44.890
Äh.

03:17:44.890 --> 03:17:46.890
Berlin. So.

03:17:46.890 --> 03:17:48.890
Zack.

03:17:48.890 --> 03:17:50.890
Und jetzt kriegen wir

03:17:50.890 --> 03:17:52.890
Temperaturen in Berlin sind

03:17:52.890 --> 03:17:57.100
Post Champ.

03:17:59.100 --> 03:18:11.560
Äh. Wurde ich grad

03:18:11.560 --> 03:18:13.560
gerate limited?

03:18:13.560 --> 03:18:15.560
Okay, das sind 21.

03:18:15.560 --> 03:18:17.560
Alles klar. Nice.

03:18:17.560 --> 03:18:19.560
Gut, jetzt wissen wir schon mal

03:18:19.560 --> 03:18:21.560
Bescheid, wie das funktioniert.

03:18:21.560 --> 03:18:23.560
Und jetzt kommt die große Preisfrage.

03:18:23.560 --> 03:18:25.560
Was passiert, wenn ich

03:18:25.560 --> 03:18:30.020
die alle wieder rausschmeiße?

03:18:30.020 --> 03:18:32.020
26.

03:18:32.020 --> 03:18:34.020
Nice. Okay. Dann setzt er einfach

03:18:34.020 --> 03:18:36.020
immer Frankfurt. So. Und jetzt

03:18:36.020 --> 03:18:38.020
der letzte Punkt

03:18:38.020 --> 03:18:40.020
und einer der wichtigsten Punkte.

03:18:40.020 --> 03:18:42.020
Wie mach ich da eine gescheite

03:18:42.020 --> 03:18:44.020
Command Line Application raus?

03:18:44.020 --> 03:18:46.020
Da hab ich am Anfang schon mal kurz

03:18:46.020 --> 03:18:48.020
geguckt.

03:18:48.020 --> 03:18:50.020
Aber wie bilde ich das denn

03:18:50.020 --> 03:18:52.020
jetzt, dass ich's normal ausführen kann?

03:18:52.020 --> 03:18:54.020
Da fehlt mir nämlich

03:18:54.020 --> 03:18:58.230
noch jegliche

03:18:58.230 --> 03:19:00.230
Vorstellung von.

03:19:00.230 --> 03:19:10.460
Ich mein, ich will das ja nicht

03:19:10.460 --> 03:19:14.470
verdokkerisieren müssen oder sowas.

03:19:14.470 --> 03:19:18.680
Bild.

03:19:18.680 --> 03:19:20.680
Mit dem Maven Icon

03:19:20.680 --> 03:19:30.390
rechts.

03:19:30.390 --> 03:19:39.020
Jetzt blick ich da durch.

03:19:39.020 --> 03:19:44.760
Also Leute, was ich machen

03:19:44.760 --> 03:19:46.760
will ist, ich glaube das geht überhaupt nicht.

03:19:46.760 --> 03:19:48.760
Ich hätte gern

03:19:48.760 --> 03:19:50.760
so ein Binary,

03:19:50.760 --> 03:19:52.760
was ich ausführen kann.

03:19:52.760 --> 03:19:54.760
Wahrscheinlich ist das zu viel verlangt.

03:19:54.760 --> 03:19:58.780
Oder zumindest

03:19:58.780 --> 03:20:15.340
ein JAR-File oder sowas.

03:20:15.340 --> 03:20:17.340
Was macht der denn hier beim Ausführen?

03:20:17.340 --> 03:20:23.400
Rechts Maven sollte ein JAR

03:20:23.400 --> 03:20:25.400
machen. Ja, aber ich will auch ein Self-Contain

03:20:25.400 --> 03:20:27.400
haben, ehrlich gesagt.

03:20:27.400 --> 03:20:29.400
Ja, aber ich check nicht, was ich hier machen

03:20:29.400 --> 03:20:31.400
muss, ehrlich gesagt.

03:20:31.400 --> 03:20:37.400
Diagramm.

03:20:41.540 --> 03:20:43.540
Da hab ich drauf gewartet. Endlich.

03:20:43.540 --> 03:20:45.540
Nice.

03:20:45.540 --> 03:20:47.540
Was? Lifecycle

03:20:47.540 --> 03:20:52.900
Package? Wow.

03:20:52.900 --> 03:20:54.900
Huiuiui.

03:20:54.900 --> 03:21:00.840
Und wo ist jetzt der Output?

03:21:00.840 --> 03:21:05.880
Target.

03:21:05.880 --> 03:21:07.880
Aha.

03:21:07.880 --> 03:21:09.880
Da ist es.

03:21:09.880 --> 03:21:14.150
Der real Java-Champ.

03:21:14.150 --> 03:21:16.150
Das heißt, ich kann es jetzt zumindest

03:21:16.150 --> 03:21:21.510
schon mal

03:21:21.510 --> 03:21:23.510
mit Java

03:21:23.510 --> 03:21:25.510
minus JAR

03:21:25.510 --> 03:21:27.510
ausführen.

03:21:27.510 --> 03:21:29.510
Nee.

03:21:31.510 --> 03:21:33.510
Natürlich nicht. Wäre ja auch

03:21:33.510 --> 03:21:35.510
viel zu einfach, wenn das direkt funktionieren würde.

03:21:46.900 --> 03:21:48.900
Okay, in dem Punkt

03:21:48.900 --> 03:21:50.900
ist es einfach echt kompletter Müll.

03:21:50.900 --> 03:21:55.750
Keine Ahnung, wie das

03:21:55.750 --> 03:21:59.770
funktionieren soll jetzt.

03:21:59.770 --> 03:22:01.770
Was will das überhaupt

03:22:01.770 --> 03:22:03.770
von mir?

03:22:03.770 --> 03:22:08.230
Wie groß ist die JAR?

03:22:08.230 --> 03:22:10.230
5,4 Kilobyte. Da muss auf jeden Fall

03:22:10.230 --> 03:22:12.230
eine Runtime für da sein.

03:22:12.230 --> 03:22:18.170
Also, Java-Zeug.

03:22:18.170 --> 03:22:20.170
Ich hab keinen Plan, wie das funktioniert.

03:22:20.170 --> 03:22:24.570
Okay.

03:22:24.570 --> 03:22:26.570
Kotlin self-contained

03:22:26.570 --> 03:22:28.570
binary. Geht das irgendwie?

03:22:28.570 --> 03:22:35.080
Build final native

03:22:35.080 --> 03:22:37.080
binaries. Okay.

03:22:37.080 --> 03:22:39.080
Jetzt geht's zur Sache, ja.

03:22:39.080 --> 03:22:51.160
Multi-Plattform-Development.

03:22:51.160 --> 03:23:00.680
Oh nee,

03:23:00.680 --> 03:23:08.150
das kriegen wir nicht mehr gebacken.

03:23:08.150 --> 03:23:10.150
Getting start. Das ist Kotlin native.

03:23:10.150 --> 03:23:12.150
Ja, da scheint was anderes zu sein.

03:23:12.150 --> 03:23:18.150
Alter, ich suche nach einem

03:23:18.150 --> 03:23:20.150
Fat-JAR oder Shadow-JAR.

03:23:20.150 --> 03:23:22.150
Ich hätte gern

03:23:22.150 --> 03:23:24.150
so eine komplett self-contained

03:23:24.150 --> 03:23:57.860
Anwendung.

03:23:57.860 --> 03:23:59.860
Okay, include runtime brauchen wir

03:23:59.860 --> 03:24:01.860
noch, aber ehrlich gesagt, ich

03:24:01.860 --> 03:24:05.430
hätte auch gerne

03:24:05.430 --> 03:24:07.430
ein komplettes self-contained.

03:24:07.430 --> 03:24:09.430
Oh nee, da hab ich keinen

03:24:09.430 --> 03:24:11.430
Bock drauf.

03:24:11.430 --> 03:24:13.430
Das mach ich jetzt nicht.

03:24:13.430 --> 03:24:15.430
Das ist, glaube ich, echt eine Wissenschaft für sich.

03:24:15.430 --> 03:24:19.060
Das ist, glaube ich,

03:24:19.060 --> 03:24:21.060
echt eine Wissenschaft für sich.

03:24:21.060 --> 03:24:23.060
Self-contained heißt ja im Endeffekt,

03:24:23.060 --> 03:24:25.060
im Java-Umfeld, pack einfach

03:24:25.060 --> 03:24:27.060
die JVM komplett mit rein.

03:24:27.060 --> 03:24:29.060
Dann ist dein Binary am Ende dann halt irgendwie

03:24:29.060 --> 03:24:31.060
50, 60 MB groß.

03:24:31.060 --> 03:24:33.060
Ich bin mir nicht sicher, ob Java

03:24:33.060 --> 03:24:35.060
schon auch Versuche in Richtung

03:24:35.060 --> 03:24:37.060
Ahead-of-Time-Compilation hat.

03:24:37.060 --> 03:24:39.060
Gerade bei

03:24:39.060 --> 03:24:41.060
.NET 8

03:24:41.060 --> 03:24:43.060
hat sich da viel getan, beziehungsweise wird sich

03:24:43.060 --> 03:24:45.060
sehr viel tun noch, wenn das

03:24:45.060 --> 03:24:47.060
in ein paar Monaten rauskommt.

03:24:47.060 --> 03:24:50.570
.NET 8 Release Date.

03:24:50.570 --> 03:24:52.570
Ja, im November.

03:24:52.570 --> 03:24:54.570
Ja.

03:24:54.570 --> 03:24:56.570
Mal gucken, ob Java auch sowas...

03:24:56.570 --> 03:25:02.500
Java Ahead-of-Time-Compilation.

03:25:02.500 --> 03:25:07.030
IBM.

03:25:07.030 --> 03:25:09.030
Ich sehe schon, das ist tatsächlich gar nicht so einfach.

03:25:09.030 --> 03:25:13.110
Für Backend,

03:25:13.110 --> 03:25:15.110
für serverseitige Backend-Anwendungen

03:25:15.110 --> 03:25:17.110
ist das ja überhaupt kein Problem.

03:25:17.110 --> 03:25:19.110
Dann würde ich da jetzt irgendein Docker-Image mitbauen,

03:25:19.110 --> 03:25:21.110
mit Java-Runtime drin und fertig.

03:25:21.110 --> 03:25:23.110
Kann man sowas

03:25:23.110 --> 03:25:25.110
nicht mit der GraalVM machen?

03:25:25.110 --> 03:25:27.110
Weiß ich nicht, sagt mir nix.

03:25:27.110 --> 03:25:30.870
Was ist denn die

03:25:30.870 --> 03:25:32.870
GraalVM?

03:25:32.870 --> 03:25:37.020
Compiles your Java

03:25:37.020 --> 03:25:39.020
Ahead-of-Time.

03:25:39.020 --> 03:25:41.020
Okay. Und wie kann man das

03:25:41.020 --> 03:25:45.860
mit Kotlin verwenden?

03:25:45.860 --> 03:25:47.860
Okay. Okay, jetzt.

03:25:47.860 --> 03:25:49.860
Build a native image of a Java

03:25:49.860 --> 03:25:51.860
and Kotlin application.

03:25:51.860 --> 03:25:56.650
Aber dazu brauche ich erstmal nicht...

03:25:56.650 --> 03:25:58.650
Boah, das ist wieder

03:25:58.650 --> 03:26:00.650
hyperkompliziert.

03:26:00.650 --> 03:26:10.870
Gu install native

03:26:10.870 --> 03:26:15.660
image.

03:26:15.660 --> 03:26:17.660
Ne, ne, ne, ne, ne.

03:26:17.660 --> 03:26:23.850
Und wie kompi...

03:26:23.850 --> 03:26:25.850
Execute.build

03:26:25.850 --> 03:26:27.850
Ne, ne, ne.

03:26:27.850 --> 03:26:29.850
Das mache ich heute nicht. Das halte ich heute

03:26:29.850 --> 03:26:31.850
geistig nicht aus.

03:26:31.850 --> 03:26:33.850
Was ich ein bisschen schade finde, ist, dass das nicht funktioniert.

03:26:33.850 --> 03:26:39.020
Ich weiß nicht, warum.

03:26:39.020 --> 03:26:41.020
Du bist auf dem falschen Pfad.

03:26:41.020 --> 03:26:43.020
Okay.

03:26:43.020 --> 03:26:45.020
Na dann.

03:26:45.020 --> 03:26:47.020
Wo ist der richtige Pfad?

03:26:47.020 --> 03:26:49.020
Ne, aber das machen wir heute nicht mehr.

03:26:49.020 --> 03:26:51.020
Das ist mir zu anstrengend.

03:26:51.020 --> 03:26:53.020
Da kann ich mich jetzt nicht mit beschäftigen.

03:26:53.020 --> 03:26:55.020
Vielleicht beschäftige ich mich da mal noch ein bisschen.

03:26:55.020 --> 03:26:58.780
Die Manifest-Datei fehlt.

03:26:58.780 --> 03:27:00.780
Mag sein,

03:27:00.780 --> 03:27:02.780
aber irgendwie sagt nichts

03:27:02.780 --> 03:27:04.780
darüber Bescheid, dass ich eine Manifest-Datei

03:27:04.780 --> 03:27:16.340
brauche.

03:27:16.340 --> 03:27:18.340
Ach, keine Main.

03:27:18.340 --> 03:27:20.340
Was ist denn das Maven-Manifest?

03:27:20.340 --> 03:27:22.340
Das hier, oder wie?

03:27:22.340 --> 03:27:26.490
Pom.

03:27:26.490 --> 03:27:28.490
Ist das das Maven-Manifest?

03:27:28.490 --> 03:27:30.490
Pom.xml?

03:27:32.490 --> 03:27:34.490
Ich weiß wirklich nicht, wo ich was machen muss.

03:27:34.490 --> 03:27:38.120
Ich habe davon absolut keinen Plan.

03:27:38.120 --> 03:27:40.120
Kann das hier vielleicht sowas?

03:27:40.120 --> 03:27:46.150
Ne.

03:27:46.150 --> 03:27:48.150
Und da muss ich eine Main-Methode festlegen.

03:27:48.150 --> 03:27:50.150
Das kann man doch bestimmt auch hier drüber machen.

03:27:50.150 --> 03:27:55.700
Ne.

03:27:55.700 --> 03:27:57.700
Pom.xml Main.

03:27:57.700 --> 03:28:05.820
Du müsstest in die

03:28:05.820 --> 03:28:07.820
Pom noch schreiben, was ein Manifest

03:28:07.820 --> 03:28:09.820
in die JAR soll. Ne, das mache ich jetzt nicht, Leute.

03:28:09.820 --> 03:28:11.820
Zack.

03:28:13.820 --> 03:28:15.820
Das mache ich jetzt nicht.

03:28:15.820 --> 03:28:17.820
Genug Kotlin für heute.

03:28:17.820 --> 03:28:19.820
Vielleicht gucken wir uns das nächste Mal tatsächlich

03:28:19.820 --> 03:28:21.820
noch weiter an. Ich muss mich erst mal

03:28:21.820 --> 03:28:23.820
ein bisschen

03:28:23.820 --> 03:28:25.820
noch damit beschäftigen.

03:28:25.820 --> 03:28:29.830
Ich würde sagen, als Fazit,

03:28:29.830 --> 03:28:31.830
Kotlin als Sprache

03:28:31.830 --> 03:28:33.830
echt nice.

03:28:33.830 --> 03:28:35.830
Intuitiv.

03:28:35.830 --> 03:28:37.830
Man weiß, wie die Sachen gehen, obwohl man sie noch nicht gemacht hat.

03:28:37.830 --> 03:28:39.830
Finde ich gut.

03:28:39.830 --> 03:28:41.830
Das Java-Ökosystem, boah, ich weiß echt

03:28:41.830 --> 03:28:46.100
nicht.

03:28:46.100 --> 03:28:53.700
Ja, das, was ich gerade gesagt habe.

03:28:53.700 --> 03:28:55.700
Cradle macht einiges einfacher.

03:28:55.700 --> 03:28:57.700
Vielleicht gucken wir uns das das nächste Mal an.

03:28:57.700 --> 03:28:59.700
So. Chatge.

03:29:01.700 --> 03:29:03.700
Wer noch nicht gefollowt hat und wem der Content

03:29:03.700 --> 03:29:05.700
gefällt, ich würde mich sehr

03:29:05.700 --> 03:29:07.700
freuen, wenn ihr demnächst hier öfters da seid.

03:29:07.700 --> 03:29:09.700
Ich muss ein bisschen sehr laut machen, weil ich habe gesehen,

03:29:09.700 --> 03:29:11.700
meine Stats waren diese

03:29:11.700 --> 03:29:13.700
Woche nicht so gut.

03:29:13.700 --> 03:29:15.700
Das geht ja nicht. Cackweight.

03:29:15.700 --> 03:29:17.700
Für mehr Stonks.

03:29:17.700 --> 03:29:23.130
Ja.

03:29:23.130 --> 03:29:26.760
Und ansonsten

03:29:26.760 --> 03:29:28.760
würde ich sagen, Chat,

03:29:28.760 --> 03:29:30.760
schön,

03:29:30.760 --> 03:29:32.760
dass ihr so high IQ seid.

03:29:32.760 --> 03:29:36.260
Und wir sehen uns im nächsten Stream.

03:29:36.260 --> 03:29:38.260
Macht's gut, bis dann.
