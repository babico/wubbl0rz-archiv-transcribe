Ja, doch. Die letzte Woche habe ich 600 Euro Tierarztrechnung ausgegeben. Aber ich will ja, dass es Chico gut geht. Ja, aber das ist schon echt ordentlich.
Ich meine, bei mir ist es nicht so wild, ja. Die Kohle muss eh irgendwo hin. Aber schon ganz schön heftig, wenn man sich das überlegt.
Wie macht man das, wenn man jetzt nicht so viel Geld hat?
Ich meine, es war ja nicht zum Fenster rausgeschmeißt. Es war für die Katz sozusagen. Aber 600 Euro Tierarztkost, schon krass. Ich war... Ich habe einmal... Einmal habe ich das... Ne, ich will keine neue Katz.
Einmal waren die hier, haben sich Chico angeguckt. Dann war ich beim Augenarzt mit Chico. Moment, die Musik ist zu laut. Wait. Dann war ich beim Augenarzt mit Chico.
Dann war ich beim Augenarzt mit Chico. Also, also das Ding war, ich habe letzte Woche, hat Chico hier auf dem Schrank... Ich war mal nicht vor M an.
Letzte Woche hat Chico, letztes letzte Wochenende hat Chico hier auf dem Schrank gehockt und hat so ein bisschen, habe ich gesehen, die hat so ein bisschen Blut im Auge gehabt.
Denkt man sich ja erstmal nichts großartiges dabei. Man kann sich gekratzt haben oder irgendwie sonst was. Also unten rechts ein bisschen Blut im Auge.
Aber, nachdem Chico ja bekanntermaßen ein bisschen Nierenprobleme hat und auch nur Diätfutter und alles kriegt. Chico ist ja 13 mittlerweile schon. Er ist jetzt zwar kein alter wirklich für Katzen, aber schon alt.
Also sie sind alt, sie können durchaus noch älter werden, aber auf jeden Fall schon Oma. Und zumindest, dann habe ich im Internet geguckt, dass gerade Katzen mit Nierenerkrankung oftmals auch unter Bluthochdruck leiden und Bluthochdruck bei Katzen sehr oft auf das Auge geht und das Auge blutet und manchmal löst sich auch tatsächlich die Netzhaut ab.
Zumindest war ich dann beim Tierarzt, wo wir sonst hingehen und hab gesagt, ihr Katz hat Blut im Auge und Blutdruck messen. Da haben die irgendwie gesagt, doch nö, wir können gar keinen Blutdruck messen. Fand ich schon sehr pipega, dass sie das so alles überhaupt nicht interessiert hat.
Hab ich mir gesagt, so gut dann, neuen Tierarzt suchen. Hab ich mir neuen Tierarzt gesucht und die sind tatsächlich sogar daheim vorbeigekommen, weil die haben gesagt, dass Blutdruck messen ist am besten, wenn die Katz halt entspannt ist.
Leider war Chico sehr unkooperativ, was Blutdruck messen angeht. Da mussten sie erstmal in ihr Auto hocken und dann haben sie da gemessen und Chico hat halt richtig krass hohen Blutdruck. Chico hat über 250 Blutdruck, normalerweise ist 150 gerade so noch okay. Chico hat super krass hohen Blutdruck.
Jetzt kriegt Chico zusätzlich zu ihren Schilddrüsen und Nierenmedikamenten noch Blutdruck senkende Mittel und für das Blut im Auge war ich mit der Katze beim Augenarzt, ja es gibt Augenärzte für Katzen. Die hat das Auge untersucht, hat gemeint, oh ja, da ist schon ein bisschen blutig und hat auch nochmal Blutdruck gemessen, war auch wieder viel zu hoch.
Und jetzt muss sie noch ein paar Cortison-Tabletten schlucken, dass das alles wieder schön abschwillt im Auge und die Netzhaut auf jeden Fall dran bleibt und sie nicht blind wird. Und jetzt kriegt die halt Blutdruck senkende Mittel und morgen gehe ich schon wieder zum Tierarzt und Mittwoch wieder zum Augenarzt.
Also ich habe wahrscheinlich innerhalb von 14 Tagen bin ich 1000 Euro los, was Tierarzt angeht. Die ist 13, die ist schon älter, da haben die ja öfters mal die ein oder anderen probiert. Oh nee, C++, geh mal weg, ich mache, ich mache, ich mache weg.
Gibt es eine Krankenversicherung? Ey, keine Ahnung, ob es das gibt, aber wenn, ist es wahrscheinlich so unsinnig teuer. Ich bezahle das selbst. Irgendwo muss die Kohle ja hin.
Also ich hoffe, dass es morgen, wenn Blutdruck gemessen wird, dass, also wir waren ja da nochmal letzte Woche Blutdruck messen, und zwar am Freitag, da war er schon runter ein bisschen, aber noch nicht genug. Aber das dauert immer ein bisschen, bis das Blutdruckmedikament bei der Katze im Blut ist, bei Menschen übrigens nicht anders, bis das alles ordentlich wirkt.
Chico bewegt sich auch viel zu wenig, ja. Chico hängt immer nur rum. Und ich hoffe, der Blutdruck ist da noch ein bisschen runter gegangen und beim Augenarzt stellen sie fest, dass alles wieder, alles wieder soweit okay ist und, weil, ganz ehrlich, die Katze klickt halt sehr viel im Medikament und die Katze hat keinen Bock da drauf, die zu nehmen.
Ja, du hast aber sicherlich nicht einmal 80 Euro bezahlt, oder? Ist er Freigänger? Ne, es ist eine Sie, auch wenn sie Chico heißt, ergibt keinen Sinn, aber was weiß ich, was die Vorbesitzer sich dabei gedacht haben. Kann man aber wahrscheinlich auch nur für die junge, für eine junge Katze abschließen, wenn du das für eine 13-jährige Katze abschließt. Da wollen die fast was für sich dafür haben, Alter. Das ist so, wie wenn du mit 70 sagst, ich möchte noch Krankenversicherung abschließen.
Ne, ist er nicht. Das Einzige, was Chico kann, ist, die kann hier auf die Terrasse, aber die Terrasse hat so ein Netz drumherum.
Ich bin ganz schön kaputt heute. Gestern Abend, ähm, ja, wie gesagt, ich bin ganz schön kaputt. Gestern Abend Fahrrad gefahren, 45 Minuten volle Pulle und heute Morgen 10 Kilometer gerannt. Ich merk's echt in den Beinen, das reicht jetzt erstmal. Morgen mach ich nix. Morgen mach ich gar nix. Reicht echt. Ich merk's auch voll im Schienbein.
Du warst heute Morgen nicht da, gell? Heute Morgen hat mich die Waage übelst debatet. Ich bin rübergegangen, hab mich auf die Waage gestellt, hatte noch Socken und Unterhose an. Da hat die Waage 90 Kilo angezeigt. Dann bin ich weg, hab das Handy geholt zum Fotografieren, hab Socken und Unterhose ausgezogen, hat 90,2 oder 90,3.
Das heißt, ich hatte weniger an, hab mehr gewogen. Null. War nix. Es war ganz knapp, es war ganz knapp über 90. Das heißt, noch ein paar Wochen, also bis Ende des Jahres sollte ich dieses Mal unter 90 auf jeden Fall schaffen, wenn das so weitergeht. Ja, wird's ja auch.
Es war nicht so krass wie zu Corona-Zeiten, wo ich angefangen hab mit allem. Ja, man darf nicht vergessen, dass wenn man sich ordentlich bewegt, man kriegt ja auch Muskel. Man tradet ja auch ein bisschen Speck gegen Muskel. Ja, kenn ich, hab ich aber noch nie großartig was mitgemacht.
Excellent. So, dann erstmal Finger aufwärmen für krasse Progress-Action. So, Finger aufgewärmt. Auf geht's. Ich zeig euch mal, für alle, die nicht dabei waren, war jemand beim letzten Rust-Stream dabei und hat mir zugeguckt, wie ich nix gecheckt hab.
Ich zeig euch kurz, was Sache ist und heute wird's nicht so super kompliziert, weil erstens bin ich ziemlich kaputt und hab wahrscheinlich auch jetzt 19 Uhr nicht mehr die größten Brain-Resources übrig. Heute versuchen wir das mal ein bisschen aufzuräumen. Dazu braucht man aber auch Rust-Spezialitäten.
Und dementsprechend schauen wir mal. So, also, hab ich jetzt Package-Updates gemacht? Arch-Linux, by the way, falls jemand Fragen hat. Schon wieder Package-Updates? Meine Güte. Hast du mal zwei Minuten keine Package-Updates gemacht? Ja. Arch use ich, by the way. Packages 171. Ich weiß wahrscheinlich von gerade mal 20 oder so, dass ich die wirklich wissentlich installiert hab.
Übrigens, Leute, jetzt, wo ich ttf-Tweemojis sehe, pass mal auf. Wisst ihr, was ich gesehen hab? Es gibt bald eine neue Tweemoji-Version auf GitHub. Endlich neue Unicode-15-Emojis. Tweemoji-GitHub. Und zwar Discord macht Gigachat-Move. Ja. Discord macht Gigachat-Move und addet den Großteil der fehlenden Unicode-15-Emojis.
Steven from Discord ist am Start. Steven from Discord und sagt, ihr In-House-Artist, der Kevin VQ-Damm, geiler Name, VQ-Damm, hat Emojis open-sourced für Tweemoji.
Also, wer sich fragt, was das Problem ist eigentlich, das Ding ist, Tweemoji ist eigentlich der Twitter-Emoji-Font. Das dumme ist nur, seit Elon Twitter übernommen hat, wurde jegliches Open-Sourcing von ihrem Emoji-Font eingestellt.
Und dementsprechend können die neuesten Emojis nicht einfach kopiert werden von Twitter, weil die halt copyrighted sind. Bei Twitter oder bei X.
Witzigerweise, der Fork auf GitHub ist von alten Twitter-Mitarbeitern, die rausgeschmissen wurden von Twitter und sich damals um den Emoji-Font gekümmert haben.
Und die Discord-Leute haben neue Emojis beigesteuert. Ich glaube, es sind jetzt nahezu alle Unicode-15-Emojis. Das heißt, sie müssen jetzt nur noch einen neuen Font bauen.
Und dann gibt es endlich eine neue Version von Tweemoji, die Unicode-15-kompatibel ist.
Wie sieht es eigentlich mit Unicode-16 aus?
Okay, kommt September 2024 raus.
Aha, guck mal, 2024 gibt es neue Emojis. Gucken wir mal, ob es da schon welche gibt zum angucken.
Fingerprint-Emoji gibt es noch kein Beispiel für. Emoji-16 gibt es noch nicht.
Face with backs under eyes gibt es dann. Aha, alles klar, gibt es auch noch keine Implementierung.
Blätter, Leafless-Tree, Harp, eine Schaufel und irgendwelche Veganer-Sachen.
Unbedingt Unicode-16 braucht es.
Da bin ich wirklich froh, dass hier Discord-Leute den Giga-Chat-Modus gezündet haben und neue Emojis beisteuern.
Dann heißt das Ding zwar Tweemoji, hat aber nicht die Emojis von Twitter, wobei Twitter auch nicht mehr Twitter, sondern X heißt.
Also Chat, weiter geht's.
Hier sind wir stehen geblieben. Ich zeige euch, wie wir stehen geblieben sind.
Das Ziel ist eine WebRTC-Anwendung zu bauen mit Low-Level-WebRTC in Rust.
Frontend ist ein bisschen HTML-JavaScript.
Backend, weil ein bisschen mehr Backend erforderlich ist, als nur Seite auszuliefern, ist eine .NET-Anwendung.
Und die .NET-Anwendung macht Interop mit Rust.
Ich zeige euch das Ganze mal. Wir machen hier mal Rust auf.
Mal kurz in die JetBrains-Toolbox looken, ob es neue Versionen von den IDEs gibt.
Massive. Es gibt neue Versionen von PyCharm und Golan.
Ja, brauche ich jetzt ehrlich gesagt. Aber komm, wir machen Update.
So, dann müssen wir Rider starten.
Frontend mit dem Framework oder Plain?
In dem Fall Plain, weil das Frontend gerade 30 Zeilen ist. Da ist nicht viel zu sehen.
Ich zeige dir gleich, wie das aussieht.
Also das hier ist aktuell alles, was das Frontend beinhaltet.
Das macht zur Zeit nichts anderes als WebRTC-Verbindungsaufbau.
Und dann auf die Webseite schreiben.
Boah, laggy im Hintergrund.
Alter, wie das... What the f...
Das Update... Alter.
JetBrains. Java. Keck Java.
Was ist da los?
Die brauchen beim Updaten der IDEs einfach mal alle 8 CPU-Cores.
So gehört sich das.
Ich habe das All-Products-Pack, ja.
Was genau macht das da jetzt 3 Stunden beim Updaten?
Oh, es gibt eine neue Sea Lion.
Interesting.
So. Update ist gelaufen.
Gut. Also, ich zeige euch mal, wie das aktuell aussieht.
Das Frontend ist äußerst unspektakulär.
Da sieht man nicht viel, aber ich zeige es euch mal trotzdem.
.NET Run.
Aktuell sieht das...
Äh, Moment. Ist das überhaupt...
Moment, Moment. Das geht ja gerade gar nicht.
Geht ja gerade gar nicht, weil ich gestern in weiser Voraussicht die Hälfte auskommentiert habe.
Keck, wait.
Die wir jetzt wieder einkommentieren müssen.
Wait a minute. Ich glaube, es ist gerade kaputt.
Wir haben doch gestern noch mit UIDs rumgewurschtelt, oder?
Ja, es ist gar kein UN64 mehr.
Das wird jetzt gar nicht funktionieren.
Pass mal auf, das crasht jetzt.
Okay. Wir haben das etwas unfertig hinterlassen gestern.
Das Ganze.
Wir haben so halb aufgehört.
Zwischendrin.
Zumindest, dass das Frontend...
Oh, wir müssen gerade mal kurz eine Sache im Frontend machen. Das ist mir viel zu hell.
Ähm, Style.
Wie macht man das? Background, Color.
Und jetzt?
Keine Ahnung.
Gray, oder sowas?
Okay, schon besser.
Okay, ja, ein bisschen nicht ganz so anstrengend.
Okay.
Also das Frontend ist äußerst simpel.
Das ist alles an JavaScript.
Der baut eine WebRTC-Verbindung auf.
Im Detail werdet ihr es wahrscheinlich gleich sehen.
Dann ist das hier das .NET-Backend.
Moment, das hier ist das .NET-Backend.
Da passiert auch nicht viel.
Und das hier ist die Raster-Anwendung. Das ist da, wo wir heute drin rumbauen werden.
Und ich glaube,
ich glaube, Chad, wir müssen das erstmal wieder funktional machen.
Bevor wir jetzt weitermachen.
Deswegen, ich schmeiß
diesen Krempel hier mit
mit der UID schmeiß ich wieder raus.
Wir machen da wieder ein U64 draus.
Sodass, sodass, erstmal, erstmal kurz machen, dass es wieder funktioniert.
Okay, ja.
Wozu baust du das denn?
Erstens, um ein bisschen Rust zu lernen.
Und zweitens, weil ich vorhabe, alle meine Webcams
realtime zu streamen auf eine Webseite.
ID. ID kommt hier her.
ID ist einfach 1. Jetzt hardcoded.
Gucken, ob es noch
ob es noch compiled.
Cargo.
Nope.
UID mal wieder rausschmeißen.
1.
Und wo hat er jetzt noch Schmerzen?
Client ID.
Hä?
Wie?
Wie kommt er da drauf, dass es ein U128 sein soll?
Will er mich gebanen?
Achso!
Weil hier oben die Collections noch U128 sind, gell?
Ah, okay, alles klar.
Nice. Und jetzt?
Okay, was ist jetzt für ein Problem?
Und?
71. Pounds.
128. Ah.
U64.
U64.
So, ich glaube, wir sollten nirgendwo mal U128 benutzen.
So, und wenn das jetzt funktioniert,
dann sollte auch alles wieder klappen
und das sollte laufen.
Zwar nicht perfekt,
aber laufe ich sein?
Oh man! Alter, ich hab's kaputt gemacht gestern.
Jetzt müssen wir das...
Jetzt müssen wir das erst mal fixen wieder.
Okay, also.
Na geil, na geil.
Jetzt haben wir das irgendwie zerstört.
Warum?
Was haben wir hier zerstört?
Was will er eigentlich von mir, man?
Achso, ich weiß warum.
Weil ich das falsche returne.
Wir returnen jetzt kein U128 mehr,
sondern ein U46.
U in 46.
So, jetzt geht's wieder.
Nice. Guck, passt wieder.
Also, folgendermaßen.
Frontend?
Das Cray.
Gibt das nicht irgendwie Light Cray oder sowas?
Azure.
Äh.
Okay, wir können einfach...
Wir können einfach...
Wie geht das? RGB?
Ich wollte gerade sagen,
Visual Studio hat doch da so einen Selektor.
Perfekt.
Hä?
Das ist doch im Leben nicht die gleiche Farbe, oder?
Hä?
Moment, was...
Was zum...
Hat da Visual Studio Code gerade draus gemacht?
Okay, ja, so ist es okay.
So lass ich mir das gefallen.
Das ist ganz...
Es ist wirklich easy, es macht nicht viel.
Es versucht eine WebRTC-Verbindung aufzubauen.
Dazu holt es sich vom Backend die Informationen,
was der Server für Codecs und alle möglichen Sachen unterstützt.
Dann subscribes es zum ConnectionState-Event
und ändert hier ein bisschen die Farbe und den Text auf der Webseite,
wenn sich da was ändert.
Dann schickt es eine Antwort an den Server zurück,
was der Browser selbst für Codecs unterstützt.
Und...
Ja, das war's.
Mehr macht das Frontend nicht.
Das Ganze wird quasi mehr oder weniger durch die .NET-Anwendung durchgeschleift.
Das ist alles.
Das ist alles, was einen hier großartig interessieren muss.
Und das landet dann in der jeweiligen Rust.
In der jeweiligen Rust-Endpunkt.
Rust ist deutlich komplizierter gewesen gestern,
als ich mir das vorgestellt habe.
Und zwar...
Die Main-Funktion brauchen wir nicht.
Das ist ein asynchrones Rust.
Das heißt, das läuft mit Tokio.
Und damit Tokio funktioniert, braucht man eine Tokio-Runtime.
Leute, ich habe bis heute nicht gecheckt, was es genau macht
und wofür das Ganze gut ist.
Aber es hat funktioniert,
nachdem wir gestern sehr viel Try-and-Error rumgefuddelt haben.
Und jetzt funktioniert es.
Und man sieht hier die entsprechenden Sachen,
die in C-Sharp aufgerufen werden.
Hier wird beispielsweise aufgerufen Get-Offer.
Hier wird Create-Connection aufgerufen.
Hier wird Set-Answer aufgerufen.
Wenn man sich das hier in Rust anguckt, sieht man das auch.
Das ist eigentlich das Einzige.
Hier passiert eigentlich das meiste.
Der erstellt eine neue WebRTC-Connection.
Hier, der erstellt eine neue WebRTC-Connection.
Warum habe ich hier Tracks?
Das ergibt überhaupt keinen Sinn.
Ah, Tracks, weil ich die...
Okay, ergibt doch Sinn.
Hier erstelle ich eine WebRTC-Connection
und hole mir dann raus, was der Server für Codecs unterstützt.
Was für Codecs unterstützt werden, stelle ich hier ein.
Es wird genau ein Codec unterstützt, und zwar H.264
mit 90.000 Clockrate, das ist alles.
Hier wird die WebRTC-Verbindung aufgebaut
und hier wird die Sache, die der Browser antwortet, gesetzt.
Ist aber alles nicht so wild,
weil heute geht es um syntaktische Rust-Geschichte,
weniger um die WebRTC-Sache an sich.
Denn, was ich mir überlegt habe, ist,
das hier ist ja kein schönes Rust hier oben.
Also, schön ist hier vieles nicht dran,
beispielsweise diese ganzen Calls mit GetUnwrap, ReadUnwrap.
Das sieht schon abartig aus.
Was willst du da absichern?
Es macht keinen Sinn, die abzusichern, weil es...
Es darf durchaus crashen, wenn...
Also, wenn das hier nicht funktioniert, was soll er machen?
Dann muss er ja crashen im Endeffekt.
Ach so, gut. Ja doch, du hast insofern recht.
Stimmt schon.
Man könnte gucken, wenn es aus irgendwelchen Gründen nicht klappt,
dass das Main-Programm nicht crasht.
Aber ganz ehrlich, das sind solche Dinger,
die sollten eigentlich nicht crashen.
Also, die sollten eigentlich nicht fehlschlagen.
Wenn sie doch fehlschlagen, ist irgendwas kaputt,
dann soll es halt crashen.
Ist schon okay.
Dass hier eine hardcoded-ID drin ist, ist übrigens auch nicht so sinnvoll.
Java ist gigalangsam, das stimmt überhaupt nicht.
Java ist gar nicht so lahm.
Java ist...
Sag mal so aus...
Historisch wurde gerne über Java geflamed.
Und...
Gerade über Memory-Consumption.
Aber die reine CPU-Performance ist Java gar nicht so schlecht.
Genauso wie C-Sharp und .NET.
.NET ist sogar ziemlich schnell.
Sogar einen Ticken schneller als Java, je nachdem,
was man sich für Benchmarks anguckt.
So, und zwar, wir haben hier ganz viele globale Variablen.
Das ist nicht gerne gesehen in Rust.
Mal ganz davon abgesehen,
dass mich das nicht wirklich interessiert,
ob das irgendwelche Rust-Experten als schön oder nicht schön empfinden.
Das Ding ist, es geht nicht anders als globale Variablen.
Denn, es ist ja nicht...
Es liegt ja hier nicht in der Hand,
von Rust das alles zu machen,
sondern, ich call ja in den Rust-Code von außen rein.
Das heißt, ich brauche irgendwie den State vom letzten Call
und den kann Rust nicht tracken für mich.
Wie soll es das machen?
Das wird aufgerufen von C aus
und geht dann zurück mit ein paar Sachen zu dem C-Interface zurück.
Das heißt, wir brauchen ein paar statische Variablen.
Was ich mir jetzt überlegt habe,
und da bin ich mal gespannt, ob ich das hinkriege.
Was mir hier persönlich am allerwenigsten gefällt,
sind diese ganzen Unwrap-Orgien.
Das sieht einfach total unreadable und eklig aus.
Und was mir auch nicht gefällt,
sind diese Ultra-Deep-Nested-Typen.
Guckt euch das mal an.
Da rast es da aus.
Once-Log, Rw-Log, Hash-Map, Arc-Track...
Im Prinzip will ich einfach nur einen Dictionary haben
mit int64 als Key
und diesem Struct hier als Value.
Damit das funktioniert,
musst du das in diesen ganzen Krempel reinwrappen.
Das ist echt nicht normal.
Deswegen habe ich mir überlegt,
wir machen folgendes.
Wir haben nämlich aktuell da so einen kleinen Bug drin,
der daraus resultiert,
dass ich gestern nicht besser darüber wusste,
was ich machen soll.
Und zwar jede Connection und jeder Track,
der angelegt wird.
Also mit Track ist in Video gemeint.
Das Ziel ist ja im Endeffekt,
mit FFmpeg Webcams auslesen,
auf Serverseite RTSP Webcams auslesen
und dann auf Serverseite das Ganze in einen Stream schreiben,
rüber streamen an den Browser.
Und der Browser rendert die Videos
dann in einem Canvas oder einem Video-Element.
Das Ding, damit das funktioniert,
ist, es braucht jeder Track und jede Connection
eine eindeutige ID.
Und aktuell ist es kaputt.
Weil jeder Track hardcoded die ID 2 bekommt.
Das kann ja schon mal gar nicht funktionieren.
Und jede neue Connection hardcoded die ID 1 bekommt.
Das kann auch schon nicht richtig funktionieren.
Also insofern,
und diese unwraps und read und get und unwrap,
das ist auch eklig.
Deswegen habe ich mir überlegt,
wir machen folgendes, wir probieren das mal zumindest.
Wir legen heute in Rust zwei neue Typen an.
Und zwar einmal so eine Art AppState.
Hier so etwas wie AppState.
Und da fassen wir diese ganzen Dinger hier drinnen zusammen.
Gucken, wie das funktioniert.
Und dann würde ich gerne noch ein Struct,
so etwas wie zum Beispiel Registry bauen
und das generic machen.
Ich habe keine Ahnung, wie das in Rust funktioniert.
Geht das vielleicht sogar so?
Moment, Punkt.
Geht das etwa so?
Das ist die gleiche,
das ist die Sharp-Syntax für generics.
So.
Und dann will ich eine generic Collection machen,
die ich jetzt mal Registry nenne.
Wir können sie auch einfach List nennen oder so.
Letztendlich ist es egal, wie das Ding heißt.
Die folgendes macht.
Ich nenne es lieber Registry.
Das ist deutlich sinniger in dem Fall.
Die Tracks und Connections sammelt.
Also dass man quasi eine Collection machen kann,
entweder auf Tracks oder auf Per-Connections.
Und die automatisch eine ID-Such, die frei ist
und eine freie ID für die jeweilige Connection
und für den jeweiligen Track vergibt.
Gestern habe ich mir kurzzeitig überlegt,
man könnte einfach eine JuJu-ID generieren für alles.
Das Problem ist, dass eine JuJu-ID ein 128-Bit-Int ist.
Und man das interop-technisch nicht gescheit hinbekommt.
Man muss es ja über einen C-Interface quasi mit C-Sharp dann sharen.
Und es geht, haben wir gestern gebaut.
Aber schön ist was anderes.
Oh ne.
Da habe ich...
Ich setze mich jetzt erstmal mit Rust auseinander.
Und wenn mich Rust irgendwann so abfuckt,
dass ich Erholung brauche,
dann gehe ich nicht zu Java.
Dann baue ich irgendwas in irgendeiner Webseite
in irgendeiner Sprache, auf die ich Bock drauf habe.
Oder wir bauen mal wieder Microcontroller,
löten irgendwelche Sachen,
spielen mal wieder Battlefield oder sonst was.
Gibt es irgendwo ein FAQ mit Setup und so weiter?
Ne.
Aber es gibt ein Archiv, falls du alte Streams angucken willst.
Und das Archiv ist absolut gigachat-nice gebaut hier.
Mit AI-generated Thumbnails für die Streams.
Ja, hier hat Whisper ein bisschen gefailt, oder?
Whisper hat es ja prinzipiell nicht so mit Text.
Rrrri.
Ne, ne, ne. Kein Java.
Ja, da wurde wahrscheinlich keins für generated.
Ja. Ja.
Steht auch noch aus.
Neowim-Stream steht ja auch noch drin.
Guck. Irgendwo, glaube ich.
Neowim mit Plugins. Pimp mein Neowim. Ja.
Das ist auf GitHub.
Du kannst ja das klonen, wenn du willst.
Okay, so. Das ist der Plan heute.
Ich auch. Es ist nicht so, als hätte ich super Ahnung von Neowim.
Ich habe früher halt meinen Wim auch mega aufgebohrt mit Plugins.
Aber das war alles Wim-Skript.
Und Neowim ist ja zum größten Teil Lua.
Okay. Also das ist der Plan.
So stelle ich mir das vor. Ja.
Das heißt, wir fangen jetzt mal an.
Mit was fangen wir jetzt einfach an?
Kompiliert das jetzt eigentlich gerade?
Wenn ich das auskommentiere?
Ja. Okay. Nice.
Also. Ich würde sagen, wir machen erstmal einen Struct Upstate.
Okay. Und wir hauen jetzt mal diesen ganzen Krempel,
der hier aktuell so in global Sachen hängt.
Wir machen es mal testweise.
Nehmen wir einfach mal die API.
Die hauen wir hier rein.
Static brauchen wir nicht. Nehmen wir mal API.
Wir brauchen auch kein Oneslock mehr,
sondern einfach nur API, oder?
Sonst nichts, glaube ich.
Das Ding müsste thread-safe sein.
Das heißt im Endeffekt,
wir brauchen jetzt einmal noch das hier für den AppState.
AppState.
So.
Machen wir mal hier die API weg,
um zu checken, ob da alles funktioniert.
Da sollte es ein paar rote Sachen geben.
So. Jetzt müssen wir das Ganze noch initialisieren.
Let AppState set AppState.
Okay. Gut.
Was hat er hier? Use shorthand. Alles klar.
So. Hoffen wir mal, ob das jetzt funzt.
Nein. Funktioniert nicht, weil Zeile 95.
Obviously. Zeile 95.
Ach so. Ja. Das brauchen wir jetzt gar nicht mehr, oder?
Wir brauchen jetzt AppState.
Get
Unwrap API.
Nee. Das wäre jetzt auch zu einfach,
wenn das einfach funktionieren würde, oder?
Gag wait.
Das wäre deutlich way too easy,
wenn das auf first try irgendwie klappen würde.
Was ist denn das Problem,
was er jetzt schon wieder hat?
Da fehlt der BorrowOperator.
Das heißt, ich muss da einen...
Ach. Wie?
Okay.
Der Chat weiß Bescheid.
Der Chat ist wirklich schlau.
Nee. Die sind teilweise nicht wirklich useful.
Aber es funktioniert.
Ich meine, findest du das useful?
Eindeutiger Hinweis, dass man einen Unten nehmen soll.
Oh. Okay.
Ach ja.
Okay. Ich habe nichts gesagt. Ihr habt recht.
Steht ja wirklich da.
Es steht wirklich darunter.
Okay. Ich gebe zu, die Rust-Fehlermeldung in dem Fall war hilfreich.
Alles klar. Gut. Gut.
Keck G.
Ja. Ist okay.
Ich gebe zu, die war wirklich hilfreich.
Also, das hat schon mal funktioniert.
Das in AppState zu moven.
So. Jetzt packen wir die Runtime.
Kannst du nochmal das Backinserter-Meme machen?
Nee.
Das Backinserter-Meme?
Du meinst das auf Stackoverflow, das C++-Zeug?
Ja. Ich habe jetzt keinen Bock. Das kann ich in jedem Stream zeigen.
Welche Idee ist das eigentlich?
Das ist Rust-Rover.
Das ist die Rust-Idee von JetBrains für Rust.
Die hat aber noch so ein paar etwas...
Ja.
Vielleicht etwas unrunde...
Ist auch etwas unrunde.
Ist auch etwas unrund an manchen Stellen.
Ja.
So. Die API haben wir jetzt da reingepackt.
Jetzt packen wir noch die Runtime da rein.
Wobei, Leute. Ich habe eine Idee.
Passt mal auf. Six-Head-Time.
Wenn das klappt in Rust, dann habe ich Rust verstanden.
Ja. Da dauert es noch ein bisschen hin.
Gucke mal. Guck dir mal. Guck dir mal.
Ich sage doch jedes Mal hier,
wenn ich diese Async-Runtime starte,
ich sage jedes Mal,
Runtime.get.unwrap.plogon.
Ich habe eine Idee. Ich habe eine Idee.
Und zwar. Und zwar. Passt mal auf.
Wir gucken uns die Funktionsdefinition von Plogon an.
Kopieren die uns.
Und jetzt.
Und jetzt geben wir unserem API-State eine Funktion,
die Plogon heißt.
Das funktioniert. Ach, Moment. Das ist ja Rust.
Moment. Das ist ja Rust.
Das ging doch irgendwie so, oder?
Moment.
Ich will kein Makro, ne.
So. Das kriegt jetzt eine Funktion.
Plogs on.
Dann braucht das hier API-State.
Dann braucht das hier noch Runtime,
als, ja, für Klassenvariable.
Wie auch immer das heißt in Rust.
Als Instanzvariable.
Kein Schimmer, wie man das korrekt in Rust nennt.
Trade-Variable. Struct-Variable.
Struct-Failed. Weiß nicht.
So.
Und.
Jetzt sagen wir.
Moment. Self. Passt doch.
Jetzt sagen wir. Self.
Runtime.
Und jetzt kopieren wir das, was ich hier immer mache.
Plogon.
Wobei, ne. Muss ich ja gar nichts machen.
Plogon.
Und da schieben wir das jetzt rein.
Und hoffen, dass es noch kompiliert.
Ne. Shit.
Ah ne. Moment. Missing Runtime.
Hier. Missing Runtime.
Runtime.
So.
Ach so. Ich muss. Hä?
Wait a minute.
Ah.
Moment.
Das beißt sich jetzt ein bisschen in den Schwanz.
Gutschi.
Was?
Äh.
Die Runtime setze ich hier oben.
Und.
Hier unten lege ich erst den App-State an.
Ich mein.
Das muss aber nicht so sein.
Kann ich nicht einfach den ganzen Crample hier raus kopieren?
Und da rein.
Und dann. Ja. Okay.
Äh. Und dann brauche ich das hier.
Dann brauche ich das doch eigentlich gar nicht.
Ach doch. Ach. Moment. Moment. Moment. Moment.
Doch. Doch. Das muss in der Runtime gecallt werden.
Sonst hab ich wieder so diesen komischen Bug. Ne. Ne. Ne. Ne. Ne.
Nopos.
Das Rust-Buch. Ja. Soll ich jetzt das Rust-Buch im Stream lesen oder wie?
Aber was wir machen können ist.
Kann man.
Okay. Jetzt bin ich mal gespannt.
Kann ich das hier einfach die Runtime als Parameter übergeben?
Runtime.
Runtime.
Alter. Ich.
Mir pegelt das zu schreiben.
Und jetzt. Runtime.
Da reinschreiben.
Ne. Weil.
Achso. Äh. Is missing.
Runtime.
Used after move.
Okay. Dann muss. Dann. Dann muss das hier.
MonkaS. Alter. Ich hab mir das so einfach vorgestellt.
Ist es aber nicht.
Ich. Okay. Wir lassen das. Wir lassen das sein. Ja.
Wir. Wir lassen. Wir. Wir lassen das sein.
Wir lassen das. Wir lassen das sein.
Weil. Ich. Ich will ja Runtime get. Ich. Ich will das ja wegschmeißen.
Ich will das ja. Ich will das ja gar nicht mehr haben.
Ähm. Okay. Wir. Wir lassen das mal kurz hier jetzt weg.
Das ist eigentlich gar nicht das. Vielleicht fällt mir das später noch was zu ein.
Das. Das darf jetzt so bleiben.
Und das. Das. Das hier fliegt jetzt erstmal wieder weg. Okay.
Und das. Das hier auch.
Da. Da bin ich grad noch nicht high IQ Rust-mäßig genug für.
Das muss ich mal schauen, wie man das später noch macht.
Weil das beißt sich. Ich kann nicht die Runtime hier anlegen.
Das ist. Das ist halt echt blöd.
Egal. Das waren wir jetzt nicht.
Vielleicht. Vielleicht. Vielleicht fällt mir das später noch was zu ein.
Wir. Wir. Also was mich viel mehr interessiert ist.
Wie man ein Custom. Custom Type implementiert in Rust.
Eine Custom Collection wohlgemerkt in Rust implementiert.
Eine Generic Custom Collection in Rust.
Ich würde mal vorschlagen.
Wir kopieren das Ganze in ein eigenes.
In ein eigenes File.
Kann man das nicht kopieren?
Refactor. Move.
To ähm.
Registry.rs.
So. Jaja. Add.
Jetzt bin ich mal gespannt. Jetzt. Jetzt bin ich mal gespannt.
Also. Warte nicht. Runtime. Moment.
Äh.
Also. Was ich haben will.
Ich will ein Generic. Ich will ein Generic Type.
In Rust. Ich habe keine Ahnung wie man Generic.
Rust. Rust. Generic Type. Wie geht das?
Generic Data Types.
Strukt. Äh.
Ja. T.
Also im Prinzip ein bisschen wie in .NET.
Registry. T. Okay. So.
Dann machen wir hier mal eine Variable drin.
Die nennen wir einfach Storage. Oder Store.
Storage. Keine Ahnung. Store. Wir nennen es Store.
Und.
Das wird eine Hash Map.
Das wird eine Hash Map.
Vom Typ. Ähm. Tja. Wie viele IDs brauche ich?
Wahrscheinlich reicht ein U32 Log da aus.
U32 Max.
Nicht Z32. Was auch immer ich da gerade gegoogelt habe.
Z32 Max ist. Ja. Ja.
Ich glaube das reicht.
Ich glaube ich werde nie so viele Connections gleichzeitig haben.
Dass das irgendwie Probleme macht.
So. Also.
Wir brauchen eine extra ID pro Connection.
Wenn das Compile. Das wird auf jeden Fall nicht Compile.
So. Ähm. Und dann.
Ein Value auf Type T. Okay.
So weit sollte es noch Compilieren. Da haben wir noch nichts gemacht.
So. Aber. Aber generic das ganze.
So. Und jetzt.
Kann das mal machen. Was ich will.
Registry of Type T.
Moment. Jetzt geht das nicht. Warum?
Unresolved Reference.
Ach. Hier muss T vorne noch hin.
Implement. Okay.
Implement T. Implement Type T.
Registry of Type T. So. Also.
Connection.
Muss man da Public eigentlich da vorschreiben?
Ja ne. Ich muss da Pub da vorschreiben.
Damit das exportiert wird nachher.
Dass ich das benutzen kann. Glaube ich.
Oder muss ich. Muss ich nur hier.
Pub da vorschreiben.
Also nicht genau. So. Fn.
Also was brauchen wir in so einer Collection?
Wir brauchen einmal New.
So. Wir machen das mal so ein bisschen wie in Go.
Also. Es. Boah. Ich habe keine Ahnung wie das geht.
Rust. New. Constructor.
Ja. Jawohl. Genau das will ich haben.
Excellent. Copy. Paste.
So. Wir wollen kein Value. Wir returnen Self. Okay.
Und Self ist immer. Okay. Store.
Ist eine Hash Map.
Ein neues Dictionary im Endeffekt.
Okay. Funs. Nice. Was hat er für Schmerzen?
Function is never used.
Kompiliert. Alles gut.
Das heißt wir können jetzt das ganze neu anlegen.
Übrigens um das zu testen.
Machen wir hier einfach mal eine Funktion.
Und rufen das auf. Wir tun einfach mal so.
Registry new. Achso. Registry of type.
Ah. Int. Oder so.
Ähm.
Wie schreibt man das jetzt?
In. Muss man das hier vorne
irgendwie schreiben?
Type annotation needed.
Ah ja.
Okay. Das muss man hier machen.
Das ist auch ein bisschen gewöhnungsbedürftig.
Off. Ja. Hier.
U32.
Oder machen wir local static track
Sample. So. Perfekt.
Kompiliert noch. Kompiliert noch.
So.
Also.
Was braucht man für eine Collection?
Wir brauchen im Prinzip
ähm. Wir brauchen im Prinzip
drei Methoden. Vier. Vier Methoden.
Wir brauchen add Elemente,
get Elemente,
delete Elemente und
loop
oder sowas. Ja.
Alles klar.
Also. Pop.
Fangen wir mal an. Pop.
Fn. Machen wir mal add.
Add dürfte ja noch relativ easy sein.
Und jetzt. Ne Moment.
Wo kommt jetzt hier der
der Type hin?
Also bei .net kommt er
dahin glaube ich. Ja. Okay. Kommt den Rust
auch dahin. So. Add.
So. Und dann kriegen wir als Parameter
ein
ein Element.
Oh fuck. Wie war man das jetzt?
Ähm.
Also wir kriegen Element of T im Endeffekt.
So.
Was hat er hier für Schmerzen?
T is already used.
Hä? Ach brauche ich das
hier gar nicht mehr?
Ah. Ich brauche das gar nicht mehr.
So. Und dann brauchen wir aber noch
irgendwie und self.
Das ist übrigens das gleiche wie
this in C Sharp oder self in Python
oder me glaube ich
in Lua oder sowas.
So.
Das heißt jetzt sagen wir self
store
insert
Das findest du doch so im Leben nicht.
Jetzt brauchen wir. Achtung Moment. Eine ID
brauchen wir noch. Eine ID die
muss ich generieren.
Let ID gleich 1. Die generiere ich.
ID und dann fügen
wir das Element ein.
Das geht natürlich nicht.
Weil das nicht mutt ist.
Ich glaube in Lua heißt es me.
Leute. Das kann
so nicht funktionieren.
Das ist verkehrt was ich mache.
Also okay. Das würde funktionieren
im Chat. Das würde funktionieren
aber spätestens
wie will Rust das handeln
wenn ich das von verschiedenen Threads
aufrufe?
Moment. Das testen wir jetzt mal.
Ja.
Weil ich glaube schon dass man das hier locken muss.
HashMap ist ja sicherlich nicht
thread safe. Probieren wir das mal.
Jetzt irgendwie
1 oder so.
Moment. Let mutt
R mutt. Ja gut.
Hier weiß er ja
dass es nicht multithreaded ist, weil das in der gleichen
Funktion ist.
Der wird mich das
schlicht und ergreifend nicht anlegen lassen.
Vermute ich einfach mal.
Ich glaube wir brauchen
da einen Lock drum.
Ich glaube damit ersparen wir uns schon
einige Probleme.
Wir brauchen da
einen Lock drum. Lassen wir das mal
so. Also Ziel muss sein dass
die Registry selbst nicht mutable ist.
Aber er hat trotzdem funktioniert.
So. Heißt im Endeffekt
wir brauchen hier wahrscheinlich ein
RwLock. Ne oder wie ist das Ding
was wir hier hatten? Doch RwLock.
RwLock
HashMap.
Und jetzt ist es RwLock
new. Du könntest
auch nur self machen und dann versuchen mit get
mutt die Referenz
zu holen. Was?
Wie jetzt?
Das kann aber doch auch multithreaded nicht
funktionieren. Was soll ich
machen? Add? Also quasi
das muss
übrigens weg hier.
Self.
Get.
Okay was ist das
für schwarze Magie?
Returns a mutable
reference to the value. The key may be
any borrowed form of
the map key partitionable.
Wie soll das funktionieren?
Get mutt.
Geht auch nicht.
Ach Moment.
Das ist
das ist
jetzt aus
der HashMap raus.
Das ist was anderes.
Ne ne das
ich check es auch nicht.
Ne ne das gibt es überhaupt nicht.
Try?
Ne das muss in den Lock.
Das muss in den Lock rein sonst funzt das nicht.
Wir hatten es doch eben
gerade hier schon.
Lock.
LWLock. Also
Self.
Store.
Store ist jetzt allerdings nicht mehr
direkt eine HashMap sondern
ein ThreadSaveLock.
Das holen wir jetzt.
Write. Die Referenz raus.
Unwrap. Okay.
Und jetzt sagen wir MapInsert
ID
und Element E. So und das funzt
jetzt wahrscheinlich. Ja. Ach shit.
Was ist das? CannotBorrowMutable.
Make mutable. Ja. Sehr schön.
Fuck.
CannotBorrow
as mutable. Achso.
Weil dann noch. Das brauchen wir doch jetzt gar nicht mehr.
Oder? Ah. Nice. Funzt.
Sehr schön. Also.
Jetzt müssen wir die Registry selbst
nicht mutable machen. Können aber
trotzdem Sachen einfügen.
Boah. Meine Güte.
Der fliegt jetzt auf die Schnauze
wenn es von einem anderen gelockt ist.
Ich hab ehrlich gesagt keine Ahnung wie sich
wie sich das verhält.
Ob das einfach nur
hängt an der Stelle.
Oder ob
das. Oh.
Ne.
Locks
das LWLock with exclusive
write access. Blocking the current thread
until it can be acquired. Ne.
Ne. Ne. Ne. Hier. Blocking the current
thread until it can be
acquired. This function
will not return while other writers
or other readers currently have access to the
lock.
Okay. Das hängt einfach an der Stelle.
Das ist aber auch okay, dass das hängt.
Weil wir wollen ja
die einzige mutable reference haben,
dass wir was einfügen können.
Rast5head.
Ja. So. Also. Jetzt haben wir
unsere Add-Methode. Das war erstaunlich
einfach. Das war erstaunlich
erstaunlich einfach bis jetzt.
So.
Als nächstes brauchen wir
ein Get. Muss ich hier überhaupt
public davor schreiben?
Pub. Fn.
Get.
Und self.
Jetzt brauch ich ne ID.
Jetzt brauch ich ne ID.
Moment. Wait a minute.
Wait a minute. Ich hab doch die ID gar nicht.
Moment. Hier muss die
ToDo
generate ID.
Das funktioniert nicht so wie gedacht
gerade.
Wobei. Muss ich
jemals überhaupt einzelne Elemente
daraus getten? Ja klar.
Für die Connections.
Das heißt, mein Add muss
eigentlich die ID returnen,
dass das funktioniert.
Return ID.
So.
Jetzt weiß ich die ID.
So. Jetzt hab ich die ID.
Und jetzt kann ich wahrscheinlich sagen
self
store. Read.
Reicht jetzt. Unwrap.
Get.
Element oder sowas. Get.
Key value.
Was? Get.
Wat?
Get.
Und jetzt ID.
Das ganze dann returnen.
Return. Func. Wat?
Unwrap. Unwrap.
Was?
Found.
Wat?
Expected.
Found.
Achso.
Der Return Type fehlt.
Was hat er hier unten für Schmerzen?
Ah.
Moment.
Get muss eine Referenz sein.
Okay.
Und jetzt
kann ich auch eine Reference
returnen dazu.
Geht aber immer noch nicht.
Cannot return value reference.
Oh je, oh je. Was will er von mir?
Ne, was soll ich denn sonst machen
außer Unwrap?
Moment, Moment. Das kann ja nicht funktionieren.
Wobei, warum eigentlich
nicht?
Das ist eine Referenz.
Achso, ich weiß warum das nicht
funktionieren kann.
Das ist eine Referenz und ich könnte
ja jederzeit
den Inhalt löschen hier drin zum Beispiel.
Heißt im Endeffekt,
dann wäre die Referenz ungültig
und das mag Rust ja nicht.
Also, was muss ich jetzt machen?
Cannot return. Was schlägt mir
denn der Compiler vor?
Returns the value
referencing data owned by the
current function.
Okay, ich habe was gelernt. Ich glaube ich weiß,
wie wir das fixen können.
Ich glaube ich weiß, wie wir das fixen können.
Genauso wie wir es hier gefixt haben.
Ein Arc drum herum
wrappen. Also es ist jetzt
nicht
es ist jetzt nicht
Type T, sondern es ist Type
Arc
of T.
Und dann hier ist es Arc
new.
Ey, gibt das so Sinn?
Und jetzt, und jetzt
kriege ich den Arc
zurück
und den können wir klonen,
was den Referenz-Counter
erhöht.
Und dann sollte es
funktionieren?
Hey, es kommt
bald!
Five-Head-Time!
Es funktioniert!
Ob es genau das macht,
was ich haben will? Chat, hat irgendjemand
einen Plan, was der Unterschied ist zwischen
Box
und Arc? Also Arc ist
ein Reference-Counter, das weiß ich.
Genauso wie RC. Warum es unterschiedliche Sachen
gibt, habe ich auch noch nicht gecheckt.
Aber,
ich vermute mal, dass Box
ne, keine Ahnung.
Ich wollte gerade sagen, ich vermute, ne.
Würde das
auch so funktionieren mit Box?
Box of T?
Ja, Arc ist Atomic, aber was das in dem
Fall bedeuten soll? Keine Ahnung.
Okay, das funktioniert. Expected Box,
Found und Box.
Und Box.
Ne, das ist das gleiche Problem.
Ja, wir müssen das
mit Arc machen, weil Threat Safety.
Genau, so.
Wunderbar. Also wenn ich
das richtig verstehe, passiert jetzt Folgendes.
Der
speichert jetzt, also
der Arc, also das ist ein
Atomic Reference-Counter.
Der Arc
übernimmt Ownership of T.
Das ist so Rust-Logik für,
ja, gibt es eigentlich in anderen Sprachen oftmals
nichts direkt Vergleichbares.
Also,
T gehört dem Arc und Arc
selbst ist ein Reference-Counter und jedes Mal,
wenn ich den klone,
wird der Reference-Counter um 1
hochgezählt und erst wenn der Reference-Counter
bei 0 ist, wird
das freigegeben. Das heißt, jetzt
kann ich Save
das Returnen, weil dadurch, dass
es in einem Arc ist, immer sichergestellt
ist, solange ich noch irgendwo
ne gültige Referenz habe, bisschen wie der
Garbage-Collector in C-Sharp,
naja, ganz, ganz
light, ja.
Sobald ich
quasi noch irgendwie einen Reference-Counter habe,
dann
ist das quasi sicher
und kann nie out of scope gehen.
Oh man, die Musik ist vorbei.
Sack.
Gut.
So, jetzt können wir das Element
getten, auch schon mal nice.
RC cannot be shared
between threads. Ja, deswegen braucht
man wahrscheinlich Arc, dass
der Reference-Counter irgendwie
Atomic-mäßig erhöht wird
und damit thread-safe ist. Rate
ich jetzt einfach mal. So.
Soweit, so gut. Was hat er hier?
Registry is never constructed.
Die IDE ist auch schon ein bisschen pp-iger,
oder? Ja gut, die Funktion
wird nicht aufgerufen. Ja, okay. Okay, okay.
Lasst mir gefallen. So,
das brauchen wir als nächstes. Delete.
Delete brauchen wir als nächstes.
Fn.
Nennen wir einfach Dell.
U32, die ID.
Und jetzt, das dürfte relativ easy
sein. Das dürfte relativ easy
sein. Self. Moment, das kann ich doch eigentlich
so lassen. Self, so. Jetzt
wahrscheinlich write.
Ähm.
Wie löscht man? Wie löscht
man da was? Get, insert,
ether, clear. Ne.
Ich will sowas wie erase, delete
oder sowas. Remove.
Remove.
Remove entry.
Oh.
Was ist der Unterschied?
Removes the key from the map, returning the stored
key and value if the key was previously
in the map. Okay.
Und, und.
Remove is,
removes the key from the map, returning the
value at the key. Achso,
das eine returned key value und das andere
returned nur den value. Ich will überhaupt
nichts returnen.
Gibt es sowas wie drop oder so? Hey.
Moment, ist wieder was anderes.
Was zum Teufel macht drop?
Drop
ist so Nische, das hat auch nicht mal
irgendeinen Hilfetext.
Also, remove.
Einfach nur remove.
ID.
Und da muss auch gar nichts returned werden. Einfach
so. Easy.
Eats. Eats.
Easy as fuck.
Easy as fuck.
Moment, das funds wieder nicht. Warum?
Achso, und.
Mit was? Mit STRG Q kannst du...
Meinst du hier?
Nö.
Ich habe Visual Studio Key Mappings.
Keine Ahnung. Ich glaube, das war keine gute Idee.
Okay.
Ja, das war es doch im Großen und
Ganzen schon. Und jetzt,
jetzt eigentlich nur noch sowas wie
public
function.
Ja.
All oder so.
All.
Irgendwas in der Richtung.
All.
Und jetzt
quasi return self.
Ach Moment.
Self.
Store.
Ähm.
Read.
Vermutlich.
Unwrap.
Eater. Klingt gut.
Und das jetzt einfach
zurückgeben, oder? Das müsste doch sein.
Nee.
Ist es nicht. Warum nicht?
Oh Gott, Rust.
Warum ist das wieder kompliziert?
Returns a value
referencing data owned by the current
function.
Was ist das eigentlich für ein
ultra hässlicher Return Wert?
Eater.
Ähm. Single quotes.
Underscore.
What?
Kann man es nicht einfach löschen?
Äh, prägt nichts.
Okay, Rust.
Ich habe legit keine Ahnung,
wie das funktioniert.
Leute, ich habe
eine absolute Pipega-Idee, was
wir machen könnten.
Wir können sagen, unwrap.
Clone.
Und wir returnen eine neue Hash Map
jedes Mal, wenn wir all. Aber das kann es ja nicht
sein, oder?
Ich will einfach
nur außerhalb
eine Schleife machen können über alle
Elemente in der Registry.
Wie funktioniert das?
Ich will sagen können,
for.
Äh, Moment.
Äh, for.
Er.
All.
Äh, ja, blub.
Das will ich
sagen können. Das funzt jetzt
an der Stelle. Klar, weil ich eine neue Map
mache. Aber ich will
ja nicht wirklich
die Map einmal komplett klonen.
Bei jedem Aufruf.
Das ist ja nicht Sinn und Zweck der Sache.
Okay, stack overflow.
Rust. Return
iterator.
Oh. Returning
iterator. Was? Returning
Rust iterators. Depth
first. Returning an iterator.
Ja, genau.
Genau das will ich machen. Und das habe ich
auch gerade gemacht, aber das funzt nicht.
The compiler produces an error.
The type is contained within the error
messages. Ja, genau das
habe ich gerade gemacht.
Genau das
habe ich gerade gemacht.
Beifällige Webseite.
Aber.
Moment.
Ne, ne, ne.
Moment, das funzt. Ne, das funzt nicht.
Das ist nicht das, was ich haben will.
Oh man.
IDE, please.
Genau das habe ich gemacht,
aber das funzt nicht.
Gibt es da nicht
Intuiter? Ja, aber ich will ja nicht
Ownership zurückgeben.
Ich will ja nicht Ownership zurückgeben.
Sondern einfach nur
eine.
Ja.
Jede Menge. Die Referenzen
auf die Elemente in diesem
in dieser HashMap.
So, also. Das was
die Seite vorschlägt funzt nicht, weil
dann returns a value
referencing data
owned by the current function.
Und da bin ich mir nicht sicher, was
es mir sagen möchte, ehrlich gesagt.
Muss ich vielleicht das hier erst nochmal.
Moment. Muss ich sagen let m irgendwie so.
Und dann.
Ne, das funktioniert natürlich auch nicht.
Okay. Und wie geht das weiter?
Das habe ich probiert.
Laut der Seite geht das so.
Ist das irgendwie
so eine AI generierte Webseite?
Aber von 2020 eher nicht.
Irgendeine AI generierte Webseite.
Das ist gut.
How to implement iterator
over
wrapped vector in Rust.
Genau. Hier. Wrapped.
Und jetzt
will der, dass man das iteraten kann.
Genau das will ich. Genau sowas will ich haben.
Actual to call it
as you described. You don't need to
implement iterator.
For it, you just need to return
the iterator of the inner vec.
Ja, ich habe das schon gesehen,
den Link. Okay, six hat time.
Okay, probieren wir
das doch mal so aus.
Das sollte doch nicht allzu kompliziert
sein. So, self.
Jetzt brauchen wir erstmal hier den,
probieren, planten wir das mal aus hier.
So, zack.
M iter.
Funzt nicht,
weil
unelide
lifetimes.
What?
Ich weiß nicht mehr, was es will von mir.
Ich lass mal hier den.
Okay, und jetzt geht das?
Method not found.
Achso. Moment.
Nee. Returns a value
referencing data owned by the current function.
Okay, das funzt schon mal
nett.
So, das geht nicht. Also,
stackoverflow fail.
Nee, da fehlt kein return.
Wenn man das Semikolon
weglässt, wird die letzte
Zeile automatisch als return
verwendet. Ist auch
ein bisschen, weiß nicht, bisschen
pp-iger irgendwie, dass es dafür was extra
gibt. Aber das funktioniert
nicht. Also, stackoverflow
Antwort three hat.
Okay,
nächste Antwort. Accepted Antwort.
Accepted Antwort.
Vec itself does not implement
iterator. However, it implements into
iterator in three ways.
You probably wanted to implement
these for your wrapper as well.
Nee, into iterator will ich
schon mal nett.
Deref. Wie?
Deref to slice so that we can.
Ich. Was?
Was bin ich überhaupt sehend
hier gerade? Implementier
doch den iterator für arc iterator.
Oder bin ich gerade dumm?
Ja, wie denn?
Alter, was? Okay.
Implement iterator.
So, okay.
Also, so einfach wie stackoverflow das macht, geht das
schon mal nett. Also, implement
iterator for registry
of
t.
Ähm, was?
Okay, item type.
Type item gleich
u32.
Nee, mein item type ist t.
Und dementsprechend ist es auch einfach
option of t.
Und das da oben lass ich weg.
Und was? Ich check's nicht,
was der hier macht.
Was soll das?
Was soll das heißen?
Ach, man muss das?
Moment, man braucht das hier.
Okay, das ist erforderlich.
Hast du Tipps,
wie man am besten anfangen kann, zu programmieren?
Ja, der beste Tipp ist,
du hast irgendwie eine coole Idee, was
du schon immer mal machen wolltest,
und suchst dir die beste Technologie dafür raus
und fängst damit an. Weil dann hast du auch
immer Motivation, was zu machen,
weil das ja was ist, was du letztendlich
schon immer mal machen wolltest. Also, wenn du
sagst, ich würde gerne microcontroller
programmieren, eine eigene Webseite machen,
meinen Rollladen hoch- und runterfahren
automatisch, das ist natürlich am besten,
wenn du so ein Ziel schon im Kopf hast.
Das ist motivierend. Wenn du gar keine Ahnung
hast, wie du anfangen sollst und einfach
nur gucken willst, ob das was für dich
ist, kann ich dir nur empfehlen,
lad dir Visual Studio Code runter
und fang mit JavaScript an.
JavaScript, bisschen HTML, CSS
hat die mit Abstand
niedrigste Einstiegshürde. Du brauchst
einen ordentlichen Texteditor, wie gesagt,
nimm Visual Studio Code, ist alles out of the box
für JavaScript dabei.
Und du brauchst einen Browser, und einen Browser hast du,
sonst wärst du hier nicht im Twitch-Chat.
Und dann legst du los.
Ich check nicht, was ich machen muss, Chat.
Was will das hier von mir?
Here we define a sequence using
current und next.
Fn next. Okay,
option will ich doch gar nicht, oder?
Ich will einfach
t return.
Nee, das geht nicht. Es muss
eine Option sein.
Moment, kann ich nicht...
Was will...
Current next?
Self current? What?
Kann ich nicht das einfach
re-usen?
Store? Kann ich das nicht
einfach re-usen von...
Read? Kann ich das
nicht einfach re-usen?
Von dem anderen?
Und so?
De-referencen?
Wobei, das braucht man eigentlich nicht.
Dass ich jetzt sagen kann, irgendwie, return
m next.
Ja, das kann man doch
einfach reppen, oder?
Return n.
Wobei, nee. Moment.
Was muss man returnen?
Hier return was?
Option of
u 32
t.
Oh man, was ist denn jetzt?
Method next has an incomparable
expected time
found.
Ach so. Moment.
Ähm.
Was muss ich sagen? Wie haben die gesagt?
Self? Item?
Item? Nee.
Wie haben die das hier gemacht?
Oh man, shit. Das ist ja super
komplizierter shit wieder.
Self. Self cross.
Okay.
Item. Und item ist quasi
u 32
t.
Okay. Ist nicht,
weil... Ach so.
Weil es und
es ist und u 32
aus irgendwelchen Gründen
und a t.
Alter, what the fuck, man.
Found was?
Okay, u 32.
What the hell?
Alter, Rust, man.
Ich will einfach ne Schleife drüber machen.
Was will das denn von mir?
Was will das von mir, man?
Oh, fucking shit.
Ich mein, okay.
Würde das dann prinzipiell überhaupt
funktionieren? Würde das...
Nee, all ist auskommentiert.
Meine Güte.
Okay, also.
Was will das von mir?
Und. Okay. Und und
ist nicht erlaubt. Warum ist und
nicht erlaubt? Weil missing
lifetime specifier.
Okay, Rust, hilf mir.
Rust, please.
Was? Und not
a.
MonkaW.
Oh. So.
Okay. Okay.
Ich habe absolut keine Ahnung, was ich
da gerade mache.
Okay. Okay. Moment. Moment, Leute.
Nee, was ist jetzt?
Leute.
Mann, das kann doch nicht so schwierig
sein.
Ich habe absolut keine Ahnung, was Rust von mir will, man.
Nehme mal oben das
a raus. Habe ich. Aber
das geht nicht.
Dann will er
nicht, weil lifetime
specifier missing.
So. Und jetzt sagt
er mir hier.
Alles klar. Jetzt sofort.
Muss man vielleicht so machen? Hier so?
Nee.
Ich habe keine Ahnung, man.
Alter, Rust. Die Sprache fuckt
jedenfalls hier so krass ab, ey.
Also, ich habe wirklich, ich habe absolut keine Ahnung,
was das Ding von mir will, man.
Du musst es auch embracen.
Naja.
Massive embracing am Start.
Okay. Keine Ahnung. Wir gucken mal.
Wir gucken mal weiter.
Also, das funzt ja schon mal nett.
Wie das hier.
Was haben wir hier sonst noch so zur Auswahl?
Imple deref for binary.
Okay, dann probieren wir. Okay. Wenn das mit dem iterator
nicht funktioniert, dann probieren wir einfach was anderes.
For registry
t.
Probier mal. Moment, was?
Moment. Wo soll ich das
probieren? Wir kommentieren das mal aus,
weil vielleicht brauchen wir das gleich nochmal.
Probier mal self next
map.
What?
Was? Zeile 26.
Fiver time. Das ist ja nicht self.
Das ist ja nur m. C++
Level types, würde ich sagen.
So.
Das wird jetzt auskommentiert. Okay.
Next. Also, probieren wir das mit dem
deref.
Implement deref for. Okay.
t.
Registry.
t.
Output.
Moment.
Das sind die Elemente.
Das sind die Elemente.
Also, mein Element ist
Output ist dann
ein
32 Vector of t.
Self.
Self.
Warum hat er hier noch ein und davor?
Warum ist hier nochmal ein und
davor?
Ich check's nicht. Okay.
Self.
Store. Achso, ja.
Moment. Hä?
Deref ist gar nicht
importiert. Okay. Nice.
Das gibt's überhaupt nicht.
Output is not
member.
Implement members. Ja, ganz toll.
Target. Heißt das jetzt
Target? Wurde das umbenannt oder wie?
Moment. Was macht
deref eigentlich?
Deref. Rust.
Was zum...
Alter. Ich will einfach nur
ne Schleife da drüber machen
können, man.
Ist das so kompliziert in fucking Rust
ne Schleife zu machen?
Type targets.
Target self.
Okay. Okay.
Type t.
Type t. Okay.
Type t. Sehr gut. Sehr gut. Exzellent.
Deref.
Self target.
Aus welchen Gründen auch immer.
Reference.
Und jetzt self store.
Was ich programmiere?
Eine Schleife in Rust.
Für nen eigenen Typ. Aber
aus irgendwelchen Gründen mag
Rust das nicht wirklich.
Also.
Und jetzt?
Store unwrap.
Self store get.
Hä? Sekunde.
Bin verwirrt.
Self store read.
Ach read. Read.
Unwrap.
Das wird so nicht funktionieren.
Expected but found it.
Mann.
Wofür machst du das überhaupt?
Lass die wrapper Funktion weg.
Ich will ne Schleife machen da drüber.
Mann. Und das geht ja nicht.
Irgendwie hier
muss der Kram ja da drankommen.
Am liebsten
hätte ich
ne Funktion, die irgendwie all oder so
heißt. Deref hat nix
mit ner Schleife zu tun. Laut Stack Overflow
schon. Hier will auch ein Typ ne Schleife
machen. Und das
legt vor, dass man das entweder so macht
so macht oder so macht.
Moment.
Der Typ
transferiert. Ne der Typ
der Typ ähm. Warte
mal. Was hatten wir da vor?
Moment. Wie hatten wir das gerade
nochmal hier unten?
Iterator next. Ne.
Hab ich doch. Das ist doch das allererste
was ich gemacht hab hier unten. Das funktioniert
nicht.
Das funktioniert nicht.
Das allererste was ich probiert hab. Das
klappt nicht. Ich mein kann ich nicht
kann ich nicht einfach sowas hier machen?
Wir klauen
das jetzt einfach von hier.
Da sagt er bestimmt, dass es nicht matcht oder?
Er ist ein incompatibel
Typ. Was ist das da
vorne überhaupt? Kann das mal weg?
Er ist inkompatibel. Okay.
Moment. T. Moment. Moment.
Moment. Moment. Moment. Target T ergibt ja
auch überhaupt keinen Sinn.
Target ist
was? Target? Ne Output.
Was? Das stimmt doch nicht nochmal
überhaupt hier. Target ist
was? Target ist das
was man zurück gibt oder?
Also im Prinzip
ein
Was haben wir denn hier bei?
Bei Keys? What the fuck man?
Was beim ersten Ansatz
mit der Hashmap. Du meinst das da unten?
Was den
Iterator muss ich klonen? Man kann den
klonen? Okay. Nice.
I? Ne.
Ne. Ne. Ne.
Nope.
Du musst die Referenz zur Hashmap klonen.
Die was bitte? Die Referenz?
Was soll ich
klonen?
M.Clone
Ja Moment. Dann klone ich die Hashmap.
Das will ich doch nicht.
Ich will doch nicht die Hash...
Das ist doch das allererste was ich gemacht hab.
Das ist doch das allererste was ich gemacht hab.
Dass das geht ist klar aber dann
erstellt er doch eine neue Hashmap.
Das ist doch komplett für den Arsch.
Der soll keine neue Hashmap erstellen.
Das ist doch das allererste was ich gemacht hab.
Das hat auch funktioniert.
Aber das ist doch bescheuert.
Ich will doch nicht eine komplett neue Hashmap
anlegen wenn ich einfach nur die Elemente
durchlaufen will von einer schon bestehenden Hashmap.
Warum soll ich das machen?
Das funktioniert.
Das habe ich schon ausprobiert. Das funktioniert.
Guck das geht.
Das ist das allererste was ich gemacht hab.
Ich will ne Schleife
machen man.
Ne Schleife. Eine stinknormale
Schleife über nen Customtyp.
Und ich hab keine Ahnung wie man das in Rust
gescheit macht. Also das ist schon mal
nix. Ja genau.
Ich will ne Schleife machen. Guck ich will
vor...
Keine Ahnung. Vor Blub in...
Alter.
Das will ich machen können. Okay?
So und das geht nicht.
Weil it's not a iterator.
Okay alles klar.
Iterator implementieren.
Habe ich absolut keine Ahnung gehabt.
Was der von mir will.
Und was sie hier auch immer mit deref
wollen. Ich habe auch keine Ahnung.
Okay wir machen jetzt einfach mal.
Wir suchen jetzt. Rust deref
Vector
wrapped
Was hast du lieber?
C++ oder Rust?
Auf keinen Fall C++.
Aber Rust in dem Fall jetzt gerade auch nicht.
How to create a new
instance of wrapped vector in Rust.
Oh was ist das?
5 hat time.
After the creation of such an object you can use
the object somewhat transparently by
implementing deref.
Moment hier ist target.
Wait a minute.
Hier ist target
nicht T.
Sondern. Moment.
Return self store.
Ne und.
Und self store.
Moin Kirolo.
Was für ein Typ ist das jetzt?
Kann er nicht mal den Typ davon ordentlich ableiten?
Oder was?
Das ist ein hier.
RwLogHashMap irgendwas.
Aber und. Und okay.
Jaja.
So.
Shit. Fast. Fast.
Äh.
RwLogHashMap.
Ah ne.
Und self.
Kann ich nicht einfach so das
ganze Ding returnen?
Ne das geht nicht.
Über den internen.
Über meine interne HashMap.
Ich hab eine interne HashMap
gerappt quasi in einem eigenen
Struct und ich will über meinen Struct iteraten.
So. Angeblich stimmt das so.
Ne natürlich.
Was?
Ey super.
Jetzt kompiliert er so eine Fehler aber.
Gehen. Gehen tut es trotzdem
nicht.
Und die Funktion gibt es hier nicht.
Okay und was war jetzt der Sinn davon?
Gibt es wenigstens D-Ref? Ah D-Ref gibt es okay.
Wait a minute.
Was? Ich weiß nicht ob ich D-Ref brauche.
Das hat irgendjemand aus Sega overflow
vorgeschlagen.
Und jetzt? Ey Leute ich hab keine Ahnung
was das für ein Scheiß.
Übrigens Rotzsprache alter.
Was? Read?
Und was will
er hier von mir? Read?
Log Result?
Achso.
Moment.
Moment. Weil ich.
Wait a minute.
Weil ich ja das
returne mit dem Log.
Sag bloß wenn das ja. Wait a minute.
Ich wollte mir jetzt erzählen. Das funktioniert oder was?
Haha.
What the fuck?
Ich hab. Alter.
Was bin ich sehend
überhaupt man?
Das geht auf jeden Fall besser.
Ich hab keine Ahnung was das überhaupt.
Was mir das überhaupt sagen soll.
What the fuck?
What?
Was ist der Hashmap iter?
Naja, ein Iterator über die Typ in der Hashmap.
Also der Typ ist das hier.
Guck das da.
Ich hab keine Ahnung was ich hier gemacht
habe, warum es kompiliert und was ich
jetzt. Was das überhaupt tut unter der Haube.
Okay.
What the fuck?
Ich versteh es auch nicht.
Macht dir nichts draus.
Was musst du? Okay. Chatgear
ist pfeifert. Ich glaube im Next von dem
Iterator implementierst du nur
arg s ref.
Okay. Done. Wenn ich das nur
nur das machen muss. Easy.
Es holt
den rwLog, umwrapped den readAxis
iteriert. Ja, ja, ja.
Im Prinzip habe ich damit die Hash
Im Prinzip könnte ich auch
so
Das ist nichts anderes wie
direkt auf die
Struct Variable zugreifen im Endeffekt.
Also eigentlich komplett unsinnig.
Okay.
Implement Iterator for Registry.
So, was muss ich?
Arg s ref.
Was? Wo?
Wie? Wo muss ich
hier was machen?
Arg s ref. HashMap fällt
vom Struct. Okay. Arg s.
Alles klar. Easy. Easy.
Arg s ref
self
store
ähm
read
unwrap
Mäh.
Das funktioniert
nicht. Chat, ich bin froh, dass ihr auch
nicht schlauer seid wie ich, was das angeht.
Also hier weiß ich auch noch nicht mal,
was die Referenz überhaupt ist.
Es ist
b auf unknown.
Alles klar, ja.
Ich meine, es kann doch
nicht so schwer sein.
Das hier ist die HashMap
doch.
Ah ne, das ist das VamaletMap.
Gleich.
Ah ne, das ist die rwLogGuard.
Ähm.
Das da ist die HashMap.
Zumindest eine Referenz
auf die HashMap.
Aber das checkt er trotzdem nicht.
Mismatch.
ExpectedArg.
Was? Was? Was?
Was expected er?
Expected und? Ne, ne, ne.
Okay, so funktioniert das schon mal nicht.
Chat, ne, ne, ne.
So klappt das nicht.
Ich hab
wirklich keine Ahnung, wie es funktioniert.
Echt nicht. Kein Schimmer.
Okay, wir suchen nochmal
stackr. Rust iterator.
Implement
iterator Rust.
Iterators.
Rust by example.
Ja, das, Moment. Das Exampel habe ich ja schon
wrapped
HashMap. So.
Okay, genau das. Hier.
Der hat eine HashMap in einem struct.
Und jetzt will er für sein
struct.
Jetzt will er für sein struct
äh, response.
Ah, response headers.
Will er das? Okay.
Genau das. Im Prinzip genau
das, was
was ich auch machen will.
You are doing
right. Was?
What you are doing right now is delegating to
the into iterator implement.
But you need to delegate to the
into iterator implementation
of on HashMap
string. Because
you can't get
an own version. Ja, ja, ja.
This is easy to fix.
Thankfully. Leute.
Easy.
Es ist easy to fix.
Alles klar.
Easy to fix.
Dann machen wir das doch mal. Easy to fix.
Let's go. Easy.
And for
ähm
Wait a minute.
For registry
of T.
Okay.
Was ist das eigentlich
für hässliche Sachen wieder?
Irgendwelche Lifetime Sachen. Okay.
ItemType.
Ach, hier oben.
HeaderMap.
ItemType ist
Hash. Okay. Ich kopiere das mal.
U32 of T.
Ja, gut. Das ähm.
Das funktioniert so nicht.
Not member of. Okay.
Kann man das vielleicht
hier irgendwie reinpappen? Nein.
Kann man das irgendwie
äh hier reinpappen?
Nein.
Okay. Es ist ja auch wurscht.
Wir können das copy-pasten.
Was ich da mache, das frage ich mich auch.
HeaderMap.
Okay. Okay. Das ist okay. Alles klar.
Okay.
Ja. Nice. Nice. Nice.
Okay. Ja.
Und self.
Okay.
Self. Store.
Read.
Unwrap.
Ey, das wäre jetzt zu einfach, wenn es funktioniert.
Ist das hier überhaupt die Map?
Map gleich.
Ey, wir brauchen
wieder hier.
Und jetzt. Moment. Jetzt brauche ich doch eigentlich.
Das wäre jetzt viel zu einfach, wenn
das funktioniert.
ItemMismatch.
Ne, ne.
Der Store ist nicht die HashMap.
Der Store ist ein RwLog.
Was?
Ah.
Siehste?
Hab's ja auch verkehrt gemacht.
Äh.
Aber. Aber.
Warum geht das jetzt nicht?
Wieder genau der gleiche
Scheiß wie vorher, Mann.
Was will er hier jetzt?
TemporaryValueCreated
Ja und?
Was will er?
Das kann doch nicht so schwer sein.
Meine Fresse, Alter.
Ich will eine Schleife machen.
Ich meine.
Ich bin ja froh, dass das easy to fix ist.
Glücklicherweise
ist es easy to fix.
Ich weiß nicht, was das von mir
will, Mann.
Es ist ja noch nicht mal AsyncRust.
Und?
Echt. Ich hab. Ich hab. Seriously.
Ich hab keinen blassen Schimmer.
SetCursorOfHashMap.
I'm trying a simple thread.
SaveMemoryKeyValue.
My code looks like this.
Jeder macht.
Obviously. Simple. Implement.
Cursor.
Okay. Ist vielleicht.
Ich will die Werte nicht klonen, Mann.
Ich check die Antwort noch nicht mal.
Die Antwort ist mir
schon zu sick.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
Okay.
I'm trying a simple thread.
Eventually.
Es gibt übrigens viele Autos.
Welcher Datentyp wäre deiner Meinung nach besser geeignet an der Stelle als RWLOG von den vielen Threadsafe-Datentypen?
So, jetzt können wir hier sagen...
Jetzt funzt es. Ja, das ist klar, aber jetzt kopiert er das auch.
Das fuckt mich ultra ab, man.
Ich will wissen, wie das funktioniert.
Wir machen jetzt aber damit nicht weiter, sonst dreh ich echt am Rad.
Okay, Moment mal.
Chat, Chat, das ist genau das, was ich machen will.
A, B, D...
What?
What the f...
Ich verstehe noch nicht mal, was er fragte.
You can't solve this with naming your lifetimes, as this isn't really a lifetime problem, but a problem with ownership.
You can provide access to the HashMap and make the call values.
Ja, sowas in der Richtung habe ich ja auch schon gebaut.
Ich meine, das soll mir auch recht sein.
Trivial, trivial.
Because God-like FN-Trades don't exist.
Jetzt weiß ich, Leute, jetzt weiß ich, warum es nicht funktioniert, man.
Because God-like FN-Trades don't exist.
Hätte es mal gleich einer gesagt, Mensch.
Ich hoffe, euch ist jetzt auch alles klar.
Jetzt, obviously, jetzt ist alles logisch.
Ja, easy.
So, ich war mal...
Es leuchtet ein, ne? Es leuchtet komplett ein.
Achso, Moment. Item ist die HashMap.
Alter.
Guck mal, hier, Rust weiß noch nicht, was will ich? Map, Map.
It's not an iterator. Ja, ach, okay. Nice.
Sehr gut, sehr gut. Excellent. Jetzt weiß ich Bescheid, ja, man.
Cannot find. Moment, das gibt es überhaupt nicht?
Das gibt es einfach überhaupt nicht, was die hier vorschlagen.
Alter, was ist das für ein pp-iger Post, man?
LW-LogGuard gibt es über... Ach, Moment, das ist von ParkingLot.
Was auch immer ParkingLot ist.
Das ist die ParkingLot-LW-Guard, Mensch.
Ja, dann ist klar.
Ich glaube, ich weiß, wo...
Alles klar, scheiß drauf.
Jetzt nicht, jetzt nicht, Leute.
Jetzt nicht. Wir lassen es jetzt.
Da drehe ich ab bei...
Also, ich bin erstaunt,
dass das so krass kompliziert ist.
Okay, Rust Playground.
Ich mache jetzt nicht weiter.
Reicht dir das? Ja, Moment, Moment. Mal gucken.
Moment. Excellent, excellent. ChatGym macht mit.
Ich bin froh. Chat ist schlau.
Wo ist der Unterschied zu mir? Ah, hier.
Okay, was macht das jetzt?
Anders als meins?
Zwei, okay.
Store. Unwrap.
Okay, wirklich schön ist...
Da muss ich zumindest nicht klonen.
Das finde ich eigentlich ganz gut.
Da muss ich zumindest nicht klonen.
Und es funktioniert, oder?
Das ist gut. Das reicht mir.
Also, ich würde sagen, das reicht mir.
Das ist im Prinzip einfach noch mal gerappt.
Das ist die bisschen schönere Variante
wie von meinem geklonten.
Wofür ist denn hier vorne das Ding?
Kann man das wegmachen?
Anscheinend, okay. Ich weiß nicht, wofür das da ist.
Wofür ist das Ding? Eine Lifetime.
Aber Lifetime für was?
Lifetime, die ich sonst nirgendswo benutze, oder?
Lassen wir einfach mal weg.
Ja, das finde ich gut.
Alter, was ein Akt, Mann.
MonkaS.
MonkaS, Mann.
Okay, können wir jetzt eigentlich... Moment, Moment.
Ja, wir machen weiter, aber jetzt kommt ja noch was anderes,
was das Ding können soll.
Und zwar, es soll ja noch IDs berechnen können.
Wie könnten wir das mit der ID-Berechnung machen, Chat?
Habt ihr irgendeine klare Idee?
Also, wir könnten einfach random was generieren.
Das wäre eigentlich schön.
Ich meine, die Chance, dass was doppelt generiert wird,
bei meiner kleinen Anzahl.
UID ist raus, weil ich UID nur etwas komplizierter
hin- und herschieben kann über ein C-Interface.
Aber wir könnten...
Ich habe eine Idee, Leute.
Ich habe eine Idee, was wir machen können.
Was ist mit random oder einem Hash?
Ich hätte gerne lieber irgendeinen simplen Counter.
Okay, ich habe nämlich eine Idee,
wie wir das ganz einfach machen können.
Ich meine, unsere Keys sind U32.
Also, wir haben 4 Trillionen, was auch immer, Milliarden, sonst was.
Möglicher...
Ich weiß nicht, was U32 Max ist. Irgendwas mit einer 4 vorne.
Ah, das läuft.
Mögliche, mögliche IDs.
Wir machen mal so eine Funktion.
Wobei, brauchen wir nicht mal für.
Also, den Store.
Er ist hier.
Also, die ID.
Wir generieren die ID folgendermaßen.
Und zwar, wir checken einfach...
Ich habe eine Idee.
Ich muss mir nur kurz Gedanken drüber machen.
Wir machen eine Schleife.
Und wir lassen eine Schleife laufen.
Von 0 bis U32 Max.
Und die erste freie ID,
die noch nicht vergeben ist, nehmen wir.
Das müsste doch eigentlich gut funktionieren.
Nee? Warum nicht?
Warum ist das kacke?
Dann kannst du auch random nehmen.
Das bedeutet immer, dass ich eine Unique ID finde.
Bei random habe ich im Zweifelsfall...
Bei einem 32-Bit-Random habe ich im Zweifelsfall doppelte Werte.
Die Chancen sind gering.
Aber sie sind da.
Und mit einem Counter nicht.
Also, bei einem 32-Bit...
Das ist nicht impossible.
Bei einem 32-Bit-Int...
Hast du... Moment.
U32 Max.
Was ist denn das?
Das ist gar nicht mal so viel.
Das sind nur 4 Milliarden.
Wir haben nur 4 Milliarden...
mögliche...
IDs.
4 Milliarden bei 5 gleichzeitigen Connections...
ist die Chance auch sehr gering.
Aber nur mal von der Idee her...
Die Chancen sind gar nicht so klein.
Wir haben 5 Milliarden zufällige IDs.
Und ab der Hälfte...
Ab 2 Milliarden IDs...
ist die Chance über 50%...
dass die nächste generierte Random ID schon mal vorhanden ist.
Es sind einfach...
Es sind einfach in einem U32 zu wenig Platz.
Unix-Timestamp ist selbst in Millisekunden...
nicht unbedingt so sinnvoll an der Stelle.
Komm, wir machen mal das, was ich gesagt habe.
Also, wir machen eine Schleife.
Wir machen eine Schleife von...
Kann man nicht einfach zählen hier mit einer Schleife?
4i...
4i in...
U32 Max...
So, und jetzt...
Wir müssen das hier mal kurz unwrappen.
Hier oben schon.
If Map...
Da gibt es doch immer so Contains...
Contains Key i...
If Not Contains Key i...
Dann...
Das ist alles, was wir machen müssen.
Schon kriegen wir die erste freie ID.
Nee, das ist doch eigentlich gar nicht schlecht.
Weil das Schöne ist, die Verbindung...
Das ist ja nicht nur Add, Append Only.
Es können ja auch Sachen gelöscht werden.
Mal angenommen, der erzeugt 5 Verbindungen.
Irgendwann macht einer den Browser zu...
und die ersten 5 Verbindungen werden gelöscht.
0-5 wieder frei.
Und wenn das nächste Mal die Schleife läuft,
vergibt er IDs 0-5 neu.
Das dürfte immer ziemlich schnell laufen.
Übrigens Return i ist an der Stelle für Pegatime.
Leute, wie würde man das jetzt Rust...
Ich habe eine Idee.
Wir machen jetzt Rust Idiomatic Way das Ganze.
Match.
Ich habe keine Ahnung.
Ähm...
Da müssen wir...
Connectest du vielleicht dann so mit dem Sam...
Ähm...
Nee, weil einmal geschlossene Connections...
können glaube ich nicht mal neu aufgebaut werden.
Moin, für die nicht Programmierer unter uns sind.
Was wird programmiert?
Ein Rust WebRTC Backend.
Mit dem du alle deine Webcams im Browser...
in Echtzeit rein streamen kannst.
Also, wenn es denn dann funktioniert.
So, also.
Und wir lernen Rust dabei.
Also, guck mal.
Kann man hier so eine Art Range draus machen?
Range Rust.
So was hier.
Plammern.
Und jetzt sagen wir Eater.
Moment, das gibt es nicht.
Into Eater, soll mir auch recht sein.
Select.
Filter.
Nee, Filter will ich nicht.
Rust.
Position.
Find.
Find.
Find.
Find takes the...
Okay.
Find is short-circuiting.
In other words, it will stop processing as soon as the closure returns true.
Ja, das ist das, was ich haben will.
Closure in Rust.
Das ist so, glaube ich. Wie in Ruby ist das.
Ja.
Oder sagen wir mal ID.
Und jetzt so?
Okay, jetzt weiß ich nicht weiter.
Wahrscheinlich einfach Klammer auf, Klammer zu.
Moment.
Oder kann man vielleicht sogar...
Map contains key.
ID.
Oder not.
Ah.
Moment, da ist jetzt ein Match drauf.
Dass wir eine Fehlermeldung schmeißen, wenn er keine freien IDs findet.
Wie fundst du das jetzt?
Match. Jawohl, die Idee hat mal was gebracht.
Okay, wenn er keine freien gefunden hat,
dann würde ich sagen, paniken wir.
Panik.
No free ID found.
Und wenn er was gefunden hat,
dann soll er die ID returnen.
Macht das so Sinn?
Du kannst auch expect machen.
Mit Panik killst du den Prozess.
Ja, das ist gut so.
Auf der anderen Seite, ihr habt recht,
das macht überhaupt keinen Sinn mit Match,
sondern wir sagen einfach let ID,
expect und dann machen wir eine custom Fehlermeldung.
No free ID found.
Zack, easy.
Das finde ich schick.
Kompiliert auch noch.
Und jetzt haben wir jedes Mal eine frische ID.
Sehr gut, nice.
Jetzt können wir doch gleich mal testen, ob das funktioniert, was wir gebaut haben.
Ich glaube, mehr brauchen wir in dieser Custom-Klasse nicht.
So, dann lass uns doch mal gucken,
ob sich die Aufregung heute gelohnt hat.
Gehen wir mal in unsere Lib.
So, RP State.
Da gibt es jetzt ein Feld für Connections.
Ich habe jetzt schon öfters gesehen,
dass die Leute gerne in Rust die Sachen abkürzen.
Wie würdet ihr das schreiben an der Stelle?
Würdet ihr die Variable Connections nennen?
Mojo, Jojo, danke schön für den Sub.
Würdet ihr die Variable an der Stelle Connections nennen?
Con?
Cons?
C?
Oder WConnections?
Poggen.
Verbindungen, ja, genau.
Prime Sub für die Krustentiere.
Sehr schön, Pogu.
Von Aqua, danke schön für den Sub.
Und für die feinfette Unterstützung vorhin.
Okay, Connections, also.
Registry of T.
Kann das sein, dass ich schon mal Registry irgendwie habe hier?
Registry.
Das habe ich schon mal importiert.
Was ist das?
Shit.
Registry of.
So, was brauchen wir jetzt?
Testweise Connections, haben wir gesagt.
Track local static sample.
Wo ist das Problem jetzt?
Ah.
Exzellent.
Wie will ich importieren?
Moin.
Pogu.
Der Name kommt mir zumindest bekannt vor.
Ich weiß nicht genau, woher.
Aber der Name kommt mir bekannt vor.
Also hier aus dem Chat auf jeden Fall.
Connections, Registry, Track local static sample.
Das müsste doch immer noch kompilieren, oder?
Nein, natürlich nicht.
Ist okay, ist okay.
Registry new.
Alles klar, es kompiliert.
Top.
Dann können wir das auch jetzt mal ausprobieren.
Connections, dann schmeißen wir das hier mal weg.
Check mal, ob die Funktionen alle public sind.
Aber sonst alle.
So.
Und jetzt, wo verwenden wir denn jetzt Connections?
Ich lösche das hier einfach mal.
Connections, klar.
Also im Prinzip brauchen wir jetzt bloß noch self.
App state, get.
Unwrap Connections.
Cannot move.
Achso, muss ich wieder und davor machen.
Okay, Registry.
Pair Connections.
Connections, get.
Moment, erstmal da unten das Ganze fixen.
App state, get.
Unwrap Connections.
Und wieder und.
So, insert. Insert gibt es nicht.
Es gibt add.
Und es wird einfach nur die Pair Connections hinzugefügt.
Achso.
Ja, wenn man es mal richtig macht, dann wird es auch funktionieren.
Das hier unten brauche ich gar nicht mehr.
Weil es schon initialisiert ist.
Ja.
Bleibt im Endeffekt nur noch das hier.
Pair Connections, get ID.
Das hier bleibt jetzt noch zu fixen.
So, und wir getten jetzt.
Okay, das ist ein U32, muss es nur noch sein.
Wir sind mal hart drauf und casten mal schnell das U64 runter zu einem U32.
Und get ist bei mir ein U32.
Moment, kann man in Rust irgendwie casten, dass ich sage U32, ID?
Äh, okay.
Das ist unsafe.
Ach nee, SU32.
Unwrap.
Jetzt brauchen wir gar nichts unwrappen.
Doch, ist doch gut. Passt doch alles.
Okay, ich glaube das war es schon.
Das ist übrigens blöd. Wir machen das mal richtig.
Das ist ein U32 hier.
Und das ist ein U32 hier.
Und das ist ein U32 hier.
U64.
Das ist ein U32 hier. Wir machen das mal richtig.
Sonst habe ich nachher irgendwelche merkwürdigen random Bugs.
Und in .NET ist das auch ein UINT32.
Okay, so.
So, und jetzt können wir mal sehen, ob der Bug gefixt ist.
Das nur einmalig funktioniert.
Das sollte jetzt mehrmalig mit reloaden funktionieren.
Starten. Okay.
Shit. Irgendwo habe ich was verkehrt gemacht.
Okay. 44. Zeile 44.
Okay, let's go. Zeile 44.
Hast du die Lib kopiert?
Ja. Zeile 44.
Die ID gibt es nicht.
Okay, die ID gibt es nicht. Warum gibt es die ID nicht?
Weil ich irgendwo Mist mache hier.
ID gleich.
Okay, ID.
Ach hier, ID gleich 1.
ID gleich.
Und jetzt gibt es die ID auch.
Wenn da immer 1 drin steht.
Nee, Option Return. Das ist gut, dass das gecrashed ist.
Der konnte schlicht und ergreifend nicht weitermachen.
Ich finde das gut. Da weiß man nichts, was kaputt ist.
So, nochmal.
Es geht.
Der Browser war einfach nur PP gerade.
Kann das sein, dass mein Javascript ein bisschen weird champ ist?
Ich glaube, mein Javascript war ein bisschen weird champ gerade.
Aber es funktioniert. Der Bug ist behoben.
WebRTC funktioniert.
Und er funktioniert mehrfach.
Auch wenn man refresht.
Aber wenn man zu schnell refresht, dann...
Moment, wenn er irgendwas reused, dann funktioniert es nicht.
Okay, das müssen wir so nochmal überprüfen.
Der baut aber gar nicht die Verbindung auf.
Nun ja.
Der versucht irgendwas zu reusen, was er nicht reusen soll.
Da stimmt irgendwas doch nicht ganz in der Logik, würde ich sagen.
Wir geben nochmal kurz aus.
Die Connection ID.
Weil das sollte immer eine neue ID sein.
Es sollte immer...
Log...
Es sollte immer eine neue ID sein.
35, 36, 37...
Es ist auch immer eine neue.
38, 39...
Ja, der Browser denkt nur, er kann die Sache cachen aus irgendwelchen Gründen.
Und das funktioniert nicht.
Manchmal cacht das und manchmal nicht.
Keine Ahnung, was mein Browser da für PP-Ger-Sachen macht.
Aber ich bin mir relativ sicher,
weil es auch immer neu ist, dass das nicht an meinem Backend liegt.
Weil, weil,
wenn ich ohne Cache refreshe,
guckt, wenn ich ohne Cache refreshe,
dann funzt es immer.
Bis es nicht funktioniert.
Kommt das nicht irgendwie in die Quere?
Das sieht ein bisschen nach Threat-Problemen aus, oder?
Aber ihr seht, es ist immer eine neue Connection.
Und daran kann es ja eigentlich nicht liegen.
Und nachdem ich immer alles schön unwrappe und hier nichts abkackt,
ich schiebe das wirklich aktuell auf meinen Browser.
Dass der da nicht so genau...
weiß, was er macht.
Ich schiebe es auch auf JavaScript.
Versuch mal Firefox.
About WebRTC.
True, lol, weh.
Failed.
Aber ihr seht, er bekommt die Offer hier.
Hat er Probleme mit dem Multiplexen beim Port oder so?
Wir machen noch mal ganz kurz den Debug rein.
ATMX.
Das ändert daran doch jetzt auch nichts.
Wir haben in Rust nirgendwo Error-Handling.
Also an Rust wird es in dem Fall echt nicht liegen.
Irgendwie liegt es glaube ich an PPGaJava-Skript.
Das ist meine Vermutung.
Das ist übrigens auch, da waren sie lustig bei Firefox.
Das steht in jeder dieser Meldungen drin.
Das ist SDP.
Weil das halt das Session-Description-Protokoll ist.
War einer lustig, hat geschrieben.
Also wenn ihr das mal seht, da war ein Mozilla-Mitarbeiter.
Wollte witzig sein.
Also das hat funktioniert offensichtlich.
Das hätte hier ja nichts geantwortet.
Wir machen noch mal hier.
Keckl.
Rintel.
Jetzt können wir mal gucken.
Also das sieht nicht so aus, als liegt das...
Hä?
Ich glaube eher, das liegt an meinem Java-Skript-Zeug.
Okay, zweites ist kaputt gegangen.
Bei mir ist alles durchgegangen.
Also ich vermute, das liegt...
Es ist auch immer eine neue ID am Start.
ID2.
Wir können mal gucken, ob es in neuen Tabs irgendwann auftritt.
Wenn es nämlich nicht in neuen Tabs auftritt, dann liegt das...
Okay, es tritt auch in neuen Tabs auf.
Dann ist tatsächlich irgendwas kaputt.
Aber das werden wir nicht jetzt fixen.
Ist der Browser nicht lang genug?
Nee, das glaube ich nicht so schnell, wie das immer geht.
Aber auf jeden Fall, wenn es jeden zehntes Mal loaden oder so nicht funktioniert,
dann ist schon pipega.
Clear History.
Clear History juckt dies nicht.
Clear History.
Ja, das geht doch in unerheblichen Teilen der Fälle...
...geht es kaputt.
Er bekommt aber den Handshake.
Ja, er bekommt auch Candidates.
Also ich tippe drauf, dass das ein Problem der Rust-Library vielleicht ist.
Weil ich mache hier so Port-Multiplexing.
Ich mache hier so Port-Multiplexing und...
Okay, das ist meine letzte Amtshandlung heute.
Ich lasse das mal weg, das Port-Multiplexing,
und gucke mal, ob es dann weg ist.
Aber ohne Port-Multiplexing will ich das nicht betreiben.
Was bedeuten die Abkürzungen in Rust?
Welche Abkürzungen?
Also unspezifischer Fragen hättest du auch nicht mehr können, oder?
Oder du meinst, für was Rust steht?
Rust ist gar keine Abkürzung. Rust ist eine Programmiersprache.
Was ist Port-Multiplexing?
Der macht mehrere Connections über den gleichen Port, anstatt für jeden Port was eigenes auf.
Ah!
Chat-Gear?
Das liegt am Port-Multiplexing, guckt mal.
Seht ihr das?
Jetzt kackt nichts ab.
Das liegt am Port-Multiplexing von der Library.
Aber ohne Port-Multiplexing werde ich das nicht betreiben.
Guckt, das wäre schon längst abgekackt, normalerweise.
Ich kann noch ein paar mal refreshen.
Pass mal auf.
Ich habe halt ein paar Ports offen jetzt, ne?
Das ist wirklich nicht viel.
Was ich jetzt machen würde, ist,
ich würde einen Retry im JavaScript einbauen.
Also, guckt mal.
Das ist ja relativ offensichtlich der Bug.
Der irgendwie im Port-Multiplexing liegt.
Und nachdem ich hier nichts großartig einstellen kann,
man kann ja auch keine großartigen Settings sonst einstellen.
UDP-Multiplexing-Default.
Man kann da nicht wirklich viel einstellen.
Closed.
Gibt keine großartigen Settings.
Ich würde einen Retry im JavaScript einbauen.
Da kann man nicht viel. Option.
Warum nicht TCP?
Würde ich gerne machen, unterstütze die Library nicht.
Und ist für Echtzeit-Video jetzt auch nicht so wichtig,
dass sie das kann.
Und zwar,
kompilieren das nochmal.
Dann gehen wir in C-Sharp.
Höhen das nochmal aus.
Gucken, ob das Problem noch auftritt.
Ja, Problem tritt immer noch auf.
Es liegt echt am Port-Multiplexing.
Guckt, dass das manchmal nicht geht.
Kaum ist das eingeschaltet, buggt es wieder rum.
Was ich jetzt machen würde,
ich würde einen Retry im JavaScript einbauen.
So nach dem Motto,
wenn das innerhalb von nicht-connected hat,
dann Retry.
Das kann ich mir jetzt nicht aus dem Ärmel schütteln.
Aber ich schreibe mir das mal als To-Do rein.
To-Do, Retry.
5 Minuten haben wir noch Zeit.
Vielleicht kann man das sogar relativ einfach machen.
Der legt hier die Verbindung an.
Okay, ich weiß, was wir machen.
Easy.
Es ist JavaScript, da können wir auch eklige Sachen machen.
SetInterval nach einer Sekunde.
Passt mal auf, das wird jetzt richtig eklig.
Das wird so eklig,
da werdet ihr den Stream ausschalten wollen.
Also, wenn nach einer Sekunde der Connection State
ungleich
ungleich
ungleich
connected ist,
dann, pass auf, Pfeil fährt,
dann Window, Location,
Reload.
Das ist ein bisschen schnell.
Vielleicht 2 Sekunden.
Okay, 2 Sekunden.
Jetzt habe ich es gebroken.
Jetzt ist es kaputt, Leute.
Ah, geht doch. Easy.
Vielleicht machen wir auch 3 Sekunden.
Easy.
Eventuell noch ClearInterval im Else-Case.
Moment, ich will ja auch nicht SetInterval,
ich will ja SetTimeout.
Ich will ja gar nicht SetInterval.
Ich will ja, dass es nur einmal ausgewählt wird.
Guck, und es funzt.
Connection-Probleme, 3 Sekunden später,
Bam, Seite, Reloaded, Connection funzt.
Kannst du nicht das Event Connected abfangen für den Reload?
Doch.
Aber ich will ja hart nach 3 Sekunden gucken,
dann fange ich hier ab.
Ich könnte warten, bis das auf Failed steht.
Guck mal, wie lange das dauert,
bis es sich auf Failed stellt.
Das dauert ewig, bis es auf Failed geht.
Das geht einfach gar nicht auf Failed.
Das fängt auch gar nicht an erst.
SetInterval, wir gucken jetzt mal kurz.
Alle Sekunde,
Log, PC,
Connection-State und Log,
PC, Ice,
Connection-State.
New, New, New,
Das geht nie auf Failed.
Das macht einfach gar nichts.
Jetzt habt ihr es gerade gesehen.
Ich mache das da für euch in die Mitte.
Das erkennt gar nicht, dass es Failed ist.
Das heißt, mein Ansatz ist einfach
bester JavaScript-Fix ever.
3 Sekunden warten, wenn nicht Connected,
Restart. Easy.
Guck, nicht Connected, 3 Sekunden später,
Restart und Connected.
Ich glaube, das liegt in diesem Port-Multiplexing.
Was man auch gesehen hat.
Wenn ich das Port-Multiplexing
raus mache.
Irgendwann geht das auf Failed.
GitHub,
WebRTCS.
Wir können noch einmal kurz hier reingucken
in die Examples.
Single Port.
Die hatten gar kein Beispiel dafür.
Okay, die High-IQ-Leute setzen das so.
Was ist UDP?
Die verbindungslose Variante von TCP.
Settings
Engine.
Okay, das hat jetzt wahrscheinlich nicht so viel gebracht.
Settings Engine,
Set UDP Network.
Okay, die coolen Leute machen so.
Vielleicht bin ich einfach nicht Rust-Pro genug.
Ich meine mal seriously,
das hier ist wahrscheinlich nicht viel anders
zu dem, was ich gebaut habe.
Ach so, Settings Engine sollte ich
gleich noch anlegen.
Das müsste die gleichen Probleme haben.
Es ist kein Unterschied zu dem, was ich gemacht habe.
Nur irgendwie ineinander gerappt.
Placingly fast und coole Leute verwenden Rust.
Ich will auch zu den coolen Leuten gehören.
Nee, okay, Probleme gibt es immer noch.
Jetzt geht es gar nicht mehr.
Leute, jetzt ist es komplett kaputt.
Jetzt ist es komplett broken.
Hat ein bisschen gebraucht.
Nee, aber es ist immer noch kaputt.
Aber leakst du jetzt nicht eine Connection
beziehungsweise eine ID?
Aktuell schon.
Wir probieren WebRTC zu streamen.
Vom Server in den Browser.
Doch aktuell leake ich.
Ich brauche jetzt noch sowas wie
Cleanup
Old Connections.
Dazu kann man,
das machen wir aber heute nicht,
dazu kann man beispielsweise
ein Event subscriben.
Da gibt es per Connection
State On
On State
On per Connection State Changed
Wie auch immer man das aufruft.
Da steckt man ein Callback rein.
Da ist einfach ein Syntaxfehler drin.
Da kann ich warten bis der Code
Closed ist und dann lösche ich den
aus der Hashmap.
Und dann wird nichts mehr geleakt.
Okay, der Rest ist selbsterklärend.
Deswegen hat es auch keine Tests oder Docs.
Braucht man nicht.
Git Add Minus A
Diff Minus Minus
Staged
Ich wollte gucken ob Windows Line Endings wieder drin sind.
Okay, Git Status
Git Commits A Minus M
Cute Chat
Okay, MVP
Wir küren jetzt am Abschluss jedes Streams
Chatge-MVPs
MVP
Okay, vielleicht mehrere Leute
Wer ist euch heute besonders positiv aufgefallen?
Wir machen Chatge
Chatge darf Chatge bewerten
Communityge
RonAqua
RonAqua
Odolmit
😅
ulen
NㅁN
NㅁN
NㅁN
NㅁN
NㅁN
NㅁN
Anzeige ist raus. So mal gucken, ob alles auf ShitHub ordentlich drin ist. Ja, sieht gut aus.
Okay, ChatGel, nice. Schön, dass ihr am Start gewesen seid. Ich gehe jetzt pennen. Wir sehen
uns. Bis denn. Macht's gut. CEU.
