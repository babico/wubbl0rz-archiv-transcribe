WEBVTT

02:29.230 --> 02:47.390
So, heute Five-Head-Time, Leute.

02:47.390 --> 02:51.390
Wir benchmarken heute mal ein paar Sachen.

02:51.390 --> 02:53.390
Und zwar...

02:53.390 --> 02:57.390
Ich zeige euch das, bevor ich jetzt lange erzähle.

02:57.390 --> 03:04.280
Wir haben ja auch im Stream schon ein bisschen mit Web...

03:04.280 --> 03:07.280
Ich muss mal ein bisschen leiser machen.

03:07.280 --> 03:10.280
Heute schon gesportet? Ja, heute moin.

03:10.280 --> 03:12.280
Allerdings...

03:12.280 --> 03:22.350
Die Lautstärke kann sich mal wieder nicht entscheiden.

03:22.350 --> 03:26.050
Okay.

03:26.050 --> 03:30.050
Aber heute nur 5,56 Kilometer.

03:30.050 --> 03:34.050
Nicht wieder 10 plus wie letzten Sonntag.

03:34.050 --> 03:37.050
Also ganz normale Runde, die ich sonst auch renne.

03:37.050 --> 03:39.050
Naja, wobei nicht exakt die gleiche.

03:39.050 --> 03:41.050
Meine normale Runde 6,2.

03:41.050 --> 03:45.450
Ich mach schon mal meine VM an.

03:45.450 --> 03:48.450
Ich muss jetzt erstmal, bevor es losgeht...

03:48.450 --> 03:51.450
Ich zeige euch jetzt, was wir machen.

03:51.450 --> 03:53.450
Und...

03:53.450 --> 03:58.450
Dann futtere ich nochmal zwei Plätzchen, die ich mitgebracht habe hier gerade.

03:58.450 --> 04:04.450
Aber in der Zwischenzeit können wir nochmal ein Package-Update auf der VM machen, falls es das in der Zwischenzeit schon gegeben hat.

04:04.450 --> 04:08.450
Weil ich glaube, zuletzt haben wir heute Morgen geupdatet.

04:08.450 --> 04:10.450
Also, ich zeige euch, was wir heute machen.

04:10.450 --> 04:14.450
Ich glaube, das wird recht spannend, zumindest interessieren mich die Ergebnisse auch.

04:14.450 --> 04:25.270
Und zwar, wir rufen heute von C-Sharp aus sowohl Rust-Funktionen auf, als auch Go-Funktionen.

04:25.270 --> 04:27.270
Was liegt daran?

04:27.270 --> 04:30.270
Ihr könnt euch vielleicht noch dran erinnern.

04:30.270 --> 04:35.270
Ich hab im Stream ja schon öfters mal ein bisschen mit WebRTC auf Serverseite rumgebastelt.

04:35.270 --> 04:41.270
Zum Beispiel, dass man sich connecten kann in den Browser und dann Webcams abspielen und solche Geschichten.

04:41.270 --> 04:44.270
Also ich hab ja schon öfters mal ein bisschen mit WebRTC rumgebastelt.

04:44.270 --> 04:50.270
Und ich hab die letzten Tage über mal so ein bisschen Just for Fun wieder ein bisschen rumgebaut mit WebRTC.

04:50.270 --> 04:55.270
Also WebRTC ist quasi Real-Time Video im Browser.

04:55.270 --> 04:58.270
Nicht Streaming, wohlgemerkt nicht Streaming.

04:58.270 --> 05:01.270
Also Streaming ist ja meistens HLS.

05:01.270 --> 05:04.270
Also HLS ist, was heißt das?

05:04.270 --> 05:06.270
Für was steht HLS eigentlich?

05:06.270 --> 05:09.900
Gute Frage.

05:09.900 --> 05:11.900
HTTP-Live-Streaming.

05:11.900 --> 05:13.900
Okay.

05:13.900 --> 05:15.900
Wusste ich gar nicht.

05:15.900 --> 05:18.900
Also die ganzen Streaming-Seiten, die funktionieren meistens über HLS.

05:18.900 --> 05:20.900
HLS ist relativ easy.

05:20.900 --> 05:24.900
HLS gibt es eine M3U8-Datei.

05:24.900 --> 05:27.900
Und da stehen dann URLs drin, die rotatet werden.

05:27.900 --> 05:31.900
Und alle paar Sekunden gibt es da einen neuen Eintrag drin.

05:31.900 --> 05:33.900
Und dann streamt das.

05:33.900 --> 05:36.900
Also es macht ab und zu mal ein Get und dann holt sich so ein 5-Sekunden-Häppchen vom Stream.

05:36.900 --> 05:39.900
Und dann macht es wieder ein Get neues 5-Sekunden-Häppchen.

05:39.900 --> 05:42.900
WebRTC ist tatsächlich Real-Time.

05:42.900 --> 05:44.900
On-End-Gerät zu End-Gerät.

05:44.900 --> 05:47.900
Das ist besonders gut, wenn man möglichst Latency-Free-Video haben will.

05:47.900 --> 05:51.900
Was cool ist für Audio-Calls.

05:51.900 --> 05:53.900
Also beispielsweise Microsoft Teams und sowas.

05:53.900 --> 05:55.900
Das läuft nach Möglichkeiten über WebRTC.

05:55.900 --> 05:59.900
Und halt auch für Videokameras.

05:59.900 --> 06:02.900
Wenn man zum Beispiel drauf gucken will, wer vor der Tür steht und sowas.

06:02.900 --> 06:05.900
Und das möglichst Latency-Free sehen will alles.

06:05.900 --> 06:07.900
Dann ist WebRTC gut.

06:07.900 --> 06:08.900
Aber das machen wir heute nicht.

06:08.900 --> 06:10.900
Ich sag nur, wie ich drauf gekommen bin.

06:11.900 --> 06:13.900
Und ich verwende für...

06:13.900 --> 06:15.900
Oh, ich habe irgendwas im Auge.

06:15.900 --> 06:19.980
Das ist ja super abartig.

06:19.980 --> 06:23.940
Razer, danke für den Sub.

06:23.940 --> 06:32.500
Und by the way, wir installieren gerade mal die neue JetBrains IDE für Rust.

06:32.500 --> 06:35.500
Erstmal hier updaten.

06:35.500 --> 06:38.500
Die Toolbox darf auch updaten.

06:38.500 --> 06:42.500
Genau, und normalerweise habe ich das immer mit dieser Library hier gemacht.

06:42.500 --> 06:45.940
Und die ist in Go.

06:46.940 --> 06:48.940
Die ist in Go.

06:48.940 --> 06:51.940
Und eine Sache, die mich in Go immer genervt hat.

06:51.940 --> 06:53.940
Stripes, dankeschön für den Sub.

06:53.940 --> 07:02.940
Eine Sache, die mich in Go immer genervt hat, ist, dass Go Interop mit anderen Sprachen so langsam ist.

07:02.940 --> 07:05.940
Die IDE ist absoluter Müll, echt.

07:05.940 --> 07:07.940
Hast du schon ausprobiert?

07:07.940 --> 07:09.940
Wie heißt denn das Ding überhaupt?

07:09.940 --> 07:11.940
Rust Rover.

07:11.940 --> 07:14.940
Was verwendest du, wenn das Kacke ist?

07:14.940 --> 07:18.940
Meistens sind die JetBrains-Dinger doch immer ganz gut.

07:18.940 --> 07:21.940
Aber zumindest Goland ist nice und Ryder ist nice.

07:21.940 --> 07:35.050
Moin.

07:35.050 --> 07:43.810
Was macht Visual Studio Code besser?

07:43.810 --> 08:01.260
Plätzchen, Stelz, Easy Light.

08:01.260 --> 08:31.070
Keine Ahnung, was die da treiben.

08:31.070 --> 08:41.170
Das denke ich persönlich auch.

08:41.170 --> 08:48.400
Es würde mich weniger interessieren, was Mr. Robot nicht gefallen hat.

08:48.400 --> 08:51.400
Beziehungsweise, was ihn wie das Code besser ist.

08:51.400 --> 09:01.540
Update ist raus, installieren wir das Ding.

09:01.540 --> 09:08.730
Das Ding buggt ja vor allem manchmal ein bisschen.

09:08.730 --> 09:16.140
So.

09:16.140 --> 09:20.140
Also, nachdem ich meine Plätzchen weggestelzt habe, kann ich weiter erzählen.

09:20.140 --> 09:24.140
Wie gesagt, ich sage euch gleich, wir machen heute nicht viel WebRTC.

09:24.140 --> 09:26.140
Wenn überhaupt, gar nicht.

09:26.140 --> 09:28.140
Das ist nur, wie ich auf die Idee gekommen bin.

09:28.140 --> 09:32.140
Und zwar, für WebRTC habe ich immer diese Library hier verwendet.

09:32.140 --> 09:39.140
Aber eine Sache, die mich an Go aufrufen aus anderen Sprachen immer extrem abgefuckt hat, ist,

09:40.140 --> 09:44.140
dass das, wenn man das öfters callt, ziemlich langsam ist.

09:44.140 --> 09:46.140
Es gibt zwei Varianten.

09:46.140 --> 09:53.140
Wenn man aus Go selber C-Funktionen aufruft, also quasi von Go andere Sprachen aufruft,

09:53.140 --> 09:58.140
dann ist das langsam, aber es hält sich noch halbwegs in Grenzen.

09:58.140 --> 10:03.140
Wenn man aus anderen Sprachen in Go rein callt, in Go-Code rein callt,

10:03.140 --> 10:07.140
dann ist das in der Vergangenheit zumindest extrem langsam gewesen.

10:07.140 --> 10:16.140
Also, wir reden hier von ein native function call von C-Sharp nach C-Sharp dauert, was weiß ich,

10:16.140 --> 10:21.140
keine Ahnung, eine halbe Nanosekunde oder so.

10:21.140 --> 10:23.140
Es ist kurz.

10:23.140 --> 10:29.140
Und ein call nach Go rein dauert irgendwie 300 Nanosekunden oder so.

10:29.140 --> 10:34.140
Also, Go ist sehr langsam, wenn es um Interop mit anderen Sprachen angeht.

10:35.140 --> 10:50.140
Das hat mich immer genervt, weil ich sende mehrfach, also ich sende 30 mal die Sekunde pro Kamera neue Videoframes nach Go

10:50.140 --> 10:53.140
und die WebRTC-Library verarbeitet die dann.

10:53.140 --> 10:58.140
Heißt, im Endeffekt, ich hab, sag mal, wenn du 30 FPS pro Kamera hast,

10:58.140 --> 11:02.140
hast du 10 Kameras, oder sagst du, du hast 100 Kameras,

11:02.140 --> 11:06.140
dann hast du 3000 Function Calls die Sekunde.

11:06.140 --> 11:10.140
Das ist nicht viel und das ist auch, ganz ehrlich,

11:10.140 --> 11:16.140
selbst wenn es richtig, richtig langsam ist in Go,

11:16.140 --> 11:19.140
nicht so wirklich das Bottleneck, aber mich nervt.

11:19.140 --> 11:21.140
Deswegen wollte ich das erstens mal ausprobieren.

11:21.140 --> 11:26.140
Naja, also es gibt noch nichts zu rewriten in Rust, aber wir probieren das mal in Rust aus.

11:26.140 --> 11:31.140
Also zumindest, wir machen heute kein komplettes WebRTC-Example, vielleicht nächsten Stream oder so,

11:31.140 --> 11:33.140
weil das geht erstmal zum Ausprobieren.

11:33.140 --> 11:38.140
Zumindest wollte ich erstmal ausprobieren, ob das schneller geworden ist mittlerweile.

11:38.140 --> 11:41.140
Also C und Go Interop.

11:41.140 --> 11:45.140
Ich sag C stellvertretend für alle anderen Sprachen, die es gibt,

11:45.140 --> 11:49.140
weil jede Sprache, oder sag mal so, mir fällt keine Sprache ein,

11:49.140 --> 11:53.140
die nicht Interop mit C machen kann.

11:54.140 --> 12:02.140
Wie C Funktionen aufruft, hat sich so ein bisschen als Standard etabliert in der Programmierwelt.

12:02.140 --> 12:06.140
Egal ob das jetzt Python ist, Node, C Sharp, was auch immer,

12:06.140 --> 12:10.140
alle können sie eigentlich dynamisch C Funktionen aufrufen.

12:10.140 --> 12:20.520
Also mir fällt keine Sprache ein, die nicht C Funktionen aufrufen kann.

12:20.520 --> 12:27.520
Sagen wir mal, kompilierte Sachen, die mit C Interface rausgefallen sind.

12:27.520 --> 12:33.520
Und das Ding ist, ich hab irgendwas im Auge, das ist wirklich richtig nervig.

12:33.520 --> 12:48.210
So, und das Ding ist, wir testen jetzt erstmal, ob das schneller geworden ist mit Go.

12:48.210 --> 12:51.210
Was hab ich eigentlich für eine Go-Version drauf hier?

12:51.210 --> 12:54.210
Go-Version, sieht man das?

12:54.210 --> 12:57.210
Ach nee, das ist die Minus-Version, nur so?

12:57.210 --> 12:59.210
Nee, das ist einfach nur Version.

12:59.210 --> 13:03.210
Warum macht das eigentlich jedes Command-Line-Tool irgendwie anders?

13:03.210 --> 13:06.210
Bei Java ist es glaube ich Minus-V oder so.

13:06.210 --> 13:09.210
Das kann man sich ja echt nicht merken.

13:09.210 --> 13:12.210
So, und Rust müssen wir auch gleich mal installieren.

13:12.210 --> 13:15.210
Nee, Rust ist schon installiert.

13:15.210 --> 13:27.540
So, und der Kompilierer für die deutsche Programmiersprache, oje.

13:27.540 --> 13:51.720
Ja, das mit dem einen Minus ist in der Go-Welt voll verbreitet.

13:51.720 --> 13:53.720
Ich verstehe es ehrlich gesagt nicht.

13:53.720 --> 13:56.720
Man hätte sich da ein bisschen an Lilux-Standards halten können.

13:56.720 --> 14:01.720
Und Lilux-Standard ist Minus Minus ausgeschrieben, einfaches Minus mit Abkürzung.

14:02.720 --> 14:06.720
Aber Go hat sich gedacht, scheiß drauf, wir lassen das einfach.

14:06.720 --> 14:16.820
Wobei, in dem Fall ist es ja sogar nicht nur einfaches Minus, sondern sogar ganz ohne Minus, also Sub-Command.

14:18.820 --> 14:23.820
Leute, wartet mal, ich muss mal kurz Wasser ins Auge machen, ey.

14:23.820 --> 15:17.160
I-Champ gefixt, hoffe ich.

15:17.160 --> 15:21.940
Ja, bei Git ist es auch so.

15:21.940 --> 15:23.940
Wobei, bei Git bin ich es gewöhnt.

15:23.940 --> 15:27.940
Gar nicht so schlimm, da muss ich einfach nur dran gewöhnen, dass Sub-Commands sind.

15:27.940 --> 15:32.940
Aber Version finde ich halt doof als Sub-Command, Minus Minus Version ist einfach viel intuitiver.

15:32.940 --> 15:37.830
So, also das ist das erste, was ich ausprobieren will.

15:37.830 --> 15:42.830
Ob Go-Interop mit anderen Sprachen immer noch so langsam ist.

15:42.830 --> 15:46.830
Und dann, ja, dann kam das nächste, wie ich auf Rust gekommen bin.

15:46.830 --> 15:54.830
Ich hab gesehen, dass es eine Rust-Reimplementation von dieser Go-Library gibt in Rust.

15:54.830 --> 16:00.830
Also das Ding ist ziemlich beliebt, 11.900 Sterne und das da 3.500 Sterne.

16:00.830 --> 16:02.830
Also fast so viel wie der Fiat-Champ.

16:02.830 --> 16:16.260
Hat da jemand sein Issue geschlossen, kann das sein?

16:16.260 --> 16:20.260
Guck mal, ich sag doch, keine Fehler, keine Fehler im Fiat-Champ.

16:20.260 --> 16:30.180
Einfach immer, versteht keiner, wie man es verwendet.

16:30.180 --> 16:36.180
So, und dann habe ich gefunden, dass es eine Reimplementierung von dieser WebRTC-Library in Rust gibt.

16:36.180 --> 16:40.180
Und dann habe ich mir überlegt, okay, jetzt wäre es doch mal an der Zeit,

16:40.180 --> 16:44.180
bevor ich irgendwie eine der beiden Libraries benutze,

16:44.180 --> 16:49.180
mal zu gucken, was sich prinzipiell angenehmer aus .NET aufrufen lässt.

16:49.180 --> 16:51.180
Rust oder Go.

16:51.180 --> 16:55.180
Ich persönlich tippe drauf, dass es meilenweit Rust sein wird.

16:55.180 --> 17:01.180
Sowohl easier zu benutzen als auch, also nicht zu schreiben, sondern anzusprechen,

17:01.180 --> 17:07.180
als auch deutlich höhere Performance vom Callen von C-Sharp aus.

17:07.180 --> 17:09.180
Aber so ganz sicher bin ich mir nicht.

17:09.180 --> 17:12.180
Ich gehe aber davon aus, dass Rust meilenweit vorne sein wird.

17:12.180 --> 17:16.180
Das Problem an Rust ist, dass Rust absolut abfuck zu schreiben ist.

17:16.180 --> 17:21.180
Aber der Interop mit C-Sharp sollte schneller sein.

17:21.180 --> 17:25.180
Deswegen probieren wir das jetzt überhaupt gar nicht, Leute.

17:25.180 --> 17:32.180
Ich bin ja schon seit MW1 der Meinung, dass das Kreativität komplett bankrott dort ist.

17:32.180 --> 17:37.180
MW2 war schon nochmal der Aufguss des Remake-Aufgusses.

17:37.180 --> 17:39.180
Und MW3 komplett.

17:39.180 --> 17:42.180
Ich habe heute bei Huskers in den Stream reingeguckt,

17:42.180 --> 17:46.180
habe festgestellt, die haben zwar teilweise Karten dabei,

17:46.180 --> 17:54.180
aber das Gameplay, was ich sehe, ist das gleiche Up-Aim-MW1-Reboot-Gameplay

17:54.180 --> 18:00.180
mit ultrahoher Time-to-Kill, also niedriger, niedriger, nicht hoher, niedriger Time-to-Kill.

18:00.180 --> 18:09.610
Also ich habe mir null davon angeguckt, das interessiert mich nicht und ich werde es mir auch nicht kaufen.

18:09.610 --> 18:11.610
Findest du ernsthaft? Ich finde Rust ist eklig.

18:11.610 --> 18:14.610
Ich meine, sowohl Go als auch Rust sind jetzt nicht gerade die schönsten Sprachen,

18:14.610 --> 18:16.610
aber ich finde Rust extrem umständlich.

18:16.610 --> 18:18.610
Deswegen werden wir das jetzt mal ausprobieren.

18:18.610 --> 18:20.610
So, also, was gibt es hier?

18:20.610 --> 18:26.610
Hey Max, kannst du eventuell berichten, wie es in dem Bankenwesen seine Ausbildung zum Anwendungsinformatiker zu machen?

18:26.610 --> 18:30.610
Weiß ich nicht, ich habe keine Ausbildung gemacht in der Finanzbranche,

18:30.610 --> 18:32.610
weder bei der Bank noch bei der Versicherung.

18:32.610 --> 18:36.610
Ich habe bei einem Internetprovider meine Ausbildung gemacht.

18:36.610 --> 18:47.700
Da hatte ich nicht direkt zumindest was damit zu tun.

18:47.700 --> 18:51.700
Nein, du solltest dich dort bewerben, wo die Stelle möglichst vielversprechend aussieht.

18:51.700 --> 18:55.700
Ich meine, der Laden, dass der dir vielleicht zusagen sollte, ist nicht verkehrt.

18:55.700 --> 18:58.700
Aber bewerb dich ruhig bei einer Bank oder bei einer Versicherung oder sowas.

18:58.700 --> 19:01.700
Finanzbranche ist gut, wenn du deinen Fuß in der Tür hast.

19:01.700 --> 19:06.700
Finanzbranche bezahlt mit Abstand am meisten, wenn man sich das anguckt.

19:06.700 --> 19:09.700
Es gibt so eine Tabelle.

19:09.700 --> 19:14.700
Ich glaube, das erste waren Banken, das zweite waren Versicherungen, das dritte war Pharmaindustrie in Deutschland.

19:14.700 --> 19:18.700
Ich glaube, das vierte Automobilindustrie oder sowas für IT-Kräfte.

19:18.700 --> 19:20.700
Es könnte auch umgedreht gewesen sein.

19:20.700 --> 19:23.700
Es könnte auch zuerst Automobil und dann Pharmaindustrie.

19:23.700 --> 19:26.700
Aber der erste Platz, der zweite Platz war auf jeden Fall Banken und das zweite war Versicherung.

19:26.700 --> 19:31.700
Das heißt, wenn du in der Finanzbranche irgendwie deinen Fuß in die Tür kriegst, ist sinnvoll.

19:31.700 --> 19:39.700
Und meistens sind die auch ein bisschen größer, was oftmals echt von Vorteil für die Ausbildung ist.

19:39.700 --> 19:42.700
Also je nachdem, was für eine kleine Klitsche das hier ist,

19:42.700 --> 19:47.700
da wird halt sehr viel so auf Gutmeinen gemacht.

19:47.700 --> 19:49.700
Ob es dann gut ist, weiß man nicht.

19:49.700 --> 19:56.700
Also bei den großen Läden kommt es halt weniger oft vor, dass keiner Plan hat, wie das bei einer Ausbildung laufen soll.

19:56.700 --> 19:59.700
Dass du keinen Ansprechpartner hast, dass sich keiner um dich kümmert und sowas.

19:59.700 --> 20:01.700
Das hast du bei großen Läden weniger.

20:01.700 --> 20:08.700
Und dann hast du in der Finanzbranche einen Fuß in der Tür, was immer gut ist, weil die bezahlen einfach gut.

20:08.700 --> 20:12.700
Also ganz ehrlich, wenn du die Möglichkeit hast, das zu machen, würde ich mir das angucken.

20:12.700 --> 20:38.760
So sieht es aus.

20:40.760 --> 20:42.760
Jetzt habe ich erklärt, was wir machen wollen.

20:42.760 --> 20:44.760
Jetzt probieren wir das Ganze mal aus.

20:44.760 --> 20:46.760
Also wir legen mal ein neues Projekt an.

20:46.760 --> 20:50.760
Also wie gesagt, wir fangen ganz simpel an.

20:50.760 --> 20:56.760
Wir machen ein Go-Projekt, exportieren dort eine Funktion, die nichts macht,

20:56.760 --> 21:04.760
rufen die FonziSharp auf und wir machen ein Rust-Projekt mit einer leeren Funktion

21:04.760 --> 21:10.760
und rufen die FonziSharp aus und dann benchmarken wir das erstmal und gucken, was da schneller ist.

21:10.760 --> 21:12.760
Beim reinen FunctionCall.

21:12.760 --> 21:16.760
Da wissen wir auch schon mal, dass das nicht daran liegt, dass die eine Sprache irgendwas besser kann,

21:16.760 --> 21:21.760
als die andere Sprache in der Implementierung, sondern einfach so der reine Funktionsaufruf.

21:21.760 --> 21:23.760
Mal gucken, wie schnell der ist.

21:23.760 --> 21:25.760
Ich würde erwarten, dass der saumäßig schnell ist.

21:25.760 --> 21:29.760
Vielleicht nicht so schnell wie ein Native-Aufruf, .net zu .net, aber immer noch schnell.

21:29.760 --> 21:37.760
Ich weiß aber aus Erfahrung, dass Go-Interop mit anderen Sprachen echt problematisch war in der Vergangenheit.

21:37.760 --> 21:42.760
Gerade wenn das was ist, was wirklich hunderttausendfach aufgerufen wird.

21:42.760 --> 22:04.750
Große Unternehmen haben Ausbildungsverantwortlichen, da passiert sowas eigentlich selten.

22:04.750 --> 22:09.880
Danke.

22:09.880 --> 22:11.880
Was ist für dich groß?

22:11.880 --> 22:13.880
50 Mann sind nicht groß.

22:14.880 --> 22:17.880
100 und 200 Mann sind auch nicht wirklich groß.

22:17.880 --> 22:29.930
Ich bin mir nicht sicher, ob das eine T-Bait-Frage ist oder ernst gemeint.

22:29.930 --> 22:33.930
Egal, ich sage dazu nichts, weil wenn ich damit anfange, dann höre ich halt nicht mehr auf.

22:33.930 --> 22:50.100
Das muss nicht sein.

22:50.100 --> 22:52.100
So, dann legen wir mal los.

22:52.100 --> 22:56.100
Ich lege mal ein neues BenchmarkChamp.

22:59.740 --> 23:02.740
Wir testen jetzt erstmal, wie schnell das Ganze ist.

23:02.740 --> 23:07.740
Und wenn das in Rust wirklich, und das ist ja zu erwarten, so viel schneller ist,

23:07.740 --> 23:11.740
dann werde ich demnächst mal etwas WebRTC in Rust programmieren.

23:11.740 --> 23:15.740
Wobei ich weiß jetzt schon, dass ich durchdrehen werde dabei.

23:15.740 --> 23:17.740
Ein gutes hat's, ein gutes hat's.

23:19.740 --> 23:25.740
Das ist quasi eine Rust-Reimplementation von der Go-Library hier.

23:25.740 --> 23:29.740
Das heißt, ich hoffe, wenn man die Go-Library ein bisschen kennt, kommt man hier auch ganz gut klar.

23:29.740 --> 23:37.080
Müssen wir mal schauen.

23:37.080 --> 23:40.520
Das ist ziemlich groß.

23:40.520 --> 23:45.520
Da gibt es doch eigentlich Ausbildungsbeauftragte und Leute, die dann einen Blick drauf machen.

23:45.520 --> 23:51.520
Also es ist selten, dass es so reingeschissen wird bei großen Unternehmen, was Ausbildung angeht.

23:51.520 --> 23:54.520
Das sehe ich eher gehäufter bei den kleinen.

23:54.520 --> 23:57.520
Okay, wir installieren mal eine neue .NET-Version.

23:57.520 --> 24:02.900
Wir haben mal Zeit, weil ich glaube, es gibt eine neue Preview-Version.

24:02.900 --> 24:04.900
Wenn ich das richtig sehe.

24:04.900 --> 24:11.900
Ja, es gibt 8.0.1, wobei 100 haben die glaube ich immer, RC2.

24:11.900 --> 24:14.900
RC2, 2.3.5.0.2.2.

24:14.900 --> 24:19.900
Sag mal, .NET-Team, wie viele Versionsnummern wollt ihr eigentlich noch haben?

24:19.900 --> 24:22.900
8.0, das lasse ich mir ja noch gefallen.

24:22.900 --> 24:27.900
8.0.100 ist schon ein bisschen pp-iger, aber auch noch okay.

24:27.900 --> 24:35.900
Aber 8.0.100-RC2.2.3.5.0.2.2.

24:35.900 --> 24:38.900
Also irgendwann ist auch mal gut.

24:38.900 --> 24:49.970
Also ich meine, bis hierhin geht es ja irgendwie noch halbwegs klar.

24:49.970 --> 24:52.970
Aber das dahinter ist schon komplett bescheuert.

24:52.970 --> 24:57.470
Das hat dann mit Semware auch nichts mehr zu tun.

24:57.470 --> 25:00.470
Das interessiert Microsoft eh nicht.

25:00.470 --> 25:03.470
Also, .NET-New-Console.

25:04.470 --> 25:07.470
Wir machen mal ein paar neue Ordner.

25:07.470 --> 25:15.100
Wir machen mkdir Rust, mkdir Go, mkdir Benchmark.

25:15.100 --> 25:21.100
Benchmark legen wir das .NET-Projekt an.

25:21.100 --> 25:23.100
Wow, der für Schmerzen.

25:23.100 --> 25:25.100
Blazer, wen interessiert Blazer?

25:25.100 --> 25:27.100
Wer auch immer das benutzt.

25:27.100 --> 25:31.100
Also Microsoft will das zur Zeit boosten wie sonst was.

25:32.100 --> 25:35.100
Aber auch wenn ich ein großer C-Sharp-Fan bin.

25:35.100 --> 25:38.100
Ehrlich, im Browser wie es bisher ist, brauche ich das nicht.

25:38.100 --> 25:41.100
So, dann haben wir hier Go und haben Rust.

25:41.100 --> 25:43.100
Dann kopieren wir uns mal das Verzeichnis.

25:43.100 --> 25:46.100
Und ich würde sagen, dann fangen wir mal ganz easy an.

25:46.100 --> 25:51.820
Öffnen wir das mal in Rider.

25:51.820 --> 25:58.060
Und tun mal so, als wüssten wir was wir machen.

25:58.060 --> 26:00.060
So, Repos, wie habe ich das genannt?

26:00.060 --> 26:02.060
Nicht Backup.

26:02.060 --> 26:05.060
Benchmark, Champ.

26:06.060 --> 26:08.060
Hier, da, öffnen.

26:08.060 --> 26:15.100
So, hier auf dem vierten Bildschirm machen wir Go Land auf.

26:15.100 --> 26:17.100
Und auf dem fünften, auf dem fünften.

26:17.100 --> 26:19.100
Boah, das kostet RAM, Leute.

26:19.100 --> 26:21.100
Das kostet RAM, Alter.

26:21.100 --> 26:23.100
Drei JetBrains Ideen ist offen.

26:23.100 --> 26:26.100
Ihr MonkaS Javer, Alter.

26:26.100 --> 26:29.100
Und hier machen wir das Rust-Ding auf.

26:29.100 --> 26:32.980
I confirm that I have Red X.

26:32.980 --> 26:34.980
Ja, ja, ja, ich konfirme.

26:34.980 --> 26:36.980
Ich konfirme alles hier.

26:36.980 --> 26:38.980
Wir wollen nichts senden.

26:39.980 --> 26:41.980
Rust-Version detected.

26:41.980 --> 26:43.980
173.0

26:43.980 --> 26:45.980
Perfekt, top.

26:45.980 --> 26:48.980
Wir wollen allerdings Location Repos.

26:48.980 --> 26:50.980
Benchmark, Champ.

26:50.980 --> 26:52.980
Rust.

26:52.980 --> 26:54.980
Da wollen wir rein.

26:54.980 --> 26:56.980
Binary Application.

26:56.980 --> 26:58.980
Standard Library.

26:58.980 --> 27:00.980
Egal.

27:00.980 --> 27:02.980
Die Standard Library von dieser Version halt.

27:02.980 --> 27:04.980
Ich weiß nicht, wo die ist.

27:04.980 --> 27:06.980
Rust.

27:07.980 --> 27:12.320
Let's go.

27:12.320 --> 27:14.320
Oh, geht ja gut los.

27:14.320 --> 27:16.320
Erstmal Minischrift.

27:16.320 --> 27:18.320
Und als nächstes irgendwelche komischen Errors.

27:18.320 --> 27:20.320
Nice.

27:20.320 --> 27:22.320
Rust am Start.

27:22.320 --> 27:24.320
Cargo failed.

27:24.320 --> 27:26.320
Sync Rust Project.

27:26.320 --> 27:28.320
Retrieving Rust Standard Lib.

27:28.320 --> 27:30.320
Hä, warum muss er die noch retrieven, bitteschön?

27:30.320 --> 27:32.320
Rust kommt mit der Standard Library dabei.

27:32.320 --> 27:34.320
Deswegen heißt es Standard Library.

27:34.320 --> 27:36.320
Rust up not found.

27:36.320 --> 27:42.930
Ja, und jetzt?

27:42.930 --> 27:44.930
Kann das sein, dass der Rust up braucht?

27:44.930 --> 27:46.930
Damit das hier funktioniert?

27:46.930 --> 27:48.930
Ich kann auch Rust up installieren, wenn es sein muss.

27:48.930 --> 27:50.930
Ja, easy.

27:50.930 --> 27:55.330
Rust up.

27:55.330 --> 27:57.330
Installieren wir Rust up, auch gut.

27:57.330 --> 27:59.330
Deinstallieren wir Rust, installieren wir Rust up.

27:59.330 --> 28:01.330
Top.

28:01.330 --> 28:03.330
Ist jetzt Cargo und so da?

28:03.330 --> 28:09.580
Was?

28:09.580 --> 28:11.580
Run Rust Default Stable.

28:11.580 --> 28:13.580
Okay, nice.

28:13.580 --> 28:15.580
Das mag ich.

28:15.580 --> 28:17.580
Das mag ich an Rust.

28:17.580 --> 28:19.580
Also unabhängig davon, dass die Sprache ein bisschen eklig zu schreiben ist.

28:19.580 --> 28:21.580
Die Command-Line-Tools

28:21.580 --> 28:23.580
und das wie das ausgeliefert ist,

28:23.580 --> 28:27.660
ist wirklich ziemlich gut gemacht.

28:27.660 --> 28:29.660
Das Ziel ist, sowohl Rust

28:29.660 --> 28:31.660
als auch Go aus die Sharp aus aufzurufen

28:31.660 --> 28:33.660
mit C-Interface und zu gucken, was

28:33.660 --> 28:35.660
schneller ist.

28:35.660 --> 28:37.660
Nur in diesem einen Fall.

28:37.660 --> 28:39.660
Also jetzt nicht die Sprache an sich,

28:39.660 --> 28:41.660
da dürfte Rust vorne liegen,

28:41.660 --> 28:43.660
sondern nur das Aufrufen aus der

28:43.660 --> 28:45.660
anderen Programmiersprache aus.

28:45.660 --> 28:47.660
Da dürfte allerdings Rust auch meilenweit vorne liegen,

28:47.660 --> 28:49.660
weil Go ist mega langsam.

28:49.660 --> 28:51.660
Interop mit anderen Sprachen.

28:51.660 --> 28:53.660
Zumindest war das in der Vergangenheit so.

28:53.660 --> 28:55.660
Es wird aufgerufen

28:55.660 --> 28:57.660
C-Sharp nach Go und C-Sharp nach Rust.

28:57.660 --> 28:59.660
Es wird nicht C-Sharp Go Rust aufgerufen.

28:59.660 --> 29:01.660
Es wird C-Sharp nach Go

29:01.660 --> 29:03.660
und dann C-Sharp nach Rust aufgerufen.

29:03.660 --> 29:05.660
Ich tippe einfach, dass Rust

29:05.660 --> 29:07.660
in allen Belangen komplett

29:07.660 --> 29:09.660
meilenweit ahead of Go ist,

29:09.660 --> 29:11.660
weil Go bekannt dafür ist, dass Go langsam ist

29:11.660 --> 29:13.660
als Interop mit anderen Sprachen.

29:13.660 --> 29:15.660
Also langsamer als ziemlich jede andere

29:15.660 --> 29:17.660
technisch bekannte Programmiersprache.

29:17.660 --> 29:19.660
Und Go ist super langsam, was das angeht.

29:19.660 --> 29:21.660
Also das ist langsamer

29:21.660 --> 29:23.660
als so ziemlich jede andere Sprache,

29:23.660 --> 29:25.660
die mir so einfällt.

29:25.660 --> 29:27.660
Das ist langsamer als

29:27.660 --> 29:29.660
Python, also nur in diesem

29:29.660 --> 29:31.660
einen Fall.

29:31.660 --> 29:33.660
Also Callen von und nach

29:33.660 --> 29:35.660
anderen Sprachen über irgendeinen

29:35.660 --> 29:37.660
C-Interface.

29:37.660 --> 29:39.660
Das ist langsamer als Python, als Java,

29:39.660 --> 29:41.660
als alles.

29:41.660 --> 29:43.660
Einfach nur Javascript.

29:43.660 --> 29:45.660
Das ist wirklich,

29:45.660 --> 29:47.660
Go ansonsten ist ja recht flott,

29:47.660 --> 29:49.660
aber in dem Bereich ist es wirklich

29:49.660 --> 29:51.660
pepega langsam.

29:51.660 --> 29:53.660
So, also, hat es jetzt,

29:53.660 --> 29:55.660
jetzt starten wir nochmal dieses Rusting,

29:55.660 --> 29:57.660
ob das jetzt besser funktioniert, nachdem ich

29:57.660 --> 30:01.810
Rustup installiert hab.

30:01.810 --> 30:03.810
Ja nice, scheint zu funktionieren.

30:03.810 --> 30:05.810
Was hat Go für Vorteile?

30:05.810 --> 30:07.810
Go hat

30:07.810 --> 30:09.810
ein paar Vorteile. Zum Beispiel

30:09.810 --> 30:11.810
ist Go relativ flott.

30:11.810 --> 30:13.810
Wie gesagt, was langsam ist,

30:13.810 --> 30:15.810
ist ja nur diese eine Sache, die ich gerade

30:15.810 --> 30:17.810
gesagt habe. Champ, schön vielen Dank für den

30:17.810 --> 30:19.810
Sub. Ansonsten

30:19.810 --> 30:21.810
ist Go relativ flott.

30:21.810 --> 30:23.810
Go ist richtig

30:23.810 --> 30:25.810
gut, wenn man self-contained

30:25.810 --> 30:27.810
binaries haben möchte, die rückwärtskompatibel

30:27.810 --> 30:29.810
einfach auf jedem Linux-System laufen.

30:29.810 --> 30:31.810
Da ist Go so ziemlich die beste Sprache,

30:31.810 --> 30:33.810
die es gibt, die existiert, die man dafür

30:33.810 --> 30:35.810
benutzen kann.

30:35.810 --> 30:37.810
Auch im Cloud-Umfeld

30:37.810 --> 30:39.810
ist Go

30:39.810 --> 30:41.810
sehr beliebt. Warum kann ich die

30:41.810 --> 30:43.810
Preise nicht ändern?

30:43.810 --> 30:55.180
Und? Ach, jetzt geht es

30:55.180 --> 30:58.560
auf einmal, okay.

30:58.560 --> 31:00.560
JetBrains Mono, meinetwegen.

31:00.560 --> 31:02.560
Aber

31:02.560 --> 31:04.560
ich glaube, die Schriftgröße ist ganz okay,

31:04.560 --> 31:06.560
oder? Ich glaube,

31:06.560 --> 31:08.560
Chatgy, ich muss mal kurz

31:08.560 --> 31:10.560
in meiner Vorschau gucken. Ja, die Schriftgröße ist

31:10.560 --> 31:12.560
gut. Ich sehe das gerade hier in der Vorschau,

31:12.560 --> 31:14.560
die ist okay, da kann man nichts sagen.

31:14.560 --> 31:16.560
Das ist eigentlich sehr

31:16.560 --> 31:18.560
angenehm zu lesen gerade. Ich gucke mir das gerade

31:18.560 --> 31:20.560
auf dem Vorschau-Monitor an.

31:20.560 --> 31:22.560
Auch nettes,

31:22.560 --> 31:24.560
recht nicht so ins Auge

31:24.560 --> 31:26.560
brennende Dark-Theme dabei,

31:26.560 --> 31:30.450
das ist okay. So,

31:30.450 --> 31:32.450
Main Print Hello World, ja, das kommt schon mal weg.

31:32.450 --> 31:34.450
Wir brauchen gar keine Main-Funktion.

31:34.450 --> 31:36.450
Ach so, ja, Moment.

31:36.450 --> 31:38.450
Ich muss das ja umstellen auf eine Library.

31:38.450 --> 31:40.450
Wir legen erst mal das Go-Projekt

31:40.450 --> 31:42.450
an. Was haben wir hier noch offen?

31:42.450 --> 31:44.450
New Session, New Message,

31:44.450 --> 31:49.040
Create Session,

31:49.040 --> 31:52.800
New Sender. Ach so, ah,

31:52.800 --> 31:54.800
ich weiß, das ist, ja, ja, ja, das

31:54.800 --> 31:56.800
haben wir mal gebaut. Das können wir wegmachen.

31:56.800 --> 31:58.800
Da müssen wir ein neues

31:58.800 --> 32:00.800
Projekt anlegen.

32:00.800 --> 32:02.800
Also legen wir ein neues Go-Projekt an.

32:02.800 --> 32:06.300
Wo ist das hier? Go,

32:06.300 --> 32:08.300
New, Project.

32:08.300 --> 32:10.300
Und zwar

32:10.300 --> 32:12.300
wollen wir nach Repos

32:12.300 --> 32:14.300
Benchmark

32:14.300 --> 32:16.300
Champ Go. Und jetzt

32:16.300 --> 32:18.300
wollen wir ein Go-Modules

32:18.300 --> 32:20.300
Projekt anlegen. Ich glaube, das macht er

32:20.300 --> 32:22.300
standardmäßig.

32:22.300 --> 32:24.300
Was ist Enable Vendoring Support?

32:24.300 --> 32:41.280
Äh,

32:41.280 --> 32:43.280
verstehe ich nicht.

32:43.280 --> 32:45.280
Sollte ich das an- oder ausschalten?

32:45.280 --> 32:47.280
Ich verstehe die Hilfe

32:47.280 --> 32:49.280
nicht. Kann weg.

32:49.280 --> 32:51.280
Ich habe keine Ahnung, was es mir überhaupt sagen

32:51.280 --> 32:58.300
soll, ehrlich gesagt.

32:58.300 --> 33:00.300
Okay, ihr habt auch keine Ahnung. Wenn der Chat

33:00.300 --> 33:05.150
keine Ahnung hat, dann beruhigt mich das immer.

33:05.150 --> 33:07.150
Okay, Create,

33:07.150 --> 33:12.130
this Window, Close.

33:12.130 --> 33:14.130
So, jetzt muss ich erst mal gucken, dass ich wieder ein bisschen

33:14.130 --> 33:16.130
anfange, Go zu checken.

33:16.130 --> 33:18.130
Go war doch so.

33:18.130 --> 33:20.130
So, wir gehen jetzt mal Repo,

33:20.130 --> 33:22.130
Benchmark Champ,

33:22.130 --> 33:24.130
Go. Und jetzt

33:24.130 --> 33:26.130
sagen wir

33:26.130 --> 33:28.130
Go Run. Und dann

33:28.130 --> 33:30.130
kackts ab. Weil,

33:30.130 --> 33:32.130
Missing Go Version in Modload.

33:32.130 --> 33:38.290
Nice.

33:38.290 --> 33:40.290
Achso, es fehlt ne Main, oder?

33:40.290 --> 33:42.290
Es fehlt einfach ne Main-Datei.

33:42.290 --> 33:44.290
Dann ist die Fehlermeldung, aber ppga.svg.

33:44.290 --> 33:46.290
Also New Go File

33:46.290 --> 33:48.290
Main.go

33:48.290 --> 33:50.290
Package.

33:50.290 --> 33:52.290
Moment, warum

33:52.290 --> 33:54.290
heißt das Projekt Go? Das ergibt doch

33:54.290 --> 33:56.290
gar keinen Sinn. Das Projekt

33:56.290 --> 33:58.290
soll heißen...

33:58.290 --> 34:00.290
Achso, das heißt so wie der Ordner.

34:00.290 --> 34:02.290
Und das hier heißt auch Rust.

34:02.290 --> 34:04.290
Das ist ja egal. Es sollte durchaus auch okay sein,

34:04.290 --> 34:06.290
dass das heißt. So, Package

34:06.290 --> 34:08.290
Main muss das ja sein.

34:08.290 --> 34:10.290
Weil wir sind ja hier in Go. Und dann brauchen wir

34:10.290 --> 34:12.290
Function

34:12.290 --> 34:14.290
Main. Und dann sagen wir so was wie

34:14.290 --> 34:16.290
fmt.brindln.

34:16.290 --> 34:18.290
kack wait.

34:18.290 --> 34:20.290
So, und das sollte jetzt kompilieren, oder?

34:20.290 --> 34:22.290
Nein. Warum nicht?

34:22.290 --> 34:30.140
Das darf bestimmt nicht so heißen,

34:30.140 --> 34:32.140
oder? Das ist bestimmt ppga.

34:32.140 --> 34:34.140
Weil der Ordner Go heißt. Garantiert

34:34.140 --> 34:36.140
kann das das nicht ab, weil der Ordner Go heißt.

34:36.140 --> 34:38.140
Könnte ich wetten mit euch.

34:38.140 --> 34:40.140
Was? Go mod init?

34:40.140 --> 34:42.140
Das muss man doch normalerweise nie machen.

34:42.140 --> 34:44.140
Äh.

34:44.140 --> 34:46.140
Mod?

34:46.140 --> 34:48.140
Already exists.

34:48.140 --> 34:50.140
Das ist 100 Pro. Ich wette mit euch.

34:50.140 --> 34:52.140
Das ist, weil der Ordner

34:52.140 --> 34:58.850
Go heißt.

34:58.850 --> 35:00.850
Go hat so komische Dinger.

35:00.850 --> 35:04.930
Das kann ich mir richtig gut vorstellen.

35:04.930 --> 35:06.930
Wir löschen das nochmal.

35:06.930 --> 35:14.590
Man zieht ja ins Terminal nicht.

35:14.590 --> 35:16.590
Ja, in dem Fall gibt es da eh nichts.

35:16.590 --> 35:18.590
Wir löschen das nochmal.

35:18.590 --> 35:20.590
Und machen mktl go app. Okay?

35:20.590 --> 35:22.590
So, das sollte

35:22.590 --> 35:24.590
nicht problematisch sein.

35:24.590 --> 35:31.100
Also, new project.

35:31.100 --> 35:33.100
Jetzt hat er das schon wieder.

35:33.100 --> 35:35.100
Jetzt lasse ich das mal enabled.

35:35.100 --> 35:39.760
Vielleicht macht es das dann richtig.

35:39.760 --> 35:41.760
Wir wollen nach benchmark champ

35:41.760 --> 35:43.760
go app

35:43.760 --> 35:45.760
und eigentlich da rein direkt. Genau.

35:45.760 --> 35:47.760
Create.

35:47.760 --> 35:51.970
Und jetzt sage ich

35:51.970 --> 35:53.970
go app

35:53.970 --> 35:55.970
go run Punkt.

35:55.970 --> 35:57.970
Jetzt funktioniert es auch.

35:57.970 --> 35:59.970
Ich weiß jetzt nicht, ob das an diesem automatischen

35:59.970 --> 36:01.970
Vendoring Support lag, was auch immer das macht.

36:01.970 --> 36:03.970
Oder weil das Ding...

36:03.970 --> 36:05.970
Ich tippe auf den Ordner Namen.

36:05.970 --> 36:07.970
Bei Go weißt du nie.

36:07.970 --> 36:09.970
Go hat so viele Magic Sachen,

36:09.970 --> 36:11.970
weil sie so sein müssen.

36:11.970 --> 36:13.970
Beispielsweise auch Klammern bei einem if oder so.

36:13.970 --> 36:15.970
Dass ich mir das gut vorstellen kann.

36:15.970 --> 36:19.280
Main Punkt Go.

36:19.280 --> 36:21.280
Das ist auch merkwürdig gemacht,

36:21.280 --> 36:23.280
dass das nicht so heißen darf wie die App.

36:23.280 --> 36:25.280
So, und jetzt machen wir hier

36:25.280 --> 36:27.280
Function main

36:27.280 --> 36:29.280
fmt prindeln

36:29.280 --> 36:31.280
check wait.

36:31.280 --> 36:35.490
Das sollte jetzt funktionieren.

36:35.490 --> 36:37.490
Okay, nice. Funktioniert.

36:37.490 --> 36:39.490
Mal kurz checken, ob Rust auch funktioniert.

36:39.490 --> 36:42.800
Seht ihr das Terminal hier,

36:42.800 --> 36:44.800
wenn ich da was tippe?

36:44.800 --> 36:46.800
Hier unten. Sieht man das?

36:46.800 --> 36:48.800
Da ist der Chat davor, gell?

36:48.800 --> 36:50.800
Dann machen wir es so.

36:50.800 --> 36:54.110
Dann seht ihr es auf jeden Fall.

36:54.110 --> 36:56.110
Jetzt ist genug Platz unter Chico

36:56.110 --> 36:58.110
hier rechts. Da sieht man nichts.

36:58.110 --> 37:00.110
Dann machen wir auch das Terminal

37:00.110 --> 37:02.110
hier unten drunter.

37:02.110 --> 37:04.110
So, ja.

37:04.110 --> 37:06.110
Also Repos, Benchmark,

37:06.110 --> 37:08.110
Champ, Rust.

37:08.110 --> 37:10.110
Und jetzt machen wir mal,

37:10.110 --> 37:12.110
ich glaube Cargo run ist es.

37:12.110 --> 37:14.110
Okay, Rust

37:14.110 --> 37:16.110
kompiliert fehlerfrei.

37:16.110 --> 37:18.110
Erstmal im Kalender anmarken.

37:18.110 --> 37:20.110
Tja,

37:20.110 --> 37:22.110
jetzt geht es schon los.

37:22.110 --> 37:24.110
Ich glaube,

37:24.110 --> 37:26.110
es ist prindeln, ne?

37:26.110 --> 37:29.680
Auch in Rust.

37:29.680 --> 37:31.680
Check wait.

37:31.680 --> 37:36.210
Okay, ja. Funktioniert. Nice.

37:36.210 --> 37:38.210
Okay, also.

37:38.210 --> 37:40.210
Jetzt kommt das nächste.

37:40.210 --> 37:42.210
Also das ist jetzt ja einfach nur,

37:42.210 --> 37:44.210
um zu gucken, ob alles richtig aufgesetzt ist.

37:44.210 --> 37:48.670
So, also.

37:48.670 --> 37:50.670
Was hat er hier für Schmerzen?

37:50.670 --> 37:52.670
Could not load.

37:52.670 --> 37:54.670
Ah, ja.

37:54.670 --> 37:56.670
Das liegt,

37:56.670 --> 38:02.290
nicht toll sein Bild.

38:02.290 --> 38:04.290
Das liegt daran, dass er meine .NET Version

38:04.290 --> 38:06.290
nicht erkannt hat. Warum auch immer.

38:06.290 --> 38:08.290
Reload project.

38:08.290 --> 38:10.290
Jetzt sollte es hoffentlich gleich gehen.

38:10.290 --> 38:12.290
Machen wir auch nochmal

38:12.290 --> 38:14.290
eine Konsole auf.

38:14.290 --> 38:16.290
CD, Repos, Benchmark,

38:16.290 --> 38:19.790
.NET,

38:19.790 --> 38:21.790
Run.

38:23.790 --> 38:25.790
Ja, Funzt. Okay.

38:25.790 --> 38:27.790
Alles klar.

38:27.790 --> 38:29.790
Also, was ich jetzt vorhabe, ist folgendes.

38:29.790 --> 38:31.790
Ich möchte jetzt sowas hier machen.

38:31.790 --> 38:33.790
Ich will jetzt, wir brauchen,

38:33.790 --> 38:35.790
wir machen mal

38:35.790 --> 38:37.790
den .NET Teil.

38:37.790 --> 38:39.790
Als erstes und dann den anderen.

38:39.790 --> 38:41.790
Wir machen jetzt mal eine Datei interop.cs

38:41.790 --> 38:43.790
Die kriegt

38:43.790 --> 38:45.790
eine public,

38:45.790 --> 38:47.790
eine uns,

38:47.790 --> 38:49.790
eine unsafe public

38:49.790 --> 38:51.790
static class.

38:51.790 --> 38:53.790
Warum unsafe?

38:53.790 --> 38:55.790
Naja, weil ich

38:55.790 --> 38:57.790
zähe Sachen mit Pointern und so in anderen Sprachen

38:57.790 --> 38:59.790
aufrufen will. Also das muss unsafe sein.

38:59.790 --> 39:01.790
Und damit das funktioniert,

39:01.790 --> 39:03.790
muss ich unsafe

39:03.790 --> 39:05.790
erlauben.

39:05.790 --> 39:07.790
Ich weiß eh nicht, warum das nicht standardmäßig

39:07.790 --> 39:09.790
an ist. Ich meine, wenn man es nicht verwendet, verwendet man es

39:09.790 --> 39:13.550
halt nicht. So.

39:13.550 --> 39:15.550
Und jetzt

39:15.550 --> 39:17.550
will ich beispielsweise sowas hier

39:17.550 --> 39:19.550
aufrufen.

39:19.550 --> 39:21.550
DLL-Import

39:21.550 --> 39:23.550
von, ja,

39:23.550 --> 39:25.550
RustLib

39:25.550 --> 39:27.550
will ich aufrufen.

39:27.550 --> 39:29.550
Eine Funktion, die

39:29.550 --> 39:31.550
boah, DLL-Import-Syntax

39:31.550 --> 39:33.550
Moment. Muss ich mir abgucken.

39:33.550 --> 39:35.550
Ich glaube, static-extern

39:35.550 --> 39:37.550
oder irgendwie so muss das aussehen.

39:37.550 --> 39:39.550
Public

39:39.550 --> 39:41.550
static-extern, genau.

39:41.550 --> 39:46.270
So, public static-extern.

39:46.270 --> 39:48.270
Das heißt ja hier irgendwie

39:48.270 --> 39:50.270
call me, so.

39:50.270 --> 39:52.270
Einfach nur call heißt das Ding.

39:52.270 --> 39:54.270
Also, was das macht,

39:54.270 --> 39:56.270
was noch nicht geht, weil es ist noch nicht da.

39:56.270 --> 39:58.270
Damit kann ich jetzt aus C-Sharp

39:58.270 --> 40:00.270
eine Funktion aufrufen,

40:00.270 --> 40:02.270
die in Rust, in einer

40:02.270 --> 40:05.780
Library, in einer

40:05.780 --> 40:07.780
Rust-Library, die mit C-Interface

40:07.780 --> 40:09.780
kompiliert wurde, existiert.

40:09.780 --> 40:11.780
Aufrufen.

40:11.780 --> 40:13.780
Void fehlt noch.

40:13.780 --> 40:15.780
Und hiermit

40:15.780 --> 40:17.780
kann ich, achso, die sollte ich vielleicht

40:17.780 --> 40:19.780
ein bisschen anders nennen.

40:19.780 --> 40:21.780
Call me Rust

40:21.780 --> 40:23.780
Call, oder einfach nur

40:23.780 --> 40:27.220
Call Go.

40:27.220 --> 40:29.220
Ich muss nur gucken, dass die Libraries

40:29.220 --> 40:31.220
am Ende dann richtig heißen. Also, das

40:31.220 --> 40:33.220
sucht jetzt nach einer Library, die

40:33.220 --> 40:35.220
RustLib heißt, irgendwo hier im Verzeichnis.

40:35.220 --> 40:37.220
Oder GoLib, die gibt es noch nicht.

40:37.220 --> 40:39.220
Die müssen wir anlegen.

40:39.220 --> 40:41.220
Und dort drin ruft es dann eine

40:41.220 --> 40:43.220
Funktion auf, die heißt Call Go

40:43.220 --> 40:45.220
und Call Rust. Das wird erstmal eine

40:45.220 --> 40:47.220
leere Funktion sein.

40:47.220 --> 40:49.220
Man kann mit C-Sharp DLLs

40:49.220 --> 40:51.220
erstellen, nein, man kann aber

40:51.220 --> 40:53.220
native Funktionen

40:53.220 --> 40:55.220
importieren, beziehungsweise aufrufen, die

40:55.220 --> 40:57.220
in DLLs

40:57.220 --> 40:59.220
oder in unter linux.so

40:59.220 --> 41:01.220
Dateien vorhanden sind.

41:01.220 --> 41:03.220
Also, dynamic

41:03.220 --> 41:07.680
loading. So, und mein

41:07.680 --> 41:09.680
Ziel ist dann sowas zu machen hier.

41:09.680 --> 41:11.680
Interop

41:11.680 --> 41:13.680
Punkt, Call

41:13.680 --> 41:15.680
Interop

41:15.680 --> 41:17.680
Call Rust.

41:17.680 --> 41:19.680
Wenn ich das jetzt aufrufe, wird Folgendes passieren.

41:19.680 --> 41:21.680
Bam!

41:21.680 --> 41:23.680
Er findet nämlich GoLib

41:23.680 --> 41:25.680
und

41:25.680 --> 41:27.680
RustLib nicht.

41:27.680 --> 41:29.680
Ist aber auch klar, die haben wir noch nicht angelegt.

41:29.680 --> 41:31.680
Die gibt es schlicht und ergreifend noch gar nicht.

41:31.680 --> 41:33.680
Ich würde sagen, wir fangen mal mit dem

41:33.680 --> 41:35.680
Go-Teil an. Da weiß ich noch

41:35.680 --> 41:37.680
ungefähr, so ganz grob,

41:37.680 --> 41:39.680
wie es aussehen muss,

41:39.680 --> 41:41.680
dass das funktioniert. Und zwar,

41:41.680 --> 41:43.680
wenn ich das richtig in Erinnerung habe,

41:43.680 --> 41:45.680
muss man jetzt Folgendes machen.

41:45.680 --> 41:47.680
Wir legen jetzt mal in Go was an.

41:47.680 --> 41:49.680
Die Main-Funktion brauchen wir nicht.

41:49.680 --> 41:51.680
Weil wir rufen, wir starten

41:51.680 --> 41:53.680
ja kein Binary, sondern wir

41:53.680 --> 41:55.680
callen FonziSharp in was rein,

41:55.680 --> 41:57.680
was in Go definiert ist. Also, das

41:57.680 --> 41:59.680
ist natürlich auch der Einstiegspunkt.

41:59.680 --> 42:01.680
Nicht Main, sondern der Einstiegspunkt in dem Fall ist

42:01.680 --> 42:03.680
Call Go, weil das ist, was wir aufrufen.

42:03.680 --> 42:05.680
So, wenn ich das noch richtig im Kopf habe,

42:05.680 --> 42:07.680
wie das funktioniert in Go, dann sagt man

42:07.680 --> 42:09.680
hier Function, die

42:09.680 --> 42:11.680
muss heißen Call Go, so wie

42:11.680 --> 42:13.680
hier. Also, so wie da.

42:13.680 --> 42:15.680
Und dann muss man, glaube ich,

42:15.680 --> 42:17.680
drüber schreiben

42:17.680 --> 42:19.680
Export

42:19.680 --> 42:21.680
Call Go. Entweder

42:21.680 --> 42:23.680
mit Leerzeichen, ne, ohne Leerzeichen.

42:23.680 --> 42:25.680
Und ich glaube, so muss man

42:25.680 --> 42:27.680
das machen, dass Go

42:27.680 --> 42:29.680
das als C-Interface exportiert.

42:29.680 --> 42:31.680
Aber das war noch

42:31.680 --> 42:35.180
nicht alles.

42:35.180 --> 42:37.180
Go run, ne, das geht natürlich nicht.

42:37.180 --> 42:41.520
Ähm, oh

42:41.520 --> 42:43.520
Shit. Go kompilieren

42:43.520 --> 42:45.520
als C-Library,

42:45.520 --> 42:47.520
beziehungsweise mit C-Interface. Wie ging das jetzt nochmal?

42:47.520 --> 42:49.520
Oh,

42:49.520 --> 42:51.520
meine Güte. Ähm, muss ich nachgucken.

42:51.520 --> 42:53.520
C Go Compile.

42:53.520 --> 42:58.750
Ach, Import C musste man

42:58.750 --> 43:00.750
auch noch machen. Ja, ja, okay.

43:00.750 --> 43:02.750
Genau, genau. Gut, dass wir in die

43:02.750 --> 43:04.750
Hilfe gucken. Das musste man auch

43:04.750 --> 43:06.750
noch machen am Anfang. Also,

43:06.750 --> 43:08.750
das braucht man,

43:08.750 --> 43:10.750
das braucht man in Go, damit man

43:10.750 --> 43:12.750
aus Go C-Libraries aufrufen kann.

43:12.750 --> 43:14.750
Und das hier braucht man,

43:14.750 --> 43:16.750
damit man aus anderen Sprachen Go

43:16.750 --> 43:18.750
Sachen aufrufen kann, über

43:18.750 --> 43:20.750
ein C-Interface, was generiert wird.

43:20.750 --> 43:22.750
Ich glaube,

43:22.750 --> 43:24.750
man braucht beides, oder?

43:24.750 --> 43:26.750
Egal, schadet auf jeden Fall nix.

43:26.750 --> 43:31.860
Was auch immer

43:31.860 --> 43:33.860
das da jetzt ist,

43:33.860 --> 43:46.960
keine Ahnung.

43:46.960 --> 43:48.960
Äh, what the...

43:48.960 --> 43:50.960
Ich suche

43:50.960 --> 43:52.960
den Go Build Aufruf dafür.

43:52.960 --> 43:57.940
Go Build, man muss irgendwie

43:57.940 --> 43:59.940
C Go Enable oder sowas machen.

43:59.940 --> 44:07.660
Ich hab das noch

44:07.660 --> 44:09.660
im Hinterkopf irgendwie.

44:09.660 --> 44:11.660
Go Build,

44:11.660 --> 44:13.660
ich weiß aber nur nicht mehr, hab ich das vielleicht

44:13.660 --> 44:15.660
hier irgendwo... Ne.

44:15.660 --> 44:17.660
Hab ich das vielleicht in der anderen

44:17.660 --> 44:19.660
VM noch

44:19.660 --> 44:21.660
als History?

44:21.660 --> 44:23.660
Kann GCC auch Go

44:23.660 --> 44:25.660
kompilieren? Ja,

44:25.660 --> 44:27.660
es gibt ein GCC

44:27.660 --> 44:29.660
Plugin für Go, aber das verwendet glaube ich

44:29.660 --> 44:31.660
meines Wissens nach so gut wie niemand.

44:31.660 --> 44:33.660
C Go?

44:33.660 --> 44:35.660
Gleich?

44:35.660 --> 44:37.660
Ah, shit,

44:37.660 --> 44:39.660
haben wir es auch nicht in der History mal drin.

44:39.660 --> 44:43.300
Wie war das denn

44:43.300 --> 44:45.300
jetzt nochmal?

44:45.300 --> 44:47.300
Hier, C Go Enable, genau.

44:47.300 --> 44:51.060
Ganz ehrlich, ich verstehe auch gar nicht,

44:51.060 --> 44:53.060
wozu das gut sein soll. Ja, C Go Enable,

44:53.060 --> 44:55.060
genau, das suche ich. C Go

44:55.060 --> 44:57.060
Enable. Aber

44:57.060 --> 44:59.060
die Frage ist, wie man es jetzt nochmal aufruft.

44:59.060 --> 45:01.060
Env

45:01.060 --> 45:04.370
Go OS Linux?

45:04.370 --> 45:07.740
C Go Enable.

45:07.740 --> 45:12.020
Okay, das

45:12.020 --> 45:14.020
ging irgendwie so. C...

45:14.020 --> 45:16.020
Es ist auf jeden Fall Env.

45:16.020 --> 45:18.020
C Go

45:18.020 --> 45:20.020
Enable

45:20.020 --> 45:22.020
gleich 1

45:22.020 --> 45:24.020
und dann sagt man glaube ich einfach Go Build?

45:24.020 --> 45:27.970
Ne.

45:27.970 --> 45:29.970
Aber ich bin ja auch falsch hier.

45:29.970 --> 45:31.970
Ich muss ja auch in mein Go Projekt.

45:31.970 --> 45:33.970
Ja, das wird jetzt ein bisschen abartig,

45:33.970 --> 45:38.880
bis das funktioniert.

45:38.880 --> 45:40.880
Im Moment halt einfach funktioniert gerade.

45:40.880 --> 45:45.980
Nein,

45:45.980 --> 45:47.980
das ist falsch.

45:47.980 --> 45:49.980
Der soll das als Library kompilieren.

45:49.980 --> 45:51.980
Äh,

45:51.980 --> 45:53.980
Build Mode, oh meine Güte, wie geht das?

45:53.980 --> 45:55.980
Go Shared

45:55.980 --> 45:57.980
Shared

45:57.980 --> 45:59.980
Library

45:59.980 --> 46:05.280
Shared Libraries in Go,

46:05.280 --> 46:07.280
how to use? Go Shared Libraries

46:07.280 --> 46:09.280
Ne, ne, ne, ne.

46:09.280 --> 46:11.280
Building

46:11.280 --> 46:13.280
Shared Libraries in Go.

46:13.280 --> 46:17.550
Genau, wie ging das nochmal?

46:17.550 --> 46:19.550
Ich hab das, das ist ja manchmal

46:19.550 --> 46:21.550
in der History gar nicht so gut.

46:21.550 --> 46:23.550
Weil,

46:23.550 --> 46:25.550
wenn man dann seine History nicht hat,

46:25.550 --> 46:27.550
hier,

46:27.550 --> 46:29.550
Build Mode gleich C Shared

46:29.550 --> 46:31.550
minus O Preload, ich hab keine Ahnung,

46:31.550 --> 46:33.550
was das bedeuten soll. Ich lass das einfach mal weg.

46:33.550 --> 46:35.550
Was?

46:35.550 --> 46:44.430
Okay, was auch immer.

46:44.430 --> 46:46.430
Also wahrscheinlich brauchen wir

46:46.430 --> 46:48.430
jetzt noch das hier dabei.

46:48.430 --> 46:50.430
Ach ne, das muss hier bei

46:50.430 --> 46:57.460
Go Build hin.

46:57.460 --> 46:59.460
Ja, schon besser, schon besser.

46:59.460 --> 47:03.090
Aber wo ist meine Library?

47:03.090 --> 47:07.170
Ach, Go App ist die Library.

47:07.170 --> 47:09.170
Okay, das Ding soll heißen,

47:09.170 --> 47:11.170
ach dem ist ja,

47:11.170 --> 47:13.170
ach, okay, also,

47:13.170 --> 47:20.030
äh,

47:20.030 --> 47:25.010
wenn ich,

47:25.010 --> 47:27.010
Moment, warum ist der Aufruf nicht in meiner History drin?

47:27.010 --> 47:29.010
What the?

47:31.010 --> 47:33.010
Ach so, weil ein Leerzeichen davor war.

47:33.010 --> 47:35.010
Lul.

47:35.010 --> 47:37.010
Ja, na, dann ist klar,

47:37.010 --> 47:39.010
dass das nicht drin steht.

47:39.010 --> 47:41.010
Minus O,

47:41.010 --> 47:43.010
der Output soll sein,

47:43.010 --> 47:45.010
wie hab ich das genannt in .NET?

47:45.010 --> 47:51.460
Golib.

47:51.460 --> 47:53.460
Golib.so

47:53.460 --> 47:57.920
Ja,

47:57.920 --> 47:59.920
sehr schön, genau, genau, genau, genau.

47:59.920 --> 48:01.920
So will ich das haben.

48:01.920 --> 48:03.920
Okay, Golib.so

48:03.920 --> 48:05.920
soll er bauen und dann

48:05.920 --> 48:07.920
soll er das Ganze moven,

48:07.920 --> 48:09.920
Golib.so

48:09.920 --> 48:11.920
moven hoch in das C Sharp

48:11.920 --> 48:16.770
Projekt.

48:16.770 --> 48:18.770
Golib.so, okay, nice.

48:18.770 --> 48:20.770
So, wenn ich Glück hab,

48:20.770 --> 48:22.770
klappt das jetzt schon.

48:22.770 --> 48:24.770
Fuck.

48:24.770 --> 48:26.770
Cannot open.

48:26.770 --> 48:30.660
Ah, ich weiß warum.

48:30.660 --> 48:32.660
Weil ich pp-ger bin.

48:32.660 --> 48:34.660
Ich muss die

48:34.660 --> 48:36.660
Build Action noch umstellen, dass der das

48:36.660 --> 48:38.660
ins Output Directory kopiert.

48:38.660 --> 48:40.660
Und jetzt scrollt's, präge Leute, präge.

48:40.660 --> 48:42.660
Ey,

48:42.660 --> 48:44.660
es funzt, es funzt.

48:44.660 --> 48:46.660
Ich kann euch auch beweisen, dass es funzt.

48:46.660 --> 48:48.660
Guckt mal, wir schreiben jetzt hier was

48:48.660 --> 48:50.660
in Go rein, okay?

48:50.660 --> 48:52.660
fmt, prindeln, lul,

48:52.660 --> 48:54.660
kompilieren das,

48:54.660 --> 48:56.660
und jetzt ruf ich's aus C Sharp

48:56.660 --> 48:58.660
auf,

48:58.660 --> 49:00.660
lul.

49:00.660 --> 49:02.660
Und ihr seht hier nirgends wo in C Sharp ist lul definiert,

49:02.660 --> 49:04.660
oder lul, die Ausgabe, die kommt aus Go.

49:04.660 --> 49:06.660
Also jetzt callt, jetzt callt

49:06.660 --> 49:12.400
C Sharp nach Go rein.

49:12.400 --> 49:16.540
Das ist nice.

49:16.540 --> 49:18.540
Wie mach ich in

49:18.540 --> 49:20.540
Chat, wie mach ich denn in Go

49:20.540 --> 49:22.540
ein Release Build?

49:22.540 --> 49:24.540
Ist das standardmäßig ein Release Build?

49:24.540 --> 49:35.340
Nee, nee, C Go

49:35.340 --> 49:37.340
brauch ich, auf jeden Fall.

49:37.340 --> 49:39.340
Weil ich will gleich noch versuchen,

49:39.340 --> 49:41.340
wie das ist, ob man auch in Struct returnen kann

49:41.340 --> 49:46.380
und sowas.

49:46.380 --> 49:49.760
Ähm, äh, was hab ich grade gesagt?

49:49.760 --> 49:51.760
Was wollt ich grade machen?

49:51.760 --> 49:53.760
Jetzt hab ich grad an was anderes gedacht, lul.

49:53.760 --> 49:55.760
Jetzt weiß ich, was ich grad machen wollt. Ähm,

49:55.760 --> 50:00.160
Chat, was hab ich vor zwei Sekunden gesagt?

50:00.160 --> 50:02.160
Oh, du aller Boomer hier, Mann.

50:02.160 --> 50:04.160
Achso, Release Build, ja.

50:04.160 --> 50:06.160
Achso, Release Build. Go, Build,

50:06.160 --> 50:08.160
Release.

50:08.160 --> 50:10.160
Auto Build.

50:10.160 --> 50:23.360
Achso.

50:23.360 --> 50:25.360
Strip Debug Symbols. Nö, nö, nö, nö.

50:25.360 --> 50:28.990
Ach, okay, es gibt gar kein

50:28.990 --> 50:30.990
Debug und Release Build bei Go. Gibt es nur,

50:30.990 --> 50:32.990
gibt es nur Release Builds, quasi.

50:32.990 --> 50:38.610
Was für eine Linungsliste

50:38.610 --> 50:40.610
ist drüber zugenommen? Das ist Arch, by the way.

50:40.610 --> 50:42.610
Wenn du es genau wissen willst,

50:42.610 --> 50:44.610
dafür hab ich natürlich schon mal mein Neo

50:44.610 --> 50:46.610
Fetch vorbereitet, damit ich euch regelmäßig

50:46.610 --> 50:48.610
sagen kann, dass ich Arch Linungs verwende.

50:48.610 --> 50:50.610
Das ist Arch Linungs, allerdings in der

50:50.610 --> 50:52.610
VM. Und

50:52.610 --> 50:54.610
das Terminal ist West Term.

50:54.610 --> 50:56.610
Das ist die 3 als

50:56.610 --> 50:58.610
Window Manager und ZSH

50:58.610 --> 51:00.610
als Shell.

51:00.610 --> 51:02.610
Wenn's dich

51:02.610 --> 51:04.610
genau interessiert, wie das alles konfiguriert

51:04.610 --> 51:06.610
ist und funktioniert, kannst du auf

51:06.610 --> 51:08.610
GitHub gucken, hier ist meine ganze

51:08.610 --> 51:12.110
Konfig. Und wenn du grad dabei

51:12.110 --> 51:14.110
bist, kann ich dir empfehlen,

51:14.110 --> 51:16.110
schnapp dir auch noch gleich die passenden Desktop

51:16.110 --> 51:18.110
Hintergründe,

51:18.110 --> 51:20.110
dass du auch

51:20.110 --> 51:22.110
White Paper Happy hast,

51:22.110 --> 51:34.900
im Hintergrund, so wie ich.

51:34.900 --> 51:36.900
Was ist One Fetch?

51:36.900 --> 51:38.900
Is One Fetch die coolere Neo

51:38.900 --> 51:40.900
Fetch Variante

51:40.900 --> 51:42.900
oder was?

51:42.900 --> 51:44.900
Command Line Git Information Tool.

51:44.900 --> 51:53.360
Was ist das?

51:53.360 --> 51:55.360
Written in Rust, natürlich!

51:55.360 --> 51:57.360
Die Krustentiere sind wieder am Start.

51:57.360 --> 52:03.490
Ach, da kriegt man

52:03.490 --> 52:05.490
Infos über das Repo angezeigt.

52:05.490 --> 52:07.490
Ja, das ist doch eigentlich auch ganz cool.

52:07.490 --> 52:13.550
So.

52:13.550 --> 52:15.550
Also das Call nach

52:15.550 --> 52:17.550
Go Code funktioniert schon einmal.

52:17.550 --> 52:19.550
So,

52:19.550 --> 52:21.550
wir können jetzt natürlich noch sagen, .NET

52:21.550 --> 52:23.550
Run minus

52:23.550 --> 52:25.550
C Release, dass es auch im Release Mode

52:25.550 --> 52:27.550
läuft, aber funzt.

52:27.550 --> 52:29.550
Gut, also erster Part

52:29.550 --> 52:31.550
ist geschafft.

52:31.550 --> 52:33.550
Jetzt könnt ihr euch aussuchen,

52:33.550 --> 52:35.550
Chat, ob wir als erstes

52:35.550 --> 52:37.550
den Go Part

52:37.550 --> 52:39.550
vollständig bauen, also vollständig

52:39.550 --> 52:41.550
bauen bedeutet zwei Sachen.

52:41.550 --> 52:43.550
Leider nicht aus Go die nächste

52:43.550 --> 52:45.550
Programmiersprache callen, aus C Sharp die nächste

52:45.550 --> 52:47.550
Programmiersprache callen.

52:47.550 --> 52:49.550
Also, was ich

52:49.550 --> 52:51.550
in den Sprachen machen will,

52:51.550 --> 52:53.550
ich will zwei Sachen jeweils in den Sprachen einbauen.

52:53.550 --> 52:55.550
Und zwar, das erste ist,

52:55.550 --> 52:57.550
eine leere Funktion, die wir aufrufen können.

52:57.550 --> 52:59.550
In dem Fall kommt das mit dem 0 wieder raus,

52:59.550 --> 53:01.550
weil ich will nicht 500 mal 0 ausgeben.

53:01.550 --> 53:03.550
Und

53:03.550 --> 53:05.550
das zweite ist eine Funktion, die

53:05.550 --> 53:07.550
nennen wir einfach hier irgendwie Call Go 2

53:07.550 --> 53:09.550
und die soll ein Struct

53:09.550 --> 53:11.550
returnen.

53:11.550 --> 53:13.550
Und da bin ich mal gespannt, wie ich das

53:13.550 --> 53:15.550
mache, ein Struct

53:15.550 --> 53:17.550
von Go zu returnen in C Sharp,

53:17.550 --> 53:19.550
was man dann dort

53:19.550 --> 53:21.550
auch als Struct quasi

53:21.550 --> 53:23.550
deserialisieren kann und benutzen kann.

53:23.550 --> 53:25.550
Das einfachste wäre natürlich alle seine Daten

53:25.550 --> 53:27.550
irgendwie als JSON String zu returnen

53:27.550 --> 53:29.550
und dann parsen, aber das ist ja langweilig.

53:29.550 --> 53:31.550
Wir wollen das ja richtig auf C eben

53:31.550 --> 53:33.550
Memory Bytes

53:33.550 --> 53:36.860
dann

53:36.860 --> 53:38.860
Casten zu irgendeinem Struct.

53:38.860 --> 53:40.860
Da bin ich mal gespannt, wie das geht, ich hab keinen Plan.

53:40.860 --> 53:42.860
Ne, auch nicht gRPC,

53:42.860 --> 53:44.860
das ist wirklich richtig, richtig Low Level Memory

53:44.860 --> 53:46.860
hin und her schieben soll das sein.

53:46.860 --> 53:48.860
So.

53:48.860 --> 53:50.860
Also ihr könnt euch jetzt aussuchen, wollen wir jetzt den

53:50.860 --> 53:52.860
Go Part noch implementieren, also sprich

53:52.860 --> 53:54.860
die Funktion in Go, die

53:54.860 --> 53:56.860
den Struct zurückliefert an C Sharp

53:56.860 --> 53:58.860
oder wollen wir jetzt erstmal gucken,

53:58.860 --> 54:00.860
wie man Rust

54:00.860 --> 54:02.860
callen kann von C Sharp aus.

54:02.860 --> 54:04.860
Könnt ihr euch aussuchen.

54:04.860 --> 54:12.850
War was? Rust,

54:12.850 --> 54:16.800
erstmal Go fertig.

54:16.800 --> 54:18.800
Go fertig. Go.

54:18.800 --> 54:20.800
Okay.

54:20.800 --> 54:22.800
Also, Tommy,

54:22.800 --> 54:24.800
die meisten Leute wollen Go haben.

54:24.800 --> 54:26.800
Ich denke nicht, dass das so lang

54:26.800 --> 54:28.800
dauert, wobei ich das noch nicht gemacht hab.

54:28.800 --> 54:30.800
Structs returnen

54:30.800 --> 54:32.800
von Go nach C Sharp.

54:32.800 --> 54:34.800
Ich würde sagen, wir fangen mal easy

54:34.800 --> 54:36.800
an, okay? Wir fangen mal easy

54:36.800 --> 54:38.800
an. Easy heißt,

54:38.800 --> 54:40.800
wir returnen hier jetzt ein

54:40.800 --> 54:42.800
Moment.

54:42.800 --> 54:44.800
Wie ging das nochmal?

54:44.800 --> 54:46.800
Ich glaube einfach

54:46.800 --> 54:48.800
sagen wir mal

54:48.800 --> 54:50.800
in den UN64

54:50.800 --> 54:55.970
returnen wir jetzt hier mal.

54:55.970 --> 54:57.970
So. Und jetzt sagen wir hier

54:57.970 --> 54:59.970
return 1.

54:59.970 --> 55:01.970
Mein einfacher geht's nicht mehr, okay?

55:01.970 --> 55:03.970
Return 1, kompiliert auch ohne

55:03.970 --> 55:05.970
Fehler. Und jetzt ist die Frage,

55:05.970 --> 55:07.970
das dürfte ziemlich easy

55:07.970 --> 55:09.970
sein. Jetzt gehe ich hier einfach hin,

55:09.970 --> 55:11.970
ich kommentiere mal das Rusting aus.

55:11.970 --> 55:13.970
Jetzt ist der return-Typ nicht

55:13.970 --> 55:15.970
void, sondern der return-Typ ist UN64.

55:15.970 --> 55:17.970
Das Ding ist nur, ich

55:17.970 --> 55:19.970
hab keine Ahnung, ob die

55:19.970 --> 55:21.970
Repräsentation im Speicher

55:21.970 --> 55:23.970
von einem C Sharp UN und einem

55:23.970 --> 55:25.970
C

55:25.970 --> 55:27.970
aus Go exportierten

55:27.970 --> 55:29.970
C UN die gleiche

55:29.970 --> 55:31.970
ist. Moment, geht das überhaupt so?

55:31.970 --> 55:33.970
Das geht doch

55:33.970 --> 55:35.970
eigentlich gar nicht. Ich will ja kein

55:35.970 --> 55:37.970
Rust UN exportieren,

55:37.970 --> 55:39.970
sondern ein C

55:39.970 --> 55:41.970
UN 64.

55:41.970 --> 55:43.970
Also es könnte sein, dass

55:43.970 --> 55:45.970
das funktioniert, wenn die

55:45.970 --> 55:47.970
Implementierungen einfach überall gleich sind.

55:47.970 --> 55:49.970
Probieren wir das mal

55:49.970 --> 55:51.970
aus, aber ich glaube nicht, dass das

55:51.970 --> 55:53.970
funktioniert. Machen wir mal I.

55:53.970 --> 55:55.970
Ups. Hä?

55:55.970 --> 55:59.540
Da sollte jetzt

55:59.540 --> 56:01.540
1 rauskommen. 1. Okay.

56:01.540 --> 56:03.540
Das funktioniert, aber ich glaube ganz

56:03.540 --> 56:05.540
korrekt ist das nicht.

56:05.540 --> 56:07.540
Das funktioniert wirklich nur,

56:07.540 --> 56:09.540
weil das Memory-Layout von einem

56:09.540 --> 56:11.540
UN 64 einfach in C Sharp

56:11.540 --> 56:13.540
und Go gleich ist.

56:13.540 --> 56:15.540
Ich glaube korrekt wäre

56:15.540 --> 56:17.540
hier gewesen zu returnen ein

56:17.540 --> 56:19.540
C Punkt UN 64

56:19.540 --> 56:21.540
oder sowas.

56:21.540 --> 56:23.540
Gibt es nicht. Ne, wie

56:23.540 --> 56:25.540
heißt das? T oder so, gell?

56:25.540 --> 56:27.540
Heißt das so? Ne, ah man.

56:27.540 --> 56:29.540
UN 64

56:29.540 --> 56:31.540
C. Wie heißt der Kram?

56:31.540 --> 56:36.190
UN

56:36.190 --> 56:38.190
64 T.

56:38.190 --> 56:44.640
Hab ich doch.

56:44.640 --> 56:46.640
Gibt es nicht.

56:46.640 --> 56:48.640
Was muss ich denn da inkluden dafür?

56:48.640 --> 56:53.620
Standard

56:53.620 --> 56:55.620
Int, Moment, was?

56:55.620 --> 57:00.340
std

57:00.340 --> 57:02.340
int.h, okay.

57:02.340 --> 57:04.340
Hey, Funst! Nice!

57:04.340 --> 57:06.340
Stack Overflow Triff and Copy Pasting.

57:06.340 --> 57:10.030
Okay, also einzelne

57:10.030 --> 57:12.030
Ints returnen von Go nach C.

57:12.030 --> 57:14.030
Vor allem nach, von

57:14.030 --> 57:16.030
Go

57:16.030 --> 57:18.030
über C nach C Sharp. Funst?

57:18.030 --> 57:22.820
Jetzt ist die Frage,

57:22.820 --> 57:24.820
wie machen wir das mit einem Struct?

57:24.820 --> 57:26.820
Das wird bestimmt etwas

57:26.820 --> 57:28.820
komplizierter.

57:28.820 --> 57:30.820
Könnte ich mir vorstellen, weil

57:30.820 --> 57:32.820
wir brauchen ja einen

57:32.820 --> 57:34.820
C Struct, kein Go Struct.

57:34.820 --> 57:36.820
Okay,

57:36.820 --> 57:38.820
Go Struct to C

57:38.820 --> 57:40.820
Struct.

57:40.820 --> 57:45.410
Layouts sind in C Sharp

57:45.410 --> 57:47.410
recht easy.

57:47.410 --> 57:49.410
Wenn du dem sagst, dass er

57:51.410 --> 57:53.410
wie heißt das?

57:53.410 --> 57:55.410
Serialisieren soll,

57:55.410 --> 57:57.410
dann ist es das gleiche Layout wie von C.

57:57.410 --> 57:59.410
Dann ist das eigentlich kein Ding.

57:59.410 --> 58:05.660
Hoff ich mal.

58:05.660 --> 58:07.660
Genau, genau, das meine ich.

58:07.660 --> 58:09.660
Damit ist das

58:09.660 --> 58:11.660
meistens nicht so ein großes Problem.

58:11.660 --> 58:13.660
Go Lang Struct

58:13.660 --> 58:15.660
with C Struct in C.

58:15.660 --> 58:30.880
Okay, okay, okay.

58:30.880 --> 58:32.880
Nee, der hat einen

58:32.880 --> 58:34.880
Go Struct

58:34.880 --> 58:36.880
mit C Types drinnen.

58:36.880 --> 58:38.880
Das will ich nicht.

58:38.880 --> 58:40.880
Okay, C Go

58:40.880 --> 58:45.920
Return Struct.

58:45.920 --> 58:47.920
How to return Struct

58:47.920 --> 58:49.920
from C Go?

58:49.920 --> 58:51.920
Ja, genau, das will ich haben.

58:51.920 --> 58:56.130
I have found a solution

58:56.130 --> 59:02.060
in C.

59:02.060 --> 59:07.040
Okay, der definiert ein Struct in C.

59:07.040 --> 59:09.040
Gibt es nicht C Pack Unpack?

59:09.040 --> 59:11.040
Ich hab keine Ahnung.

59:11.040 --> 59:26.960
Go C Pack?

59:26.960 --> 59:28.960
How to return a C Struct from a Go Function?

59:28.960 --> 59:30.960
Genau das will ich wissen.

59:30.960 --> 59:32.960
Okay, Struct Point.

59:32.960 --> 59:34.960
Ich muss das in C definieren

59:34.960 --> 59:41.020
auf jeden Fall.

59:41.020 --> 59:43.020
To access a Struct Type

59:43.020 --> 59:45.020
directly.

59:45.020 --> 59:47.020
Prefix it with Struct Underscore.

59:47.020 --> 59:49.020
Okay.

59:49.020 --> 59:51.020
C Punkt Struct Underscore.

59:51.020 --> 59:53.020
Oh meine Güte.

59:53.020 --> 59:57.100
Jetzt wird es aber Pepega Style.

59:57.100 --> 59:59.100
Also ich glaube, das wird in Rust

59:59.100 --> 01:00:01.100
deutlich angenehmer sein.

01:00:01.100 --> 01:00:03.100
Als in Go.

01:00:03.100 --> 01:00:05.100
Also sprich, wir brauchen jetzt...

01:00:05.100 --> 01:00:07.100
Nee, Moment.

01:00:07.100 --> 01:00:09.100
So.

01:00:09.100 --> 01:00:11.100
Und das muss, soweit ich weiß,

01:00:11.100 --> 01:00:13.100
dann auch direkt über Import C stehen.

01:00:13.100 --> 01:00:15.100
Sonst mag er nicht.

01:00:15.100 --> 01:00:20.270
Die Includes können wir dann hier rein machen.

01:00:20.270 --> 01:00:28.190
Massive Pepega.

01:00:28.190 --> 01:00:30.190
So, jetzt haben wir einen Struct Point.

01:00:30.190 --> 01:00:32.190
Wir wollen allerdings nicht Point Return.

01:00:32.190 --> 01:00:34.190
Wir wollen ein Struct...

01:00:34.190 --> 01:00:36.190
Okay, machen wir einfach mal sowas hier.

01:00:36.190 --> 01:00:38.190
Struct Session

01:00:38.190 --> 01:00:40.190
hat eine...

01:00:40.190 --> 01:00:42.190
Wir machen mal was, was von später

01:00:42.190 --> 01:00:44.190
auch sinnvoll irgendwie...

01:00:44.190 --> 01:00:46.190
Das einmal gibt es hier ein

01:00:46.190 --> 01:00:49.630
Int.

01:00:49.630 --> 01:00:51.630
Oder ein

01:00:51.630 --> 01:00:53.630
U

01:00:53.630 --> 01:00:55.630
Int. Machen wir es mal so.

01:00:55.630 --> 01:00:57.630
Ein U Int 64 T.

01:00:57.630 --> 01:01:01.200
Client ID.

01:01:01.200 --> 01:01:04.900
Und dann

01:01:04.900 --> 01:01:06.900
gibt es... Oh, jetzt wird es interessant.

01:01:06.900 --> 01:01:08.900
Jetzt gibt es einen String.

01:01:08.900 --> 01:01:10.900
Den nennen wir...

01:01:10.900 --> 01:01:12.900
Keine Ahnung. Name. Oder so.

01:01:12.900 --> 01:01:14.900
Ja. Client Name.

01:01:14.900 --> 01:01:16.900
Jetzt bin ich mal

01:01:16.900 --> 01:01:18.900
gespannt, wie ich

01:01:18.900 --> 01:01:20.900
einen Struct mit einem

01:01:20.900 --> 01:01:22.900
Char Pointer

01:01:22.900 --> 01:01:24.900
irgendwie rüberkriege in C Sharp.

01:01:24.900 --> 01:01:26.900
Ohne,

01:01:26.900 --> 01:01:28.900
wohlgemerkt, ohne

01:01:28.900 --> 01:01:33.230
Memory Leaks zu verursachen.

01:01:33.230 --> 01:01:35.230
Das wird...

01:01:35.230 --> 01:01:37.230
Ohje.

01:01:37.230 --> 01:01:39.230
Ich weiß leider mal,

01:01:39.230 --> 01:01:41.230
wie ich das über... Okay. Return.

01:01:41.230 --> 01:01:43.230
Also wie ging das jetzt? C Punkt

01:01:43.230 --> 01:01:45.230
Struct Underscore

01:01:45.230 --> 01:01:47.230
und dann Session

01:01:47.230 --> 01:01:49.230
Und jetzt durfte ich

01:01:49.230 --> 01:01:51.230
das so benennen mit

01:01:51.230 --> 01:01:53.230
ähm...

01:01:53.230 --> 01:01:55.230
Client Name

01:01:55.230 --> 01:01:57.230
Ich weiß überhaupt nicht, wie ist die Syntax?

01:01:57.230 --> 01:02:01.180
X. Ah, die Variable

01:02:01.180 --> 01:02:03.180
Variable zuerst. Okay.

01:02:03.180 --> 01:02:07.140
Ja. Ja, Tommy.

01:02:07.140 --> 01:02:09.140
Also Client ID. So.

01:02:09.140 --> 01:02:11.140
Das ist jetzt ein C Char

01:02:11.140 --> 01:02:13.140
Array oder so.

01:02:13.140 --> 01:02:15.140
Ich hoffe,

01:02:15.140 --> 01:02:17.140
dass... Nee.

01:02:17.140 --> 01:02:19.140
Nee, nee. Das fand ich schon mal nett.

01:02:19.140 --> 01:02:21.140
Ohje.

01:02:21.140 --> 01:02:23.140
Wie ist das Syntaktisch denn richtig?

01:02:23.140 --> 01:02:25.140
Nee, das ist eigentlich okay so.

01:02:25.140 --> 01:02:29.340
Und dann haben wir noch was.

01:02:29.340 --> 01:02:31.340
Ich weiß das... Moment. Client ID.

01:02:31.340 --> 01:02:33.340
Client ID ist 123.

01:02:33.340 --> 01:02:35.340
Und dann haben wir noch Client Name.

01:02:35.340 --> 01:02:37.340
Client Name ist dann...

01:02:37.340 --> 01:02:39.340
Das wird so definitiv nicht

01:02:39.340 --> 01:02:41.340
funktionieren, Leute. Das kann ich euch... Das kann ich euch sagen.

01:02:41.340 --> 01:02:43.340
Das wird nicht funktionieren.

01:02:43.340 --> 01:02:50.560
Okay. Das funktioniert schon mal nett.

01:02:50.560 --> 01:02:52.560
Also.

01:02:52.560 --> 01:02:54.560
Das ist falsch, weil das ist ja auch

01:02:54.560 --> 01:02:56.560
ein U Int.

01:02:56.560 --> 01:02:58.560
Also das hier muss ja auch

01:02:58.560 --> 01:03:00.560
ein sowas hier sein.

01:03:00.560 --> 01:03:02.560
Moment. Meine

01:03:02.560 --> 01:03:04.560
Go Skills verlassen mich. Ich glaube, das geht so,

01:03:04.560 --> 01:03:06.560
dass das

01:03:06.560 --> 01:03:08.560
funktioniert.

01:03:08.560 --> 01:03:10.560
Ja. Nee.

01:03:10.560 --> 01:03:12.560
Achso.

01:03:12.560 --> 01:03:14.560
Moment. Ich return ja gar kein Struct.

01:03:14.560 --> 01:03:16.560
Ich will das hier returnen.

01:03:16.560 --> 01:03:21.790
Okay. Schon besser.

01:03:21.790 --> 01:03:23.790
Schon besser. Hätte ich es auch einfach

01:03:23.790 --> 01:03:25.790
so returnen können, ohne dass der rummeckert?

01:03:25.790 --> 01:03:27.790
Anscheinend.

01:03:27.790 --> 01:03:29.790
So. Also das funktioniert nicht.

01:03:29.790 --> 01:03:31.790
Ich muss jetzt einen...

01:03:31.790 --> 01:03:33.790
Charakter Array

01:03:33.790 --> 01:03:35.790
in Go machen. Okay.

01:03:35.790 --> 01:03:37.790
Äh.

01:03:37.790 --> 01:03:39.790
C String

01:03:39.790 --> 01:03:41.790
C Go Return. Wie funzt das?

01:03:41.790 --> 01:03:43.790
Return Strings

01:03:43.790 --> 01:03:45.790
C Function in Go legen.

01:03:45.790 --> 01:03:47.790
C Punkt

01:03:47.790 --> 01:03:49.790
C String.

01:03:49.790 --> 01:03:51.790
Was ich mache?

01:03:51.790 --> 01:03:53.790
Ich rufe aus C Sharp Go

01:03:53.790 --> 01:03:55.790
auf über ein C Interface.

01:03:55.790 --> 01:03:57.790
Also machen wir es

01:03:57.790 --> 01:03:59.790
irgendwie sowas wie

01:03:59.790 --> 01:04:01.790
Let String

01:04:01.790 --> 01:04:03.790
C String

01:04:03.790 --> 01:04:05.790
Moment. Let. Wir sind...

01:04:05.790 --> 01:04:07.790
Achso.

01:04:07.790 --> 01:04:09.790
Nee. Go.

01:04:09.790 --> 01:04:11.790
Nee. Moment.

01:04:11.790 --> 01:04:13.790
Zu viele Programmiersprachen auf einmal.

01:04:13.790 --> 01:04:15.790
So, oder?

01:04:23.650 --> 01:04:25.650
Okay.

01:04:25.650 --> 01:04:27.650
Leute. Es kompiliert.

01:04:27.650 --> 01:04:29.650
Okay.

01:04:29.650 --> 01:04:31.650
Client Name ist Omega Lul

01:04:31.650 --> 01:04:33.650
Keckel HD

01:04:33.650 --> 01:04:35.650
XYZ 123.

01:04:35.650 --> 01:04:37.650
Könnte ein geiles Passwort sein. Das ist es aber nicht.

01:04:37.650 --> 01:04:41.660
Okay. Jetzt returne

01:04:41.660 --> 01:04:43.660
ich ein Struct aus Go.

01:04:43.660 --> 01:04:45.660
Heißt im Endeffekt, wenn ich

01:04:45.660 --> 01:04:47.660
das hier aufrufe, das sollte noch funktionieren.

01:04:47.660 --> 01:04:49.660
Weil das erst... Okay.

01:04:49.660 --> 01:04:51.660
Das ist schon mal gut.

01:04:51.660 --> 01:04:53.660
123 ist die Client ID, die ich hier gesetzt habe.

01:04:53.660 --> 01:04:55.660
Das funzt, weil in meinem Struct

01:04:55.660 --> 01:04:57.660
vorne immer noch

01:04:57.660 --> 01:04:59.660
die Client ID ist. Jetzt ist die große Preisfrage.

01:04:59.660 --> 01:05:01.660
Wie kriege ich hier raus

01:05:01.660 --> 01:05:03.660
ein Struct?

01:05:03.660 --> 01:05:05.660
Also machen wir mal.

01:05:05.660 --> 01:05:07.660
Das nennen wir auch Session.

01:05:07.660 --> 01:05:09.660
Public

01:05:09.660 --> 01:05:11.660
Uint64

01:05:11.660 --> 01:05:13.660
Tja.

01:05:13.660 --> 01:05:15.660
Client ID. Wir nennen das mal genauso.

01:05:15.660 --> 01:05:17.660
Public

01:05:17.660 --> 01:05:19.660
String

01:05:19.660 --> 01:05:21.660
Das kann ich mir so nicht

01:05:21.660 --> 01:05:23.660
vorstellen, dass das funktioniert.

01:05:23.660 --> 01:05:25.660
Und selbst wenn es funktioniert,

01:05:25.660 --> 01:05:27.660
passiert Memory Leaks.

01:05:27.660 --> 01:05:29.660
Das werden wir jetzt mal ausprobieren.

01:05:29.660 --> 01:05:31.660
Mal gucken, ob das

01:05:31.660 --> 01:05:33.660
C Sharp Interop

01:05:33.660 --> 01:05:35.660
Zeug so schlau ist

01:05:35.660 --> 01:05:37.660
und erkennt, dass man ja aus einem

01:05:37.660 --> 01:05:39.660
C String

01:05:39.660 --> 01:05:43.360
ein C Sharp String machen kann.

01:05:43.360 --> 01:05:45.360
Automatisch. Da bin ich mal gespannt.

01:05:45.360 --> 01:05:47.360
So und das Ding soll heißen

01:05:47.360 --> 01:05:49.360
Client Name. Übrigens, die Namen hier

01:05:49.360 --> 01:05:51.360
sind vollkommen egal.

01:05:51.360 --> 01:05:53.360
Die Namen sind vollkommen wurscht.

01:05:53.360 --> 01:05:55.360
Die müssen nicht die gleichen sein wie hier.

01:05:55.360 --> 01:05:57.360
Wichtig ist, die Byte Anzahl.

01:05:57.360 --> 01:05:59.360
Also dass das hier

01:05:59.360 --> 01:06:01.360
quasi so lang ist

01:06:01.360 --> 01:06:03.360
und das hier so lang ist und

01:06:03.360 --> 01:06:05.360
dass es dann passt im Endeffekt.

01:06:05.360 --> 01:06:07.360
Wie das hier heißt, ist vollkommen egal.

01:06:07.360 --> 01:06:09.360
Also das Layout im Speicher muss das gleiche sein.

01:06:09.360 --> 01:06:11.360
So und jetzt returnen

01:06:11.360 --> 01:06:13.360
wir hiervon kein Uint, sondern

01:06:13.360 --> 01:06:15.360
eine Session.

01:06:15.360 --> 01:06:17.360
Das funktioniert nicht, weil es nicht public ist.

01:06:17.360 --> 01:06:22.400
Okay. Session.

01:06:22.400 --> 01:06:26.350
Jetzt bin ich mal gespannt.

01:06:26.350 --> 01:06:28.350
Jetzt bin ich mal gespannt.

01:06:28.350 --> 01:06:30.350
Client ID. Ich hoffe,

01:06:30.350 --> 01:06:32.350
das geht noch. Okay, das funzt.

01:06:32.350 --> 01:06:34.350
Okay, das funzt.

01:06:34.350 --> 01:06:36.350
Was ist hier? Warum kann ich

01:06:36.350 --> 01:06:38.350
kein Konsole

01:06:38.350 --> 01:06:40.350
PPGA IDE gerade

01:06:40.350 --> 01:06:44.690
Client Name.

01:06:44.690 --> 01:06:50.110
Funzt einfach. Es funktioniert einfach.

01:06:50.110 --> 01:06:52.110
Moment.

01:06:52.110 --> 01:06:54.110
Der erkennt automatisch.

01:06:54.110 --> 01:06:56.110
Der weiß automatisch, wie man

01:06:56.110 --> 01:06:58.110
einen C String in einen C Sharp String

01:06:58.110 --> 01:07:00.110
Aber das hat 100

01:07:00.110 --> 01:07:02.110
pro Memory Leaks. Das hat

01:07:02.110 --> 01:07:04.110
sowas von Memory Leaks, Leute. Ich sag's euch.

01:07:04.110 --> 01:07:06.110
100 pro hat es

01:07:06.110 --> 01:07:08.110
Memory Leaks. Moment. Moment.

01:07:08.110 --> 01:07:10.110
Watch 3 minus

01:07:10.110 --> 01:07:12.110
H. Wir machen jetzt die simpelste

01:07:12.110 --> 01:07:14.110
Variante Memory Leaks zu erkennen.

01:07:14.110 --> 01:07:16.110
Passt mal auf. Wir machen jetzt folgendes.

01:07:16.110 --> 01:07:18.110
Wir gucken jetzt

01:07:18.110 --> 01:07:20.110
mal, ob es Memory Leaks hat.

01:07:20.110 --> 01:07:22.110
While true.

01:07:22.110 --> 01:07:24.110
While lulw.

01:07:24.110 --> 01:07:27.490
Okay. So.

01:07:27.490 --> 01:07:29.490
Wir gucken, ob es Memory

01:07:29.490 --> 01:07:31.490
Leaks hat. Wir rufen es einfach in der Schleife

01:07:31.490 --> 01:07:33.490
auf und gucken, ob

01:07:33.490 --> 01:07:37.630
Free runtergeht.

01:07:37.630 --> 01:07:41.460
Run. Oh, shit.

01:07:41.460 --> 01:07:43.460
Ich glaube, es hat

01:07:43.460 --> 01:07:45.460
Naja, nö.

01:07:45.460 --> 01:07:49.090
Oder doch. Doch.

01:07:49.090 --> 01:07:51.090
Ah. Das ist jetzt

01:07:51.090 --> 01:08:03.100
aktuell so gar nicht mal zu

01:08:03.100 --> 01:08:05.100
Das ist jetzt, das ist echt schwer.

01:08:05.100 --> 01:08:07.100
Der GC

01:08:07.100 --> 01:08:09.100
kann es nicht freen, weil der GC

01:08:09.100 --> 01:08:17.090
wahrscheinlich kein free...

01:08:17.090 --> 01:08:19.090
Nee, nee. Das hat Memory Leaks.

01:08:19.090 --> 01:08:27.620
Oder? Oder nicht?

01:08:27.620 --> 01:08:29.620
Das hat 100 pro Memory.

01:08:29.620 --> 01:08:31.620
Also, wenn das kein Memory Leak hat, dann wundert

01:08:31.620 --> 01:08:49.780
es mich extrem. Warum

01:08:49.780 --> 01:08:51.780
verursacht das nicht mehr CPU Last?

01:08:51.780 --> 01:08:55.410
Nee, macht es doch. Ja.

01:08:55.410 --> 01:08:59.680
Memory.

01:08:59.680 --> 01:09:01.680
Wir könnten doch einfach mal mit einem Debugger starten.

01:09:01.680 --> 01:09:21.820
Schwer zu sagen.

01:09:21.820 --> 01:09:23.820
Also, das könnte auch einfach

01:09:23.820 --> 01:09:25.820
kein Memory Leak. Aber das wundert

01:09:25.820 --> 01:09:29.580
mich. Woher will es

01:09:29.580 --> 01:09:31.580
sie scharf festen, wie man das

01:09:31.580 --> 01:09:33.580
Ei gibt?

01:09:33.580 --> 01:09:39.840
Moment. Moment.

01:09:39.840 --> 01:09:41.840
Moment. Moment. Moment. Moment. Hab ich das überhaupt

01:09:41.840 --> 01:09:43.840
schon kompiliert jetzt und dahin geschoben?

01:09:43.840 --> 01:10:05.390
Wie kann das sein, dass das kein

01:10:05.390 --> 01:10:16.260
Memory Leak gibt?

01:10:16.260 --> 01:10:18.260
Warum das .NET nicht freeen können soll?

01:10:18.260 --> 01:10:20.260
Weil .NET nicht zuständig ist dafür, das zu

01:10:20.260 --> 01:10:22.260
freen.

01:10:22.260 --> 01:10:24.260
Woher möchte .NET wissen

01:10:24.260 --> 01:10:26.260
an der Stelle, dass ich den eigentlichen

01:10:26.260 --> 01:10:28.260
Pointer, auf dem das basiert, das im Ursprungsprogramm

01:10:28.260 --> 01:10:30.260
nicht mehr verwende?

01:10:30.260 --> 01:10:32.260
Wenn ich das selbst

01:10:32.260 --> 01:10:34.260
aufrufen würde, dann ist okay.

01:10:34.260 --> 01:10:36.260
Aber, dass das

01:10:36.260 --> 01:10:43.110
Automatisch Fried wird er gibt Eigentlich Keinen sinn Aber anscheinend

01:10:44.870 --> 01:10:46.870
anscheinend funktioniert das

01:10:53.570 --> 01:10:58.000
Zappt!Con Danke Für. Den Stab also das ist das

01:10:58.860 --> 01:11:00.860
Irgendwas Falsch

01:11:01.060 --> 01:11:03.060
Interop Call

01:11:16.250 --> 01:11:18.890
Wir MüsSen Mal Kurz was Checken steht Da üBerhaupt was Drinne

01:11:20.090 --> 01:11:21.730
Session

01:11:21.730 --> 01:11:24.850
Name steht Da üBerhaupt was sinnvolles Drinne Jetzt Ja

01:11:25.570 --> 01:11:34.580
Ich bin leute ich bin hochgradig verwirrt dass das kein

01:11:34.940 --> 01:11:53.740
Kann das Sein dass es Einfach raus optimiert wird ich bin ich bin echt jetzt begeistert

01:11:54.260 --> 01:11:57.700
verwirrt und begeistert gleichzeitig dass es wohl anscheinend Kein

01:11:58.580 --> 01:12:00.580
Memory leak

01:12:00.580 --> 01:12:01.620
Ergibt

01:12:01.620 --> 01:12:06.540
Wir Können das hier nicht mit dem debugger starten und sehen an die ram auslastung also in Visual Studio gibt es

01:12:06.700 --> 01:12:10.860
In Visual Studio gibt es ein debugger mit ram auslastung ich weiß nicht wie das hier in

01:12:11.820 --> 01:12:17.500
den rider aussieht

01:12:25.820 --> 01:12:46.740
Was was Genau MöcHte rider von mir wo ist das wo ist das problem ach hier

01:12:54.650 --> 01:13:05.700
rider was willst du von mir

01:13:06.220 --> 01:13:10.060
Was hat er Für. Schmerzen mit war der weißt du wo mein dotnet zeug liegt

01:13:27.420 --> 01:13:29.420
Also ich würde gerne das kann man

01:13:30.500 --> 01:13:32.780
das muss doch hier irgendwie funktionieren benchmark

01:13:34.100 --> 01:13:38.940
Wo ist das hier ja richtig runtime korrekt

01:13:41.280 --> 01:13:43.280
exec pass korrekt

01:13:43.440 --> 01:13:49.890
der

01:13:49.890 --> 01:13:52.250
Ja Aber das hier ist doch dort nicht acht stimmt eigentlich

01:13:53.050 --> 01:14:02.300
Ja Ja der ruft das nicht der ruft das nicht mit mit dem richtigen mit dem richtigen

01:14:03.100 --> 01:14:07.940
mit der richtigen installation auf was aber äußerst pepega ist weil

01:14:08.780 --> 01:14:16.050
Hier checkt das hier checkt das ja

01:14:16.650 --> 01:14:20.860
Da ist IrGendwas Falsch Falsch

01:14:27.540 --> 01:14:32.420
Der benutzt meines ist meine meine system runtime was aber keinen sinn ergibt weil ich überall hier

01:14:33.540 --> 01:14:43.780
Überall hier das richtige eingestellt ist auch hier acht guck ich glaube irgendwie das packt rum

01:14:44.900 --> 01:14:48.940
Okay, wir probieren jetzt mal was anderes nur um sicherzustellen dass das irgendwie an mir liegt

01:14:49.660 --> 01:14:50.900
und zwar

01:14:50.900 --> 01:14:56.500
Guck mal was wir jetzt machen wir sind jetzt einfach mal das hier ist jetzt einfach kein string sondern in pointer

01:14:57.220 --> 01:14:59.700
Und spätestens jetzt sollte er es ja nicht aufräumen

01:15:00.220 --> 01:15:16.520
So mal gucken ob es jetzt memory leaks gibt also ich würde sagen es gibt memory leaks

01:15:17.000 --> 01:15:36.620
Ja, ja ja

01:15:36.620 --> 01:15:38.380
guck das geht

01:15:38.380 --> 01:15:39.980
das geht steil

01:15:39.980 --> 01:15:45.820
Ja, also im pointer gibt es memory leaks

01:15:48.520 --> 01:15:55.280
Aber wenn es ein string ist dann gibt das woher weiß der dass er das automatisch freigeben kann das ergibt für mich eigentlich überhaupt

01:15:56.040 --> 01:16:08.040
Nee guck im string checkt er das ich habe keine ahnung wie warum die runtime so 6 header ist

01:16:09.200 --> 01:16:12.360
Aber wenn man ihm sagt ist ein string dann freeter das automatisch

01:16:13.680 --> 01:16:18.960
Ich bin begeistert ich hätte nicht damit gerechnet dass das dort netto das dort netto schlauer ist und das kapiert

01:16:23.250 --> 01:16:25.930
Macht er da unter der haube irgendwie einen free drauf

01:16:26.490 --> 01:16:31.050
Aber woher weiß er überhaupt dass ein free drauf machen darf also das finde ich äußerst

01:16:31.090 --> 01:16:33.090
Spannend dass das funktioniert

01:16:33.610 --> 01:16:41.750
Der checkt das hätte ich nicht gedacht ich hätte gedacht ich muss das von hand machen also das ist das ist schlau

01:16:42.270 --> 01:16:49.380
Also dass das ist von der runtime wirklich schlau dass der den den string ja automatisch freien kann

01:16:50.500 --> 01:16:53.300
Das das ding ist nur das ding ist nur

01:16:53.940 --> 01:16:57.700
dass eigentlich er das eher nicht machen sollte weil

01:16:58.220 --> 01:17:02.460
Er hat keine ahnung ob ich das hier noch irgendwie verwende zum beispiel

01:17:02.460 --> 01:17:04.460
Machen wir doch mal was machen wir mal folgendes

01:17:05.100 --> 01:17:08.340
Machen wir mal hier das muss man jetzt mit wahr machen glaube ich

01:17:09.220 --> 01:17:11.220
Irgendwie so wahr

01:17:13.470 --> 01:17:15.470
Und der wird jetzt gefreed

01:17:16.070 --> 01:17:21.880
Wobei ne dann ist er wahrscheinlich so schlau

01:17:24.790 --> 01:17:26.790
Gute frage

01:17:27.790 --> 01:17:35.580
Entdeckt entdeckt

01:17:36.860 --> 01:17:38.860
Exposed

01:17:39.380 --> 01:17:43.460
Ja die runtime ist so schlau und ruft wirklich free unter der haube

01:17:43.820 --> 01:17:51.420
Das hätte ich nicht gedacht aber da sieht man auch schon das kann echt zu problemen führen wenn ich den string noch weiterverwende in dem

01:17:51.420 --> 01:17:59.700
Drunter liegenden go programm ich bin mir nicht so sicher ob das ein sinnvolles default verhalten ist dass das immer automatisch einen pointer freed

01:18:01.700 --> 01:18:03.700
Da bin ich mir nicht so sicher

01:18:03.700 --> 01:18:06.100
Aber ich glaube das ist ein sinnvolles default verhalten

01:18:06.100 --> 01:18:08.100
Ich glaube das ist ein sinnvolles default verhalten

01:18:08.100 --> 01:18:10.100
Ich glaube das ist ein sinnvolles default verhalten

01:18:10.220 --> 01:18:12.220
Da bin ich mir nicht so sicher

01:18:12.220 --> 01:18:14.220
Wie hast du das rausgefunden?

01:18:14.220 --> 01:18:16.220
Indem ich das einfach einmal global angelegt habe

01:18:16.220 --> 01:18:18.220
den string und immer den gleichen returne

01:18:18.220 --> 01:18:20.220
Und jetzt versucht ihr ihn zum zweiten mal zu freeen

01:18:20.220 --> 01:18:22.220
Und das geht natürlich nicht

01:18:22.220 --> 01:18:24.220
Also ihr habt . net versucht

01:18:24.220 --> 01:18:26.220
Also ich mein ok

01:18:26.220 --> 01:18:28.220
In gewisser logik hat das

01:18:28.220 --> 01:18:30.220
. net erkennt wir bekommen einen charakter pointer

01:18:30.220 --> 01:18:32.220
Und am Ende

01:18:32.220 --> 01:18:34.220
Erkennt wir wir bekommen einen character pointer

01:18:34.220 --> 01:18:36.220
Und am Ende

01:18:36.220 --> 01:18:38.220
Erkennt wir wir bekommen einen charakter pointer

01:18:38.220 --> 01:18:46.340
Charakterpointer und am wandelnden Charakterpointer um, kopieren quasi den Inhalt in einen .NET-String und dann fremen wir den ursprünglichen Pointer.

01:18:46.440 --> 01:18:49.080
Das ist aber eigentlich gar nicht so ungefährlich, weil

01:18:49.800 --> 01:18:55.400
.NET, weil es das automatisch macht, weiß doch überhaupt nicht, ob ich den darunter liegenden Characters,

01:18:55.840 --> 01:18:57.520
Charakter

01:18:57.520 --> 01:19:00.920
Pointer noch weiter verwende, hier beispielsweise.

01:19:02.320 --> 01:19:04.320
Also, weiß nicht.

01:19:04.520 --> 01:19:07.360
Da bin ich, da gehe ich nicht so d'accord mit,

01:19:07.760 --> 01:19:12.290
was das da macht, aber

01:19:12.690 --> 01:19:14.250
soll mir recht sein,

01:19:14.250 --> 01:19:19.640
in dem Fall funzt einfach ohne mein Zutun.

01:19:20.200 --> 01:19:26.130
Ja, wenn man es nicht direkt als String macht, geht das, kann man garantiert unterbinden.

01:19:26.690 --> 01:19:30.690
Wir haben es ja gesehen, man kann es schon unterbinden, indem ich hier einfach einen In-Pointer draus mache.

01:19:31.330 --> 01:19:36.290
Sobald ich hier einen In-Pointer draus mache, dann, dann wird Memory geleaked as fuck, guck.

01:19:37.770 --> 01:19:41.120
Ja,

01:19:41.120 --> 01:19:42.840
700 MB,

01:19:42.840 --> 01:19:47.920
160 MB, 1,2 Gig, 1,4 Gig, 1,7 Gig.

01:19:49.780 --> 01:19:55.540
Also da, also eigentlich hätte ich damit gerechnet, dass ich das eh so machen muss. Charakter-Pointer,

01:19:56.580 --> 01:20:02.400
selbst deserialisieren und dann fremen. Also eigentlich dachte ich, ich muss sowas hier machen, sinngemäß.

01:20:03.500 --> 01:20:06.200
Session,

01:20:06.200 --> 01:20:11.440
In-Pointer, das ist ja im Prinzip nur ein Pointer an die Stelle, wo das Charakter-Array steht,

01:20:11.600 --> 01:20:15.200
sondern ich dachte mir, ich muss, ich muss da jetzt sowas hier machen, zum Beispiel.

01:20:16.120 --> 01:20:17.080
Ähm,

01:20:17.080 --> 01:20:23.960
UTF-8, hier Pointer to String, UTF-8, Client Name. So, wenn ich das mache, sollte es auch Memory Leaks geben, hä?

01:20:24.480 --> 01:20:34.000
Das machen soll es auch Memory Leaks.

01:20:34.920 --> 01:20:36.920
Achso, Semi-Kolon.

01:20:37.720 --> 01:20:45.160
Das sollte auch Memory Leaks geben. Ja, ja, ja, ja, fette, fette Memory Leaks.

01:20:45.920 --> 01:20:47.920
250 MB Memory Leaks pro Sekunde.

01:20:48.600 --> 01:20:51.480
Ja, so und jetzt dachte ich eigentlich, ich, ich

01:20:52.480 --> 01:20:56.640
kopiere mir das hier im .NET String und danach, danach sage ich

01:20:57.120 --> 01:20:59.120
Native Memory Free.

01:20:59.120 --> 01:21:02.360
Das ist, das ist was Neues, das gibt es noch nicht so lange in C-Sharp, das ist, um

01:21:02.600 --> 01:21:10.960
die, den, die Standard, ja, C-Free-Funktion aufzurufen, in der Hoffnung, dass der Code, von dem ich den Pointer bekomme, das mit der Standard C-Free

01:21:12.160 --> 01:21:17.600
Geschichte, mit der Standard, Standard C Alloc-Geschichte allockiert hat, den Speicher. Also

01:21:18.040 --> 01:21:23.600
hoffen wir einfach mal und jetzt sagen wir hier Session Client Name und jetzt sollte ich,

01:21:24.560 --> 01:21:26.080
warum nicht?

01:21:26.080 --> 01:21:32.200
Ach, Unsave, ja, ja. Geht nicht, weil

01:21:33.640 --> 01:21:35.640
muss ein Void Pointer sein.

01:21:36.800 --> 01:21:40.320
Okay, so und jetzt sollte ich auch keine Memory Leaks mehr haben,

01:21:41.120 --> 01:21:45.800
weil jetzt mache ich das von Hand. Ich schnappe mir den Pointer, kopiere den in .NET String und

01:21:46.080 --> 01:21:49.160
dann free ich den Pointer. So müsste das eigentlich sein.

01:21:51.560 --> 01:21:54.280
Und siehe da, es gibt auch keine Memory Leaks mehr.

01:21:54.840 --> 01:22:05.120
Also das macht anscheinend, ernsthaft .NET unter der Haube. Das finde ich ehrlich gesagt ein bisschen

01:22:08.640 --> 01:22:13.420
merkwürdig,

01:22:13.420 --> 01:22:15.020
dass es das macht.

01:22:15.020 --> 01:22:31.310
Sehr komisch, sehr, sehr komisch auf jeden Fall, dass das macht. Wir probieren noch mal was, wir machen jetzt hier noch mal einen String

01:22:31.310 --> 01:22:34.470
draus und dann machen wir das, was der Chat sagt, das interessiert mich nämlich echt.

01:22:35.670 --> 01:22:40.450
S

01:22:40.490 --> 01:22:42.490
Unmanaged

01:22:42.730 --> 01:22:44.730
Unmanaged Type, nicht Bool.

01:22:46.650 --> 01:22:48.810
Char, ne Moment, was gibt es denn da überhaupt?

01:22:50.170 --> 01:22:51.370
Str

01:22:51.370 --> 01:22:53.370
Was haben wir? Oh, das ist Windows Shit.

01:22:53.890 --> 01:23:01.360
LP String, a single byte, null terminated on the character single. Dann haben wir

01:23:02.880 --> 01:23:05.880
LPT String, Unicode Character String.

01:23:11.770 --> 01:23:15.930
LPW String, zwei Byte, alles klar.

01:23:24.740 --> 01:23:37.090
B String, B-Wall-T String. Alter, Microsoft, es ist ja gut, man, übertreibt es halt nicht.

01:23:39.210 --> 01:23:46.690
LPUTF8 String, a pointer to UTF8, Unicode String. Okay, das klingt, das klingt schon mal ganz gut.

01:23:48.010 --> 01:23:50.010
Way too dank.

01:23:52.420 --> 01:23:55.860
Auch keine Memory Leaks. Okay, okay, das muss man wissen.

01:23:57.020 --> 01:23:59.300
Das muss man echt wissen, dass

01:24:06.410 --> 01:24:13.160
es ein automatisches Free macht. Ich weiß nicht, nach was ich suchen muss.

01:24:16.660 --> 01:24:18.660
Das ist Interessantes, also

01:24:20.460 --> 01:24:22.460
Damit hätte ich nicht gerechnet.

01:24:22.540 --> 01:24:24.540
Guck, kein Memory Leak.

01:24:26.920 --> 01:24:33.560
Das muss man in dem Fall wirklich wissen, weil damit rechnet man eigentlich nicht. Gut, also hätten wir den Part, ich muss sagen, das ging

01:24:34.440 --> 01:24:36.120
einfacher als gedacht.

01:24:36.120 --> 01:24:39.080
Jetzt benchmarken wir das Ganze mal, so auf die Schnelle.

01:24:39.440 --> 01:24:45.480
Wir können danach noch ein ordentliches Benchmark.net Projekt drumherum machen, um es beides zu vergleichen, aber

01:24:46.600 --> 01:24:48.600
probieren wir das mal aus.

01:24:48.960 --> 01:24:50.960
Übrigens, das da

01:24:51.120 --> 01:24:55.560
ist auch PPGA, das hier soll eigentlich die Funktion sein, die nichts returnt und

01:24:56.160 --> 01:25:04.590
GoCall2 soll die Funktion sein, die was returnt, sonst wird das nix.

01:25:05.790 --> 01:25:07.790
Jetzt müssen wir das hier anlegen, interop.

01:25:07.790 --> 01:25:14.270
Ja, kopieren wir das mal, GoCall2 und GoCall2 ist einfach nur Void.

01:25:14.870 --> 01:25:20.910
Okay, jetzt benchmarken wir das Ganze mal ganz kurz, auf die Schnelle, also

01:25:21.750 --> 01:25:23.750
Stopwatch

01:25:24.430 --> 01:25:27.720
Start.

01:25:27.720 --> 01:25:31.160
Okay, aus irgendwelchen Gründen funzt mein

01:25:32.000 --> 01:25:34.000
Console-Rightline-Makro nicht.

01:25:34.680 --> 01:25:36.520
Elapsed

01:25:36.520 --> 01:25:38.320
Total

01:25:38.360 --> 01:25:40.360
Seconds

01:25:40.720 --> 01:25:45.280
Stopwatch Stop und hier dazwischen rufen wir mal auf interop.

01:25:45.280 --> 01:25:50.560
So, das hier sollte so gering sein, ein einfacher Function Call, dass das gar nicht auffällt im Endeffekt, ja.

01:25:51.640 --> 01:25:56.000
Das ist jetzt, weil er zum ersten Mal aufgerufen wird, da wird ja nix drauf geben, wir machen da mal eine Schleife drum.

01:25:56.720 --> 01:25:58.720
So, machen wir mal

01:25:59.480 --> 01:26:02.040
100 Aufrufe davon und gucken, wie schnell das ist.

01:26:02.960 --> 01:26:07.240
Und einmal rufen wir es vor der Stopwatch auf, damit es nicht mitgezählt wird.

01:26:07.720 --> 01:26:12.570
Wo bist du überrascht, dass es Pointer gibt?

01:26:14.730 --> 01:26:16.730
Okay, ja, das ist sehr schnell jetzt.

01:26:20.560 --> 01:26:23.280
Gibt es in C-Sharp auch einen Typ für String-Pointer?

01:26:26.000 --> 01:26:30.600
In C-Sharp sind Strings immer Pointer. String ist ein Ref-Type.

01:26:35.210 --> 01:26:37.930
In C-Sharp ist ein String unter der Haube immer ein Pointer.

01:26:39.130 --> 01:26:45.450
Ohne, dass du explizit was hinschreibst. In C-Sharp ist eigentlich 90 Prozent der Sachen, die du verwendest, Pointer.

01:26:46.450 --> 01:26:48.250
Ohne Pointer-Syntax.

01:26:48.250 --> 01:27:00.200
Ich glaube, er meint aber über der, was, wie jetzt?

01:27:13.480 --> 01:27:21.080
Ach so, nee, das ist jetzt in dem Falle von Interop mit wirklich Raw-C-Pointern zu Managed-String-Objekten.

01:27:21.800 --> 01:27:24.240
Damit geht er echt nicht so um, wie erwartet.

01:27:24.680 --> 01:27:33.500
Ja, als dumm gibt es das nur, wenn ich es anscheinend nicht explizit sage. Also,

01:27:33.700 --> 01:27:37.460
was ich vermute, was hier passiert, sobald ich hier hinschreibe,

01:27:38.020 --> 01:27:40.260
sobald ich hier hinschreibe String,

01:27:40.820 --> 01:27:43.220
dann checkt er, wenn das ein

01:27:45.140 --> 01:27:48.220
oder, dann erwartet er einen Character-Pointer,

01:27:49.580 --> 01:27:56.740
kopiert sich den bis zu einem Null-Terminator in einen .NET-String und macht dann einen Free auf den ursprünglichen Pointer.

01:27:56.860 --> 01:28:00.180
Das ist Ultra-Magic unter der Haube, was da passiert.

01:28:00.620 --> 01:28:06.830
Und wenn du das nicht haben willst, dann musst du einfach sagen, mach keinen String draus,

01:28:07.030 --> 01:28:11.390
sondern nimm den, nimm den Raw-Pointer und dann kannst du ihn selbst auslesen und freen.

01:28:11.510 --> 01:28:14.710
Das, das muss ich echt sagen, das ist richtig krasse Magic unter der Haube.

01:28:16.580 --> 01:28:18.940
Also, ja, wenn du das in dumm haben willst,

01:28:19.380 --> 01:28:25.100
okay, dann was du machen kannst ist, ach, das war, meinst du, du kannst auch sowas machen, ja, das funktioniert auch.

01:28:25.700 --> 01:28:31.460
Muss sagen, Unsave-Character-Pointer. Das funktioniert auch, das ist dann, Moment, Moment, das, ha ha,

01:28:31.940 --> 01:28:35.500
Debated, nein, das ist nicht das Gleiche. Du musst einen Byte-Pointer,

01:28:36.140 --> 01:28:40.460
Pointer auf Start von einem Byte-Array setzen, weil, weil,

01:28:42.340 --> 01:28:44.100
das ist auch ein bisschen

01:28:44.100 --> 01:28:51.180
eine Verarschung, da müssten wir aufpassen, wenn man einen Character-Pointer macht, in C-Sharp ist das nicht das Gleiche wie ein Character-Pointer in C.

01:28:51.740 --> 01:28:59.740
Character und ein Byte ist in C das Gleiche. In C-Sharp ist ein Character zwei Byte, weil C-Sharp-Strings intern als UTF-16 speichert.

01:29:00.340 --> 01:29:02.820
Deswegen ist quasi in C,

01:29:03.340 --> 01:29:05.340
in C ist das da

01:29:05.820 --> 01:29:10.740
quasi mehr oder weniger das Gleiche wie das da und das da auch in C-Sharp, aber in C-Sharp ist

01:29:11.500 --> 01:29:18.860
Character-Pointer was anderes. Also das könntest du auch machen, das geht allerdings nur mit Unsave davor, weil sobald du Pointer-Matching machst,

01:29:19.140 --> 01:29:22.220
sagt C-Sharp, ah ja, das ist aber, könnt auch in die Hose gehen.

01:29:23.300 --> 01:29:28.140
Aber muss man in dem Fall gar nicht, weil tatsächlich die Managed-Implementierung von diesem,

01:29:28.540 --> 01:29:34.220
unter der, also unter der Haube machen, machen die schon das Richtige in dem, in dem einen Fall, ja.

01:29:34.940 --> 01:29:41.620
Umwandeln, kopieren einen .NET-String und da unten drunter Free-Callen, das ist schon sehr Magic-mäßig.

01:29:42.100 --> 01:29:48.290
Nee, nee, das ist egal, unter der Haube ist das alles das Gleiche.

01:29:48.890 --> 01:29:54.210
Die, die Interpretation der Daten ist da ein bisschen anders, zum Beispiel, dass du bei einem

01:29:57.510 --> 01:29:58.870
Byte

01:29:58.870 --> 01:30:04.950
kein Minus drin stehen haben kannst, aber bei einem S-Byte, bei einem Signed-Byte, könntest du theoretisch minus 180, aber das reine

01:30:05.270 --> 01:30:09.670
Interpretierungs-, reine Interpretationsfrage, es ist alles in C ein Byte.

01:30:10.110 --> 01:30:16.030
Egal, ob es ein Charakter, ein Byte oder, nee, ein Short ist 16, glaube ich, oder? Ist ein Short nicht in C

01:30:16.630 --> 01:30:21.550
nicht 2-Byte? Also 1 bis 16.000 noch etwas?

01:30:23.390 --> 01:30:28.960
Da bin ich mir jetzt aus dem Kopf nicht sicher. So, aber jetzt haben wir uns,

01:30:29.800 --> 01:30:32.600
jetzt haben wir uns etwas sidetracken lassen.

01:30:33.160 --> 01:30:35.160
Anscheinend ist .NET mittlerweile so

01:30:35.560 --> 01:30:43.000
Five-Head-schlau, dass es, wenn man so komische Dinger macht, wie ich, von denen ich nicht geahnt hätte, dass sie funktionieren,

01:30:43.560 --> 01:30:45.560
tatsächlich funktioniert

01:30:45.800 --> 01:30:50.800
ohne Memory-Leaks zu verursachen. Das hätte ich wirklich nicht gedacht.

01:30:51.640 --> 01:30:56.120
Okay, jetzt wollte ich das mal ganz kurz benchmarken. Wie schnell ist denn das Ganze?

01:31:03.600 --> 01:31:06.440
Okay, ein paar Nanosekunden, aber 100 ist ja auch nix.

01:31:07.240 --> 01:31:09.240
Machen wir mal 1000

01:31:09.640 --> 01:31:15.560
und dann machen wir mal eine Million. Es gibt übrigens ein nices Feature schon seit ein paar C-Sharp-Versionen. Kennt ihr das hier?

01:31:18.020 --> 01:31:19.620
Dass man

01:31:19.620 --> 01:31:23.260
Underscores in die Zahlen machen kann, die eigentlich nix ändern da dran,

01:31:23.980 --> 01:31:28.500
aber viel viel besser lesbar sind. Jetzt erkennt jeder, dass das hier,

01:31:28.940 --> 01:31:33.740
das ist eine Million, also dass das quasi zehn Millionen sind. Machen wir das mal weg. Dass das eine Million ist.

01:31:34.260 --> 01:31:38.860
Das kann man viel besser, viel besser lesen. Man darf übrigens nicht auf die Idee kommen, so zu versuchen,

01:31:39.780 --> 01:31:44.740
weil dann ist das ein Float beziehungsweise ein Double und also mit zwei Punkten geht es dann auch gar nicht.

01:31:46.490 --> 01:31:49.930
Aber das hier, aber das hier ist nice. Ja, das andere sind zehn Millionen gewesen.

01:31:50.570 --> 01:31:56.770
Es ist kein Unterschied. Also, ob ich so schreibe oder so, unter der Haube kommt genau das Gleiche raus, aber es ist besser lesbar.

01:31:56.770 --> 01:32:02.810
Man kann es auch so schreiben, das ist ein bisschen pp-iger, aber es würde auch funktionieren. Oder so, oder so, aber das macht eigentlich keiner.

01:32:02.970 --> 01:32:08.250
Also, das finde ich ganz nice, dass einfach Anderscores in Zahlen ignoriert werden. So eine Million Aufrufe.

01:32:08.650 --> 01:32:11.330
Oh, das ist schon recht langsam.

01:32:13.450 --> 01:32:16.730
90 Millisekunden für eine Million Function Aufrufe.

01:32:17.250 --> 01:32:25.990
Ist das ein Callback Function zu einer Go-Funktion?

01:32:26.510 --> 01:32:32.430
Das ist kein Callback, das ist ein direkter Call von einer Funktion in Go und zwar der hier.

01:32:33.150 --> 01:32:35.150
Guck.

01:32:35.150 --> 01:32:39.030
Wir haben eine leere Funktion in Go, die einfach nur Call Go heißt,

01:32:40.030 --> 01:32:45.190
die in eine Library reinkompiliert wird. Die Library wird in .NET geladen,

01:32:46.830 --> 01:32:50.590
definiert, dass es darin eine Funktion Call Go gibt und dann wird die aufgerufen.

01:32:55.030 --> 01:33:01.990
Unter welchen Umständen merkt man das? Naja, ganz ehrlich, eine Million Function Calls sind schon ganz schön viel.

01:33:02.310 --> 01:33:04.310
Das wird man normalerweise

01:33:05.390 --> 01:33:09.550
nicht wirklich merken. Es sei denn, es sei denn, man hat wirklich irgendwie so eine

01:33:09.870 --> 01:33:16.870
irgendein Parser oder so oder irgendwas, wo das millionenfach aufgerufen wird pro Durchgang, dann macht es schon

01:33:17.430 --> 01:33:22.270
performantechnisch einiges aus. Ich zeige euch jetzt mal den Unterschied. Wir machen jetzt mal eine

01:33:23.230 --> 01:33:28.030
eine Static Public, nennen wir es mal Call

01:33:30.190 --> 01:33:32.590
.NET, nennen wir das jetzt mal, okay.

01:33:33.830 --> 01:33:37.270
Static Public Void. Also, das ist jetzt eine .NET Funktion.

01:33:37.750 --> 01:33:43.270
Nichts irgendwie über Libraries, eine ganz normale .NET Funktion ist das. Und wenn ich die jetzt mal aufrufe hier,

01:33:44.750 --> 01:33:49.030
Call .NET, dann werden wir sehen, Bäm, 1,2 Millisekunden.

01:33:50.470 --> 01:33:54.310
Und mit Release-Modus wahrscheinlich sogar noch ein bisschen weniger, ja.

01:33:55.830 --> 01:33:58.790
Also 500, 500 Nanosekunden

01:34:00.790 --> 01:34:02.790
Versus, versus

01:34:05.130 --> 01:34:07.130
500 Nanosekunden versus

01:34:07.850 --> 01:34:09.850
80 Millisekunden.

01:34:10.690 --> 01:34:12.290
Okay, also

01:34:12.290 --> 01:34:21.910
C-Interop ist immer noch nicht das Allerschnellste, was man machen kann. Das ist, das ist echt lahm. Das ist wirklich lahm.

01:34:22.430 --> 01:34:29.750
80 Millisekunden für eine Million Funktionsaufrufe. Also von .NET nach .NET braucht das Ganze, braucht das Ganze

01:34:29.990 --> 01:34:34.710
500 Nanosekunden. Also hier 0,5 Millisekunden und

01:34:35.670 --> 01:34:44.670
von .NET nach Go braucht es 80 Millisekunden. In normalen Anwendungen, wo das nicht oft aufgerufen wird, ist es überhaupt gar kein Problem, ja.

01:34:46.470 --> 01:34:50.830
Aber so ist schon ordentlich Overhead.

01:34:52.150 --> 01:34:59.630
Ich meine, selbst bei meiner WebRTC-Anwendung, wenn man 30 FPS hat pro Kamera und 100 Kameras drin, dann sind das

01:35:00.150 --> 01:35:01.510
3000,

01:35:01.510 --> 01:35:03.670
3000 Function Calls pro

01:35:04.670 --> 01:35:08.470
Sekunde. Das ist halt nix im Endeffekt, nix.

01:35:09.470 --> 01:35:14.150
Das ist egal, ob ich Function, ob ich hier C-Go Overhead habe, das juckt einfach nicht.

01:35:14.750 --> 01:35:22.450
Für jeden Function Call einen neuen Thread starten,

01:35:23.570 --> 01:35:25.570
ist vielleicht ein bisschen Overkill, aber das würde,

01:35:26.130 --> 01:35:29.890
würde, würde zumindest teilweise die ganze Sache schneller machen, ja.

01:35:33.130 --> 01:35:35.930
Also besser parallel, aber also es ist schon,

01:35:36.570 --> 01:35:41.230
ja,

01:35:41.470 --> 01:35:43.550
schon ein bisschen, schon ein bisschen langsamer.

01:35:46.180 --> 01:35:53.900
Ich glaube, in dem Fall macht .NET gar nicht so viel Magie, sondern es ist eher Go, was die Magie macht. .NET macht in dem Fall ein relativ straight

01:35:54.580 --> 01:35:57.300
Call, wie man halt eine C-Funktion callt.

01:35:57.700 --> 01:36:04.500
Bisschen Magic bestimmt, aber Go macht halt extrem viel Magic für ihren Threads und, und Runtime-Scheduler,

01:36:04.940 --> 01:36:08.180
dass sich das nicht in die Quere kommt. Also C-Go ist

01:36:08.740 --> 01:36:13.740
berüchtigt, oder Go ist berüchtigt dafür, dass der Interop mit anderen Sprachen echt langsam ist.

01:36:14.220 --> 01:36:34.390
Du hast recht, du hast recht, wer auch immer das gesagt hat, du hast recht, deswegen, deswegen machen wir das jetzt mal im Debug-Modus, du hast recht,

01:36:34.910 --> 01:36:38.190
du hast recht. Also im Debug-Modus brauchen wir ungefähr

01:36:39.070 --> 01:36:42.910
82 Millisekunden, 85 Millisekunden Go und Call-NET

01:36:43.550 --> 01:36:45.470
brauchen wir

01:36:45.470 --> 01:36:47.270
eine Millisekunde, okay.

01:36:47.270 --> 01:36:54.150
Ja, du hast recht, das könnte durchaus sein, dass sie scharp schlau genug ist und die Funktion rausschmeißt im Release-Modus, weil es feststellt, okay,

01:36:54.670 --> 01:36:59.430
das ist eine, das ist eine Schleife mit nichts drinnen, also scheiß drauf, mach weg. Ja.

01:37:03.580 --> 01:37:06.780
Test mit einem Print. Print ist immer ganz schlecht für sowas.

01:37:08.060 --> 01:37:10.260
Print ist immer ganz, ganz mies.

01:37:12.060 --> 01:37:18.620
Print ist auf die Konsole und Single Output und so. Nee, der überspringt, ich hab's jetzt im Debug-Modus, da wird nix, da wird nix geskippt.

01:37:19.300 --> 01:37:23.000
Da wird nix geskippt.

01:37:23.400 --> 01:37:25.200
Der ruft die wirklich auf.

01:37:25.200 --> 01:37:31.600
Aber ganz ehrlich, das ist auch zu erwarten,

01:37:32.200 --> 01:37:38.600
dass ein Function Call von .NET nach .NET nahezu kein Overhead hat. Wäre ja auch, wäre ja auch schlimm, wenn nicht.

01:37:38.960 --> 01:37:42.600
Okay, also, dann haben wir das jetzt ausprobiert für Go.

01:37:43.480 --> 01:37:46.360
Wollen wir mal gucken, wie schnell das mit dem Struct ist.

01:37:49.310 --> 01:37:51.790
Oh, das ist natürlich noch mal eine ganze Ecke langsamer.

01:37:52.430 --> 01:37:58.490
Hoho.

01:37:58.770 --> 01:38:00.770
Ja, es schwankt ein bisschen.

01:38:01.210 --> 01:38:05.370
Wir machen gleich mal eine, wir machen gleich mal einen Benchmark. Komm, wir machen jetzt schon einen Benchmark draus.

01:38:06.330 --> 01:38:09.650
Wir machen jetzt schon einen Benchmark draus, bevor wir die Rust-Sache basteln.

01:38:10.650 --> 01:38:12.650
Nougat.

01:38:13.370 --> 01:38:15.370
Benchmark.net

01:38:16.850 --> 01:38:24.360
Bam. Mir gefällt C-Sharp auch enorm gut und ich bin wirklich kein Microsoft-Fan.

01:38:24.920 --> 01:38:31.120
Ich weiß, ich weiß. Wobei das, das ein uralter Artikel ist, das meinte ich ja, und das ist auch das, was ich am Anfang des Streams gesagt habe.

01:38:31.440 --> 01:38:36.320
Dass ich auch mal heute gucken will, wie sehr sich das, wie sehr sich das verbesserte, wie, wie sehr sich das

01:38:39.060 --> 01:38:45.020
verbessert hat. C, Go, Interop. Ich denke schon, dass es schneller geworden ist. Wir machen mal kurz eine Benchmark-Klasse.

01:38:45.500 --> 01:38:47.500
Public Class, Bench,

01:38:49.300 --> 01:38:51.300
Benchmark.

01:38:53.300 --> 01:39:00.220
Wie geht, Moment, Moment, wie ging das jetzt noch mal, Moment, Moment, irgendwie Benchmark, Runner, nee, nee, nee, Bench, Benchmark, Runner?

01:39:01.220 --> 01:39:03.220
Runner? Benchmark, Runner?

01:39:04.780 --> 01:39:09.660
Run, Benchmark, okay.

01:39:11.500 --> 01:39:14.660
Das hier oben kommt weg, das,

01:39:15.940 --> 01:39:20.060
ein Aufruf hier oben ist okay, das kommt da rein.

01:39:20.940 --> 01:39:24.380
Public, Void, das nennen wir jetzt einfach mal irgendwie Run,

01:39:25.100 --> 01:39:27.100
Run, Go oder so.

01:39:27.420 --> 01:39:33.330
Dann kommt das hier rein. Machen wir, machen wir aber mal nur, nur,

01:39:35.560 --> 01:39:43.310
ja doch, na komm, 1000, 1000 Aufrufe ist vielleicht besser, da kann das mehrfach, mehrfach die Funktion aufrufen.

01:39:43.830 --> 01:39:45.830
Okay, Go, Run.

01:39:46.430 --> 01:39:47.910
Und jetzt,

01:39:47.910 --> 01:39:52.560
ich glaube, jetzt muss man hier noch Benchmark drüber schreiben, ne?

01:39:55.580 --> 01:40:00.660
Okay, so und jetzt sollte er eine ordentliche Ausgabe haben, wie schnell der ist.

01:40:03.410 --> 01:40:04.890
Zack.

01:40:04.890 --> 01:40:06.890
Wow, wat?

01:40:06.930 --> 01:40:09.610
There are not any result runs, warum?

01:40:10.410 --> 01:40:18.860
Failed. Der erkennt wieder mein .NET nicht. Mann, was ist das für ein Upfuck? Okay, Export, hier, Path,

01:40:20.660 --> 01:40:38.500
Export, .NET, kann man hier drinnen, kann man hier drinnen relative Farbe verwenden?

01:40:39.100 --> 01:40:43.760
Gar nicht sicher. .NET,

01:40:46.080 --> 01:40:49.010
Version,

01:40:49.010 --> 01:40:51.610
Minus, Minus, Version, 7, nee.

01:40:52.610 --> 01:40:54.610
Also, Home,

01:40:56.250 --> 01:40:58.250
Max,

01:40:58.370 --> 01:41:00.370
Jetzt ist es 8, okay.

01:41:00.690 --> 01:41:05.330
Mach doch in die Bash-RC. Eigentlich will ich meine System.NET Version nicht überschreiben.

01:41:06.730 --> 01:41:08.010
So.

01:41:08.010 --> 01:41:10.530
Und jetzt sagen wir Run, Release, jetzt soll es hoffentlich gehen.

01:41:15.240 --> 01:41:21.880
Jetzt wird ordentlich gebenchmarkt, fast wie in einem Nick Chapsas Video hier. Der Benchmarkt auch immer.

01:41:22.080 --> 01:41:24.080
50 Mal.

01:41:25.360 --> 01:41:27.360
Falls dir jemand guckt.

01:41:28.120 --> 01:41:30.120
Da wird auch immer bis zum Umkippen gebenchmarkt.

01:41:31.120 --> 01:41:42.840
Wenn du Variable für die Anzahl machst, kannst du die Anzahl der Durchläufe testen.

01:41:43.760 --> 01:41:48.120
So, also, Go hat im Durchschnitt

01:41:50.120 --> 01:41:52.120
182

01:41:52.640 --> 01:41:57.160
Mikrosekunden.

01:41:58.200 --> 01:42:00.200
Also für

01:42:00.960 --> 01:42:02.960
1000 Aufrufe.

01:42:09.900 --> 01:42:12.220
Das ist jetzt halt nicht, nicht so schnell.

01:42:20.760 --> 01:42:22.760
Warum? Warum?

01:42:23.360 --> 01:42:25.360
Ich brauche ja keine Parameter, oder?

01:42:28.300 --> 01:42:33.980
Hast du dir mal das Video angeguckt? Da muss ich nicht das Video angucken, das habe ich oft genug erzählt, dass die .NET Versionierung

01:42:34.460 --> 01:42:43.530
beschissen ist. Da habe ich ja schon, da habe ich ja schon selbst oft genug gesagt, also, ach komm.

01:42:44.770 --> 01:42:50.480
Machen wir einfach, machen wir nur 100.

01:42:54.250 --> 01:42:58.850
Und wir callen jetzt das ohne Overhead, also das, was nix macht.

01:42:59.730 --> 01:43:05.310
So, und jetzt das Ganze noch einmal für Rust. Auf geht's.

01:43:06.750 --> 01:43:35.840
Krustentiere versammeln. Ah ja, ja, danke schön für den Sub.

01:43:37.840 --> 01:43:39.840
Bolgi19.

01:43:40.880 --> 01:43:42.880
Huge Subscription.

01:43:44.240 --> 01:43:48.120
Sorry, falls ich irgendjemanden übersehen habe, ich gucke mal kurz rein.

01:43:49.160 --> 01:43:51.160
Creator Dashboard.

01:43:51.240 --> 01:44:00.010
Der Karlzon, danke für den Sub, haben wir hier den ZeppCon.

01:44:01.010 --> 01:44:08.410
Shapeshifter und Stripes. Der Razer hat auch Subscribed vorhin noch, der Alfred auch.

01:44:09.010 --> 01:44:11.010
Gar nicht richtig gesehen, alles hier.

01:44:13.420 --> 01:44:20.930
Vomax heute morgen.

01:44:20.930 --> 01:44:24.210
So, also, es wird Zeit für Go.

01:44:28.520 --> 01:44:31.160
Wir kommentieren das hier gerade mal aus.

01:44:32.640 --> 01:44:34.640
Und ich sage jetzt mal,

01:44:35.320 --> 01:44:37.240
Call.

01:44:37.240 --> 01:44:40.640
Wir brauchen jetzt, wir brauchen jetzt Call

01:44:42.120 --> 01:44:44.120
Call Rust.

01:44:44.120 --> 01:44:46.120
Das wird nicht funktionieren, weil es das auch nicht gibt.

01:44:49.010 --> 01:44:55.130
Ja, bam, Crash, gibt es nicht. So, also, ich muss jetzt in Rust eine Library erzeugen, die RustLib heißt.

01:44:55.370 --> 01:45:00.610
Jetzt geht es los. Ich habe keine Ahnung, wirklich absolut keinen blassen Schimmer, wie ich das jetzt machen soll.

01:45:00.610 --> 01:45:03.410
Okay, also, müssen wir mal suchen. Rust

01:45:05.530 --> 01:45:07.530
FFI

01:45:07.770 --> 01:45:12.370
The Rustonomicon. Okay, jetzt kriegen wir es erklärt.

01:45:13.210 --> 01:45:16.210
Also, Calling Foreign Functions.

01:45:21.240 --> 01:45:24.960
Rust ist so eklig. Alter, wenn ich das hier schon sehe. Ich dreh aber.

01:45:26.840 --> 01:45:30.790
Create Type.

01:45:35.040 --> 01:45:41.540
Wie macht man das überhaupt? Da gab es doch mal irgendein GitHub.

01:45:42.580 --> 01:45:44.580
Rust FFI Examples.

01:45:45.100 --> 01:45:48.760
Gucken wir mal.

01:45:48.760 --> 01:45:52.320
Hat er denn? C Sharp to Rust, das ist doch schon mal ein gutes Beispiel.

01:45:53.080 --> 01:45:55.080
Ja, Cargo Tommel.

01:45:56.240 --> 01:45:58.520
Also, das braucht man. Lib.

01:45:59.600 --> 01:46:03.960
Okay, also, let's go. Wir müssen in unsere Cargo Tommel gehen.

01:46:04.720 --> 01:46:07.080
Und da jetzt ein Lib hinzufügen. Lib.

01:46:08.120 --> 01:46:10.120
Name ist einfach

01:46:11.040 --> 01:46:15.480
RustLib. RustLib, so wahrscheinlich, wie der Output heißen soll.

01:46:16.480 --> 01:46:18.480
CD Lib klingt gut.

01:46:21.830 --> 01:46:26.110
Und jetzt ist die Frage, wie funzt das? Source, Lib S.

01:46:26.830 --> 01:46:35.790
Ja, copy-pasten wir uns mal hier rein und nennen es Call Rust, aber wir haben kein Input und wir haben kein Output erst mal.

01:46:37.150 --> 01:46:41.150
No Mängel extern FN Call Rust.

01:46:44.880 --> 01:46:51.400
Das hier bedeutet, glaube ich, dass er die Namen genauso lässt, wie die Funktion heißt, sodass sie später aufgerufen werden kann.

01:46:52.360 --> 01:46:57.360
Und Main können wir eigentlich raus machen. No Main Function Found. Ja, ist doch klar, will ich auch nicht mehr.

01:46:58.440 --> 01:47:01.640
Cannot Find Library RustLib. Rename File zu...

01:47:02.440 --> 01:47:06.960
Okay. Source Main in Lib. S.

01:47:08.680 --> 01:47:14.640
Achso, Cargo Run geht natürlich. Cargo Build. Ohne Fehler hat es gebildet. Ich fass es nicht.

01:47:17.240 --> 01:47:21.120
Und jetzt, wo ist das Ganze? Target. Debug.

01:47:22.520 --> 01:47:25.160
Lib. Lib. Rust. Lib.

01:47:26.160 --> 01:47:29.240
Hört sich ein bisschen kacke vielleicht an, oder?

01:47:30.080 --> 01:47:35.160
Wie habe ich es genannt? Ich habe es einfach nur RustLib genannt. Also, dann heißt es hier einfach nur Rust.

01:47:37.300 --> 01:47:40.280
Build.

01:47:40.280 --> 01:47:47.280
Lib Rust Punkt S. Ja, meinetwegen, dann heißt es halt nicht RustLib, sondern Lib Rust.

01:47:47.880 --> 01:47:50.080
Auch gut, kann ich auch mit leben, okay?

01:47:51.800 --> 01:47:54.280
Und jetzt Build. Okay, Minus Minus Release.

01:47:54.760 --> 01:48:03.030
Wobei eigentlich wurscht es, wie ich das nenne. Wir können auch sagen Build Release. Dann sagen wir CP oder MV.

01:48:05.710 --> 01:48:14.340
Target. Build. Release. Lib Rust Punkt S. O. Hoch zu...

01:48:15.940 --> 01:48:17.540
Benchmark.

01:48:17.540 --> 01:48:19.540
Und dann soll das einfach heißen

01:48:19.740 --> 01:48:21.900
RustLib Punkt S. O. Ich benenne es einfach um.

01:48:25.450 --> 01:48:30.690
Doch, doch. Das ist eigentlich schon richtig. Ich habe es nur falschrum benannt. Ich habe es falschrum benannt. Lib, das ist auf jeden Fall

01:48:30.810 --> 01:48:34.050
so, so ist richtiger als meins. Mit Lib zuerst.

01:48:36.840 --> 01:48:43.280
Okay, so jetzt haben wir in unserem .NET Projekt noch eine RustLib. Die fügen wir hinzu in den Output.

01:48:44.120 --> 01:48:49.240
Dass er die auch findet, wenn er dann später, später läuft. Ja, so, also Build Action.

01:48:51.040 --> 01:48:57.160
Copy hier. Zack. So, und wenn wir Glück haben, funktioniert das jetzt schon.

01:48:57.160 --> 01:49:05.400
Hey, es läuft. Rust Aufruf. Funzt. So, Beweis. Moment. Beweis, dass es funktioniert.

01:49:06.400 --> 01:49:08.400
Source.

01:49:08.440 --> 01:49:09.640
Print.

01:49:09.640 --> 01:49:14.080
Was ist das? Module. Declaration. Reload. Immer. Restart. Hilft immer.

01:49:14.800 --> 01:49:17.360
Okay, nice. So, jetzt bin ich mal hier. Das Brindeln.

01:49:18.000 --> 01:49:20.000
Cack W.

01:49:20.800 --> 01:49:27.120
Build. Und jetzt aufrufen von .NET aus. Moment. Oh, zu viele Fenster. Aufrufen von .NET auf. Cack W.

01:49:27.960 --> 01:49:29.960
Funzt. Sehr gut.

01:49:30.000 --> 01:49:37.240
Exzellent. Okay, jetzt können wir mal testen, wie schnell das ist, in Go das, in Rust das Ganze zu machen.

01:49:37.240 --> 01:49:41.160
Und danach bauen wir das noch mit Rust und Struct zurückgeben.

01:49:42.280 --> 01:49:46.000
Also, wir sagen jetzt Interop. Call. Go.

01:49:49.070 --> 01:49:51.070
Und zwar mein Benchmark.

01:49:52.760 --> 01:49:56.160
Interop. Call. Net. Wir machen jetzt alle drei Sachen.

01:49:58.320 --> 01:50:00.720
So, also wir kopieren uns den Benchmark.

01:50:02.240 --> 01:50:09.240
Und den Benchmark. Sagen wir Run. Go. Run. Rust. Und Run. .NET. Das sollte ja eigentlich das Schnellste sein.

01:50:10.040 --> 01:50:11.680
Call. Net.

01:50:11.680 --> 01:50:17.520
Und hier Rust. Jetzt bin ich mal auf die Ergebnisse gespannt, was da rauskommt.

01:50:19.520 --> 01:50:22.240
C. Release. Wir machen es auch so schnell, wie geht. Zack.

01:50:23.440 --> 01:50:30.640
Lassen wir das mal kurz laufen und ich gucke in den Chat. Moin, bin aktuell auf Windows. Man würde gerne auf Linux rüber wechseln.

01:50:30.960 --> 01:50:37.360
OS gefällt mir sehr. Jedoch zweifle ich noch, da ich gerne zocke und ich weiß, wie gut das unter Linux funktioniert. Ganz ehrlich,

01:50:38.200 --> 01:50:44.080
wenn du viel spielst und je nachdem, was du spielst, wenn du Spiele beispielsweise mit Anti-Cheat spielst, also

01:50:44.160 --> 01:50:47.760
wobei CS ja wohl mittlerweile ganz gut funktioniert, aber wenn du sowas wie, sagen wir mal,

01:50:48.000 --> 01:50:52.920
Rainbow Six, Fortnite oder sowas spielst, dann hast du eigentlich verloren unter Linux.

01:50:54.780 --> 01:50:59.220
Ich würde dir empfehlen, mach das so wie ich erstmal. Benutz Windows als Host

01:50:59.820 --> 01:51:07.060
und auf dem zweiten Windows-Desktop eine Linux-VM mit Fullscreen, wo du zwischendrin hin- und herschalten kannst. Du machst in der Linux-VM alles, was du

01:51:07.060 --> 01:51:11.660
machen willst, was gut unter Linux ist und für Sachen wie

01:51:12.620 --> 01:51:14.580
Videos gucken,

01:51:14.580 --> 01:51:16.580
streamen, Videobearbeitung,

01:51:17.580 --> 01:51:19.420
irgendwelche

01:51:19.420 --> 01:51:25.140
Games, dann machst du es unter Windows. Da hast du, finde ich, das Beste aus beiden Welten und das Gute ist,

01:51:25.420 --> 01:51:31.620
du kannst dich ein bisschen an Linux gewöhnen, ohne dass du irgendwie Dualboot machen musst oder direkt ins kalte Wasser geworfen wirst.

01:51:32.020 --> 01:51:34.020
Also zum Anfang

01:51:35.260 --> 01:51:43.880
einfach nur eine VM und gut ist. So, aber was sagt der meine Benchmarks hier?

01:51:51.740 --> 01:51:53.740
Meine Benchmarks, Benchmarken noch.

01:51:54.020 --> 01:52:05.510
Ich bin mal gespannt, was rauskommt. Also ich meine, eigentlich kann ich es mir schon denken. .NET am schnellsten, gefolgt von Rust

01:52:05.870 --> 01:52:07.870
und dann Go hintendran.

01:52:07.910 --> 01:52:16.240
Also in diesem einen speziellen Fall jetzt. Was macht der da eigentlich so lange?

01:52:17.960 --> 01:52:23.640
So, ja, guck mal. Boah, alter, was ein Unterschied, man!

01:52:26.200 --> 01:52:34.160
Guckt euch das mal an. Okay, also unser Benchmark ist 100 Funktionsaufrufe, die nichts machen, ja. Also

01:52:35.480 --> 01:52:39.280
von einem Funktionsaufruf 100, nicht einer.

01:52:40.280 --> 01:52:45.200
100 Funktionsaufrufe von .NET nach .NET sind natürlich abfuck schnell.

01:52:46.680 --> 01:52:50.440
28,8 für Nanosekunden. Das ist mega schnell, ja.

01:52:51.400 --> 01:52:53.160
Das ist aber auch klar.

01:52:53.160 --> 01:53:00.960
Gefolgt von Rust. Call in Rust, also die haben ein super, super C-Interface, was einfach funktioniert, ohne viel Overhead.

01:53:01.720 --> 01:53:03.040
Nur

01:53:03.040 --> 01:53:06.120
125 Nanosekunden für 100 Aufrufe. Das ist auch im Prinzip

01:53:06.840 --> 01:53:14.360
Mix, eigentlich. Und jetzt kommt Go. Go braucht einfach mal, sehe ich das richtig, 8 Millisekunden.

01:53:14.800 --> 01:53:16.480
Also

01:53:16.480 --> 01:53:21.590
8114 Nanosekunden.

01:53:21.590 --> 01:53:24.590
Jetzt muss ich ein Video machen auf YouTube, dass Go stirbt, ja.

01:53:27.090 --> 01:53:30.210
Blazingly fast. Rust is destroying Go.

01:53:33.330 --> 01:53:38.410
Go will be dead soon. Oder irgendwas in der Regel. Wir brauchen noch ein bisschen mehr, mehr Klick.

01:53:38.530 --> 01:53:43.810
Wir brauchen, wir brauchen Klickbait. Go is dead. Here is why.

01:53:54.460 --> 01:53:57.980
Mikrosekunden. Ja, ja, Mikrosekunden. Wir sind hier in Bananosekunden.

01:53:59.900 --> 01:54:03.260
How Golang is destroying your performance. Genau.

01:54:04.900 --> 01:54:08.820
Mikrosekunden, nicht Millisekunden. Ja, ich hab mich vertan. Kann man auch mal durcheinander kommen. Also

01:54:09.540 --> 01:54:13.780
.NET, logischerweise in dem Fall das schnellste. 28 Nanosekunden. Rust

01:54:14.020 --> 01:54:20.540
125 Nanosekunden. Würde ich sagen, das ist so wirklich, da kannst du ohne Problem nach Rust callen. Und hier 8 Mikrosekunden.

01:54:20.940 --> 01:54:24.020
Nicht, dass 8 Mikrosekunden schnell wäre, aber es ist um Größenordnungen

01:54:25.260 --> 01:54:35.620
langsamer als Rust. .NET steht ja eigentlich gar nicht zur Auswahl, weil die WebRTC-Libraries für .NET,

01:54:36.220 --> 01:54:39.300
da gibt, es gibt SipSorcery für .NET, das ist auch nicht schlecht.

01:54:39.980 --> 01:54:44.540
Aber ich finde, dem fehlen noch ein paar Features, dass man sie komplett

01:54:45.100 --> 01:54:50.780
so gut benutzen kann, wie die Go-Library zum Beispiel. Und die Rust-Library weiß ich noch nicht.

01:54:50.860 --> 01:54:56.300
Das ist ein Nachbau von der Go-Library, die ich verwenden will, aber ich weiß nicht, wie feature-complete die schon ist.

01:55:09.960 --> 01:55:12.800
Mach die Übung mal anders, mit Rust als Base und import C-Sharp.

01:55:17.710 --> 01:55:21.710
Also, von Rust nach Go wird mehr oder weniger genauso sein.

01:55:23.470 --> 01:55:27.510
Aber von Rust nach C-Sharp ist gar nicht so einfach möglich,

01:55:27.990 --> 01:55:32.630
weil C-Sharp braucht eine .NET-Runtime, die läuft.

01:55:33.230 --> 01:55:37.350
Das heißt, ich müsste quasi eine .NET-Runtime in Rust hosten, was sicherlich geht.

01:55:38.030 --> 01:55:41.710
Ja, du kannst AOT machen, aber ich erzähle euch, wie es die ganze Zeit gewesen ist.

01:55:42.150 --> 01:55:46.590
Du bräuchst quasi, du musst quasi eine .NET-Runtime in Rust hosten. Ich glaube, das will man nicht machen.

01:55:47.230 --> 01:55:49.230
Seit den letzten,

01:55:49.710 --> 01:55:56.630
seit .NET 6, aber eher seit .NET 7 und noch spannender wird es mit .NET 8. .NET 8 kommt ja demnächst,

01:55:56.910 --> 01:55:58.790
quasi raus.

01:55:58.790 --> 01:56:03.190
Da unterstützen die ja auch Ahead-of-Time-Compilation, also im Prinzip das, was

01:56:03.790 --> 01:56:05.790
so ein Compiler macht.

01:56:06.230 --> 01:56:10.670
Normalerweise halt irgendwas native ausführbares rauswerfen. Dann kann man

01:56:11.510 --> 01:56:17.310
auch, Moment, da gibt es wirklich was, da kann man dann auch direkt Funktionen daraus aufrufen.

01:56:20.150 --> 01:56:25.310
Nee, das ist was anderes. Das ist was anderes. Das ist Rust zu

01:56:26.150 --> 01:56:31.510
IR-Kompilieren, was dann in .NET laufen kann. Das ist auch Six-Head, dass es sowas gibt,

01:56:32.830 --> 01:56:36.110
aber das ist andersrum.

01:56:36.110 --> 01:56:40.550
Das ist Rust in .NET. Wir wollen ja .NET von echtem Rust aufrufen.

01:56:41.430 --> 01:56:43.430
So, jetzt müssen wir aber nochmal,

01:56:43.870 --> 01:56:47.190
was ist IR-Intermediate? Also das ist quasi IL.

01:56:49.910 --> 01:56:54.270
IL und IR ist das, ist das, ist das gleiche quasi.

01:56:54.790 --> 01:56:56.790
Bin ich jetzt blöd?

01:56:59.150 --> 01:57:03.630
Ja, also IR und IL ist das gleiche im Endeffekt. Das ist nicht direkt

01:57:04.150 --> 01:57:10.790
ausführbar von deinem Rechner, aber ausführbar von der .NET-Runtime. Also C-Sharp kompiliert ja auch nicht direkt in

01:57:11.550 --> 01:57:16.230
ein Binary, was du ausführen kannst, sondern C-Sharp kompiliert in Bytecode,

01:57:16.750 --> 01:57:23.790
den .NET ausführen kann. Und wenn du in den C-Sharp-Binary startest, dann ist es in Wirklichkeit sehr, sehr, sehr, sehr, sehr, sehr, sehr, sehr, sehr

01:57:24.670 --> 01:57:28.040
so, dass erst mal

01:57:28.040 --> 01:57:31.080
.NET gestartet wird und .NET startet dann ein C-Sharp,

01:57:32.000 --> 01:57:34.000
liest dann das

01:57:34.400 --> 01:57:39.400
CLR, IR oder IL ein, je nachdem wie man es nennt und führt das aus.

01:57:40.320 --> 01:57:42.920
Und dort ist es so, dass quasi

01:57:43.760 --> 01:57:49.360
Rust zu IL umgewandelt wird und IL kann dann von der .NET-Runtime ausgeführt werden.

01:57:49.600 --> 01:57:54.000
Das ist halt echt schon richtig sick, Seth. Ich wüsste nicht genau, wozu das...

01:57:54.360 --> 01:58:04.920
Ich meine, ja, um Rust-Libraries in C-Sharp zu verwenden, aber es funktioniert noch nicht alles.

01:58:05.920 --> 01:58:07.920
Aber cool, dass das funktioniert.

01:58:08.760 --> 01:58:15.040
So, jetzt haben wir unser Benchmark-Zeug hier am Start. Das werde ich jetzt gerade einfach mal wieder auskommentieren.

01:58:16.760 --> 01:58:24.560
Und wir gucken uns mal an, wie man in Rust ein Struct baut und das Struct zurückgibt

01:58:24.960 --> 01:58:28.880
an C-Sharp. Also, Call Rust 2 brauchen wir jetzt noch.

01:58:31.700 --> 01:58:33.700
Das legen wir jetzt hier auch mal an.

01:58:36.150 --> 01:58:43.550
Ich prophezeie, dass es etwas einfacher wird als in Go, weil Rust-C-Interop ist ziemlich gut in der Regel.

01:58:54.500 --> 01:59:00.820
Aber Rust hat schon .NET-Libraries, oder nicht? Nee, Rust ist Rust und Rust ist nicht .NET normalerweise.

01:59:07.170 --> 01:59:11.490
Hast du einen coolen, vielleicht auch leichten Weg mit Rust? Ich habe keine Ahnung.

01:59:12.490 --> 01:59:18.890
Aber ich glaube, man muss ganz schön masochistisch sein, veranlagt sein, mit Rust Windows-UI-Anwendungen bauen zu wollen.

01:59:20.330 --> 01:59:22.330
Das ist einfach nur so mein Bauchgefühl dazu.

01:59:30.980 --> 01:59:36.260
Blazingly fast written in Rust. Musst du jetzt aber auch bei allen deinen Projekten dabeischreiben.

01:59:40.110 --> 01:59:46.790
Also, okay, wie macht man... Es geht ja schon mal los, Leute. Wie man überhaupt einen Struct in Rust macht.

01:59:47.150 --> 01:59:49.150
Struct. Okay, so...

01:59:49.830 --> 01:59:51.830
Nice, Max, super.

01:59:52.750 --> 01:59:56.750
Ich glaube, so weit wärt ihr wahrscheinlich auch schon gekommen, oder?

01:59:57.550 --> 01:59:59.110
Okay, aber...

01:59:59.110 --> 02:00:01.470
Wie geht es weiter? Rust, Struct.

02:00:02.350 --> 02:00:04.350
FFI, suchen wir mal danach.

02:00:04.830 --> 02:00:08.310
Ja, Complex Data Tabs and Rust FFI, genau.

02:00:09.430 --> 02:00:15.030
Okay, also, Inamstruct, hier, RepR, RepR, RepR, C.

02:00:15.790 --> 02:00:19.990
Okay, das ist so ein typisches Rust-Ding. Das können wir copy-pasten.

02:00:20.510 --> 02:00:23.510
Das ist eines der Gründe, warum Rust echt nicht schön zu lesen ist.

02:00:24.270 --> 02:00:28.280
Pupp, Pupp

02:00:28.840 --> 02:00:34.880
ist quasi was wie Public. Public Ausschreiben ist outdated, overrated. Also machen wir hier mal das gleiche. Session,

02:00:35.480 --> 02:00:38.880
Name. Okay, wir fangen einfach an. Wir machen wieder das gleiche.

02:00:40.320 --> 02:00:42.320
Hier, Client ID.

02:00:42.720 --> 02:00:44.520
Und...

02:00:44.520 --> 02:00:51.480
Nee, komm, wir sind A, B, heißt es jetzt. So, UINT, nee, Moment.

02:00:53.000 --> 02:00:56.920
Int. Moment, es ist Rust. Da ist es U64 einfach nur, gell?

02:00:57.760 --> 02:01:03.400
Ja, es ist Rust. Und hier noch mal, eh noch ein Bool oder so. Ja, okay, Build.

02:01:04.280 --> 02:01:06.800
Es bildet noch. Und jetzt, Return.

02:01:07.560 --> 02:01:09.560
Tja, das ist eine gute Frage. Ich weiß gar nicht, wie ich das

02:01:12.960 --> 02:01:17.160
So? A, 1, 2, 3.

02:01:24.760 --> 02:01:26.760
B, Moment.

02:01:27.760 --> 02:01:29.760
B, Schuhe.

02:01:29.760 --> 02:01:31.760
Ne? Ein Semikolon vielleicht?

02:01:33.760 --> 02:01:37.460
Ja.

02:01:39.460 --> 02:01:41.460
So? Hm.

02:01:44.800 --> 02:01:46.800
Was hat er denn für Schmerzen?

02:01:50.710 --> 02:01:52.710
Ah, ja, ja.

02:01:52.710 --> 02:01:54.710
Was hat er denn für Schmerzen?

02:01:54.790 --> 02:01:57.390
Ach so, weil ich kein Return-Type angegeben habe.

02:01:58.310 --> 02:02:03.430
Rust-Return-Type ist so, gell? Ja, okay, ist schon besser, schon besser.

02:02:03.670 --> 02:02:06.950
Übrigens, ich hab's verkackt. Ich hab's in der falschen Funktion gemacht. Das muss hier unten rein.

02:02:12.170 --> 02:02:13.530
Format.

02:02:13.530 --> 02:02:17.990
Okay, und das funktioniert jetzt. Moment, das funzt.

02:02:19.070 --> 02:02:24.590
Okay, jetzt bin ich mal gespannt, wie das, wie das zurückkommt in, in .NET.

02:02:27.380 --> 02:02:29.900
Wir brauchen, wir müssen das mal kurz ein bisschen ändern.

02:02:30.780 --> 02:02:38.960
Hier, Session, Rename, Rename, Session, äh, Go.

02:02:42.030 --> 02:02:46.390
Session, Rust. So, U, Int, und dann haben wir hier einen Bool.

02:02:47.670 --> 02:02:49.670
Und ja, A, B, wie's heißt, ist egal.

02:02:49.990 --> 02:02:55.230
Jetzt bin ich, jetzt bin ich mal gespannt, ob das, das ist ja die Basics. Das sind einfach nur Values zurückgeben.

02:02:55.910 --> 02:03:01.030
Und unser Ziel ist ja hier auch noch einen String zurückzugeben und sowas. Das wird dann schon ein bisschen komplizierter.

02:03:01.950 --> 02:03:05.950
Call Rust 2 zurück, bekommen wir eine Session.

02:03:06.910 --> 02:03:08.910
Okay, Call Rust 2.

02:03:09.710 --> 02:03:13.400
Session gleich.

02:03:13.760 --> 02:03:15.760
Session A

02:03:16.280 --> 02:03:18.280
und

02:03:18.520 --> 02:03:26.480
Session B. Und jetzt gucken wir mal, ob das funzt, was da rauskommt. 1, 2, 3 und True.

02:03:28.440 --> 02:03:31.400
True, Lulw. Ja, das funzt. Okay, das,

02:03:32.240 --> 02:03:35.640
das war schon ein bisschen einfacher als in Go an der Stelle.

02:03:36.600 --> 02:03:42.000
Weil Rust ist deutlich besser, also wir brauchen kein C, Go und C, Struct definieren und sowas.

02:03:43.680 --> 02:03:48.280
Das ist einfacher. So, und jetzt kommt ein String. Jetzt bin ich mal gespannt, wie das funzt.

02:03:49.800 --> 02:03:55.880
Kann ich, kann ich einfach sagen, String, das geht doch im Leben nicht, oder? Wenn ich hier einfach sage, ich returne ein String.

02:03:57.160 --> 02:03:59.160
Keck weh.

02:03:59.720 --> 02:04:02.240
Okay, jetzt kommt Rust-Gedöns.

02:04:02.240 --> 02:04:05.360
Warum kann ich einem Struct String kein String zuweisen?

02:04:05.920 --> 02:04:10.400
Weil man irgendwie sagen muss, Pass as String oder sowas. Ich erinnere mich dunkel.

02:04:11.200 --> 02:04:15.520
From String, from to String. Wo ist der Unterschied dazwischen?

02:04:17.000 --> 02:04:19.560
Aber das habe ich schon mal, das habe ich schon mal gesehen in Rust, ja.

02:04:20.440 --> 02:04:34.000
Das kompiliert zwar, aber das wird nicht funktionieren.

02:04:35.200 --> 02:04:40.960
Das wird, das wird so nicht funktionieren, weil die Rust-String-Repräsentation ganz anders ist.

02:04:40.960 --> 02:04:43.520
Als das, was sich C-Sharp vorstellt.

02:04:45.040 --> 02:04:51.120
Aber wir können es mal ausprobieren. Wir stellen uns einfach mal wieder doof und sagen, das ist ein String, okay.

02:04:51.680 --> 02:04:53.680
So, das wird nicht funzen.

02:04:54.240 --> 02:04:56.240
Es crasht sogar.

02:04:56.640 --> 02:04:58.640
Crasht es? Crasht es wirklich?

02:05:01.990 --> 02:05:03.990
Ja, es crasht.

02:05:04.070 --> 02:05:06.070
Okay, es crasht, es crasht komplett.

02:05:06.870 --> 02:05:08.870
Macht einfach gar nichts.

02:05:08.950 --> 02:05:14.500
Also das funzt so definitiv nicht.

02:05:14.500 --> 02:05:17.780
Aber das habe ich auch schon gedacht.

02:05:18.900 --> 02:05:26.340
Ich brauche, ich brauche ein c-string oder sowas. Oder einen, oder einen character array oder sowas.

02:05:27.780 --> 02:05:32.200
Wir gucken mal in die Hilfe von Rust. Ach hier guck mal.

02:05:33.240 --> 02:05:37.000
Const c, Const c char.

02:05:37.960 --> 02:05:43.960
Hat er importiert?

02:05:43.960 --> 02:05:48.230
hat er importiert?

02:05:48.230 --> 02:05:50.230
konsti

02:05:50.230 --> 02:05:52.230
das geht natürlich nicht

02:05:52.230 --> 02:05:54.230
kann man sowas machen wie pointer?

02:05:54.230 --> 02:05:56.230
es pointer

02:05:56.230 --> 02:06:00.820
aber das ist kein null

02:06:00.820 --> 02:06:02.820
terminierter string

02:06:02.820 --> 02:06:04.820
das

02:06:04.820 --> 02:06:06.820
das kann man sagen wie into pointer

02:06:06.820 --> 02:06:08.820
oder so

02:06:08.820 --> 02:06:10.820
rust magic

02:06:12.820 --> 02:06:14.820
das funzt nicht

02:06:14.820 --> 02:06:16.820
was ist konst

02:06:16.820 --> 02:06:18.820
konst u8

02:06:18.820 --> 02:06:20.820
das ist jetzt quasi ein byte array

02:06:20.820 --> 02:06:22.820
kompiliert

02:06:22.820 --> 02:06:24.820
ich bin mal gespannt was jetzt

02:06:24.820 --> 02:06:26.820
in C sharp rauskommt

02:06:26.820 --> 02:06:28.820
es crasht einfach wieder

02:06:28.820 --> 02:06:30.820
ok

02:06:30.820 --> 02:06:38.680
es crasht

02:06:38.680 --> 02:06:40.680
ok dann probieren wir was anderes

02:06:40.680 --> 02:06:42.680
dann probieren wir was anderes

02:06:42.680 --> 02:06:44.680
int pointer

02:06:44.680 --> 02:06:46.680
das sollte jetzt nicht mal crashen

02:06:46.680 --> 02:06:48.680
es crasht immer noch

02:06:48.680 --> 02:07:07.000
ich habe die

02:07:07.000 --> 02:07:09.000
go session bearbeitet

02:07:09.000 --> 02:07:11.000
ah

02:07:11.000 --> 02:07:19.940
ich bin ein kack noob

02:07:19.940 --> 02:07:21.940
ok das funzt

02:07:21.940 --> 02:07:25.570
also

02:07:25.570 --> 02:07:27.570
hier gibt es den int pointer

02:07:27.570 --> 02:07:33.000
hier kriege ich den int pointer

02:07:33.000 --> 02:07:35.000
zurück

02:07:35.000 --> 02:07:39.970
und was kann ich mit dem int pointer jetzt machen

02:07:39.970 --> 02:07:41.970
sicherlich nicht als string parsen

02:07:41.970 --> 02:07:43.970
oder

02:07:43.970 --> 02:07:45.970
marshall

02:07:45.970 --> 02:07:47.970
pointer to string

02:07:47.970 --> 02:07:51.480
bam geht nicht

02:07:51.480 --> 02:07:53.480
pointer

02:07:53.480 --> 02:07:59.860
to

02:07:59.860 --> 02:08:01.860
ey das funzt nicht

02:08:01.860 --> 02:08:03.860
das ergibt aber auch sinn dass das nicht funktioniert

02:08:03.860 --> 02:08:05.860
weil rust strings sind ja nicht null terminated

02:08:05.860 --> 02:08:07.860
und sonst wie das

02:08:07.860 --> 02:08:09.860
das klappt nicht

02:08:09.860 --> 02:08:14.200
mut u8 haben wir auch noch

02:08:14.200 --> 02:08:16.200
nicht dass das was ändert oder so

02:08:16.200 --> 02:08:20.210
ne ne das funzt nicht

02:08:20.210 --> 02:08:22.210
ok also ich muss da irgendwie mit

02:08:22.210 --> 02:08:26.550
c string hantieren

02:08:26.550 --> 02:08:28.550
c string new

02:08:28.550 --> 02:08:30.550
c unwrap

02:08:30.550 --> 02:08:32.550
das klingt sehr rust style

02:08:32.550 --> 02:08:34.550
machen wir es mal sowas hier

02:08:34.550 --> 02:08:36.550
let str gleich

02:08:36.550 --> 02:08:38.550
c string

02:08:38.550 --> 02:08:40.550
was

02:08:40.550 --> 02:08:45.140
new

02:08:45.140 --> 02:08:47.140
und jetzt hier sowas wie

02:08:47.140 --> 02:08:51.540
kack w oder so

02:08:51.540 --> 02:08:53.540
und an der stelle dann

02:08:53.540 --> 02:08:55.540
hier machen wir auch wieder char

02:08:55.540 --> 02:08:57.540
c char

02:08:57.540 --> 02:08:59.540
und an der stelle dann str

02:08:59.540 --> 02:09:01.540
ok ne funzt nicht

02:09:01.540 --> 02:09:03.540
warum

02:09:03.540 --> 02:09:05.540
expected const

02:09:05.540 --> 02:09:07.540
found

02:09:07.540 --> 02:09:09.540
ah nochmal unwrap

02:09:09.540 --> 02:09:11.540
unwrap

02:09:11.540 --> 02:09:13.540
unwrap muss da oben hin

02:09:13.540 --> 02:09:15.540
unwrap

02:09:15.540 --> 02:09:17.540
unwrap

02:09:17.540 --> 02:09:24.820
into raw

02:09:24.820 --> 02:09:26.820
into raw

02:09:26.820 --> 02:09:28.820
klingt doch sinnvoll oder

02:09:28.820 --> 02:09:30.820
s pointer

02:09:30.820 --> 02:09:32.820
zack kompiliert

02:09:32.820 --> 02:09:34.820
run

02:09:34.820 --> 02:09:43.760
oh

02:09:43.760 --> 02:09:45.760
das lookt nicht korrekt

02:09:45.760 --> 02:09:53.170
das lookt gar nicht korrekt

02:09:53.170 --> 02:09:55.170
das sieht nach

02:09:55.170 --> 02:09:57.170
wurde gefreed aus

02:09:57.170 --> 02:09:59.170
das ergibt

02:09:59.170 --> 02:10:01.170
auch sinn dass es nicht funktioniert

02:10:01.170 --> 02:10:03.170
weil rust

02:10:03.170 --> 02:10:05.170
wird das hier wahrscheinlich verwerfen

02:10:05.170 --> 02:10:07.170
sobald die funktion zu ende ist

02:10:07.170 --> 02:10:09.170
jetzt ist die große preisfrage

02:10:09.170 --> 02:10:16.200
wie kriege ich rust dazu

02:10:16.200 --> 02:10:18.200
dass es das

02:10:18.200 --> 02:10:20.200
überlebt

02:10:20.200 --> 02:10:22.200
wir gucken uns mal die hilfe von c

02:10:22.200 --> 02:10:27.560
string in rust an

02:10:27.560 --> 02:10:29.560
global definieren

02:10:29.560 --> 02:10:31.560
ne ne ne

02:10:31.560 --> 02:10:33.560
extracting a raw pointer

02:10:35.560 --> 02:10:42.390
s pointer

02:10:42.390 --> 02:10:44.390
also eins kann man rust ja meistens nicht vorwerfen

02:10:44.390 --> 02:10:46.390
dass uns zu wenig docs haben

02:10:46.390 --> 02:10:48.390
aber dass ich nicht durchblicke

02:10:48.390 --> 02:10:52.470
ist schon wieder

02:10:52.470 --> 02:10:54.470
s pointer

02:10:54.470 --> 02:10:56.470
ja so schlau bin ich auch

02:10:56.470 --> 02:11:16.800
safety

02:11:16.800 --> 02:11:18.800
ich muss

02:11:18.800 --> 02:11:20.800
ich muss dem ding jetzt

02:11:20.800 --> 02:11:22.800
bei rust ist es so

02:11:22.800 --> 02:11:24.800
rust ist super pingelig

02:11:24.800 --> 02:11:26.800
was lifetime von objekten angeht

02:11:26.800 --> 02:11:28.800
und rust ist schlau genug und weiß

02:11:28.800 --> 02:11:30.800
am ende dieses dings

02:11:30.800 --> 02:11:32.800
normalerweise müsste ich jetzt sowas machen

02:11:32.800 --> 02:11:34.800
ja irgendwie und also rust

02:11:34.800 --> 02:11:36.800
logisch da muss man dann und mut oder so

02:11:36.800 --> 02:11:40.240
komisches zeug da vormachen

02:11:40.240 --> 02:11:42.240
aber das also

02:11:42.240 --> 02:11:44.240
dass ich rust sage

02:11:44.240 --> 02:11:46.240
ich möchte

02:11:46.240 --> 02:11:48.240
quasi das ownership

02:11:48.240 --> 02:11:50.240
heißt das bei rust übertragen an den der aufruft

02:11:50.240 --> 02:11:52.240
aber ich weiß nicht wie das funktioniert

02:11:52.240 --> 02:11:55.750
geht mit nem apostrophe

02:11:55.750 --> 02:11:57.750
mit was

02:11:57.750 --> 02:11:59.750
so

02:11:59.750 --> 02:12:01.750
alter rust macht mich fertig

02:12:01.750 --> 02:12:11.840
ne ne das kanns nicht sein oder

02:12:11.840 --> 02:12:15.280
examples

02:12:15.280 --> 02:12:21.250
den hat man schon

02:12:21.250 --> 02:12:27.960
weg

02:12:27.960 --> 02:12:29.960
wenn du willst übergibst du einfach noch den c string noch mal als

02:12:29.960 --> 02:12:33.520
feldinstruct

02:12:33.520 --> 02:12:35.520
ich übergebe doch das

02:12:35.520 --> 02:12:37.520
feldinstruct

02:12:37.520 --> 02:12:41.160
hier

02:12:41.160 --> 02:12:43.160
oder du meinst hier c string

02:12:43.160 --> 02:12:45.160
ja aber das wird doch

02:12:45.160 --> 02:12:47.160
da nicht so funktionieren wie ich mir das gedacht

02:12:47.160 --> 02:12:53.860
hab oder

02:12:53.860 --> 02:12:55.860
so

02:12:55.860 --> 02:12:57.860
nee its not ffe safe

02:12:57.860 --> 02:12:59.860
das wird nicht funktionieren so

02:12:59.860 --> 02:13:09.480
siehste

02:13:09.480 --> 02:13:11.480
crasht einfach direkt ne ne ne ne

02:13:11.480 --> 02:13:13.480
so funzt das nicht

02:13:13.480 --> 02:13:15.480
ähm

02:13:15.480 --> 02:13:17.480
wir sind glaube ich

02:13:17.480 --> 02:13:19.480
im richtigen weg

02:13:19.480 --> 02:13:21.480
das ist glaube ich garnicht so verkehrt

02:13:21.480 --> 02:13:23.480
vielleicht muss ich auch einfach sagen

02:13:23.480 --> 02:13:25.480
mut

02:13:25.480 --> 02:13:33.910
hier oben anstatt konst

02:13:33.910 --> 02:13:35.910
in c sharp muss das in den session daten

02:13:35.910 --> 02:13:37.910
zu string geändert werden nee muss es nicht

02:13:37.910 --> 02:13:39.910
ich bekomme nen in pointer

02:13:39.910 --> 02:13:41.910
und den wandle ich dann selbst

02:13:41.910 --> 02:13:43.910
in den string um das muss auch funktionieren

02:13:43.910 --> 02:13:51.380
ok das geht nicht warum

02:13:51.380 --> 02:13:53.380
weil

02:13:53.380 --> 02:13:55.380
type differs in

02:13:55.380 --> 02:13:57.380
expected raw pointer

02:13:57.380 --> 02:13:59.380
und found raw pointer

02:13:59.380 --> 02:14:05.440
konst

02:14:05.440 --> 02:14:07.440
jetzt kommt richtig krasses

02:14:07.440 --> 02:14:09.440
nice backseating hier an start

02:14:09.440 --> 02:14:11.440
und das soll jetzt funktionieren

02:14:11.440 --> 02:14:13.440
da hab ich so meine zweifel

02:14:13.440 --> 02:14:15.440
dass das funzt

02:14:15.440 --> 02:14:17.440
und

02:14:17.440 --> 02:14:29.010
funzt nicht

02:14:29.010 --> 02:14:31.010
ich will dem sagen dass er hier

02:14:31.010 --> 02:14:33.010
ownership übertragen soll

02:14:33.010 --> 02:14:35.010
ok wie geht das

02:14:35.010 --> 02:14:37.010
was haben wir denn sonst noch hier

02:14:37.010 --> 02:14:39.010
from raw

02:14:39.010 --> 02:14:41.010
into raw

02:14:41.010 --> 02:14:43.010
consumes

02:14:43.010 --> 02:14:45.010
the c string and transfer

02:14:45.010 --> 02:14:47.010
ownership of the string to the c

02:14:47.010 --> 02:14:49.010
caller das ist das

02:14:49.010 --> 02:14:54.310
was ich wahrscheinlich will

02:14:54.310 --> 02:15:04.020
into

02:15:04.020 --> 02:15:06.020
into raw

02:15:06.020 --> 02:15:08.020
das gibt ein mut

02:15:08.020 --> 02:15:10.020
c char

02:15:10.020 --> 02:15:12.020
was ja auch durchaus ok ist ich kann ja da drin rum

02:15:12.020 --> 02:15:14.020
sauen wie ich will mach ich aber nicht aber könnte ich

02:15:14.020 --> 02:15:16.020
ok lässt sich

02:15:16.020 --> 02:15:18.020
kombinieren und jetzt und jetzt

02:15:18.020 --> 02:15:23.320
post champ

02:15:23.320 --> 02:15:28.870
post champ ich finde meine

02:15:28.870 --> 02:15:30.870
emotes grad nicht

02:15:30.870 --> 02:15:32.870
post champ time

02:15:32.870 --> 02:15:34.870
funzt easy

02:15:34.870 --> 02:15:36.870
kaum macht man es richtig

02:15:36.870 --> 02:15:38.870
easy as fuck

02:15:38.870 --> 02:15:40.870
easy

02:15:40.870 --> 02:15:42.870
easy

02:15:42.870 --> 02:15:48.360
easy as fuck

02:15:48.360 --> 02:15:50.360
hat funktioniert

02:15:50.360 --> 02:15:52.360
also so funzt das in rust

02:15:52.360 --> 02:15:56.240
c string

02:15:56.240 --> 02:15:58.240
moment

02:15:58.240 --> 02:16:00.240
und dann sagt man

02:16:00.240 --> 02:16:02.240
moment

02:16:02.240 --> 02:16:04.240
das ist go

02:16:04.240 --> 02:16:07.560
und dann sagt man

02:16:07.560 --> 02:16:19.510
into raw

02:16:19.510 --> 02:16:21.510
so was haben wir denn sonst noch

02:16:21.510 --> 02:16:23.510
the pointer

02:16:23.510 --> 02:16:25.510
which this function returns

02:16:25.510 --> 02:16:27.510
must be returned to rust

02:16:27.510 --> 02:16:29.510
and

02:16:29.510 --> 02:16:31.510
reconstituted using

02:16:31.510 --> 02:16:33.510
c string from

02:16:33.510 --> 02:16:35.510
raw

02:16:35.510 --> 02:16:37.510
so

02:16:37.510 --> 02:16:39.510
so

02:16:39.510 --> 02:16:41.510
so

02:16:41.510 --> 02:16:43.510
so

02:16:43.510 --> 02:16:45.510
so

02:16:45.510 --> 02:16:47.510
so

02:16:47.510 --> 02:16:51.650
so

02:16:51.650 --> 02:16:53.650
so

02:16:53.650 --> 02:16:55.650
so

02:16:55.650 --> 02:16:57.650
so

02:16:57.650 --> 02:17:11.430
so

02:17:11.430 --> 02:17:13.430
so

02:17:13.430 --> 02:17:15.430
so

02:17:15.430 --> 02:17:18.870
so

02:17:18.870 --> 02:17:22.560
so

02:17:22.560 --> 02:17:24.560
so

02:17:24.560 --> 02:17:26.560
so

02:17:26.560 --> 02:17:28.560
so

02:17:28.560 --> 02:17:30.560
so

02:17:30.560 --> 02:17:32.560
so

02:17:32.560 --> 02:17:34.560
so

02:17:34.560 --> 02:17:36.560
so

02:17:36.560 --> 02:17:38.560
so

02:17:38.560 --> 02:17:40.560
so

02:17:40.560 --> 02:17:42.560
so

02:17:42.560 --> 02:17:44.560
so

02:17:44.560 --> 02:17:46.560
so

02:17:46.560 --> 02:17:48.560
so

02:17:48.560 --> 02:17:51.280
Das ist schon ein See, quasi. Ohne was dazwischen.

02:17:52.080 --> 02:17:54.580
Zwei Sekunden, vier Gigabyte RAM, Alter.

02:17:55.840 --> 02:18:00.280
Mich würde nicht wundern, wenn irgendeine IDE abgekackt ist, jetzt, weil er zu viel RAM sich geschnappt hat.

02:18:02.000 --> 02:18:05.280
Halbe Forkbomb ist das schon, ohne sich zu forken. Gut.

02:18:06.520 --> 02:18:08.320
Also, was müssen wir machen?

02:18:10.930 --> 02:18:19.530
The pointer which is found must be returned to Rust and re-configured using C-String from raw to be properly deallocated.

02:18:20.050 --> 02:18:23.130
Da bin ich mal gespannt, ob das stimmt, was die da sagen.

02:18:23.530 --> 02:18:29.410
Wir machen jetzt da einfach mal ein String draus, weil dann wissen wir ja, dass der automatisch freet.

02:18:33.660 --> 02:18:35.860
Und jetzt sollten wir kein Memory Leak mehr haben.

02:18:41.160 --> 02:18:42.440
Wir haben kein Memory Leak mehr.

02:18:46.430 --> 02:18:48.550
Alles perfectly fine.

02:18:49.590 --> 02:18:52.510
Na, oder vielleicht doch so ein kleines Memory Leak vielleicht.

02:18:53.710 --> 02:18:55.030
Ne, wir haben kein Memory Leak.

02:18:57.600 --> 02:18:59.600
Aber, aber vielleicht doch ein kleines.

02:19:00.360 --> 02:19:02.240
Genau, C-Sharp macht wieder free.

02:19:03.720 --> 02:19:07.800
Profile ist doch... Ich weiß ehrlich gesagt gerade nicht, wie gescheit, weil...

02:19:08.880 --> 02:19:11.960
...mein Rider ist irgendwie der Meinung, Debugger funktioniert nicht.

02:19:13.040 --> 02:19:14.680
Warum auch immer, vielleicht geht er jetzt.

02:19:16.160 --> 02:19:16.680
Nö.

02:19:17.840 --> 02:19:19.760
Obwohl ich's mit... er versucht mein...

02:19:20.400 --> 02:19:25.920
...ihr .NET Location, ergibt überhaupt keinen Sinn, der soll mein .NET verwenden und nicht das falsche .NET.

02:19:27.950 --> 02:19:28.750
Ja, ist es nicht!

02:19:32.120 --> 02:19:33.120
Ist es eben nicht!

02:19:33.560 --> 02:19:37.520
Das Ganze ist ein .NET 8 Projekt und er zeigt's auch hier an, dass es .NET 8 ist.

02:19:38.120 --> 02:19:39.920
Aber Rider ist der Meinung, ne...

02:19:40.680 --> 02:19:43.760
...ist es nicht. Guck hier, .NET 8, .NET Version 8.

02:19:46.670 --> 02:19:49.350
Ich weiß nicht, keine Ahnung, ergibt keinen Sinn, ich glaub...

02:19:49.790 --> 02:19:52.790
...ich glaube fast, das ist ein Bug in Rider, was wir hier haben.

02:19:59.860 --> 02:20:00.660
.Memory.

02:20:03.180 --> 02:20:05.860
So, und jetzt lesen wir mal weiter, was hier steht.

02:20:07.380 --> 02:20:08.900
Ja, okay, hier.

02:20:09.900 --> 02:20:18.420
Specifically, one should not use the standard C3 function to deallocate the string.

02:20:18.420 --> 02:20:21.100
Das ist schon mal falsch, was wir da gerade machen.

02:20:21.980 --> 02:20:27.220
Failure to call CString from raw will lead to a memory leak.

02:20:29.060 --> 02:20:31.860
The C-Site must not modify the length of the string?

02:20:31.860 --> 02:20:32.620
Ja, okay.

02:20:43.340 --> 02:20:45.220
Also müssen wir noch das hier machen.

02:20:45.780 --> 02:20:52.180
Bedeutet im Endeffekt auch, so dass wir kein Memory leaken, brauche ich noch eine Funktion, die nennen...

02:20:52.180 --> 02:20:52.700
Ups.

02:20:54.020 --> 02:20:57.740
...brauche ich noch eine Funktion, die nennen wir jetzt einfach mal hier, ähm...

02:20:58.740 --> 02:21:00.100
...pre-stril oder so.

02:21:01.580 --> 02:21:03.340
Und da rufen wir jetzt auf...

02:21:04.780 --> 02:21:07.980
...CString from raw, okay, hier Pointer rein.

02:21:09.060 --> 02:21:13.900
Und dann wahrscheinlich, wahrscheinlich, äh, okay, Rust.

02:21:13.900 --> 02:21:15.100
Rust, geht das so?

02:21:22.240 --> 02:21:24.240
Achso, das muss in den Unsave-Block.

02:21:24.840 --> 02:21:26.160
Ist ja fast wie in .NET hier.

02:21:37.040 --> 02:21:40.500
Öh, das ist nicht einfach.

02:21:45.000 --> 02:21:45.840
Ich will das so haben.

02:21:48.770 --> 02:21:55.360
Warum, warum sieht der Unsave-Block hier so kacke aus?

02:21:55.360 --> 02:21:56.400
Ah, dann machen wir es so.

02:21:59.120 --> 02:22:01.360
Okay, und jetzt ist das, jetzt ist das safe.

02:22:02.400 --> 02:22:06.080
Da muss ich das aber noch dazu aufrufen, und zwar...

02:22:07.800 --> 02:22:09.280
...würde ich sagen...

02:22:10.920 --> 02:22:12.440
...muss ich dann hier noch...

02:22:13.400 --> 02:22:15.520
...was reinpacken, und zwar...

02:22:16.120 --> 02:22:17.840
...nicht call Rust, sondern...

02:22:18.520 --> 02:22:19.920
...pre-stril...

02:22:21.280 --> 02:22:22.280
...int Pointer...

02:22:25.200 --> 02:22:25.720
...äh...

02:22:26.320 --> 02:22:29.480
...so, und wenn ich jetzt das Memory-Leak vermeiden will...

02:22:30.080 --> 02:22:34.900
...sage ich interop pre-stril...

02:22:35.940 --> 02:22:38.620
...und gebe da Session meinen...

02:22:40.220 --> 02:22:42.660
...nee, nein, ich mein String, das funktioniert ja so jetzt nicht.

02:22:42.980 --> 02:22:46.260
Ja, okay, jetzt ergibt das Sinn, jetzt müssen wir es nämlich wirklich selbst machen.

02:22:46.740 --> 02:22:47.740
int Pointer...

02:22:51.080 --> 02:22:53.080
Ich hab schon wieder das Falsche editiert, man.

02:22:55.060 --> 02:22:57.060
Ich hab schon wieder die Go-Session editiert.

02:22:59.560 --> 02:23:03.880
int Pointer, wir benennen das übrigens mal gescheit, sonst kann ich es gar nicht mehr nicht merken.

02:23:05.600 --> 02:23:06.640
Client Name, so.

02:23:07.000 --> 02:23:10.600
Und jetzt sollte das Memory-Leak auch wieder weg sein.

02:23:13.800 --> 02:23:15.400
Ja, ja, ja, ja.

02:23:16.320 --> 02:23:17.320
Da liegt nix mehr.

02:23:18.880 --> 02:23:24.840
Ich mein, es ist offensichtlich, vorher hatten wir 4 Gigabyte pro 2 Sekunden und jetzt haben wir nix.

02:23:25.840 --> 02:23:26.440
Okay.

02:23:26.760 --> 02:23:32.080
.memory hab ich noch nie ausprobiert, kann man .memory vielleicht installieren über die Toolbox?

02:23:35.680 --> 02:23:37.680
.trace haben wir.

02:23:38.080 --> 02:23:42.240
.net performance profiler.

02:23:43.240 --> 02:23:44.240
Geht das damit auch?

02:23:45.280 --> 02:23:47.520
Hab ich noch nie, hab ich noch nie verwendet.

02:23:49.280 --> 02:23:51.760
Zeigt der mir auch die Memory-Usage?

02:23:53.910 --> 02:23:55.710
Eigentlich, ohne Scheiß...

02:23:55.910 --> 02:23:59.510
Eigentlich fucks mich übelst ab, dass der Ryder-Debugger nicht geht.

02:24:01.930 --> 02:24:04.330
Warum geht da Ryder? Okay, ich hab ne Idee, woran das liegt.

02:24:04.530 --> 02:24:07.530
Wir gehen jetzt mal hier auf Build & Tool Sets.

02:24:08.730 --> 02:24:12.330
Es ist eindeutig richtig eingestellt.

02:24:21.480 --> 02:24:24.280
Kann ich das systemweit speichern, einfach?

02:24:30.600 --> 02:24:31.600
Jetzt funzt's.

02:24:33.200 --> 02:24:36.200
Shit, warum benutzt der? Alter, was ist das für ein Kack?

02:24:36.400 --> 02:24:40.200
Warum benutzt der so ein alles outdatedes .net?

02:24:41.800 --> 02:24:42.800
Versteh ich nicht.

02:24:46.440 --> 02:24:47.640
Es ist irgendein Bug.

02:24:48.040 --> 02:24:49.840
Hier ist alles richtig eingestellt.

02:24:50.440 --> 02:24:55.440
Nee, der Ryder benutzt die Runtime, die ich ja ausgewählt hab normalerweise,

02:24:55.440 --> 02:24:59.440
aber anscheinend macht's das in dem Fall nicht, weil's irgendwie verbuggt ist.

02:25:00.440 --> 02:25:01.840
Was ziemlich suckt.

02:25:18.340 --> 02:25:19.340
Ich weiß es nicht.

02:25:23.870 --> 02:25:25.870
Das sind doch die richtigen Settings, oder was?

02:25:31.040 --> 02:25:32.440
Ich wüsste nicht, was hier dran...

02:25:33.440 --> 02:25:35.040
Weil die Runtime auch stimmt.

02:25:39.180 --> 02:25:41.180
Wir können hier nochmal die Runtime hinzufügen.

02:25:41.580 --> 02:25:43.780
maxhome.net

02:25:47.540 --> 02:25:48.340
.net

02:25:49.340 --> 02:25:50.740
Custom. So, Apply.

02:25:55.210 --> 02:25:56.210
Ah, jetzt geht's!

02:26:00.810 --> 02:26:01.810
Jetzt geht's.

02:26:05.960 --> 02:26:06.960
Glaub ich zumindest.

02:26:07.160 --> 02:26:07.760
Oder?

02:26:08.160 --> 02:26:08.560
Ja.

02:26:09.160 --> 02:26:09.960
Memory.

02:26:13.600 --> 02:26:14.800
Haben die nicht sowas?

02:26:15.000 --> 02:26:15.600
Chat Gil.

02:26:15.800 --> 02:26:18.200
Ich benutze den Debugger in Ryder sehr selten.

02:26:19.400 --> 02:26:21.600
Haben die nicht so eine Anzeige wie in Visual Studio Code,

02:26:21.600 --> 02:26:25.000
wo man einfach sehen kann live, was das für Memory verwendet?

02:26:31.830 --> 02:26:33.030
Anscheinend nicht, oder?

02:26:39.160 --> 02:26:40.360
Ja, stimmt auch wieder.

02:26:44.760 --> 02:26:46.760
Aber ist doch blöd, dass das nicht eingebaut ist, oder?

02:26:47.160 --> 02:26:49.760
Das ist dann tatsächlich eine Sache, wo ich sagen würde,

02:26:51.680 --> 02:26:54.080
da ist Visual Studio Code angenehmer.

02:26:54.080 --> 02:26:56.680
Äh, nicht Visual Studio Code, äh, Visual Studio angenehmer.

02:27:02.560 --> 02:27:04.360
Auf die drei Dots bei Debuggen.

02:27:08.570 --> 02:27:09.770
Du meinst hier, oder wo?

02:27:09.970 --> 02:27:10.570
Oder da?

02:27:13.640 --> 02:27:15.440
Profile with Sampling.

02:27:21.370 --> 02:27:25.620
Ah.

02:27:25.820 --> 02:27:26.820
Excellent.

02:27:27.820 --> 02:27:30.020
So, und wo seh ich jetzt den, den RAM-Verbrauch?

02:27:30.420 --> 02:27:32.420
Erst wenn ich's wieder geschlossen hab, oder...

02:27:33.220 --> 02:27:34.420
...seh ich das live?

02:27:44.720 --> 02:27:46.120
Da gibt's doch eins für Memory.

02:27:46.320 --> 02:27:46.920
Echt?

02:27:56.630 --> 02:27:57.230
Snapshot?

02:28:01.060 --> 02:28:03.060
Ey, das ist aber nicht die Memory-Size, oder?

02:28:10.080 --> 02:28:12.880
Äh, boah, da blinke ich nicht durch, das mit zu high IQ jetzt.

02:28:15.250 --> 02:28:18.450
Das mir, das ist mir massified zu high IQ, äh.

02:28:21.770 --> 02:28:23.770
Was ist jetzt CPU? Ja, ich hätte gerne Memory.

02:28:28.820 --> 02:28:31.020
Das massify IQ Zeug hier.

02:28:33.320 --> 02:28:34.320
Okay, stoppen wir mal.

02:28:37.760 --> 02:28:40.360
Profile with? Profile running process? Profile...

02:28:41.560 --> 02:28:42.960
Sampling? Memory!

02:28:54.480 --> 02:28:56.880
Ja, sowas such ich!

02:28:57.080 --> 02:28:58.080
Genau.

02:28:58.880 --> 02:28:59.880
Excellent.

02:29:00.280 --> 02:29:02.280
Genau das hab ich gesucht.

02:29:05.210 --> 02:29:07.210
Dass man sieht, wie viel Speicher das Ding verbraucht.

02:29:07.410 --> 02:29:11.810
Man sieht, wir haben absolut null Memory-Leaks.

02:29:12.010 --> 02:29:12.810
Gar nix.

02:29:17.220 --> 02:29:18.020
Null Memory-Leaks.

02:29:18.220 --> 02:29:19.820
Es ist einfach die ganze Zeit...

02:29:20.620 --> 02:29:23.020
...immer auf 43,59.

02:29:24.020 --> 02:29:26.620
So, wir können das, wir können das Ganze, Ganze nochmal...

02:29:28.530 --> 02:29:30.530
...checken, indem wir sagen...

02:29:31.130 --> 02:29:33.330
...wir lassen das, wir lassen das Free mal weg, aber...

02:29:33.730 --> 02:29:34.330
...wir machen...

02:29:36.130 --> 02:29:37.730
...wenn man in Sleep kurz rein...

02:29:38.330 --> 02:29:38.930
...von...

02:29:40.130 --> 02:29:41.330
...einer Millisekunde...

02:29:41.730 --> 02:29:42.330
...das ist...

02:29:44.130 --> 02:29:47.130
...jetzt hatten wir es mehrfach drauf, dass es nicht sich komplett in die...

02:29:49.770 --> 02:29:51.370
...in die, in die Quere kommt, ja.

02:29:51.970 --> 02:29:52.970
So, und jetzt sagen wir...

02:29:53.370 --> 02:29:55.370
...Profile with Memory.

02:30:06.300 --> 02:30:07.900
Ich hätte jetzt eigentlich erwartet...

02:30:14.930 --> 02:30:16.530
...ich hätte jetzt eigentlich erwartet, dass das...

02:30:20.640 --> 02:30:21.240
...irgendwie...

02:30:24.490 --> 02:30:26.490
Es geht hoch, ja es geht hoch, guckt Leute.

02:30:27.090 --> 02:30:27.890
Es geht hoch.

02:30:28.690 --> 02:30:30.890
Langsam, weil eine Millisekunde Sleep dazwischen...

02:30:31.090 --> 02:30:33.090
...und eine Millisekunde ist verdammt viel...

02:30:33.290 --> 02:30:36.090
...wenn der Millionen Aufrufe pro Sekunde macht normalerweise.

02:30:36.690 --> 02:30:37.090
Ja.

02:30:37.490 --> 02:30:39.290
Jetzt sieht man, dass ein Memory-Leak drin ist.

02:30:39.290 --> 02:30:40.890
Guckt, es geht immer ein bisschen weiter hoch.

02:30:46.640 --> 02:30:47.440
Nice, nice.

02:30:47.640 --> 02:30:50.240
Okay, heute, das ist wirklich nice...

02:30:50.640 --> 02:30:53.040
...dass ihr wusstet, wo das ist, weil...

02:30:54.040 --> 02:30:54.640
...ähm...

02:30:54.840 --> 02:30:56.640
...wir können aber sagen, Timespan...

02:30:57.640 --> 02:30:58.640
...Brom...

02:30:59.240 --> 02:31:00.440
...Microseconds...

02:31:01.840 --> 02:31:03.040
...jede Mikrosekunde...

02:31:03.240 --> 02:31:04.040
...einfach, bam.

02:31:07.620 --> 02:31:08.820
Profile Memory.

02:31:13.560 --> 02:31:14.560
Oh ja, guckt Leute.

02:31:15.360 --> 02:31:16.360
Jetzt geht's steil.

02:31:16.560 --> 02:31:17.760
Jetzt geht's steil.

02:31:18.760 --> 02:31:20.160
Die Speicher aus Gigabyte.

02:31:20.760 --> 02:31:24.160
1,2 Gigabyte, 1,4, 1,6, 1,7.

02:31:24.560 --> 02:31:26.360
Ja, jetzt wird Memory-Leaked as fuck.

02:31:31.220 --> 02:31:33.020
Jetzt hat man's, jetzt hat man's wirklich gut gesehen.

02:31:33.420 --> 02:31:34.820
So, und jetzt machen wir das Free rein.

02:31:35.820 --> 02:31:36.820
Jetzt machen wir das Free rein.

02:31:37.420 --> 02:31:39.620
Aber Chat, da habt ihr mal was Gutes gezeigt.

02:31:40.420 --> 02:31:42.020
Das wusste ich gar nicht, dass es das gibt.

02:31:42.420 --> 02:31:44.220
Das ist mega praktisch dafür.

02:31:46.590 --> 02:31:47.990
Rider ist einfach echt beste.

02:31:52.850 --> 02:31:54.650
So, guckt, und jetzt kein Memory-Leak mehr.

02:31:54.650 --> 02:31:57.450
Es bleibt einfach bei 44 MB Memory total used.

02:32:03.340 --> 02:32:04.340
Excellent, Leute.

02:32:04.940 --> 02:32:06.540
Excellent, excellent.

02:32:08.340 --> 02:32:08.740
Okay.

02:32:08.940 --> 02:32:10.540
So, und was lernen wir daraus?

02:32:10.540 --> 02:32:12.140
Okay, wir machen jetzt nochmal einen abschließenden...

02:32:12.140 --> 02:32:13.340
...wie krieg ich denn das hier minimiert, so?

02:32:13.740 --> 02:32:15.340
Jetzt machen wir nochmal einen abschließenden Vergleich...

02:32:15.340 --> 02:32:16.340
...zu diesem ganzen Campbell.

02:32:19.480 --> 02:32:20.480
Wir schmeißen das hier raus.

02:32:20.480 --> 02:32:22.480
Wir sagen...

02:32:27.730 --> 02:32:29.330
...Duster wird einmal aufgerufen.

02:32:32.020 --> 02:32:33.620
Dann wird Interop...

02:32:35.620 --> 02:32:38.820
...Call Rust einmal aufgerufen.

02:32:39.620 --> 02:32:44.920
Interop Call Rust 2.

02:32:48.050 --> 02:32:50.250
Und Interop Call Go.

02:32:50.250 --> 02:32:52.650
So, jetzt lassen wir uns einmal noch Benchmark-Ergebnisse...

02:32:52.650 --> 02:32:53.650
...generaten.

02:32:55.250 --> 02:32:56.850
Zum Vergleich...

02:32:59.400 --> 02:33:00.000
Das kommt weg.

02:33:00.000 --> 02:33:03.000
Also, den .NET-Vergleich, den machen wir mal wieder raus.

02:33:03.000 --> 02:33:04.600
Den braucht eigentlich niemand an der Stelle.

02:33:04.600 --> 02:33:06.200
Wir wissen, dass .NET schnell ist.

02:33:06.800 --> 02:33:08.000
Von .NET zu .NET.

02:33:08.400 --> 02:33:09.400
Ja, also hier Run.

02:33:10.200 --> 02:33:11.600
Gucken wir uns das nochmal abschließend an.

02:33:12.400 --> 02:33:13.200
Go 2.

02:33:14.600 --> 02:33:15.200
Und...

02:33:18.280 --> 02:33:20.480
...Run Rust 2.

02:33:21.280 --> 02:33:22.080
Wobei wir da...

02:33:23.280 --> 02:33:25.280
...tatsächlich noch einen Free machen müssen.

02:33:25.680 --> 02:33:27.680
Der in Go unter der Haube passiert.

02:33:29.080 --> 02:33:29.880
Aber das ist ja nicht schlimm.

02:33:33.320 --> 02:33:33.720
So.

02:33:34.720 --> 02:33:36.920
Und jetzt können wir nochmal den Benchmark laufen lassen.

02:33:37.920 --> 02:33:38.920
Und uns freuen...

02:33:39.520 --> 02:33:41.520
...dass wir eine tolle Benchmark-Ausgabe kriegen.

02:33:54.700 --> 02:33:57.700
Glaube ich zumindest, dass ich nichts falsch gemacht habe.

02:34:01.920 --> 02:34:02.520
Oh, doch.

02:34:03.520 --> 02:34:05.120
Run, Run Rust.

02:34:06.520 --> 02:34:07.720
Fehlt noch das normale...

02:34:09.120 --> 02:34:10.520
...Call Rust.

02:34:11.120 --> 02:34:15.420
So, okay.

02:34:15.620 --> 02:34:17.820
Wenn man jetzt noch richtig schreiben könnte, wäre perfekt.

02:34:24.470 --> 02:34:25.870
Gibt es überhaupt Go 2, ja?

02:34:25.870 --> 02:34:26.470
Gibt es?

02:34:27.070 --> 02:34:28.670
Go 2 macht das mit dem Struct.

02:34:29.870 --> 02:34:31.270
So, ich bin mal gespannt.

02:34:32.070 --> 02:34:33.670
Habst du da High IQ Stream heute?

02:34:33.670 --> 02:34:34.470
Ja, stimmt schon.

02:34:35.070 --> 02:34:37.070
Übrigens schön, dass so viele Leute wieder am Start sind.

02:34:37.270 --> 02:34:39.070
Ich meine, das ist ja nicht selbstverständlich...

02:34:39.470 --> 02:34:42.670
...dass quasi die ganze Zeit über 200 Leute zugucken...

02:34:42.670 --> 02:34:44.470
...bei so einem Kram hier, ja?

02:34:49.710 --> 02:34:53.310
Muss man beim Struct in Rust nicht auch die Namen anpassen...

02:34:53.310 --> 02:34:54.910
...oder hattest du das schon gemacht?

02:34:56.710 --> 02:34:58.310
Ne, warum brauche ich die Namen anpassen?

02:34:58.510 --> 02:34:59.110
Was meinst du?

02:34:59.310 --> 02:35:01.310
Du meinst, weil das in C Sharp...

02:35:01.910 --> 02:35:02.510
...heißt...

02:35:02.910 --> 02:35:04.510
...Session Rust und Session Go?

02:35:05.510 --> 02:35:06.310
Das ist Wurscht.

02:35:07.710 --> 02:35:09.110
Wichtig ist einfach nur, dass die...

02:35:09.310 --> 02:35:11.110
...das Speicher-Layout das gleiche ist.

02:35:11.110 --> 02:35:11.910
Ich könnte es auch ein...

02:35:11.910 --> 02:35:12.710
...ich könnte es auch...

02:35:13.310 --> 02:35:15.510
...Cacquait, QChat, Ajaja nennen.

02:35:15.710 --> 02:35:16.310
Das Struct.

02:35:16.310 --> 02:35:17.310
Vollkommen egal, wie das...

02:35:17.310 --> 02:35:18.510
...wie das in C Sharp heißt.

02:35:18.910 --> 02:35:21.110
A Client ID ist der Name auch egal.

02:35:21.110 --> 02:35:22.310
Der Typ ist das Wichtige.

02:35:23.310 --> 02:35:24.910
Also hauptsache, dass das Struct...

02:35:24.910 --> 02:35:26.310
...denn das ist das richtige Memory-Layout.

02:35:26.510 --> 02:35:29.310
Also dass es in Rust A und B heißt, ist vollkommen egal.

02:35:30.310 --> 02:35:31.910
Wichtig ist, dass es ein Struct ist...

02:35:32.310 --> 02:35:33.910
...dass als erstes ein Bool kommt...

02:35:33.910 --> 02:35:34.910
...als zweites ein Int...

02:35:34.910 --> 02:35:36.510
...als drittes ein String oder sowas.

02:35:37.110 --> 02:35:38.510
Das muss stimmen in beiden Sprachen.

02:35:38.510 --> 02:35:40.310
Wie das heißt, ist vollkommen egal.

02:35:41.910 --> 02:35:42.510
Weil die...

02:35:42.510 --> 02:35:44.310
...denn die Namen stehen dann irgendwo drinne.

02:35:44.710 --> 02:35:46.110
Was der sich einfach merkt, ist...

02:35:46.910 --> 02:35:48.310
...die Size von dem Struct...

02:35:49.110 --> 02:35:50.510
...und wie er das dann quasi...

02:35:50.710 --> 02:35:52.910
...casten muss in den eigentlichen Managed-Typ...

02:35:54.110 --> 02:35:55.110
...vom...

02:35:55.110 --> 02:35:56.510
...von der Speicher-Aufteilung her.

02:36:02.650 --> 02:36:04.050
Ja, ich mag die Streams auch.

02:36:04.250 --> 02:36:05.650
Ich meine, ich kann natürlich eben nicht immer...

02:36:05.650 --> 02:36:07.450
...so Sachen aus dem Ärmel schütteln, ja.

02:36:08.250 --> 02:36:09.450
Immer nur, wenn was ansteht.

02:36:11.450 --> 02:36:13.650
So, ich bin mal gespannt, was bei den Benchmarks rauskommt.

02:36:13.650 --> 02:36:15.250
Wobei, eigentlich bin ich nicht gespannt.

02:36:15.250 --> 02:36:16.650
Wir wissen alle, was rauskommt.

02:36:17.050 --> 02:36:18.250
Rust schneller.

02:36:18.850 --> 02:36:19.250
Ja.

02:36:20.050 --> 02:36:21.450
Um Längen schneller.

02:36:21.450 --> 02:36:22.050
Guckt mal.

02:36:22.850 --> 02:36:23.450
Also...

02:36:23.650 --> 02:36:24.250
...die Funktion...

02:36:24.250 --> 02:36:24.650
...hier...

02:36:25.050 --> 02:36:27.450
...die pure Rust-Funktion aufrufen...

02:36:29.050 --> 02:36:33.650
...ist einfach 124 Nanosekunden zu 8,5 Mikrosekunden.

02:36:34.450 --> 02:36:35.650
Und hier ist...

02:36:35.850 --> 02:36:38.250
Go braucht für die Geschichte mit dem Struct...

02:36:39.250 --> 02:36:40.050
...18...

02:36:40.250 --> 02:36:41.250
...Nanosekunden...

02:36:41.650 --> 02:36:43.050
...18.000 Nanosekunden...

02:36:43.050 --> 02:36:43.850
...ne, Moment.

02:36:44.650 --> 02:36:46.050
18.000 Nanosekunden...

02:36:46.050 --> 02:36:48.450
...also 18 Millisekunden, sehe ich das richtig?

02:36:48.850 --> 02:36:49.450
Chat?

02:36:49.850 --> 02:36:50.850
Ne, Mikrosekunden.

02:36:51.050 --> 02:36:52.050
Mikrosekunden, nicht Millisekunden.

02:36:52.250 --> 02:36:53.050
Meine Güte!

02:36:53.250 --> 02:36:53.850
Boah!

02:36:55.250 --> 02:36:56.050
Einheiten!

02:36:56.050 --> 02:36:56.850
Keck, wait!

02:36:57.250 --> 02:36:58.450
18 Mikrosekunden...

02:36:58.450 --> 02:37:01.050
...und Rust braucht einfach nur 2.

02:37:01.050 --> 02:37:05.200
Ist schon eine ganze Ecke schneller.

02:37:05.800 --> 02:37:06.800
Und hier haben wir...

02:37:06.800 --> 02:37:15.900
...und das dürfen wir nicht vergessen...

02:37:16.300 --> 02:37:18.300
...hier haben wir 2 Calls...

02:37:18.900 --> 02:37:19.500
...drinne.

02:37:20.300 --> 02:37:20.900
Wir haben...

02:37:21.300 --> 02:37:21.700
...in der...

02:37:21.700 --> 02:37:24.140
...und es sind trotzdem schneller.

02:37:24.140 --> 02:37:25.340
Wir haben 2 Calls.

02:37:25.740 --> 02:37:26.740
Wir haben den...

02:37:27.740 --> 02:37:28.540
...eigentlichen...

02:37:28.740 --> 02:37:30.540
...Call zum Struct erzeugen...

02:37:31.340 --> 02:37:33.940
...und wir haben den Call zum Free noch drinne.

02:37:34.740 --> 02:37:41.700
Nimm mal String als Type und nicht Pointer.

02:37:41.700 --> 02:37:42.900
Lass ihn Free callen.

02:37:42.900 --> 02:37:43.900
Sollte schneller sein.

02:37:44.100 --> 02:37:44.500
Ne.

02:37:45.300 --> 02:37:45.900
Also, ja.

02:37:45.900 --> 02:37:46.300
Ne.

02:37:47.100 --> 02:37:47.700
Also, ja.

02:37:47.700 --> 02:37:48.700
Vielleicht ist das...

02:37:48.700 --> 02:37:49.700
...ein Ticken schneller.

02:37:50.300 --> 02:37:51.900
Weil .NET das Free macht...

02:37:51.900 --> 02:37:53.300
...und nicht Rust gecallt wird.

02:37:53.300 --> 02:37:53.900
Aber...

02:37:54.500 --> 02:37:56.900
...die Rust-Docs sagen explizit...

02:37:56.900 --> 02:37:59.300
...man soll nicht Free callen, sondern...

02:37:59.500 --> 02:38:01.300
...soll das zurück an Rust geben...

02:38:01.300 --> 02:38:02.500
...und Rust soll es freeen.

02:38:04.100 --> 02:38:05.300
Sonst Memory Leak.

02:38:06.300 --> 02:38:06.900
Es ist...

02:38:06.900 --> 02:38:07.900
...also du hast Recht, das ist schneller.

02:38:07.900 --> 02:38:09.100
Aber wir können das ausprobieren.

02:38:09.700 --> 02:38:10.100
Schade nix.

02:38:10.100 --> 02:38:11.100
Wir können das ausprobieren.

02:38:11.300 --> 02:38:11.900
Ich lass das...

02:38:11.900 --> 02:38:12.700
...ich lass das mal weg.

02:38:13.900 --> 02:38:15.700
Und wir ändern den hier zu String.

02:38:16.100 --> 02:38:16.700
Wir haben ja gesehen...

02:38:16.700 --> 02:38:18.300
...wir haben auch nahezu kein Memory Leak...

02:38:18.300 --> 02:38:19.300
...und führen das Ganze nochmal...

02:38:19.900 --> 02:38:20.700
...ööö...

02:38:25.180 --> 02:38:25.580
...ja.

02:38:25.780 --> 02:38:27.180
Jetzt sollte er schneller sein...

02:38:27.180 --> 02:38:29.180
...aber wir haben potenziell ein Memory Leak.

02:38:29.180 --> 02:38:29.780
Zumindest...

02:38:29.980 --> 02:38:31.580
...sagen die Rust...

02:38:31.580 --> 02:38:33.180
...sagt die Rust-Doku das...

02:38:33.580 --> 02:38:35.380
...dass wir dann einen Memory Leak haben.

02:38:36.980 --> 02:38:38.180
Wenn wir das nicht so machen.

02:38:44.520 --> 02:38:46.120
Also Arduino plus Rust...

02:38:46.120 --> 02:38:47.120
...hab ich noch nie gemacht.

02:38:48.320 --> 02:38:51.320
Ich bin eher der ESP32-Enjoyer.

02:38:51.920 --> 02:38:53.720
Und da ist Rust ja auch nur...

02:38:53.720 --> 02:38:54.320
...sagen wir mal so...

02:38:54.320 --> 02:38:55.120
...sehr rudimentär.

02:38:55.120 --> 02:38:56.320
Vieles geht ja in Rust noch nicht.

02:38:56.320 --> 02:38:57.720
Ich glaube, Rust und WiFi...

02:38:58.120 --> 02:38:59.320
...geht glaube ich auch noch nicht...

02:38:59.320 --> 02:38:59.720
...auf dem...

02:38:59.720 --> 02:39:01.320
...auf dem ESP32.

02:39:09.390 --> 02:39:10.190
Ja, genau.

02:39:10.190 --> 02:39:10.390
Das...

02:39:10.390 --> 02:39:10.790
...das...

02:39:10.790 --> 02:39:11.990
...genau deshalb denke ich auch.

02:39:12.390 --> 02:39:13.990
Es kann ja auch möglich sein...

02:39:14.390 --> 02:39:15.990
...dass Rust nicht einfach...

02:39:17.390 --> 02:39:17.590
...den...

02:39:17.590 --> 02:39:17.990
...den...

02:39:17.990 --> 02:39:18.990
...das Memory...

02:39:18.990 --> 02:39:19.990
...allocated...

02:39:19.990 --> 02:39:20.990
...über die...

02:39:20.990 --> 02:39:22.390
...das normale C-Malloc...

02:39:22.390 --> 02:39:23.990
...sondern irgendwas eigenes macht.

02:39:24.390 --> 02:39:25.990
Und dann bringt ja normales C-Free...

02:39:25.990 --> 02:39:27.390
...an der Stelle ja auch wenig.

02:39:27.790 --> 02:39:28.990
Wenn da noch Sachen nestet...

02:39:28.990 --> 02:39:30.590
...irgendwie anderweitig allokiert sind...

02:39:30.590 --> 02:39:31.990
...von denen nur Rust was weiß.

02:39:33.390 --> 02:39:34.590
Also das ergibt schon Sinn.

02:39:34.990 --> 02:39:36.590
Und dass das auch ein Memory-Leak hat...

02:39:36.990 --> 02:39:37.990
...gehe ich auch von aus...

02:39:37.990 --> 02:39:38.990
...aber es dürften wahrscheinlich...

02:39:38.990 --> 02:39:39.990
...nur ein paar Bytes sein.

02:40:00.520 --> 02:40:02.520
Über Unsafe sollte WLAN gehen.

02:40:03.320 --> 02:40:04.720
Sofern man die...

02:40:05.320 --> 02:40:06.320
...eingebauten...

02:40:06.320 --> 02:40:09.120
...ESP-C-Sachen aufrufen kann aus Rust...

02:40:09.120 --> 02:40:10.320
...dann vielleicht, ja.

02:40:15.560 --> 02:40:16.560
Aber ehrlich gesagt...

02:40:16.560 --> 02:40:16.960
...muss ich...

02:40:16.960 --> 02:40:17.560
...muss ich sagen...

02:40:17.960 --> 02:40:18.960
...Plattform-IO...

02:40:19.760 --> 02:40:20.960
...und auch wenn da unter der Haube...

02:40:20.960 --> 02:40:22.960
...C++ für den ESP32 ist...

02:40:22.960 --> 02:40:24.160
...ist recht angenehm.

02:40:32.150 --> 02:40:33.350
Ich glaube ehrlich gesagt...

02:40:33.350 --> 02:40:34.550
...dass in dem Fall C++...

02:40:34.550 --> 02:40:35.750
...und ich sag's nur ungern, ja...

02:40:36.350 --> 02:40:37.750
...aber C++ für solche Sachen...

02:40:37.750 --> 02:40:38.550
...angenehmer ist.

02:40:38.750 --> 02:40:39.550
Rust plus...

02:40:39.550 --> 02:40:40.350
...plus Arduino...

02:40:40.350 --> 02:40:42.150
...gibt's da denn ein gutes Projekt für?

02:40:42.150 --> 02:40:42.750
Wir hatten das...

02:40:42.750 --> 02:40:43.750
...wir hatten das geschrieben.

02:40:44.950 --> 02:40:46.350
Gibt's da ein gutes Projekt für?

02:40:46.550 --> 02:40:47.350
Kannst mal schicken...

02:40:47.350 --> 02:40:48.750
...vielleicht können wir uns das wirklich angucken.

02:40:48.750 --> 02:40:49.150
So.

02:40:54.080 --> 02:40:55.280
Leute, ich weiß nicht warum...

02:40:55.280 --> 02:40:57.280
...aber das Ganze ist jetzt langsamer geworden...

02:41:03.550 --> 02:41:05.350
...wenn wir C-Sharp freen lassen.

02:41:08.210 --> 02:41:08.810
Okay?

02:41:12.840 --> 02:41:13.840
Also es ist schneller...

02:41:14.840 --> 02:41:17.040
...es ist schneller Rust freen zu lassen als...

02:41:18.040 --> 02:41:20.640
...als C-Sharp freen zu lassen.

02:41:25.490 --> 02:41:25.890
Okay?

02:41:27.090 --> 02:41:27.690
Ah ja.

02:41:29.600 --> 02:41:30.600
Meinetwegen...

02:41:31.200 --> 02:41:32.600
...soll mir recht sein, okay.

02:41:38.160 --> 02:41:39.360
Der Benchmark hier unten...

02:41:39.360 --> 02:41:40.960
...ist aber für meine Sachen...

02:41:40.960 --> 02:41:42.360
...eh nicht sonderlich relevant...

02:41:42.760 --> 02:41:43.960
...weil die Funktion...

02:41:43.960 --> 02:41:46.160
...die ich wirklich schnell in der Schleife aufrufe...

02:41:46.560 --> 02:41:48.760
...ist nichts was Strings oder so returnt...

02:41:49.160 --> 02:41:50.560
...sondern das returnt gar nichts.

02:41:50.760 --> 02:41:51.760
Bekommt einfach nur nen...

02:41:52.760 --> 02:41:54.960
...nen Pointer als Parameter übergeben...

02:41:57.320 --> 02:41:59.120
...den es auch nicht selbst freen muss.

02:41:59.520 --> 02:42:01.720
Also insofern ist das hier eigentlich für mich...

02:42:01.720 --> 02:42:03.720
...die, die, der relevantere Benchmark...

02:42:03.920 --> 02:42:05.920
...und da ist Rust meilenweit schneller.

02:42:06.120 --> 02:42:07.720
.NET ist noch einen Ticken schneller...

02:42:08.120 --> 02:42:10.120
...also .NET zu .NET ist logischerweise...

02:42:10.120 --> 02:42:11.520
...schneller als .NET zu Rust...

02:42:12.120 --> 02:42:14.320
...aber Rust ist um Welten schneller als Go.

02:42:16.320 --> 02:42:17.520
Überrascht mich aber auch nicht...

02:42:17.520 --> 02:42:19.320
...weil ich wusste dass C-Go langsam ist...

02:42:19.320 --> 02:42:20.720
...und ich wollte einfach mal gucken...

02:42:21.520 --> 02:42:23.520
...ob es mittlerweile besser geworden ist.

02:42:23.920 --> 02:42:25.520
Ich würde sagen es ist besser geworden...

02:42:25.520 --> 02:42:26.720
...aber es ist immer noch ziemlich...

02:42:26.720 --> 02:42:27.720
...ziemlich lahm...

02:42:27.920 --> 02:42:29.720
...wenn man Millionenfach das aufruft.

02:42:29.920 --> 02:42:31.120
Wenn man das jetzt einfach nur...

02:42:31.120 --> 02:42:32.920
...ein paar tausend mal aufruft oder so...

02:42:33.320 --> 02:42:34.120
...drauf geschissen...

02:42:34.120 --> 02:42:36.120
...da macht es ein bisschen Overhead auch nicht aus.

02:42:37.720 --> 02:42:38.720
Aber wenn man das Millionenfach...

02:42:38.720 --> 02:42:39.720
...pro Sekunde aufruft...

02:42:39.720 --> 02:42:41.120
...dann macht es schon einiges aus.

02:42:41.920 --> 02:42:43.520
Was ich übrigens auch nicht machen werde.

02:42:44.520 --> 02:42:44.920
Also...

02:42:45.520 --> 02:42:46.320
...also für meine Verhältnisse...

02:42:46.320 --> 02:42:47.320
...könnte ich auch einfach...

02:42:48.520 --> 02:42:49.920
...die Go Library verwenden...

02:42:49.920 --> 02:42:50.720
...aber warum?

02:42:50.720 --> 02:42:51.320
Ich meine...

02:42:51.720 --> 02:42:52.520
...wir können...

02:42:52.520 --> 02:42:53.120
...das machen wir dann...

02:42:53.120 --> 02:42:54.120
...einmal nächsten Streams...

02:42:54.120 --> 02:42:54.920
...da machen wir dann...

02:42:55.320 --> 02:42:57.920
...WebRTC in Rust.

02:42:58.720 --> 02:43:03.900
Sind auch Aufrufe von Go nach C langsam?

02:43:04.500 --> 02:43:05.500
Ja, ja, auch...

02:43:06.300 --> 02:43:09.680
Theoretisch sind die ein Ticken schneller...

02:43:09.880 --> 02:43:10.880
...also früher war es so...

02:43:11.280 --> 02:43:13.080
...Aufrufe von Go nach C...

02:43:13.480 --> 02:43:14.480
...waren langsam...

02:43:15.480 --> 02:43:17.680
...also auch langsamer als von anderen Sprachen...

02:43:18.480 --> 02:43:20.280
...von anderer Sprache nach C...

02:43:20.880 --> 02:43:21.480
...aber...

02:43:21.480 --> 02:43:23.680
...in Go reinkollen von C aus...

02:43:23.680 --> 02:43:25.480
...war nochmal eine Ecke langsamer.

02:43:26.480 --> 02:43:27.280
Mittlerweile...

02:43:27.680 --> 02:43:28.680
...mittlerweile ist es glaube ich...

02:43:28.680 --> 02:43:30.480
...ungefähr gleich langsam.

02:43:31.480 --> 02:43:32.680
Aber das ist auch langsam, ja...

02:43:32.680 --> 02:43:34.080
...es ist vielleicht nicht ganz so langsam...

02:43:34.080 --> 02:43:35.680
...wie von anderer Sprache zu Go...

02:43:37.280 --> 02:43:38.280
...aber auch langsam.

02:43:38.880 --> 02:43:39.880
Go hat mit...

02:43:40.280 --> 02:43:40.880
...mit...

02:43:41.280 --> 02:43:42.680
...den langsamsten Interop...

02:43:43.080 --> 02:43:44.280
...mit anderen Sprachen...

02:43:44.280 --> 02:43:45.680
...von allen Programmiersprachen...

02:43:45.680 --> 02:43:46.280
...die es gibt.

02:43:46.680 --> 02:43:48.080
Go an sich ist relativ flott...

02:43:48.480 --> 02:43:49.080
...aber...

02:43:49.280 --> 02:43:51.880
...was hier alles immer über irgendeinen C-Interface geht...

02:43:52.280 --> 02:43:53.680
...da ist Go richtig langsam...

02:43:53.880 --> 02:43:54.880
...was auch ein Problem ist...

02:43:55.280 --> 02:43:55.880
...weil...

02:43:56.080 --> 02:43:56.880
...die ganzen...

02:43:57.280 --> 02:43:59.880
...Wrapper-Libraries für SQLite...

02:44:00.280 --> 02:44:02.680
...oder für irgendwelche anderen Low-Level-Sachen...

02:44:03.080 --> 02:44:06.080
...die sind potenziell in Go einfach arschlangsam...

02:44:06.680 --> 02:44:07.480
...weil...

02:44:07.880 --> 02:44:09.080
...C-Go langsam ist.

02:44:10.080 --> 02:44:11.680
Also wenn man ordentlich Load drauf hat...

02:44:12.080 --> 02:44:12.680
...und...

02:44:13.080 --> 02:44:13.680
...und...

02:44:14.080 --> 02:44:14.680
...und...

02:44:15.080 --> 02:44:15.680
...und...

02:44:16.080 --> 02:44:16.680
...und...

02:44:17.080 --> 02:44:17.680
...und...

02:44:17.680 --> 02:44:19.480
...also wenn man ordentlich Load drauf hat, ja...

02:44:22.280 --> 02:44:24.680
...deswegen gibt es beispielsweise für SQLite...

02:44:25.480 --> 02:44:26.280
...ein Projekt...

02:44:27.080 --> 02:44:28.280
...das SQLite...

02:44:28.880 --> 02:44:31.080
...transpiled nach Go...

02:44:31.880 --> 02:44:34.680
...damit es native Go kompiliert werden kann...

02:44:34.680 --> 02:44:37.280
...und nicht mit C-Function-Calls...

02:44:37.880 --> 02:44:40.880
...weil SQLite unter ordentlich Last wohl...

02:44:42.080 --> 02:44:44.080
...eine nicht zu unterschätzende Overhead hat...

02:44:44.080 --> 02:44:47.280
...weil es sehr viele C-Calls macht in Go...

02:44:47.280 --> 02:44:49.480
...weil SQLite halt eine C-Library ist.

02:44:50.680 --> 02:44:51.080
Ja.

02:44:51.880 --> 02:44:52.880
Also macht Probleme...

02:44:52.880 --> 02:44:55.280
...Go ist schnell, solange man sich innerhalb von Go bewegt.

02:45:04.360 --> 02:45:06.360
Und gibt es noch ein paar Examples?

02:45:07.560 --> 02:45:08.960
Examples?

02:45:17.400 --> 02:45:18.400
Plattform-IO.

02:45:18.400 --> 02:45:19.000
Nice.

02:45:20.910 --> 02:45:23.510
Ach, haben die das jetzt offiziell in Plattform-IO drin, ne?

02:45:24.110 --> 02:45:25.710
Ne, das ist das ganz normale...

02:45:26.310 --> 02:45:27.710
...ESP-IDF...

02:45:32.430 --> 02:45:33.430
...Source...

02:45:35.590 --> 02:45:36.590
...Main-AS.

02:45:38.880 --> 02:45:41.080
Okay, ja, da haben sie Rapper um Sachen gebaut, okay.

02:45:41.480 --> 02:45:42.680
Ja, also anscheinend kann man...

02:45:46.640 --> 02:45:48.040
...in den Makro-Zeug...

02:45:48.040 --> 02:45:49.440
...also anscheinend kann man auch...

02:45:49.440 --> 02:45:52.240
...ESP mit Rust programmieren, aber ganz im Ernst, das...

02:45:52.440 --> 02:45:53.440
...tue ich mir nicht an.

02:46:04.890 --> 02:46:05.290
Jo.

02:46:05.290 --> 02:46:06.290
Nice, Chat.

02:46:07.290 --> 02:46:08.290
Fast drei Stunden...

02:46:08.290 --> 02:46:11.290
...heute ganz schön lang gestreamt, heute Morgen drei Stunden, jetzt drei Stunden...

02:46:26.070 --> 02:46:27.470
...das Maurice-Video.

02:46:32.640 --> 02:46:33.040
Jo.

02:46:33.240 --> 02:46:33.840
Chat.

02:46:34.840 --> 02:46:36.040
Wir sind fertig für heute.

02:46:37.040 --> 02:46:38.840
Schön, dass ihr am Start wart.

02:46:40.040 --> 02:46:43.040
Guckt mal kurz, ob wir irgendjemand hosten können.

02:46:46.880 --> 02:46:48.680
Ich hoffe, euch hat der Stream heute gefallen.

02:47:11.900 --> 02:47:12.300
Wir haben...

02:47:12.300 --> 02:47:13.100
...okay.

02:47:16.290 --> 02:47:17.490
Hier haben wir...

02:47:17.490 --> 02:47:20.090
...hier haben wir einen am Start, vielleicht hoste ich den, zeigt mal.

02:47:22.450 --> 02:47:23.250
Der macht...

02:47:25.050 --> 02:47:26.250
...ja, ja, Fake-Email.

02:47:26.450 --> 02:47:27.250
Der macht...

02:47:27.450 --> 02:47:29.250
...Devops plus Kubernetes.

02:47:34.250 --> 02:47:34.650
Oh.

02:47:35.250 --> 02:47:35.650
Der...

02:47:36.250 --> 02:47:39.650
Ich glaube, der macht auch gerade seinen Stream aus, weil er Stream-Manager ist.

02:47:40.050 --> 02:47:40.650
Na gut.

02:47:41.250 --> 02:47:41.850
Dann nicht.

02:47:43.050 --> 02:47:43.850
Okay, Chat.

02:47:44.050 --> 02:47:44.850
Dann gehe ich auf.

02:47:45.050 --> 02:47:46.050
Bis denn, macht's gut.

02:47:46.250 --> 02:47:46.650
See you.

02:47:49.360 --> 02:47:50.160
Winke-Winke.
