WEBVTT

00:30.000 --> 00:41.760
Da bin ich schon wieder.

00:41.760 --> 00:53.520
Nachdem ich gestern ja relativ zackig weg musste, wegen anstehenden MMORPG, wegen an...

00:53.520 --> 00:56.400
ich kann nicht reden, ich muss den Satz nochmal neu anfangen.

00:56.400 --> 01:04.000
Nachdem ich ja gestern weg musste, wegen anstehenden MMORPG, bin ich heute wieder am Start.

01:04.000 --> 01:10.280
Heute kein MMORPG, das entscheidet sich immer erst ein bisschen später, wenn die Leute von

01:10.280 --> 01:11.280
der Arbeit kommen.

01:11.280 --> 01:17.200
Wir sind ja mittlerweile die ultra casuals, wir spielen vielleicht 2-3 Stunden oder vielleicht

01:17.200 --> 01:22.000
auch mal 4-5, aber meistens eher so 2-3 Stunden abends.

01:22.000 --> 01:29.760
Also casual as fuck und auch nicht jeden Tag und das hängt immer ein bisschen davon ab,

01:29.760 --> 01:31.240
ob die Leute halt da sind.

01:31.240 --> 01:35.280
Ja, mit denen man MMORPG alleine spielen ist doof und das hängt dann immer ein bisschen

01:35.280 --> 01:40.440
davon ab, ob die Leute da sind und manche haben Homeoffice, da wissen sie schon dann

01:40.440 --> 01:44.400
im Tag sind sie da, aber manchmal wissen sie auch auf die Arbeit und nicht so einfach,

01:44.400 --> 01:47.360
zumal es mittlerweile auch ziemlich bunt gemischt ist.

01:48.200 --> 01:59.400
Wir haben die MMO Group, mit der ich da schon eine ganze Weile eigentlich spiele, das besteht

01:59.400 --> 02:15.760
aus 4-6 Deutsch, je nachdem wer da ist, ein Franzose, ein Niederländer, es ist wild

02:16.640 --> 02:22.160
Es sind 8 Leute, es sind sogar mehr als 8 Leute, weil in Daug brauchst halt 8, um eine gescheite

02:22.160 --> 02:25.760
Group zusammen zu kriegen, nachdem nicht immer alle da sind.

02:25.760 --> 02:29.600
Ja und das entscheidet sich dann halt immer abends, ob die Leute da sind oder nicht.

02:29.600 --> 02:35.680
Guck mal, ich hab Viewtime auf meinem eigenen Video und dementsprechend kann ich so nicht

02:35.680 --> 02:39.200
so genau sagen, ob MMORPG oder nicht.

02:39.200 --> 02:45.080
Deswegen müssen wir halt anfangen, weil vor 20 Uhr wird heute relativ sicher.

02:45.960 --> 02:50.520
Kein Kreisegrind sein, das heißt wir haben noch eineinhalb Stunden Zeit, was sinnvolles

02:50.520 --> 02:51.520
mindestens zu machen.

02:51.520 --> 02:58.600
Ich glaube nicht, dass heute was ist, wir haben gestern bis 23 Uhr 30 Uhr oder so gespielt.

03:00.120 --> 03:06.120
Excited morgen das neue Business zu skalieren, morgen nicht, nächste Woche Montag ist es

03:06.120 --> 03:07.120
so weit.

03:07.120 --> 03:10.840
Würdest du irgendwann mein Steam Game mal probieren, wenn ich dir einen Keygift also

03:10.920 --> 03:11.920
in ein paar Monaten.

03:11.920 --> 03:18.520
Du bist nicht derjenige, der schon vor einer Weile mal was von einem Steam Game geschrieben

03:18.520 --> 03:19.520
hat, oder?

03:19.520 --> 03:24.080
Irgendwas mit Strichmännchen war das doch, oder?

03:24.080 --> 03:26.320
Oder bring ich das jetzt durcheinander?

03:26.320 --> 03:28.440
War das nicht irgendwas mit Strichmännchen?

03:28.440 --> 03:38.920
Oder ist das, oder ist das fast ganz was anderes?

03:39.680 --> 03:43.600
War das nicht so etwas mit minimalistischer Grafik und Strichmännchen?

03:43.600 --> 03:46.880
Oder es kann sein, dass ich das, dass ich das.

03:46.880 --> 03:53.400
Nee, nee, nee, dann bist du jemand anderes, aber ich erinnere mich, ich erinnere mich

03:53.400 --> 03:59.800
an die Frage zur Twitch-Tint-Integration, da membre ich mich, ja.

03:59.800 --> 04:05.360
Aber an das andere, das hat irgendjemand ja auch mal erzählt, in Game of Steam Released,

04:05.360 --> 04:09.520
das war irgendwas, das war so Strichmännchen-Warfare, oder irgendwie sowas.

04:09.520 --> 04:14.920
Ich krieg's nicht mal ganz zu sagen, das war irgendwas ganz minimalistisches mit Strichmännchen.

04:14.920 --> 04:21.800
Aber das ist schon, das braucht jetzt schon, keine Ahnung, zweieinhalb Jahre oder so her.

04:21.800 --> 04:24.080
Nie wieder was von gehört.

04:24.080 --> 04:27.840
Ja, so sieht's aus.

04:27.840 --> 04:32.400
Die Playlist ist wirklich Müll, ja.

04:32.640 --> 04:37.680
Ich kann sich echt nicht entscheiden, wie laut oder leise es sein wird, ich mach mal kurz

04:37.680 --> 04:39.600
die View auf meinen eigenen Videos aus.

04:44.320 --> 04:45.320
Beste.

04:54.360 --> 05:00.600
So, da haben wir ja noch die, das ist natürlich exellent, dass wir noch die To-Do-Liste vom

05:00.640 --> 05:01.640
letzten Mal haben.

05:01.640 --> 05:06.880
Haben wir das nicht auch irgendwo hier gespeichert zufälligerweise?

05:06.880 --> 05:07.880
Nee?

05:07.880 --> 05:13.520
Na gut, da könnte man ja zur Abwechslung mal mein Notizprogramm benutzen, was ich eigentlich

05:13.520 --> 05:19.080
nie verwende hier auf der, auf der Admin, äh, auf der Streaming, nicht Admin, auf der

05:19.080 --> 05:20.080
Streaming-VM.

05:20.080 --> 05:23.400
Jetzt ist die Musik wieder zu laut, man, die können sich echt nicht entscheiden über

05:23.400 --> 05:24.400
dieser Playlist.

05:24.400 --> 05:27.400
Was ist das denn?

05:27.400 --> 05:28.400
Excellent.

05:29.200 --> 05:32.800
Ich guck gleich, ich guck gleich den Chat rein.

05:32.800 --> 05:36.920
Ich will nur mal kurz vorbereiten, dass alles, dass alles richtig, richtig funktioniert

05:36.920 --> 05:37.920
gleich.

05:37.920 --> 05:45.920
Dann guck ich, dann guck ich den Chat rein, dass wir dann gleich auch noch ein bisschen

05:45.920 --> 05:48.040
was, heute zumindest mal ein bisschen was Sinnvolles machen können.

05:48.040 --> 05:49.040
So.

05:49.040 --> 05:55.560
Also, Leute, nochmal was anderes, hat irgendjemand eine Ahnung, wie ich diesen Mist hier aus

05:55.560 --> 05:56.760
Windows raus bekomme?

05:57.120 --> 06:02.320
Ich kann hier nicht in die Search-Settings, Index-Options und so, bringt, bringt mir alles

06:02.320 --> 06:03.320
nix.

06:03.320 --> 06:04.320
Ja?

06:04.320 --> 06:09.600
Also, ich hab keine Ahnung, wie das, wie ich das, ich, ich, ich, ich will das alles

06:09.600 --> 06:10.600
nicht wissen.

06:10.600 --> 06:16.960
Also, ich, ich will weder wissen, Pflanzentricks von Oma, noch Comeback-Flopped, Rauchwolke

06:16.960 --> 06:19.240
über Moskau, wie kann man diesen Shit ausschalten?

06:19.240 --> 06:23.080
Das ist, das ist was, das regt mich wahnsinnig auf.

06:23.560 --> 06:29.400
Und was mich auch aufregt ist, dass meine, sei das meine Suchanfragen, die ich hier eintippe,

06:29.400 --> 06:32.040
automatisch zu Microsoft geschickt werden.

06:32.040 --> 06:37.800
Ja, DeepLog, aber da muss es doch was ohne irgendwie halbe Windows-Funktionalität entfernen

06:37.800 --> 06:38.800
geben.

06:38.800 --> 06:42.520
Da muss da irgendwelche, wir haben das mal probiert mit irgendeiner Gruppenrichtlinie.

06:43.520 --> 06:51.480
Settings, Personalisieren, Personalize, ne.

06:51.480 --> 06:55.160
Hier das da meiste, ne, ne, da geht das nicht.

06:55.160 --> 07:01.040
Da kann man, das wäre viel zu schön, wenn man das hier einfach ausschalten könnte.

07:01.040 --> 07:04.960
Ne, das geht natürlich nicht bei Windows.

07:12.600 --> 07:15.600
Hm.

07:15.600 --> 07:25.680
Du hast keine Default-Network-Bridge, hast du Berechtigung, bist du in der LibWirt-Gruppe

07:25.680 --> 07:26.680
drin?

07:26.680 --> 07:28.680
Das könnte ich vielleicht auch in die, in die Ritmi schreiben.

07:28.680 --> 07:31.760
Siehst du, siehst du als Root ein Netzwerk?

07:31.760 --> 07:40.440
Wenn du als Root auch kein Netzwerk siehst, dann fehlt das schlicht und ergreifend.

07:40.760 --> 07:45.960
Dann kannst du entweder über den Wirt-Manager, hier das Default-Netzwerk, aber das müsste

07:45.960 --> 07:48.560
eigentlich da sein, dieses Default-Network.

07:48.560 --> 07:52.720
Das ist, also normalerweise legt der ne, ne Wirt-Bridge, gut, das ist halt Voraussetzung,

07:52.720 --> 07:57.000
du brauchst irgendein Netzwerk-Interface, dass das Netzwerk funktioniert logischerweise.

07:57.000 --> 08:00.080
Ansonsten, ja, weiß nicht.

08:02.080 --> 08:06.680
Leute, ich, ich, ähm, muss ich noch was, muss ich noch was anderes, aber ich beantworte

08:06.680 --> 08:07.680
mal kurz.

08:07.680 --> 08:09.680
Chat, also.

08:10.680 --> 08:14.360
Sorry, wenn ich etwas off-topic reinwerfe, habe die letzten zwei Tage damit verbracht

08:14.360 --> 08:21.400
von Hand, unsere Apps von Umgebung 1 in Umgebung 2 und 3 zu releasen, wie macht ihr das automatisiert?

08:21.400 --> 08:22.400
Könnt ihr etwas empfehlen?

08:22.400 --> 08:28.760
Dazu müsste man jetzt erstmal ergründen, was du da genau gemacht hast, also.

08:34.760 --> 08:38.600
Ich, ich rate jetzt einfach mal, was du gemacht hast und du sagst dann, ob das stimmt.

08:38.760 --> 08:47.800
Also, du hast irgendwie ein paar Binaries und Config-Files und was weiß ich, vielleicht

08:47.800 --> 08:52.120
noch ein paar mehr Dependencies, die gebraucht werden, dass deine Anwendung läuft, ja, beispielsweise

08:52.120 --> 08:55.560
OS-Packages, die installiert werden müssen und sonst was.

08:55.560 --> 09:02.400
So, und du bist jetzt quasi hergegangen und hast nochmal Linux-Kisten hingestellt, hast

09:02.400 --> 09:07.440
versucht, die Pakete möglichst gleich zu installieren, wie auf der ersten, äh, nennen wir es mal

09:07.440 --> 09:11.360
im ersten Environment und dann hast du deine Anwendung, Binaries rüberkopiert, deine Config

09:11.360 --> 09:19.280
rüberkopiert, die Config editiert und dann versucht es zu starten, so irgendwie sowas

09:19.280 --> 09:20.280
in der Richtung.

09:20.280 --> 09:21.280
Oder?

09:21.280 --> 09:27.840
Also, ist schwierig zu sagen.

09:37.440 --> 09:47.160
Ja, kannst du ja mal schreiben, was du, bisschen konkreter, was du gemacht hast, so allgemein

09:47.160 --> 09:51.840
muss man sagen, Umgebung baut man am besten, oder verschiedene Environments baut man am

09:51.840 --> 09:58.960
besten damit auf, äh, baut man am besten auf, indem man das heute in irgendeiner, muss nicht

09:58.960 --> 10:04.600
zwangsläufig Terraform sein, aber in irgendeiner Infrastructure als Code-Lösung abbildet,

10:05.440 --> 10:10.280
mit passenden Variablen an den Stellen, dass du dann relativ schnell 1, 2, 3, 4 Testing-Umgebungen

10:10.280 --> 10:11.280
starten kannst.

10:11.280 --> 10:25.400
Ähm, Anwendung, Deployen ist halt immer die Frage, wohin, also sprich auf eigene Infrastruktur,

10:25.400 --> 10:29.840
ist das möglich Stateless, ist das vielleicht in der Cloud, also sprich, wieviel muss drum

10:29.840 --> 10:36.000
darum da sein, dass die Anwendung läuft, das kann man so pauschal nicht sagen, am besten

10:36.000 --> 10:44.880
ist halt, ach, Google Cloud, ok, ah ja dann, dann ist das ganze doch deutlich, ok, dann

10:44.880 --> 10:48.440
ist es doch, dann geht das doch, dann geht das doch tatsächlich ganz gut.

10:48.440 --> 10:57.880
Ähm, ich scroll mal kurz durch, soll ich da irgendwas über sehen, aber, du musst mit

10:57.880 --> 11:02.600
rechtsklick, rechtsklick alle anpinnen, hier gibt es nichts zum anpinnen, hier kann man

11:02.600 --> 11:09.120
nicht drauf, man kann das löschen, ja super, aber auch nur einmal, lull, man kann das nur

11:09.120 --> 11:17.080
einmal löschen Leute, nur einmal, mehr geht nicht, der Rest bleibt da und jetzt kann man

11:17.080 --> 11:23.560
auch nicht rechts anklicken, ich sag euch Leute, ich bin doch so ein, shit, Alter, also,

11:24.560 --> 11:28.640
Google Cloud mit Kubernetes, darf ich fragen, ist das ein Standard Kubernetes Cluster oder

11:28.640 --> 11:38.840
ist es ein Autopilot Cluster, also, meine Güte, diese Playlist macht mich fertig, einmal

11:38.840 --> 11:44.960
so, einmal so, GitLab und Jenkins sind auch da, aber trotzdem sehr viel von Hand dazwischen,

11:44.960 --> 11:54.480
also, ok, wo fange ich da jetzt am besten an, immer mit dem Sternchen dran, dass ich

11:54.480 --> 12:00.240
jetzt auch nicht der Kubernetes Alleskönner auf jeder Cloud Plattform bin, aber es gibt

12:00.240 --> 12:06.720
eine coole Möglichkeit oder ein System, wie man das ganz gut machen kann, natürlich müssen

12:06.720 --> 12:13.640
die Anwendungen darauf angepasst sein, also das erste ist natürlich, die Anwendungen

12:13.640 --> 12:19.920
selbst brauchen kein Streicheln in dem Sinn, sondern können konfiguriert werden über

12:19.920 --> 12:26.320
Environment Variablen für deine Pots, für die Container, das ist da natürlich relativ

12:26.320 --> 12:33.520
praktisch, das stellst du im Deployment ein, Image XY, die Environment Variablen und gut

12:33.520 --> 12:39.640
ist, das ist schonmal das erste, wenn die Anwendung sich so verhält, dass man sie über

12:39.640 --> 12:45.400
Environment Variablen konfigurieren kann, ist noch mal ein großes Plus und ansonsten gibt's da

12:45.400 --> 12:51.160
ein ganz gutes System, was mittlerweile auch ein bisschen gehyped ist, beziehungsweise,

12:51.160 --> 12:59.040
dass so viele als, so macht man's ansieht, muss natürlich immer zum jeweiligen Unternehmen passen

12:59.040 --> 13:06.840
und zwar, man hat das ganze zweistufig, also, du hast irgendwo dein GitLab, keine Ahnung, ob's da ein

13:06.840 --> 13:12.240
schönes Bild zu gibt, doch gibt's bestimmt ein schönes Bild zu, du hast irgendwo dein GitLab und

13:12.240 --> 13:20.120
ein Jenkins, so, du hast dein Source Code von der Anwendung und du hast für diese Anwendung selbst

13:20.120 --> 13:27.720
Kubernetes Ressourcen definiert, ja, irgendwelche Yamels, das kann entweder im Anwendungsrepo drinnen

13:27.720 --> 13:34.480
sein, also, dass du dann beispielsweise in deiner Java Anwendung einen extra Ordner für einen Helmchart

13:34.480 --> 13:38.360
oder irgendwie sowas hast oder einen extra Ordner für irgendwelche Kubernetes, Jaml-Files,

13:38.360 --> 13:44.680
wie auch immer, es ist meistens ein bisschen angenehmer, wenn das Anwendungsrepo und das

13:44.680 --> 13:51.360
Infrastruktur für die Anwendungskonfigurationsrepo zwei Getrennte sind, weil da können auch unterschiedliche

13:51.360 --> 13:58.360
Leute drinnen rumwurschteln und ja, da komm ich gleich zu und es sind ja oftmals unabhängige

13:58.360 --> 14:04.280
Sachen voneinander und du müllst dem anderen auch nicht die History, die GitHistory zu, also,

14:04.280 --> 14:10.480
ein Repo mit der Anwendung, ein Repo mit der Kubernetes-Konfig für die Anwendung oder wenn

14:10.480 --> 14:17.440
sowas klein ist, kann es auch in eins schmeißen, ist erstmal wurscht, so, dann, wir überspringen

14:17.440 --> 14:23.360
das jetzt mal mit Pull-Request und dem ganzen Blödsinn drumherum, da gibt es eine neue Version,

14:23.360 --> 14:29.160
wie auch immer das aussieht und dann triggert das Jenkins, in dem Fall machen wir Jenkins,

14:30.040 --> 14:37.840
dann baut Jenkins, und jetzt kommt der Trick an der ganzen Geschichte, dann baut Jenkins nicht

14:37.840 --> 14:51.640
nur die Anwendung, sondern, falls es notwendig ist, passt es auch so weit wie notwendig die

14:51.640 --> 15:02.400
Kubernetes-Manifest, die Konfig an und dann pusht es der Jenkins alles in ein Continuous-Delivery-Repo

15:02.400 --> 15:10.160
und dann hast du sowas wie Flux oder ArgoCD in deinem Kubernetes-Cluster laufen, was permanent

15:10.160 --> 15:19.480
guckt, ob in diesem Continuous-Delivery-Repo Changes drin sind und sobald dort Changes

15:19.480 --> 15:28.040
reingepusht werden, wendet zum Beispiel ArgoCD automatisch diese Changes aus diesem Repo auf

15:28.040 --> 15:34.400
deinen Kubernetes-Cluster an, das heißt, es ist darauf ausgelegt, dass du nichts mehr von Hand in

15:34.400 --> 15:39.040
deinem Kubernetes-Cluster machst, das ist der Sinn dahinter, das ist auch das, was ganz gut passt,

15:39.040 --> 15:43.400
weil das willst du dir auch nicht, also sprich, du würdest deine Anwendung pushen, du würdest

15:43.400 --> 15:47.000
deine Konfig-Changes wie auch immer pushen, du würdest Jenkins das ganze zusammenbauen lassen

15:47.120 --> 15:54.560
und das Endprodukt quasi neue Anwendungs-Image in die Registry pushen und was auch immer Jenkins

15:54.560 --> 15:58.840
noch so alles macht und die Kubernetes-Config updaten kann ja auch sein, dass zum Beispiel

15:58.840 --> 16:05.680
in der Kubernetes-Config einfach die Image-Version neu geupdatet werden muss, also Jenkins baut

16:05.680 --> 16:10.000
zuerst die Anwendung, baut da draußen ein Container-Image, pusht das Container-Image

16:10.000 --> 16:15.640
in die Container-Registry, dann schnappt sich als nächstes Jenkins das Infrastruktur-Repo für

16:15.640 --> 16:21.320
diese Anwendung, aktualisiert da drinnen, ist jetzt nur ein Beispiel, aktualisiert da drinnen die

16:21.320 --> 16:27.840
Version des Container-Images, dann ist Jenkins fertig mit seinem Build, pusht den Output in ein

16:27.840 --> 16:34.520
Continuous-Deployment, Continuous-Delivery, wie auch immer man es nennt, eigenes Git-Repo und

16:34.520 --> 16:41.520
auf diesem Repo lauscht dann zum Beispiel sowas wie Argo-CD und das schnappt sich die Änderung und

16:41.520 --> 16:45.800
wende das auf den Cluster an, das hat den Vorteil, du kannst alles immer wunderbar nachvollziehen,

16:45.800 --> 16:50.400
aus welchem Grund was gemacht wurde und es kann auch nicht, und das ist das eigentlich das Schöne,

16:50.400 --> 16:55.920
es kann auch nichts außer Sync kommen, weil das immer über diesen automatisierten Weg geht,

16:55.920 --> 17:01.720
das Ganze, wenn man cool sein will, nennt man dieses Verfahren GitOps, weil sich irgendwelche

17:01.720 --> 17:06.360
Leute ausgedacht haben, das hört sich geil an, man sollte nicht so sehr darauf gucken,

17:07.200 --> 17:14.400
wie ich das sage oder wie Leute in YouTube-Videos das erzählen, man muss schon immer gucken,

17:14.400 --> 17:18.800
dass das irgendwie vom jeweiligen Ablauf, weil die Tools sind ja auch in jedem Unternehmen ein

17:18.800 --> 17:24.720
bisschen anders, dazu passt, hier ist glaube ich ein ganz, das ist ja wieder wahnsinnig kompliziertes

17:24.720 --> 17:38.520
Bild, das ist jetzt mit Argo, Argo-CD-Bildchen, die Bilder sind jetzt alle nicht so schön ehrlich

17:38.520 --> 17:46.360
gesagt, ja das geht eigentlich, aber da muss es doch schönere Bilder zu geben,

17:46.360 --> 18:00.560
naja, das ist tatsächlich gar nicht, das ist tatsächlich gar nicht mal so schlecht dieses Bild

18:00.560 --> 18:12.440
hier, das ist tatsächlich gar nicht so schlecht, also irgendein Typ entwickelt seinen Kram,

18:12.440 --> 18:17.000
committer das in irgendein Git-Repo, in dem Fall natürlich, weil es Microsoft ist,

18:17.000 --> 18:25.640
selbstverständlich über GitHub, also an Git laufen, hier GitHub Actions, GitHub Actions und

18:25.640 --> 18:34.600
das ist jetzt, in dem Fall gehen die davon aus, dass anscheinend Software-Quellcode und

18:34.600 --> 18:40.240
Infrastruktur-Kubanitis-Yaml-Definition in einem Repo drin, es könnten auch in zwei Repos sein,

18:40.280 --> 18:44.800
wenn es größer wird, ist es sogar sinnvoll, das in zwei Repos zu machen, der committer das,

18:44.800 --> 18:52.080
dann laufen GitHub Actions, das ist in deinem Fall der Jenkins, der Jenkins baut dann ein

18:52.080 --> 18:57.600
Kubernetes-Manifest, baut ein neues Container-Image, pusht das Container-Image,

18:57.600 --> 19:02.200
im Prinzip genau das, was ich gesagt habe, pusht das Container-Image in die Registry und am Ende,

19:02.200 --> 19:08.320
das ist jetzt, an der Stelle fehlt eigentlich noch ein weiterer Punkt, weil das machst du nicht mit

19:08.320 --> 19:14.360
GitHub Actions, an dieser Stelle sitzt dann sowas wie ArgoCD zum Beispiel dazwischen und erkennt,

19:14.360 --> 19:20.360
ok, es gibt ein neues Kubernetes-Manifest und applied das auf deinen Cluster, du musst das

19:20.360 --> 19:24.240
natürlich nicht machen, der Chat hat vollkommen recht, du könntest die Dinge auch mit kubectl

19:24.240 --> 19:31.960
apply selbst raufhauen, wenn du willst, wobei ich das Verfahren mit ArgoCD wirklich sehr nice finde,

19:31.960 --> 19:35.840
oder Flux, Flux habe ich aber noch nie verwendet, muss ich ehrlich sagen, wobei ich das Verfahren

19:35.840 --> 19:41.800
mit ArgoCD persönlich ganz nice finde, weil du nichts mehr manuell, nichts ist jetzt übertrieben,

19:41.800 --> 19:45.800
aber zumindest die Anwendungs-Deployments, die musst du nicht mehr von Hand machen und es ist

19:45.800 --> 19:50.600
immer alles schön nachvollziehbar, du musst keine, du musst keine Images von Hand updaten,

19:50.600 --> 19:57.920
keine Versionen und sonstige Geschichten. Ich habe da letztens sogar einen Stream drüber gemacht,

19:57.920 --> 20:01.240
aber ich würde dir nicht empfehlen, den Stream anzugucken, weil der war relativ verplant,

20:01.240 --> 20:06.040
ich habe irgendwie eineinhalb Stunden gebraucht, das Setup vom letzten Stream zum Laufen zu bekommen,

20:06.040 --> 20:15.440
guck dir lieber was anderes an als meinen Twitch-Stream dazu, aber was ich dir zeigen kann ist,

20:15.440 --> 20:27.760
aus dem Stream, was ich dir zeigen kann aus dem Stream ist, wie das mit ArgoCD am Ende aussieht,

20:27.760 --> 20:35.320
weil das ist glaube ich was, was du machen willst, also guck mal, das ist das Webinterface von ArgoCD,

20:35.320 --> 20:42.360
lass dich nicht verwirren, nichts davon muss von Hand konfiguriert werden, das ist einfach nur die

20:42.360 --> 20:49.960
Anzeige und das sind alle Anwendungen, die ArgoCD kennt, also das hier sind zwar fertige Anwendungen,

20:49.960 --> 20:54.880
das ist übrigens meine hier, das ist meine Testanwendung, die ich gebaut habe, aber du

20:54.880 --> 20:57.080
kannst ja auch andere Projekte, die schon fertig sind, da reinhauen,

21:02.360 --> 21:07.360
ja, das hier war meine Testanwendung, so und wenn ich jetzt das irgendwie auf die

21:07.360 --> 21:12.960
Reihe kriege davor zu schwulen, kann man, dann kann man jetzt, ich weiß gar nicht,

21:12.960 --> 21:15.720
wo ich das, wo man es hier mal schön sieht im Stream,

21:16.720 --> 21:22.160
und jetzt einfach mal kurz vor, vielleicht sieht man es irgendwie noch,

21:32.720 --> 21:41.640
Alter, gescheit spulen geht hier auch nicht, oder? Ich glaube hier war ich schon fertig,

21:41.640 --> 21:44.840
was auch immer, zumindest sieht man das wunderbar zwischendurch,

21:44.840 --> 21:49.840
wenn ich was committe in meiner Anwendung, in meinem Anwendungsrepo,

21:49.840 --> 22:12.600
immer ich da getrieben habe, Alter, ich weiß nicht, da habe ich Prometheus Zeug jetzt nicht,

22:12.600 --> 22:20.160
wo the fuck hier, Prometheus, keine Ahnung, wo man, keine Ahnung, wo man es jetzt gescheit

22:20.160 --> 22:37.000
sieht im Stream, hier, hier, hier sieht man es jetzt, nee, ach shit, ach keine Ahnung,

22:42.600 --> 22:55.480
ach gut, bevor ich jetzt ewig rumsuche, lass ich, keine Ahnung, ja, aber wir haben das

22:55.480 --> 22:59.440
letztens im Stream zusammen gemacht, guckt ihr lieber ein paar YouTube Videos an,

23:04.960 --> 23:09.840
als Entwickler Trigger möchte das automatische commit auf deiner Konfigurationsrepo, falls

23:09.840 --> 23:22.320
Agoth sich über einen Kreis hat, aber dafür ist alles andere, äh, wie jetzt, hä? Du meinst,

23:22.320 --> 23:29.720
dass dein Bildtool oder was auch immer, dein CI Tool Infrastruktur, ja Moment, deswegen sage

23:29.720 --> 23:35.640
ich ja auch, es ist sinnvoll unterschiedliche Repos zu haben, das ist genau das, was ich ja eben

23:35.640 --> 23:40.680
gemeint habe, es macht durchaus Sinn, nicht den Source Code der Anwendung und die Infrastruktur

23:40.680 --> 23:44.960
Definition im gleichen Repo zu haben, weil es spamt ja unter anderem die History voll,

23:44.960 --> 23:53.400
das ist genau das, was ich eben gemeint habe, nee, mit Terraform hat das gar nichts zu tun,

23:53.400 --> 24:07.800
Agoth CD macht nicht CI, sondern Agoth CD macht CD, Agoth CD ist dafür da, das zu

24:07.800 --> 24:12.880
deliveren in den Kubernetes Cluster, das was schon fertig ist, CI ist Jenkins in deinem Fall

24:12.880 --> 24:18.880
und Agoth CD würde den Output von Jenkins im Infrastruktur Repo nehmen und den Applian auf

24:18.880 --> 24:24.840
den Cluster. In dem Test, in dem Bastel Stream, den ich gemacht habe, da habe ich das ganze

24:24.840 --> 24:43.520
über GitHub Actions gemacht. Ja, es ist die Frage, ob du das machst, ob das vielleicht

24:43.520 --> 24:49.640
einen Build Server macht und ob das wirklich im gleichen Repo sein muss. Also es würde sich

24:49.640 --> 24:57.800
doch durchaus anbieten zu sagen, okay, man hat ein Anwendungsrepo, eventuell mit den Kubernetes

24:57.800 --> 25:03.200
Definitionen oder mit einem Helm Chart oder irgendwie sowas drin, aber gehen wir mal von

25:03.200 --> 25:07.960
aus, du hast ein Anwendungsrepo, wo auch deine Kubernetes Configs drin sind, ja dein Customize

25:07.960 --> 25:14.080
Zeug ist da zum Beispiel drin und du müsstest jetzt ja die Version vom Image aktualisieren.

25:14.080 --> 25:21.040
Die erste Frage ist, warum kannst du die Version vom Image nicht in irgendeinem Build Prozess,

25:21.040 --> 25:25.080
in irgendeinem Jenkins, GitHub Actions, was auch immer aktualisieren, weil irgendwo muss das Image

25:25.080 --> 25:30.240
ja gebaut werden. Wenn du das Image baust, könntest du theoretisch das auch an der Stelle

25:30.240 --> 25:41.840
aktualisieren, wenn man das will und wenn das vom Ablauf her passt, aber der Output, also mal

25:41.840 --> 25:46.000
angenommen, das würde, mal angenommen du hättest den Jenkins und der baut das für dich zusammen,

25:46.000 --> 25:53.360
der baut ein Image, der pusht das Image in die Registry und der schreibt in das Yammerfile die

25:53.360 --> 25:59.440
neueste Version von einem Image rein, dann sollte der das nicht zurück committen in das

25:59.440 --> 26:05.880
Ursprungs-Source-Repo, sondern es sollte ein eigenes Repo dafür geben, wo nur automatisch

26:05.880 --> 26:09.880
generierte Sachen reinkommen werden, ansonsten wirst du ja verrückt in deiner Repo und wenn

26:09.880 --> 26:17.760
du das Problem hast, dass du von Hand editieren musst, die Image-Version, dann würde es sich

26:17.760 --> 26:23.880
vielleicht anbieten, dass du die Anwendung und die Infrastrukturkomponenten eben auch voneinander

26:23.880 --> 26:29.160
trennst, dass du eben nicht den Scheiß hast, dass dir irgendwelche Infrastrukturänderungen

26:29.160 --> 26:33.880
permanent deine Historie vollspammen. Ich glaube, das muss man ein bisschen dynamisch

26:33.880 --> 26:38.360
handhaben, je nachdem wie groß das Ganze ist, wie viele Leute daran arbeiten, wie so der allgemeine

26:38.360 --> 26:44.280
Workflow ist. Aber das kann ich verstehen, das würde mir persönlich auch extrem auf den Sack gehen,

26:44.280 --> 26:53.240
wenn keine Ahnung, die Hälfte oder 80 Prozent der Commits irgendwelche changed value in Kubernetes

26:53.240 --> 26:56.960
YAML-Commits sind. Da pleckst du ja bei der eigentliche Anwendung nicht mehr durch.

26:56.960 --> 27:03.600
Und da bietet es sich ja vielleicht wirklich an, dass man sagt, hey, man splittet die

27:03.600 --> 27:10.280
Infrastruktur-Konfiguration für die Anwendung und die Anwendung selber auf. Ja, du könntest ja zum

27:10.280 --> 27:16.320
Beispiel ein, was weiß ich, du könntest hier Qt-App machen und du könntest Qt-App-Infra machen,

27:16.320 --> 27:21.200
zum Beispiel. Also zwei Repos. Hier ist deine Anwendung drin, ihr könnt entwickeln,

27:21.200 --> 27:26.440
wie ihr lustig seid. Hier hast du die Kumpanätes-Definitionen und Gedöns drin,

27:26.440 --> 27:31.480
wo dann unter anderem vielleicht auch andere Leute dran rumbasteln als jetzt du oder rein die

27:31.480 --> 27:40.600
Entwickler an sich. So, dann hast du irgendeinen Jenkins. Da hast du irgendeinen Jenkins. Oder

27:40.600 --> 27:50.640
was ist noch cool hier? GitHub Actions oder was auch immer. Hast du dann dazwischen?

27:50.640 --> 28:00.080
Und der hier, also quasi das Continuous Integration Tool, das könnte ja dann theoretisch sowohl das,

28:00.080 --> 28:13.120
sowohl das als auch das quasi zusammenführen, indem es, sagen wir mal, App kompiliert,

28:13.120 --> 28:30.000
Dinge macht und Image baut, Image in Registry pusht und dann, und dann das Infrastruktur-Repo

28:30.000 --> 28:42.600
nimmt, dort, dort Images updated oder Image, Image-Version updated und der Output, der geht

28:42.600 --> 28:50.400
dann in irgendein, ich nenne es jetzt mal, keine Ahnung hier, k8s-gitops.git oder was auch immer,

28:50.400 --> 28:59.280
in irgendein Output oder irgendwie, keine Ahnung, generated oder sowas. So, und dieses

28:59.280 --> 29:13.320
Repo, das Pulled-Argo-CD und applied das dann auf den Cluster. So, nice. Tolles ASCII Bildchen,

29:13.320 --> 29:18.440
ja. Also ich glaube, man versteht halbwegs, mal allerdings, danke schön für den Zapp,

29:18.440 --> 29:26.080
man versteht glaube ich halbwegs, halbwegs, was ich, was ich will, ja. So, das, das stimmt,

29:26.080 --> 29:37.920
ja. Okay, danke für den Zapp. Es stimmt, GitHub Actions sind ein bisschen eklig zu debuggen,

29:37.920 --> 29:43.360
wenn was nicht funktioniert, aber es gibt da einen kleinen Trick, wenn du es lokal ausprobieren

29:43.360 --> 29:49.080
willst. Du kannst damit nicht alles ausprobieren, aber du kannst zum Beispiel sowas hier verwenden.

29:49.080 --> 29:55.280
Nicees Projekt der V-Champ, der VM-Champ, ja, wir machen gleich weiter was. Du kannst,

29:55.280 --> 30:04.200
du kannst zum Beispiel das da ausprobieren. Hat nur 36.000 Sterne, ist nicht so bekannt.

30:04.200 --> 30:11.560
Damit kannst du GitHub Actions lokal ausführen zum Testen. Wobei, wobei du selbstverständlich

30:11.560 --> 30:17.240
damit nicht alles machen kannst. Also du hast dann zum Beispiel, oder, weiß ich gar nicht,

30:17.240 --> 30:21.760
ob man das nicht vielleicht irgendwie verbinden kann, aber du kannst da zum Beispiel nicht direkt

30:21.760 --> 30:27.040
auf Repro Secrets zugreifen. Man kann allerdings irgendwie in GitHub, das habe ich aber auch noch

30:27.040 --> 30:36.720
nicht gemacht, man kann auch, man kann auch ja irgendwie Custom Runner registrieren in GitHub.

30:36.720 --> 30:42.160
Wobei ich das echt noch nie gemacht habe. Da könntest du quasi in den lokalen Runner registrieren

30:42.160 --> 30:47.400
für dein Projekt. Vielleicht, vielleicht braucht man auch in den Enterprise Abo, keine Ahnung.

30:47.400 --> 30:54.600
Ich weiß so, dass es geht, aber ich habe es noch nicht gemacht. Jo. Aber ja, es stimmt schon,

30:54.600 --> 31:00.040
GitHub Actions sind ein bisschen eklig zu entwickeln. Gerade wenn man für jeden Test was pushen,

31:00.040 --> 31:03.840
was committen muss, was pushen muss oder was force, überschreiben, force pushen muss,

31:03.840 --> 31:09.680
dann irgendwie eine Minute wartet, bis die GitHub Action durchgelaufen ist, nur dass er im Elften

31:09.680 --> 31:13.760
von Zwölf Build Steps failed mit irgendeinem Shit, wo du nicht weißt, was es bedeuten soll,

31:13.760 --> 31:17.360
dann musst du wieder von vorne anfangen. Also ich kenne dein Problem. Ich kann das,

31:17.360 --> 31:24.120
ich kann das, ich fühle es, wie man so schön sagt heutzutage. Nichtsdestotrotz muss ich sagen,

31:24.120 --> 31:31.960
es ist zwar Jaml und ich habe mittlerweile echt eine Abneigung gegen Jaml entwickelt,

31:31.960 --> 31:36.280
weil mittlerweile bist du, du bist nicht DevOps Engineer, Server Admin oder Entwickler. Du bist

31:36.280 --> 31:46.080
eigentlich zu 90 Prozent ja teilweise nur noch Jaml Engineer. Aber nichtsdestotrotz finde ich

31:46.080 --> 31:54.560
noch von allen Lösungen ist GitHub Actions eine schöne Kombination aus simple zu benutzen und man

31:54.560 --> 32:04.520
kann das meiste recht easy damit machen. Du hast sehr viele vorgefertigte Actions,

32:04.520 --> 32:08.640
die du benutzen kannst. Es gibt zum Beispiel eine komplett fertige Action, um ein neues

32:08.640 --> 32:15.800
GitHub Release zu machen, also ein neues, also Spugi Musik. Also wenn man jetzt zum Beispiel

32:15.800 --> 32:22.160
ein neues Release hier anlegen will auf GitHub, gibt es eine Action, die macht genau das. Da muss

32:22.160 --> 32:27.320
man sich gar nicht mehr selbst darum kümmern, das ist auch sehr praktisch. Nee, habe ich nicht,

32:27.320 --> 32:37.240
habe ich nicht. Ich noch nicht. Habe ich auch nicht vor. Zu viel, zu viel Kacke, JavaScript Kacke.

32:37.240 --> 32:51.640
Du meinst, wenn du die Secret nicht direkt ins Git legen willst, oder? Ach nee,

32:51.640 --> 32:56.640
du meinst, du meinst den lokalen Runner, wenn du deine Secrets nicht, ja, ja, das ist tatsächlich

32:56.640 --> 33:01.480
ganz, ganz ähnlich. Also ich weiß zum Beispiel, wir auf der Arbeit, also da wo ich mein noch

33:01.480 --> 33:10.320
Arbeitgeber, noch für quasi einen Tag, da haben wir das so. Wir haben manchmal in GitHub Actions

33:10.320 --> 33:16.720
ein bisschen Zwecke entfremdet, ja. Wir haben zum Beispiel eine GitHub Action, die bei einem Push

33:16.720 --> 33:24.640
neue Hostlisten generiert oder bei einem Push Sachen aus der CMDB Datenbank kopiert in was

33:24.640 --> 33:29.560
anderes und sowas. Es ist ein bisschen zweckentfremdet, ist auch egal warum. Zumindest wichtig ist,

33:29.560 --> 33:36.200
die haben eigentlich aus dem Internet raus keine Zugriff auf irgendwelche internen Management Tools

33:36.200 --> 33:41.080
und wir haben einen GitHub Runner, der steht bei uns und hat darauf Zugriff. Also das ist

33:41.080 --> 33:56.840
tatsächlich ganz nützlich, ja. Muss ich dir ehrlich sagen, habe ich persönlich noch nicht

33:56.840 --> 34:01.560
allzu viel mitgemacht. Das, was ich bisher gesehen habe, sah relativ ähnlich aus zu GitHub Actions.

34:01.560 --> 34:07.940
Warum nimmt man nicht gleich einen Jenkins? Naja, da musst du halt einen Jenkins installieren und

34:07.940 --> 34:13.120
musst dich um Jenkins kümmern und im Jenkins kannst du zwar alles machen, muss sagen Jenkins

34:13.120 --> 34:18.360
ist wahrscheinlich auch heute noch mit Abstand, wahrscheinlich wirklich mit Abstand das Flexibelste,

34:18.360 --> 34:22.760
aber du musst dich um den Jenkins kümmern, was du bei GitHub Actions nicht machen musst und du

34:22.760 --> 34:26.800
musst halt alles selbst, oder was heißt alles, du musst halt vieles selbst bauen, wo du bei

34:26.800 --> 34:32.040
GitHub Actions einfach sagen kannst, ich nehme die GitHub Release Action, schreibe da drei Werte

34:32.040 --> 34:38.360
rein und fertig ist bei einem Tag Push ein neues GitHub Release. Also du kannst alles in Jenkins

34:38.360 --> 34:45.400
machen, also wenn du was super Flexibles brauchst, wo ganz komische Dinge gemacht werden, die vielleicht

34:45.400 --> 34:54.920
manuelle ausgefeilte Logik erfordern, dann ist ein Jenkins nicht verkehrt. Kann man durchaus machen.

34:54.920 --> 35:03.680
Ansonsten ist GitHub Actions einfacher finde ich in der Handhabung, es ist direkt Bestandteil vom

35:03.680 --> 35:11.080
Repo und du musst dich nicht ums Hosting kümmern, also insofern finde ich es gar nicht verkehrt.

35:11.080 --> 35:20.120
Lieber Jaml oder Domain Specific, das hat Vor- und Nachteile bei, das kann ich so pauschal nicht

35:20.120 --> 35:26.560
sagen. Also Jaml hat halt den Vorteil, es ist Jaml, es ist überall gleiches Jaml, wobei natürlich die

35:26.560 --> 35:31.920
Sachen, die man reinschreiben muss, trotzdem unterschiedlich sind. Eine Ruby on Rails Config in

35:31.920 --> 35:39.720
Jaml sieht anders aus wie eine Kubernetes Config in Jaml, obwohl das alles Jaml ist und man muss

35:39.720 --> 35:43.960
halt auf Einrückungen stehen, also wahrscheinlich mögen Python Entwickler deswegen Jaml so gerne,

35:43.960 --> 35:52.160
weil die auf Einrückungen stehen, keine Ahnung, aber es ist zumindest Jaml, man kann sich dran

35:52.160 --> 35:56.680
gewöhnen. Domain Specific Language ist auch nicht der Weisheitsletzter Schluss, guckt ihr Terraform

35:56.680 --> 36:06.480
an. Das ist erträglich, aber ich finde Terraform nicht schön. Und Terraform ist auch auf die Idee

36:06.480 --> 36:18.000
gekommen schon, ich weiß nicht, ob ihr das kennt, wie heißt das? CDRTF oder so? Ne, CDKTF? Also

36:18.000 --> 36:24.560
Terraform ist nämlich auch schon auf die Idee gekommen, dass ihr Terraform HCL auch nicht so

36:24.560 --> 36:42.440
das geilste Format auf diesem Planeten ist. Wollen wir ein Beispiel an? Moment, das ist... Nein.

36:42.440 --> 37:02.880
Das ist nicht so hübsch. Ja, das hier sieht auch alles so übersichtlich aus, aber spätestens wenn

37:02.880 --> 37:09.960
du Schleifen hast und Branches und so, dann wird es ein bisschen abartig. Und das ist Terraform

37:09.960 --> 37:22.040
übrigens auch aufgefallen, dass das nicht für alle Fälle so gut ist, ihr Terraform Special Language.

37:22.040 --> 37:28.600
Und deswegen sind sie auf die Idee gekommen, wir tun einfach mal so, als sind wir Pulumi und

37:28.600 --> 37:35.000
machen Terraform nur mit ordentlichen Programmiersprachen. Und das habe ich noch nie ausprobiert, das ist

37:35.000 --> 37:40.920
übrigens auch was, was ich mal auf unsere Stream-Ausprobierliste schreiben will. Setz mal an

37:40.920 --> 37:51.200
der Stelle. Ja, das ist jetzt, das ist jetzt neu. Was heißt neu? Also so mega, mega neu ist es auch

37:51.200 --> 38:01.560
nicht mehr. Nein, das hat nichts mit CDK, das hat nichts mit CDK, mit AWS-CDK zu tun, bitteschön.

38:01.560 --> 38:08.120
Nicht, dass man auf die Idee kommt, dass CDK hier wäre das CDK da. Nein, nein, nein, nein, nein. Das

38:08.120 --> 38:15.200
ist das Cloud Development Kit for Terraform. Das andere ist das AWS Cloud Development Kit,

38:15.200 --> 38:20.240
nicht das Terraform Cloud Development Kit. Also nicht, dass ihr jetzt irgendwie durcheinander

38:20.240 --> 38:30.640
kommt oder so. Oh fuck. Big, Big Cack W. Du hast zwei Pulumi Beispiele. Ja, schick mal. Find ich,

38:30.640 --> 38:36.080
können wir uns das tatsächlich gerade angucken. Und das ist quasi noch mal ein Aufsatz auf Terraform,

38:36.080 --> 38:45.040
wo man dann Terraform, so wie Pulumi, in ordentlichen Programmiersprachen schreiben kann. Da kann man

38:45.160 --> 38:55.640
sowas hier zum Beispiel machen, falls sie irgendwie mal gescheite. Ich hätte wetten

38:55.640 --> 39:01.760
können, auf mobile konnte ich C-Sharp anklicken an der Stelle. C-Sharp Example.

39:15.040 --> 39:24.840
Natürlich alles nur für AWS, aber wie gesagt, die sagen ja selbst, dass es für alles gilt,

39:24.840 --> 39:39.800
nicht nur für AWS. Also meine persönliche Empfehlung wäre, guck dir mal Pulumi an,

39:39.800 --> 39:55.600
wenn du gerne Infrastructure as Code als Programmiersprache als Source Code hälst,

39:55.600 --> 40:03.640
dann kannst du dir Pulumi angucken. C-Sharp Example. Ich glaube, wir haben sogar ein bisschen Pulumi

40:04.240 --> 40:13.200
im Stream gemacht. Das sieht dann so aus, guck. Haben die alle mal gescheite Beispiele,

40:13.200 --> 40:30.920
please? Ja, Pulumi Examples. Weiß ich jetzt, C-Sharp, da ist sie. S3 Folder, ja. Ja, toll. Wo ist

40:30.920 --> 40:36.440
es denn? Webstack, CS, da ist es. Guck, da kannst du in normalen Programmiersprachen eben

40:37.280 --> 40:46.360
definieren. Pulumi hat damit angefangen und Terraform hat jetzt mit CDKTF nachgezogen.

40:46.360 --> 40:50.600
Das gibt es doch nicht so lange. Guck, ihr seht ja, so die ersten paar YouTube-Dinger

40:50.600 --> 41:01.640
sind von Anfang 2022. Ja, wenn die sich für Terraform entschieden haben, dann ist wahrscheinlich

41:02.480 --> 41:11.640
CDKTF-Abkürzung besser. Warum man nicht Jenkins für so was nimmt? Weil man dann unter anderem

41:11.640 --> 41:20.560
Jenkins betreiben muss. Also das ist, ich muss das jetzt an der Stelle noch mal sagen,

41:20.560 --> 41:30.760
das ist Fluch und Segen von so Cloud-Umgebung in einem. Oder, nee, das muss ich anders sagen,

41:30.880 --> 41:36.880
das ist Fluch und Segen von moderner, muss ja nicht zwangsläubig Cloud sein, von modernem

41:36.880 --> 41:47.080
Infrastruktur-Handling ist das Fluch und Segen zugleich, dass du alles auf 1000 Varianten machen

41:47.080 --> 41:52.680
kannst. Ja, es gibt für alles 10 verschiedene Tools, die du wieder auf 20 verschiedene Art und

41:52.680 --> 41:59.760
Weise zusammenstöpseln kannst. Mal damit, mal damit, mal lässt du den Step weg. Weil

41:59.760 --> 42:03.760
sind die Leute dafür zuständig, mal ist es da. Hat aber auch den Vorteil, du kannst das,

42:03.760 --> 42:07.400
wenn man genug Hirnschmalz reinsteckt, und das ist natürlich immer die Voraussetzung,

42:07.400 --> 42:16.880
fähige Leute für hast, das recht gut individuell anpassen, dass es für die Stelle, wo man es gerade

42:16.880 --> 42:24.320
baut, am besten passt. Aber es ist schon unglaublich komplizierter. Es gibt ja hunderte Varianten und

42:24.320 --> 42:29.360
insgesamt 10.000 Kombinationsmöglichkeiten, wie du die ganzen Sachen machen kannst.

42:29.360 --> 42:44.760
Ja, du hast schon recht, sollte ich wirklich machen. Das ist nicht JavaScript. Terraform

42:44.760 --> 42:52.800
unterstützt C-Sharp. Ja, also Terraform CDK unterstützt C-Sharp, Go, Java, Python und

42:52.800 --> 42:57.960
TypeScript. Also du kannst das in TypeScript machen. Das ist, ohne Scheiß, ich glaube exakt

42:57.960 --> 43:04.400
das gleiche, was Pulumi auch unterstützt. Das ist auch eine sehr gute Sprachauswahl. Du hast

43:04.400 --> 43:08.480
Python und JavaScript, somit die beliebtesten Programmiersprachen, zumindest wenn man mal nach

43:08.480 --> 43:14.080
GitHub geht aktuell. Du hast Java und C-Sharp fürs Enterprise und Go für die Hipster Cloud

43:14.080 --> 43:21.760
Native Leute. Fehlt eigentlich nur noch, damit auch die Rust-Taskforce glücklich ist. Aber dafür

43:21.920 --> 43:27.680
hat Rust glaube ich noch zu wenig Verbreitung. Und ehrlich gesagt bietet sich Rust dafür auch

43:27.680 --> 43:34.680
nicht wirklich an. Weil Rust ist eine Sprache, die hat einen ganz spezifischen Sinn, nämlich quasi

43:34.680 --> 43:42.000
unmanaged möglichst memory safe zu sein. Und es ist keine Sprache, die jetzt gedacht ist für

43:42.000 --> 43:48.280
super Programmiererproduktivität oder sonstiges, einzig und allein. Und das ist der Hauptgrund von

43:48.360 --> 43:55.000
Rust, unmanaged möglichst memory safe zu sein. Das heißt es macht auch wenig Sinn,

43:55.000 --> 44:03.520
die Konfiguration in Rust zu programmieren. Placingly, selbstverständlich alles Placingly fast.

44:03.520 --> 44:18.000
So, jetzt aber Leute. Jetzt müssen wir mal ein bisschen was machen. Excel,

44:18.000 --> 44:27.560
ich habe schon unsere To-Do-Liste für heute. Jetzt aber. Warum habe ich hier eigentlich das

44:27.560 --> 44:33.200
dreimal auf? Egal, schade nix. Kurz ein Update reinhauen, gucken ob es ein Update gibt. Das ist

44:33.200 --> 44:42.120
Arch, by the way, da gibt es immer Updates. Ah, pnp, immer wieder ein Update, alles klar.

44:42.120 --> 45:06.480
Ok, Enter drücken geht, alles klar. Glaube der Chat, ja kann schon sein, dass da der Twitch-Chat

45:06.480 --> 45:17.720
ein bisschen rumbackt. Like für Potman. Hä? Wir haben letztens irgendwas mit Potman gemacht,

45:17.720 --> 45:28.060
ja. Ah, hier. Images gebaut. Ah ja, warum haben wir, by the way, wenn wir gerade schon bei so

45:28.060 --> 45:32.200
Bildprozessen sind, kann ich noch eine Sache einwerfen, bevor wir jetzt hier anfangen mit

45:32.200 --> 45:38.320
der eigentlichen Progress-Geschichte. Potman vs. Docker. Manchmal macht es tatsächlich Sinn,

45:38.320 --> 45:49.360
Potman zu verwenden und zwar dann, wenn man keine Route-Rechte hat bzw. keine Route-Rechte vergeben

45:49.360 --> 45:56.600
will oder wenn Docker mal wieder keinen Bock hat, sinnvolle Features einzubauen, wie zum Beispiel,

45:56.600 --> 46:07.480
dass man auf lokale Registries zugreifen kann ohne HTTPS bzw. mit Self-Sign-Zertifikaten. Das

46:07.480 --> 46:12.520
kann man in Docker machen, allerdings nur, wenn man die globale Docker-Config editiert. Potman

46:12.520 --> 46:19.160
hat dafür schlicht und ergreifend ein, wie auch immer, ich weiß nicht, ob ich hier noch eine

46:19.160 --> 46:28.520
History habe. Potman hat dafür einfach ein Ignore-TLS. Potman kann dafür kein Caching,

46:28.520 --> 46:36.320
wie? Echt nicht? Wo sollen die das nicht können? Auszuschließen ist ja hier nix. Sehr schön. Gut,

46:36.320 --> 46:43.400
auf geht's jetzt. Also, heute, ich muss mal kurz gucken. Okay, heute ist wahrscheinlich kein

46:43.400 --> 46:52.200
Kreisel-Grind MMO-technisch, weil zwei Leute sind schon mal nicht da. Was im Endeffekt heißt,

46:52.200 --> 46:55.520
ist schon mal gut für euch, da können wir heute auch tatsächlich im Stream was machen und ich

46:55.520 --> 47:10.480
muss mich nicht ultra-ultra-hetzen. Vorti, da bist du ja. Moin. Hast du mal eine Nachricht gelesen und

47:10.480 --> 47:20.440
was hältst du von noch einen Bin-User-Repo anzulegen, anstatt nur ein Minus-Git? Vielleicht ganz

47:20.440 --> 47:26.840
sinnvoll, weil ich will wahrscheinlich sich kaum einer dort net installieren und dann

47:26.840 --> 47:38.240
sich das kompilieren. Vielleicht wäre ein Minus-Bin-User-Repo auch nicht verkehrt. Wo,

47:38.240 --> 47:50.440
Wim? Da, oh fuck. Da, Wim. Aber nicht lange, weil das brauchen wir jetzt nicht. Hast keine

47:50.440 --> 47:54.480
Zeit ständig zu aktualisieren. Das stimmt, dafür sind Minus-Git-Repo natürlich sinniger.

47:54.480 --> 47:59.040
Das können wir aber automatisch machen. Das können wir automatisch machen. Das macht dann,

47:59.040 --> 48:05.040
ja dann ist es tatsächlich besser, dann mach ich das. Dann mach ich das, dass es sich mit

48:05.040 --> 48:10.720
irgendwie GitHub Actions, keine Ahnung, ich hab noch nie einen Art User-Repo gemacht, aktualisiert.

48:10.720 --> 48:21.160
Das ist auch schwierig da noch durchzublicken. Das ist auch schwierig da durchzublicken. Also

48:21.160 --> 48:27.600
Docker ist so das Original-Linux-Container-Frontend. Man muss ja sagen, unter der Haube ist es alles

48:27.600 --> 48:33.760
das Gleiche. Unter der Haube sind das alles Linux-Container. Also LXC, wie sich das ursprünglich

48:33.760 --> 48:42.400
nannte. Also LX Linux-Container. Also die, wohlgemerkt die LXC Linux-Container-Funktionalität

48:42.400 --> 48:48.640
im Kernel. Das ist benutzt, alles das Gleiche. Portman, Docker, Kubernetes sind ja im Prinzip

48:48.640 --> 48:54.520
nur Frontends dafür, die natürlich noch viel mehr drumherum mitbringen, aber die alle unterm Strich

48:54.520 --> 49:02.040
die Kernel-Container-Funktionalität benutzen. Docker ist so das Original, was soll man sagen,

49:02.040 --> 49:09.320
das bekannteste, sagen wir so. Eines der ersten und eines der ersten, die es gut gemacht haben,

49:09.320 --> 49:16.080
Command Line Tools für Linux-Container, um eben diese Linux-Kernel-Container-Funktionalität zu

49:16.080 --> 49:21.600
konfigurieren. Irgendwann kam Red Hat, ich glaube es ist Red Hat, irgendwann kam Red Hat auf die Idee,

49:21.600 --> 49:29.480
Docker sackt und haben ihre eigene Docker-Version gemacht und das ist Portman. Portman ist quasi

49:29.480 --> 49:35.440
der Red Hat-Docker-Klon. Das ist sogar so weit, dass du mehr oder weniger eins zu eins die Docker

49:35.440 --> 49:39.280
Command Line copypasten kannst und einfach nur Portman anschließend als Docker reinschreiben

49:39.280 --> 49:46.840
und es funktioniert zu 99%. Das ist beides für für lokal und fürs Image bauen und sowas. Und

49:46.840 --> 49:58.320
K3S ist ein Minimal-Kubernetes für etwas schwächere Hardware. Es ist unglaublich wir. Das ist auch das,

49:58.320 --> 50:06.640
was ich als am herausforderndsten finde in diesem Kontainerisierungsumfeld und im Cloud-Umfeld ist

50:06.640 --> 50:16.040
oftmals nicht so sehr die einzelne Sache, sondern das Gesamtsystem. Kubernetes an sich selbst ist

50:16.040 --> 50:21.760
eigentlich relativ überschaubar. Also wenn es darum geht in Deployment zu machen und Service

50:21.760 --> 50:30.240
einzurichten und Loadbalancer zu konfigurieren in Kubernetes, das kriegst du innerhalb von einem

50:30.240 --> 50:34.720
Tag hin, kannst du das lernen, ist überhaupt kein Problem. Das Dumme ist nur, dass es damit ja nicht

50:34.720 --> 50:41.040
getan ist. Das Ökosystem darum ist so riesengroß und es gibt so viele Third-Party-Sachen und

50:41.040 --> 50:49.440
Dinge, die halt auf den Kubernetes-Funktialitäten aufsetzen, dass du zum Beispiel automatisch

50:49.440 --> 50:57.120
Workloads skalieren kannst anhand von Prometheus-Metriken, anhand von CPU-Auslastung, anhand von X und Y und

50:57.120 --> 51:04.800
sonst was noch. Es ist ein riesengroßes Umfeld. Deswegen ist die Kubernetes-Lernkurve ja auch so.

51:04.800 --> 51:10.640
Du fängst an und nach dem ersten Tag denkst du dir so, geht doch eigentlich. Da hast du mal

51:10.640 --> 51:14.520
Deployment gemacht, da hast du mal einen Service eingelegt, einen Loadbalancer angelegt, mal

51:14.520 --> 51:21.920
automatisch anhand der CPU-Auslastung ein paar Container skaliert. Denkst dir, geht doch eigentlich,

51:21.920 --> 51:27.840
ist doch gar nicht so wild. Und am nächsten Tag stellst du aber fest, ach du Kacke, was da alles

51:27.840 --> 51:32.920
dranhängt, da bin ich fürs nächste halbe Jahr beschäftigt, um die erweiterten Basics überhaupt

51:32.920 --> 51:39.480
mal zu lernen. Man muss sich mit tausend Projekten beschäftigen, die alle sonderbaren Namen haben.

51:39.480 --> 51:51.640
Ja, also das artet wirklich aus. Nun gut, weiter geht's. Gab's da eigentlich gerade ein Colonel-Update

51:51.640 --> 51:58.840
oder muss ich nicht neu starten? Ne, ich muss nicht neu starten. Bevor ich anfange, eine Minute

51:58.840 --> 52:07.840
nur, dann geht's auch wirklich richtig los, Leute. Ich muss euch noch was sagen. Bald ist übertrieben,

52:07.840 --> 52:19.360
in einem halben Jahr oder so ungefähr, werde ich 39 und ich habe mich heute zum ersten Mal in meinem

52:19.360 --> 52:25.360
Leben, glaubt ihr mal das, aber es ist die Wahrheit, ich habe mich heute zum ersten Mal in meinem Leben

52:25.560 --> 52:35.360
nass rasiert. Ich fände das. Zum ersten Mal nass rasiert. Bisher habe ich das immer nur,

52:35.360 --> 52:42.280
ja tatsächlich, bisher habe ich das immer nur mit einem Rasierer gemacht, also mit einem elektrischen

52:42.280 --> 52:49.480
Rasierer gemacht, einmal für die bisschen längere Haare, einmal um das glatt zu bekommen und mich

52:49.480 --> 52:57.280
hat's einfach so genervt, auch schon die letzten Jahre über, bis es jetzt so weit ist, weil es

52:57.280 --> 53:04.600
ist so unangenehm mit einem elektrischen Rasierer. Ist mir jetzt wieder aufgefallen, es hat mich so

53:04.600 --> 53:09.080
genervt, es hat mich so genervt, dass ich schon angefangen habe, mich teilweise eine Woche nicht

53:09.080 --> 53:16.200
zu rasieren, weil ich keinen Bock hatte drauf. Das ist doch auch blöd und ich habe mir jetzt mal

53:16.280 --> 53:20.880
ein Set gekauft bei Amazon, also was ist das, kein Set, ich habe mir einfach ein paar Dinge gekauft

53:20.880 --> 53:31.080
aus einem ordentlichen Rasierer, aus einem ordentlichen Rasierer, ein paar Klingen, Schaum

53:31.080 --> 53:37.880
und was, so ein bisschen Creme zum danach drauf machen. Ich muss euch sagen Leute, das war am

53:37.880 --> 53:44.160
Anfang, jetzt also als ich angefangen habe, war das erstmal ein bisschen Gewöhnungsbedürf,

53:44.160 --> 53:51.360
man wusste nicht, wie fest man drauf drücken muss und in welche Richtung, genau, und macht man einmal

53:51.360 --> 53:54.920
längs oder ein bisschen in kleinen Etappen und sowas, das hängt natürlich auch ein bisschen vom

53:54.920 --> 54:06.400
Bart ab. Kein Rasierhobel, nee, tatsächlich einfach was ganz, was fertig ist, so ein fertiges Ding

54:07.400 --> 54:16.720
zum reinklipsen und ich muss sagen, das ist mega nice, das ist echt, als hätte ich nicht gedacht,

54:16.720 --> 54:26.240
also der Schaum ist sehr angenehme Konsistenz. Ich fand Rasierschaum früher immer eklig,

54:26.240 --> 54:29.840
das lag wahrscheinlich daran, weil ich früher mal meinem Opa zugeguckt habe,

54:29.840 --> 54:38.280
wie er sich das halbe Gesicht mit eingeschmiert hat. Der Schaum, die Konsistenz ist mega nice

54:38.280 --> 54:43.240
und angenehm, das Rasieren, ich hab mir selbstverständlich ein YouTube-Tutorial

54:43.240 --> 54:50.240
vorher angeguckt, obviously, warum sollte man sich das nicht angucken, der Rasierer,

54:50.400 --> 54:59.840
das funktioniert wunderbar und danach diese Creme, nenne ich es mal, was das ist,

54:59.840 --> 55:09.360
ja, so zum Beruhigen, die fühlt sich auch mega nice an und wenn ich jetzt so mit den

55:09.360 --> 55:16.160
Fingern so ein bisschen über meine Backe gehe, dann fühlt sich das auch alles so weich und

55:16.160 --> 55:24.200
geschmeidig an. Also ich bin froh, dass ich endlich jetzt angefangen habe mit Nassrasieren,

55:24.200 --> 55:38.880
also es hat mir bis jetzt sehr gut gefallen. Gut, so. Rasiertipps mit MaxWTF, warum WTF,

55:38.880 --> 55:55.720
was hast du gegen Rasierer-Erfahrungsberichte? Also, wo sind wir stehen geblieben? Okay,

55:55.720 --> 56:00.760
wir gucken mal in unser To-Do rein. Chat, soll ich noch mal kurz erklären, um was es in der

56:00.760 --> 56:06.480
Anwendung, an der wir programmieren eigentlich geht? Für alle, die beim letzten Stream nicht

56:06.480 --> 56:10.800
dabei waren oder vielleicht zufällig heute dabei gekommen sind und es nicht so mitbekommen

56:10.800 --> 56:15.600
haben. Es ist recht übersichtlich, kann ich sagen, also ich hab nix verpasst, der SourceCode an sich

56:15.600 --> 56:21.240
ist auch, finde ich, ganz gut lesbar und der SourceCode ist übrigens auf GitHub, wer sich

56:21.240 --> 56:29.920
das angucken will, es gibt hier den VMChamp auf GitHub, Moment, so, es gibt den VMChamp auf

56:29.920 --> 56:34.680
GitHub und hier steht eigentlich auch schon in der ReadMe, was es ist, ja, es ist ein Tool,

56:34.680 --> 56:41.320
mit dem man, Linux only, wobei gemerkt, nicht zwangsläufig Linux only, sollte man es schaffen,

56:41.320 --> 56:48.640
libvirt unter macOS oder Windows zum Laufen zu bekommen, vielleicht in WSL oder so, geht das

56:48.640 --> 56:55.000
auch unter Windows, wobei ich das nicht teste und das binary, das vorkomplizierte binary gibt es auch

56:55.000 --> 57:04.880
nur für Linux aktuell. Zumindest ist es ein Tool, um schnell lokale VMs zu Testzwecken anzulegen,

57:04.880 --> 57:11.440
also vielleicht im Entfernen ein bisschen sowas wie Vacrant, nur dass es nicht Vacrant ist, dass es

57:11.440 --> 57:17.440
nicht oldschool Ruby ist, dass es nicht ein Ordner pro VM ist, dass es nicht VirtualBox braucht,

57:17.440 --> 57:24.280
sondern KVM unter Linux mit libvirt, VM anlegen, einloggen, ausprobieren, VM löschen, sieht dann

57:24.280 --> 57:29.760
folgendermaßen aus, wenn man das Ganze verwendet, ach ja, warum, vielleicht noch kurz zur Erklärung,

57:29.760 --> 57:36.480
weshalb, naja, manchmal braucht man lokal eine VM, um Sachen auszuprobieren, wo es eben ein

57:36.480 --> 57:45.720
Docker-Container oder ein Linux-Container, welches Flavors auch immer, einfach nicht tut. Es gibt

57:45.720 --> 57:50.000
Anwendungszwecke, die funktionieren im Container, es gibt Sachen, die funktionieren im Container

57:50.000 --> 57:57.200
nicht richtig. Zum Beispiel, wenn man ein Kernel-Modul laden möchte, das ist im Container keine

57:57.200 --> 58:04.880
allzu gute Idee. Das zweite ist, was viel öfters vorkommt, man möchte zum Beispiel mal das System

58:04.880 --> 58:12.640
neu starten können mit Unit-Files, also man braucht ein System, was mit einem richtigen Initial läuft,

58:12.640 --> 58:18.480
was in Docker-Containern auch nicht der Fall ist. Man möchte zum Beispiel admin und möchte

58:18.560 --> 58:24.640
ein Unit-File erstellen und dazu braucht man eben eine Kiste, wo man das Unit-File ausprobieren kann

58:24.640 --> 58:30.000
und das kann man im Docker-Container nicht so ohne weiteres. Es gibt Virtualisierungslösungen mit

58:30.000 --> 58:39.320
System D dabei und was auch immer, da kann man das theoretisch machen. Also es gibt Sachen, die sind

58:39.320 --> 58:45.160
so nur schwierig oder teilweise gar nicht in einem Container möglich und manchmal hat man diesen

58:45.160 --> 58:50.760
Anwendungsfall halt und ich habe den Anwendungsfall öfters und ich habe mir schon lange Zeit ein Tool

58:50.760 --> 58:57.160
gewünscht, wo ich innerhalb von ein paar Sekunden, also ohne jetzt hier hinzugehen zu sagen New

58:57.160 --> 59:03.400
Virtual Machine, bla bla bla, ISO einlegen, weiter weiter weiter, Installer durchlaufen lassen,

59:03.400 --> 59:09.440
wo ich einfach innerhalb von ein paar Sekunden lokale Test-VMS am Start habe, wo ich was ausprobieren

59:09.440 --> 59:14.840
kann, um sie wieder wegzuschmeißen. Also keine keine VMS, die man wirklich langfristig verwendet,

59:14.840 --> 59:18.640
so wie hier meine Ledungs-VMS, sondern VMS erstellen und wegschmeißen. Das Ganze sieht dann

59:18.640 --> 59:27.400
folgendermaßen aus, VM-Champ, Run und dann kann man dann angeben zum Beispiel Bloop VM und das erste,

59:27.400 --> 59:32.920
was passiert ist, klingt nach Multipass, vielleicht, nur allein schon, dass es irgendein

59:32.920 --> 59:43.120
Canonical-Ding ist. Multipass Virtual Ubuntu-Instanzes, ja, nee. Ja, aber das ist das, was es nur als Snap

59:43.120 --> 59:52.800
gibt. Ja, das hört schon auf. Und außerdem ist es nur Ubuntu. Schreibst du das in Rust?

59:52.800 --> 01:00:03.920
Nee. So guck, jetzt kann man zum Beispiel sagen hier VM-Champ Run Bloop. Ich zeige euch

01:00:03.920 --> 01:00:08.240
übrigens mal im Hintergrund, dass der auch wirklich eine echte neue VM anlegt. Hier da guck, da ist

01:00:08.240 --> 01:00:12.200
sie und wird sie gestartet und da läuft sie auch, aber das braucht man ja nicht mehr. Und ihr seht,

01:00:12.200 --> 01:00:18.320
da hatte ich VM angelegt, hat sich danach per SSH auf die VM verbunden und jetzt kann ich auf

01:00:18.320 --> 01:00:24.440
meiner VM rumsauen, wie ich will. Also in dem Fall ist es übrigens eine VM in der VM,

01:00:24.440 --> 01:00:28.920
weil mein Linux läuft ja schon in der VM, aber mein Rechner ist schnell genug dafür. Und jetzt

01:00:28.920 --> 01:00:33.680
kann ich hier in der VM rumwurschteln und mich auch wieder auslocken. Da kann ich auflisten,

01:00:33.680 --> 01:00:38.160
welche VMs ich gerade lokal zum Test zur Verfügung habe. Wenn ich sage, ach, ich will mich da doch

01:00:38.160 --> 01:00:43.120
mal schnell drauf verbinden, kann ich so machen. Ich habe übrigens ein Shell Auto Completion auch

01:00:43.120 --> 01:00:47.600
am Start. Wie ihr seht, also man kann hier die Sachen in seiner Shell Auto vervollständigen lassen,

01:00:47.600 --> 01:00:55.840
VM-Champ, SSH, Test, oder hier. Oh, das heißt auch nicht Test VM, das heißt Bloop. Deswegen ging

01:00:55.840 --> 01:01:03.160
das nicht. Und da kann ich mich wieder drauf verbinden. Und wenn ich fertig bin, mal angenommen,

01:01:03.160 --> 01:01:08.560
ich hätte jetzt hier noch eine zweite VM erstellt, dann könnte ich die erste VM zum Beispiel wieder

01:01:08.560 --> 01:01:12.960
löschen. Also ach, die brauche ich jetzt doch nicht mehr, kann ich löschen. So und am Ende,

01:01:12.960 --> 01:01:18.600
wenn ich fertig bin, also mit meinem Testen und Basteln und Ausprobieren, wofür ich die VMs

01:01:18.600 --> 01:01:24.040
gebraucht habe, will ich ja, dass das möglichst rückstandslos wieder weg ist. So, dann sage ich

01:01:24.040 --> 01:01:29.680
am Ende einfach VM-Champ clean. Und dann fragt er dich hier, soll ich wirklich alle, in dem Fall

01:01:29.680 --> 01:01:33.720
gibt es nur eine, alle VMs löschen und alle Images, die ich in der Zwischenzeit runtergeladen habe.

01:01:33.720 --> 01:01:38.920
Dann sage ich yes. Ich warte jetzt mal kurz, bis er mit der hier, mit der VM fertig ist. So,

01:01:38.920 --> 01:01:45.600
dann sage ich yes und es ist alles wieder rückstandslos weg. Also, schnelle lokale Test VMs ohne

01:01:45.600 --> 01:01:52.440
irgendwie großartige Experienzien und ohne irgendwie komplizierte Konfiguration, weil ja,

01:01:52.440 --> 01:01:56.720
man kann in LibVirt und kann vor allem sau viel konfigurieren, aber 99% braucht man nicht. Ich

01:01:56.720 --> 01:02:02.040
brauche kein GPU-Pass-Through, kein USB-Pass-Through, kein Geräte-Pass-Through, kein sonst was. Ich will

01:02:02.040 --> 01:02:06.480
da drin Memory angeben können, Disk-Space angeben können und vielleicht die Anzahl

01:02:06.480 --> 01:02:12.480
der CPUs angeben können und das war's. Und ich will, dass es ein gescheites Default-Setting hat,

01:02:12.480 --> 01:02:18.920
dass wenn ich nichts angebe, wenn ich einfach nur sage Run Bloop Lul V soll die VM heißen,

01:02:18.920 --> 01:02:24.160
dass er dann sinnvoller Defaults nimmt. Sinnvoller Defaults sind in dem Fall 256 MB RAM,

01:02:24.160 --> 01:02:37.200
4 GB Disk und ein aktuelles Ubuntu, nicht Ubuntu, Debian Cloud Image. Das ist also immer

01:02:37.200 --> 01:02:45.080
eine Linux-VM. Kann man die Distro spezifizieren? Ja, kann man machen. Ja, die VM-Images,

01:02:45.080 --> 01:02:51.400
die lädt er sich einmalig runter. Wenn ich jetzt eine zweite VM mache, dann siehste,

01:02:51.440 --> 01:02:56.920
Using Existing Image. Der lädt sich das Image einmal runter und dann kopiert er sich das für

01:02:56.920 --> 01:03:06.960
jede VM. Es sei denn, du hast ein Clean gemacht. Wenn du ein Clean machst, dann lösche ich mal

01:03:06.960 --> 01:03:15.920
hier ab. Dann löscht er die VMs und die Images. Ne, das mit dem automatisch löschen ist glaube

01:03:15.920 --> 01:03:23.680
ich keine. Wobei, die Idee ist nicht schlecht. Ich schreibe es mal auf. Ja, das ist eine gute Idee,

01:03:23.680 --> 01:03:33.200
tatsächlich. Können wir ausprobieren. Wobei, ich glaube, das Disconnect kriege ich. Kriege ich das

01:03:33.200 --> 01:03:42.080
Disconnect überhaupt mit? Mal gucken. Ja, vielleicht gar keine schlechte Idee. LXD. Ja,

01:03:42.120 --> 01:03:47.080
da musste er erstmal LXD installieren. Ne, LXD kann das nicht. LXD stimmt doch überhaupt nicht.

01:03:47.080 --> 01:03:53.360
LXD kann das nicht auch alles. Versuch mal LXD in Kernel Modul zu laden. Also es gibt Anwendungsfälle,

01:03:53.360 --> 01:03:59.080
da ist eine VM einfach nach wie vor wichtig, erforderlich. Ja, in LXD kannst du SystemD

01:03:59.080 --> 01:04:04.440
gescheit verwenden. Halbwegs gescheit, ja das stimmt. Das waren jetzt aber auch nur die ersten

01:04:04.440 --> 01:04:09.440
zwei Sachen, die mir eingefallen sind. Gibt bestimmt noch mehr Anwendungsfälle,

01:04:09.440 --> 01:04:16.720
wo ein Container Image bzw. Container einfach nicht funktioniert gescheit zum Testen.

01:04:16.720 --> 01:04:23.080
Ist das also immer eine Linux-File? Kann man das auch distro-spezifisch machen? Ja,

01:04:23.080 --> 01:04:32.640
du kannst es auch distro-spezifisch machen. Aktuell sind, glaube ich, Ubuntu und Debian drin.

01:04:32.640 --> 01:04:41.840
Ich werde aber noch Fedora, Oracle Linux und was hatten wir gesagt, machen wir noch rein,

01:04:41.840 --> 01:04:48.480
standardmäßig als Support. Arch, by the way, selbstverständlich, was sonst. Arch, Linux,

01:04:48.480 --> 01:04:56.920
Fedora, Oracle Linux und irgendeinen Red Hat. Wie du uns noch reinhauen. Was du aber jetzt

01:04:56.920 --> 01:05:00.480
schon machen kannst ist, wenn du ein komplett eigenes Image verwenden willst, kannst du sagen,

01:05:00.680 --> 01:05:05.600
minus, minus Local Image und da kannst du irgendwie ein x-beliebiges Image angeben,

01:05:05.600 --> 01:05:15.880
was du lokal liegen hast. Was kannst du machen? NixOS. Gibt es von NixOS Cloud Image Builds?

01:05:15.880 --> 01:05:21.800
Wenn nicht, dann funktioniert das nicht. Ich brauche Cloud Image. Ich brauche QCOW 2 Image

01:05:21.800 --> 01:05:27.600
und ich brauche Cloud Init Support, sonst klappt das nicht. Distros in der Jaml konfigurieren,

01:05:27.680 --> 01:05:33.600
ich glaube, das braucht man nicht, weil es sind die wichtigsten Sachen drin und man kann lokal

01:05:33.600 --> 01:05:48.480
das Image überschreiben. So, nice. Wie kann ich denn Daten auf einem USB Stick gescheit

01:05:48.480 --> 01:05:55.440
verschlüsseln und erwinden? Ha, das ist das Problem. VeraCrypt kannst du nehmen. Unter Linux

01:05:55.440 --> 01:06:02.280
wäre das relativ easy. Alles schon built in. Unter Windows kannst du VeraCrypt nehmen. Ja,

01:06:02.280 --> 01:06:13.920
das ist eine sehr gute Idee. Nimm VeraCrypt. VeraCrypt. Das da. Oh, meine Auge. Nimm VeraCrypt.

01:06:13.920 --> 01:06:24.120
Und ich bin locker. VeraCrypt.

01:06:24.120 --> 01:06:46.080
Exposed. Was nimmst du für Linux für USB Verschlüsselung? Was ich unter Linux für

01:06:46.080 --> 01:06:54.280
USB Verschlüsselung nimm? Datei-basiert oder vollverschlüsselt? Vollverschlüsselt Lux,

01:06:54.280 --> 01:07:06.280
wie für alles andere auch. Datei-basiert E-Crypt FS oder Enk FS. Datei-basiert ist gar nicht so

01:07:06.280 --> 01:07:13.560
blöd. Da braucht man nämlich keinen Container bzw. kein Neuflaschen und so was. Das kann man

01:07:13.560 --> 01:07:23.600
auf einem USB Stick normal drauf machen. Aber VeraCrypt nie verstanden. Ist das portabel oder

01:07:23.600 --> 01:07:29.360
braucht man überall VeraCrypt? Du brauchst überall VeraCrypt, wo du das Volume öffnen willst. Also,

01:07:29.360 --> 01:07:34.600
es gibt ja bei VeraCrypt zwei verschiedene Varianten. Vollverschlüsselung der Disk oder

01:07:34.600 --> 01:07:40.600
ein Container, ein Container-File anlegen, in dem dann deine Dateien gespeichert werden verschlüsselt.

01:07:40.600 --> 01:07:46.600
Aber egal ob du die Disk mounten willst oder ob du das Container-File öffnen möchtest,

01:07:46.600 --> 01:07:51.040
du brauchst VeraCrypt installiert. Nicht unter Linux, weil Linux hat selbstverständlich

01:07:51.040 --> 01:07:59.840
eingebauten Support für VeraCrypt Volumes. Lux in dem Fall. Oder ich weiß nicht ob es Lux,

01:07:59.840 --> 01:08:07.040
doch ich glaube Lux ist das. Die haben mittlerweile Support für VeraCrypt Images.

01:08:07.040 --> 01:08:15.200
Oh nee, keine Ahnung, jetzt hört es auf. Okay, weiter im Text. So, wo sind wir das letzte Mal

01:08:15.200 --> 01:08:19.960
stehen geblieben? Und zwar, ich glaube wir sind bei diesem Feature stehen geblieben. Ach ja,

01:08:19.960 --> 01:08:27.880
dieses Tool, das habe ich an einem Tag im Homeoffice entwickelt. Aber gut, ich bin da

01:08:27.880 --> 01:08:34.440
eh bald weg. Und eigentlich habe ich mir gedacht, ich mache da nicht mehr großartig was dran. Aber

01:08:34.440 --> 01:08:40.200
ich habe da wirklich Spaß noch ein bisschen dran rumzubasteln und außerdem gibt es coole

01:08:40.200 --> 01:08:48.080
Ideen im Stream, was man noch einbauen könnte, die auch sinnvoll klingen. Ja, kurz hier weg.

01:08:48.080 --> 01:09:02.160
Excellent. Hallo? Was hat mein Cursor für Probleme? Okay, also wir sind stehen geblieben beim Status

01:09:02.160 --> 01:09:07.440
anzeigen. Genau, hier sind wir stehen geblieben. Also sprich, aktuell ist es so, ich muss übrigens

01:09:07.440 --> 01:09:15.520
eine VM anlegen, ansonsten klappt das nicht richtig. Nee, nicht .net run. VMChamp, run, keckl, legen wir mal eine VM an.

01:09:15.520 --> 01:09:36.400
Warten auf Netzwerk. PortExPost, wenn möglich. Ich weiß nicht. Wobei, das ist easy. PortExPost,

01:09:36.400 --> 01:09:42.080
dann musst du es einfach auf eine Bridge hängen, die direkt. Nee, das würde ich. Das hängt ja

01:09:42.080 --> 01:09:47.880
auf einer ganz normalen Netzwerk Bridge mit einem eigenen Subnetz. Da müsstest du irgendwie

01:09:47.880 --> 01:09:52.600
routen oder so. Nee, nee, nee, nee. Ich glaube, PortEx weiß nicht. Das ist ja nichts. Das ist ja

01:09:52.600 --> 01:09:58.240
nichts, wo man von außen was... Das ist ja kein Docker 2.0. Kali wäre als Image, da hast du recht.

01:09:58.240 --> 01:10:04.080
Wobei es halt die Sache ist, was willst du mit dem Kali Linux ohne UI machen? Nee, ich will ja

01:10:04.080 --> 01:10:11.800
kein... Mein Ziel ist nicht, irgendwie einen Docker für VMs zu programmieren. Bring Kali Linux,

01:10:12.440 --> 01:10:18.040
per SSH, klar. Warum nicht? Die meisten verwenden es zwar nur mit Oberfläche. Das ist eine gute

01:10:18.040 --> 01:10:21.600
Idee. Könnte man tatsächlich rein machen. Können wir auch gleich noch ein Tails reinhauen. Warum

01:10:21.600 --> 01:10:30.520
nicht? Nicht Tails. Wir bauen an meinem Tool weiter, an dem hier.

01:10:41.800 --> 01:10:54.840
So, also, wir waren jetzt, glaube ich, gerade dabei, das hier einbauen. Statusanzeige, ob die VM

01:10:54.840 --> 01:11:00.200
läuft oder gecrashed ist, weil zurzeit kann ich sowas machen. List, PS oder LS,

01:11:00.200 --> 01:11:04.160
glaube ich macht alles das gleiche. Kann ich das einbauen? Dann kriege ich angezeigt, es gibt diese

01:11:04.160 --> 01:11:15.640
VM und es gibt diese IP, die für einmal diese IP. Wir machen übrigens, wir machen mal, wir machen

01:11:15.640 --> 01:11:24.360
mal zwei VMs, dass man sieht, dass es unterschiedliche IPs sind, ja. Ja, Pogu hat noch keine IP.

01:11:24.360 --> 01:11:40.680
Was ist ein Interop? Ja, das ist das Interop, wie heißt das auf Deutsch? Zusammenarbeit quasi

01:11:40.680 --> 01:11:48.360
zwischen C-Sharp und C. Weil wir brauchen C-Funktionen, also Funktionen, die in der LibVirt

01:11:48.360 --> 01:11:54.000
Library, also C-Library zur Verfügung gestellt werden. Die wollen wir aus C-Sharp verwenden.

01:11:54.000 --> 01:11:59.520
Dementsprechend muss man ein bisschen Wrapper drumherum bauen oder Definitionen anlegen,

01:11:59.520 --> 01:12:07.560
dass C-Sharp weiß, wie es C-Funktionen aufrufen soll. Das mit dem Grün und dem Punkt hinten dran

01:12:07.560 --> 01:12:14.120
finde ich ex- genau, genau, genau, genau. Guck hier, sowas machen wir hier zum Beispiel. DLL-Import,

01:12:14.120 --> 01:12:18.520
wobei DLL-Import ist ja nicht mehr the way to go. Aktuell ist es jetzt ja Library-Import,

01:12:18.520 --> 01:12:28.960
weil Source Cone Generator und sowas. Genau, ja, Marshall Pointer to String, blub. Dann kannst,

01:12:28.960 --> 01:12:36.000
du kannst den unter macOS mal testen, ja. So, also jetzt haben wir hier zwei VMs und aktuell zeigt

01:12:36.000 --> 01:12:43.560
das Status beziehungsweise das List-Command nur den Namen der VM und die IP von der VM an. Das

01:12:43.560 --> 01:12:54.440
heißt, es wäre doch ganz cool, wenn man auch noch anzeigen lassen könnte zusätzlich den Status und

01:12:54.440 --> 01:12:59.040
RAM-Verbrauch und sowas in der Richtung von der VM. RAM-Verbrauch, CPUs zugewiesen und sowas,

01:12:59.040 --> 01:13:03.960
falls man sich nicht mehr dran erinnern kann. Und ich glaube, da sind wir gestern stehen geblieben,

01:13:03.960 --> 01:13:13.800
das einzubauen. Storage, da bin ich mir nicht sicher, ob man das gescheit auslesen kann.

01:13:13.800 --> 01:13:23.880
Aber Storage, wie gesagt, das sind VMs, um sich schnell wegzuschmeißen. Die werden

01:13:23.880 --> 01:13:43.160
bei DHCP vergeben vom Default LipWirt Interface. Okay, dann fügen wir mal in unsere Tabelle hier

01:13:43.160 --> 01:13:49.960
unten noch so ein paar Informationen ein. Also, State, okay, wir machen das, was Sarix vorgeschlagen

01:13:49.960 --> 01:13:58.320
hat. Das finde ich ist eine super Idee, dass wir hier einen grünen Punkt dahinter machen,

01:13:58.320 --> 01:14:08.080
wenn der State running ist. Das finde ich ist eine gute Sache. Also, das müssen wir vielleicht

01:14:08.080 --> 01:14:13.600
noch mal rappen, dass hier unsafe rauskommt. Das ist auf jeden Fall nicht so schön. Also,

01:14:13.600 --> 01:14:21.200
was haben wir denn? VmID-Info, gut. Das heißt, wir müssen das hier reinschreiben. Machen wir

01:14:21.200 --> 01:14:28.560
es mal testweise so, dass der hier den aktuellen State reinschreibt von der VM. Der State sollte

01:14:28.560 --> 01:14:34.120
bei beiden aktuell running sein, also eine 1. Das ist natürlich eine bescheuerte Aufgabe.

01:14:34.120 --> 01:14:44.760
Es ist natürlich eine bescheuerte Ausgabe, dass da 1 steht, aber man sieht,

01:14:44.760 --> 01:14:50.000
das funktioniert prinzipiell. Das heißt, wir brauchen jetzt ein enum, wo drinnen steht,

01:14:50.000 --> 01:14:58.000
dass 1 gleich running ist. Und da können wir auf der Doku-Seite nachgucken von LipWirt,

01:14:58.000 --> 01:15:08.760
wie das auszusehen hat. Und zwar muss der Enum so aussehen. Das ist natürlich alles hier in C,

01:15:08.760 --> 01:15:14.520
das heißt, das müssen wir jetzt übersetzen in C-Sharp. Das ist bei einem Enum glücklicherweise

01:15:14.520 --> 01:15:23.720
nicht so kompliziert. Der sieht quasi genauso aus wie in C, nur ein bisschen die Werte anders

01:15:23.720 --> 01:15:34.560
angegeben. Das kann alles raus. Das darf jetzt Vim praktisch, da könnte ich das einfach wiederholen,

01:15:34.560 --> 01:15:41.160
was ich jetzt in der Zeile davor gemacht habe. Und schon haben wir den Enum, der auch in C-Sharp

01:15:41.160 --> 01:15:47.280
funktioniert. Der heißt noch ein bisschen falsch. Den benennen wir mal so um und den benennen wir

01:15:47.280 --> 01:16:00.600
so um. Dann heißt das richtig, dass die Namen gescheit sind des Wir-Domain. Das sparen wir uns

01:16:00.600 --> 01:16:09.520
einfach mal und wir nennen es am Ende so NoState, Suspended, NoState, Running, Block, Pause,

01:16:09.520 --> 01:16:16.600
Shutdown, Shutoff, Crash, Suspended, Last, was auch immer. So und diesen Enum können wir jetzt an

01:16:16.600 --> 01:16:23.920
der Stelle verwenden, um uns da was ordentliches anzeigen zu lassen. Das bedeutet, unser State

01:16:23.920 --> 01:16:41.520
Table? Hä? Ne, nicht wirklich. Unser State ist Info.State und das ganze casten wir zu dem Enum.

01:16:41.520 --> 01:16:48.440
Ne, wir Domains-State. Gibt es eigentlich was schöneres anstatt das so zu casten? Gibt es

01:16:48.440 --> 01:17:17.280
irgendwie einen Enum From oder so? House? Nicht wirklich, oder? Den Rust schon. Ja, gut. Geht auch so.

01:17:17.280 --> 01:17:27.840
Und jetzt können wir den State ausgeben und jetzt sollte da Running stehen. Da gebe ich dir

01:17:27.840 --> 01:17:37.040
recht. Da gebe ich dir recht. Das wäre enorm praktisch. Zwar in Ausnahmefällen, aber es wäre

01:17:37.040 --> 01:17:42.960
enorm praktisch. Es gibt ein ganz cooles Package auf GitHub, was das ein bisschen einfacher macht.

01:17:43.960 --> 01:17:52.600
Es gibt das hier. Das ist quasi eine Fan-Implementierung davon. Da kannst du zum

01:17:52.600 --> 01:17:57.360
Beispiel angeben. Hier ist ein gescheites Beispiel. Da kannst du zum Beispiel angeben,

01:17:57.360 --> 01:18:04.520
deine Methode hat einen Return-Type von UserInvalidName, NameTaken. Also entweder das,

01:18:04.520 --> 01:18:09.560
das oder das. Also deine kleine Methode kann quasi mehrere Sachen returnen. Also nicht,

01:18:10.040 --> 01:18:15.920
nicht mehrere Sachen returnen, unterschiedliche Typen returnen. Wobei das in der Handhabung

01:18:15.920 --> 01:18:21.040
natürlich nicht so schön ist, wie in der Sprache integriert. Aber gebe ich dir recht,

01:18:21.040 --> 01:18:28.160
das wäre ganz praktisch. Zumal ja sogar, und jetzt komplett, sogar C hat sowas in der Richtung.

01:18:28.160 --> 01:18:33.840
Das ist natürlich ein bisschen primitiver. Jetzt haben wir die Sachen in F-Sharp oder so,

01:18:33.840 --> 01:18:45.440
aber sogar C hat Union-Types. Also du kannst in C angeben, dass beispielsweise ein Value

01:18:45.440 --> 01:18:53.760
unterschiedliche Typen haben kann. Dann brauchst du halt irgendwo einen Flag, wo drinne steht,

01:18:53.760 --> 01:19:00.880
welcher Typ es ist und ein ewig langes Switch, aber es funktioniert. Und nicht mit wilden

01:19:00.880 --> 01:19:06.440
Void-Pointer-Casts oder sowas in der Sprache eingebaut. Das fehlt mir in C-Sharp auch ein

01:19:06.440 --> 01:19:11.080
bisschen. So, wenn wir das jetzt richtig gemacht haben, dann sollte jetzt da State-Running stehen

01:19:11.080 --> 01:19:15.920
oder es steht State-Running da. Nice. Das ist auch schon mal eine schön, viel schönere Ausgabe.

01:19:15.920 --> 01:19:22.320
Wir probieren das mal aus. Was passiert dann, wenn ich das Ganze mal pausiere? Steht dann auch

01:19:22.320 --> 01:19:37.040
Paust da. Paust. Paust. Guck dir das mal an hier. Pogu. Jetzt Running. Paust-Champ. Ja, wunderbar.

01:19:37.040 --> 01:19:42.480
Okay, jetzt müssen wir natürlich noch das einbauen, was eben der Sarix vorgeschlagen hat.

01:19:42.480 --> 01:19:51.520
Selbstverständlich müssen da, es muss Emoji-Fight werden, alles. Ohne Emojis in der Ausgabe ist es

01:19:51.520 --> 01:19:58.240
heutzutage, allerdings ist es ja, ich hab Mist kopiert. Ohne Emojis in der Ausgabe ist das schon

01:19:58.240 --> 01:20:11.800
ziemlich, ziemlich cringe. So, das heißt wir müssen jetzt erstmal kurz einbauen. Jetzt brauchen wir

01:20:11.800 --> 01:20:20.680
eine gute Idee, Leute, wie wir den String-Value umwandeln. Weil das Simpelste wäre sowas. Ich

01:20:21.160 --> 01:20:30.280
habe aber schon eine bessere Idee. Das simpelste Fall wäre natürlich State gleich Running,

01:20:30.280 --> 01:20:42.920
dann keine Ahnung, dann hier grüner Knopf und Else-If und so. Wir können das neue Switch-Feature

01:20:42.920 --> 01:20:50.120
verwenden, Fonzie Sharp. Also was heißt neu? Nee, nicht Switch Case, doch, aber so ein Switch

01:20:50.120 --> 01:20:54.760
Expression Statement können wir verwenden. Das blöde ist nur, ich kriege das immer aus dem Kopf

01:20:54.760 --> 01:21:01.480
nicht richtig hin. Ich glaube, wir müssen jetzt sowas machen wie hier, nennen wir es mal Icon zum

01:21:01.480 --> 01:21:11.160
Beispiel. Ich glaube, jetzt muss man sagen, State, Switch, On, nee. Ach fuck, ich kann mir das

01:21:11.240 --> 01:21:19.320
immer nicht merken, wie das funktioniert, man. State, Switch. Die Sonntags ist so kacke, man,

01:21:19.320 --> 01:21:27.560
ich kann mir die Sonntags dafür immer nicht merken. Switch, was ist jetzt falsch hier dran? No best

01:21:27.560 --> 01:21:38.320
type was, okay, okay, das ist doch richtig, was ich gemacht habe. Case, nee. Schreiben in Else-If,

01:21:38.480 --> 01:21:51.400
ja, das ist tatsächlich. Nee, Moment, das ist falsch, das ist falsch, was ich hier mache.

01:21:51.400 --> 01:21:58.840
Nein, ich kann mir diesen Sonntags für den Kram immer nicht merken, man.

01:22:08.320 --> 01:22:21.640
Anmeldung bei Azure, sorry, we can't accept prepaid cards. Hast du eine Kreditkarte generiert

01:22:21.640 --> 01:22:31.000
dafür? Also bei Google Cloud konnte ich mich mit meiner Revolut Kreditkarte anmelden. Ich

01:22:31.000 --> 01:22:38.160
habe extra noch für solche Sachen mir einen Revolut Account gemacht. Das ging bei Google

01:22:38.160 --> 01:22:42.920
Cloud, hat aber 48 Stunden gedauert, weil der Support erst eingreifen musste. Ich habe aber

01:22:42.920 --> 01:22:53.480
auch keine Single Use Kreditkarte verwendet, sondern eine normale. Dann würde ich sagen,

01:22:53.480 --> 01:23:14.160
da wird es nicht Azure, sondern Google Cloud. Was? Hallo, ich komme aus der IT. Als Frage ist es

01:23:14.160 --> 01:23:19.960
normal, dass Mitarbeiter immer nur fordern, sie wollen, sie brauchen gerade auch, dass Mitarbeiter

01:23:19.960 --> 01:23:29.800
vorgehen, welche Software gehoben, was? Geholt werden muss, weil das Anwender möglichst effektiv

01:23:29.800 --> 01:23:34.440
arbeiten wollen. Am besten mit der Software, die sie gewohnt sind, ist ja nichts Verwerfliches dran.

01:23:34.440 --> 01:23:42.000
Also ich verstehe, dass IT Support abfuck ist, deswegen würde ich auch nie freiwillig im IT

01:23:42.000 --> 01:23:48.920
Support arbeiten wollen. Ich glaube wirklich gut funktioniert es unterm Strich aber nur, wenn

01:23:48.920 --> 01:24:01.720
die Client Abteilung in der IT, die sich um Client Geräte kümmert und die Anwender zusammenarbeiten.

01:24:01.720 --> 01:24:09.040
Also sprich nicht, dass die IT sich sinnlose Vorgaben ausdenkt, nur damit sich gefälligst alle

01:24:09.040 --> 01:24:14.640
Anwender dran halten und die Anwender rum nerven mit IT kann nix. Ich weiß, dass da die Fronten

01:24:14.640 --> 01:24:20.440
sehr verhärtet sind oftmals, was aber auch oft, oder was heißt oft, eigentlich immer,

01:24:20.440 --> 01:24:25.080
Management Fail ist, wenn das der Fall ist, dass dann in beide Richtungen nicht richtig

01:24:25.080 --> 01:24:31.000
Informationen weitergegeben werden und deswegen beide Seiten aufeinander keinen Bock haben.

01:24:31.000 --> 01:24:34.120
Wie gesagt, ich hätte auch keinen Bock im User Support zu arbeiten, das ist das Schlimmste,

01:24:34.120 --> 01:24:41.080
was ich mir vorstellen könnte. Es macht es aber wahrscheinlich nur noch schlimmer,

01:24:41.080 --> 01:24:49.920
wenn man die Anwender anfängt zu gängeln, weil dann fühlen sie sich ja noch bestärkt in ihrem

01:24:49.920 --> 01:24:56.440
Eindruck, dass die IT nervig ist. Natürlich muss man manchmal Anwender auch zurück pfeifen und

01:24:56.440 --> 01:25:02.760
sagen, guck dir mal keine privaten E-Mail Anhänge mit komischen Zips bei dir auf der Arbeit an.

01:25:02.760 --> 01:25:10.240
Ja, aber in dem Fall wirst du wahrscheinlich selber gar nix machen können, sondern dein Chef

01:25:10.240 --> 01:25:16.920
muss mit dem, der der dich nervt, mit dem seinem Chef muss dein Chef reden, wenn ihr das so auf

01:25:16.920 --> 01:25:25.560
der Ebene nicht mal hinkriegt, sonst klappt das nicht. So, okay, also wie gesagt, ich krieg diese

01:25:25.560 --> 01:25:38.200
Sündags-Tafel immer nicht richtig gebacken. Ah, so war das. Ich, nee, Moment. Ach, ohne Case.

01:25:38.200 --> 01:25:53.720
Also, äh, quasi. Beer Domains State Running. Kann man dann so machen? Nee, gell? Dann muss

01:25:53.800 --> 01:26:02.160
man mal quasi hier irgendwas. Ah, so. Sonst sagt er mir, not all. Wollen wir einen Default-Arm?

01:26:02.160 --> 01:26:14.520
Nee, nee, nee, nee. Was ist das? So, also es ist rot, wenn es irgendein blöder Status ist,

01:26:14.520 --> 01:26:21.480
mit dem ich nicht rechne. Es ist Running, dann ist es grün. Es ist, warum hab ich eigentlich

01:26:21.600 --> 01:26:34.240
kein Auto? Was ist denn das hier? Warum hab ich... What the? Please, Rider. Na gut. Nee,

01:26:34.240 --> 01:26:47.680
No State sollte es eigentlich eher nicht geben. Dann haben wir... Post. Warum macht der das auf

01:26:47.720 --> 01:26:55.360
eine Zeile? Ist er irgendwie lebensmüde oder was? Post ist so. Was anderes können wir eigentlich

01:26:55.360 --> 01:27:05.080
nicht haben? Oder meint er, das muss irgendwie alles in eine Zeile? Reformat. Nee, meint er nicht.

01:27:05.080 --> 01:27:20.480
So, so können wir das machen. Und jetzt Icon plus Icon. Gucken, wie das jetzt ausschaut. Ach so,

01:27:20.480 --> 01:27:24.320
wir müssen vielleicht mal... Äh, da müssen wir ein bisschen mehr Spacing dazwischen machen.

01:27:24.320 --> 01:27:32.120
Machen wir mal kurz eins in Post-Champ-Modus. Okay, das Icon sollte an Anfang, oder? Sonst

01:27:32.600 --> 01:27:37.600
sieht das doof aus. Vielleicht sollten wir daraus auch ein Template String machen,

01:27:37.600 --> 01:27:49.680
dass man das ein bisschen gescheiter lesen kann. State. Icon. Und wie sieht es jetzt aus? Das

01:27:49.680 --> 01:28:01.840
sieht doch ganz passabel aus, oder? Jetzt müsste ich nur noch mal gucken, wie ich hier ein bisschen

01:28:02.040 --> 01:28:06.640
Space dazwischen kriege. Das ist gar nicht so einfach, weil das ist ein Terminal und kein

01:28:06.640 --> 01:28:21.440
Winner, wo ich XY-Koordinaten malen kann. Also, hm. Wie kriege ich ihn da noch? Hab ich überhaupt

01:28:21.440 --> 01:28:25.360
die Möglichkeit, irgendwie noch ein bisschen Space dazwischen zu kriegen? Gibt es so was wie Table?

01:28:25.360 --> 01:28:33.760
Padding oder sowas? Nee. Nee, ich meine zwischen oben und unten. Zwischen oben und

01:28:33.760 --> 01:28:42.680
unten Space. Gibt es da irgendwie die Möglichkeit? Columns, Border? Border Style?

01:28:42.680 --> 01:29:00.800
Rowls? Nee, add Rowl ist blöd. Dann habe ich ja immer eine Z- Nee, das ist- Add Rowl ist doof.

01:29:00.800 --> 01:29:07.560
Also natürlich, man könnte sowas hier machen wie add Rowl new line. Oh nee, wie ist das? New,

01:29:08.040 --> 01:29:24.800
new, new. Ist das nicht line? Das gab es, aber das ist doch blöd. Nee, nicht Columns,

01:29:24.800 --> 01:29:34.960
Table, add Rowl. Das ist doof. Guck mal, da hast du sowas Leeres dazwischen, das sieht kacke aus.

01:29:34.960 --> 01:29:49.840
Äh, das sieht doof aus. No Pass. Es gibt sogar add empty Rowl, ja, aber es wird auch kacke

01:29:49.840 --> 01:29:55.240
aussehen. Ich hätte so ein bisschen, so ein bisschen Space hätte ich mir dazwischen gewünscht,

01:29:55.240 --> 01:30:02.640
so ein bisschen, so ein mini UTF-8-Character-Space vielleicht. Aber das ergibt natürlich keinen

01:30:02.720 --> 01:30:07.440
Sinn. Ähm, das wird nicht gescheit funktionieren, weil es ist wie gesagt, es ist ein Terminal und

01:30:07.440 --> 01:30:11.840
keine, keine GUI-Anwendung. Da wird das wahrscheinlich schlicht und ergreifend nicht

01:30:11.840 --> 01:30:16.200
gescheit gehen, da mal einfach ein bisschen Padding dazwischen zu machen oder sowas. Ich

01:30:16.200 --> 01:30:25.800
glaube wir werden mit der Ausgabe leben müssen. Ja, nee. Mono Space ist die Breite, nicht die

01:30:25.800 --> 01:30:37.280
Höhe. Aber die Zeilenhöhe ist immer das Gleiche. Wie hast du denn die Kästen an sich gemacht? So,

01:30:37.280 --> 01:30:44.720
guck mal. New Table, add Column, add Column und hier bei jedem Schleifendurchlauf die Werte

01:30:44.720 --> 01:30:53.480
eingefügt, am Ende ausgegeben. Das ist als Library, die das kann, ist Specter Console.

01:30:53.480 --> 01:31:04.160
Eine sehr nice Library für Terminal-Programme für .NET. Ich guck uns einfach mal die Hilfe

01:31:04.160 --> 01:31:17.800
auf der Seite an. Jetzt gibt es mal Panel. Table. Ja, Moment. Ach nee, das ist die Fußnote quasi,

01:31:17.800 --> 01:31:34.120
oder? Moment, ich habe eine Idee. Ich habe eine Idee. Fußnote anzeigen. Excellent. Wir

01:31:34.120 --> 01:31:50.320
machen einfach alles als Fußnote rein. Wie auch immer man überhaupt. Wie man das überhaupt

01:31:50.320 --> 01:32:05.400
dort reinbekommt. Ja, ist eine gute Frage. Add, add, add, Fußnote gibt es ja anscheinend nicht.

01:32:05.400 --> 01:32:19.200
Geil, toll, super. Und nu? Specter Console Table. Letzte Zeile gleich Fußnote,

01:32:19.200 --> 01:32:33.280
anscheinend ja nicht. Also ein Beispiel wäre jetzt mal ganz cool, ja. Oder vielleicht hier?

01:32:33.280 --> 01:32:58.840
Gibt es die? Moment, Sixhead Time, Leute. Ich habe eine Idee. Viel besser. Anstatt Emojis zu

01:32:58.840 --> 01:33:08.160
verwenden, könnten wir einfach gefärbte UTF-8 Zeichen verwenden. Fivehead. Ja, das hier ist

01:33:08.160 --> 01:33:15.960
Green. Probieren wir das mal aus. Green. Wobei ich mir gar nicht sicher bin, ob man hier Markup...

01:33:15.960 --> 01:33:23.520
Da, geht, geht. Da brauchen wir nur... Chat, ihr habt jetzt eine Aufgabe. Muss bis morgen zum

01:33:23.520 --> 01:33:32.280
Daily fertig sein. Ich brauche ein gutes UTF-8 Zeichen, was nicht so fett ist wie das und was

01:33:32.280 --> 01:33:58.600
nicht so kleines wie das. Der Chat ist am Start hier. Nice. Jawoll, perfekt. Scrum Master ist zufrieden

01:33:58.760 --> 01:34:09.400
mit euch. Das heißt, das nächste ist da nicht Green, sondern Orange und das hier unten ist Red.

01:34:09.400 --> 01:34:31.320
Orange gibt es nicht. Yellow. Das ist nicht zentriert. Was ist das? Ich brauche ein anderes

01:34:31.320 --> 01:34:43.880
Zeichen. Und das ist ein Terminal. Wir haben hier kein CSS. Wir haben hier kein CSS, wo man

01:34:43.880 --> 01:34:58.760
das anders erleiden kann oder so. Okay, UTF-8 Search. Moment, das ist das Fette, das hatten wir

01:34:58.760 --> 01:35:11.880
schon. Oh, das funktioniert bei mir gar nicht richtig. Nee, das funktioniert nicht. UTF-8

01:35:11.880 --> 01:35:30.200
Character Search. Ja, perfekt. Circle. Okay, was haben wir da? Circle, Circle, Circle. Alter,

01:35:30.200 --> 01:35:36.760
wie viele Zeichen es hier gibt. Anders ist es doch nicht. Medium Wide Circle. Das ist das,

01:35:36.840 --> 01:35:43.080
was wir gerade haben schon. Nee, das funktioniert bei mir nicht. Ich glaube,

01:35:43.080 --> 01:35:44.840
wir müssen es jetzt nicht übertreiben, Leute.

01:36:06.760 --> 01:36:15.440
Das sieht auch so fett aus, glaube ich. Guck mal, die Zeichen sind viel zu fett.

01:36:15.440 --> 01:36:26.640
Die Zeichen sind zu fett. Außerdem werden die auch nicht richtig gerendert. Leute, Kommando zurück.

01:36:26.640 --> 01:36:38.640
Kommando zurück. Wir lassen es einfach so, wie es ist. Gut ist. Passt schon. Wir lassen es einfach

01:36:38.640 --> 01:36:52.560
so. So, State Running, State Paused. Alles andere ist Error. Gut, dann machen wir noch eine Anzeige.

01:36:53.040 --> 01:37:02.480
Was haben wir denn noch für Informationen zur Verfügung? Memory. Memory, CPU. Ja gut,

01:37:02.480 --> 01:37:13.200
CPU, Time, Nummer der CPUs. Okay, wir zeigen noch Memory und CPU-Nummern an. Also Memory und V-CPUs.

01:37:13.200 --> 01:37:32.600
Also Running in grün. Ja, ich glaube, in dem Fall wäre das vielleicht besser. Wir machen

01:37:32.600 --> 01:37:41.080
gar keine Emojis, sondern schreiben einfach wirklich Running. So, in grün hin.

01:37:41.080 --> 01:38:04.880
Ach so. Na ja, gut. Das funktioniert nicht mal richtig. Ich glaube, das ist besser. Man

01:38:04.920 --> 01:38:23.680
macht sich immer um so simple Sachen viel zu viele Gedanken. Was findet ihr schöner, so oder mit?

01:38:23.680 --> 01:38:37.000
Die Emojis haben auch schon was, oder? Aber ist das IDE ein Visual Studio Code Skin? Ne,

01:38:37.600 --> 01:38:57.160
das ist das neue UI von Rider. Fabelgeschrift ist cool. Ja, dann machen wir es so, wie der Chat das

01:38:57.160 --> 01:39:14.160
vorgeschlagen hat. Color. Red. Color. Green. Yellow. Red. Und dann machen wir Color. Und hier

01:39:14.160 --> 01:39:24.600
machen wir wieder zu. So, das müsste jetzt auch funktionieren. Und bam, nice. Excellent kann man

01:39:24.600 --> 01:39:35.440
dazu nur sagen. Excellent. So, wunderbar. So, bleibt das jetzt. Okay, was brauchen wir als nächstes?

01:39:35.440 --> 01:39:48.240
Memory brauchen wir. Also Memory, da steht dann so was wie 1024 MB oder so was drin. Und CPUs steht

01:39:48.240 --> 01:39:53.600
dann so was wie zwei drin. Nur mal gucken, ob das gescheit aussieht. Ja, das ist okay. Das kann man

01:39:53.600 --> 01:40:04.520
glaube ich so lassen. Also, dann müssen wir jetzt Memory berechnen. Und zwar am besten in Megabyte,

01:40:04.520 --> 01:40:28.600
würde ich sagen. Ja, MB ist gut. Also, das heißt wir brauchen MaxMemSize ist ByteSizeInfoMaxMemorySize und

01:40:28.600 --> 01:40:36.200
dann haben wir noch Current. Ich weiß, die C-Sharp-Style-Guide-Puristen sagen jetzt, man soll

01:40:36.200 --> 01:40:39.520
das hier alles ausschreiben, aber ich finde man muss es nicht übertreiben. Ich meine, das ist

01:40:39.520 --> 01:40:44.720
doch klar was gemeint ist, oder? Übrigens nicht Size, sondern Size, wenn man es jetzt so richtig

01:40:44.720 --> 01:40:50.600
schreibt. Also, wenn man jetzt nach dem, ich weiß nicht wie offiziell der ist, aber ich sage mal,

01:40:50.600 --> 01:40:57.600
nach dem offiziellen, ich habe schon eine Library dafür drin. Wir könnten das auch mit der

01:40:57.600 --> 01:41:03.360
Humanizer Library machen. Also, der offizielle Style Guide sagt dazu, man soll Variablen nicht

01:41:03.360 --> 01:41:11.880
abkürzen. Also, müsste ich dann schreiben MaximumMemorySize. Chat, was findet ihr besser?

01:41:11.880 --> 01:41:22.120
Das oder das? Mit dem Hintergrund, dass wir im Prinzip auch CurrentMemorySize bräuchten.

01:41:22.120 --> 01:41:31.720
Ausgeschrieben oder abgekürzt? Was würde euch persönlich besser gefallen und was

01:41:31.720 --> 01:41:40.960
würdet ihr lieber programmieren? Lieber Kürzer ist besser, ausgeschrieben sagen manche. Also,

01:41:40.960 --> 01:41:44.560
offiziell ist die Sharp Style Guide, sagt glaube ich relativ klar, man soll es ausschreiben.

01:41:44.560 --> 01:41:59.280
Ich finde es Kürzer auch besser in dem Fall. Also, MaximumMemorySize. Die sind ja auch nicht

01:41:59.280 --> 01:42:06.120
sonderlich konsistent, die Jungs hier. Da heißt es Maximum und da heißt es Memory. Alles klar. So,

01:42:06.120 --> 01:42:11.920
das bedeutet wir brauchen da jetzt einen Text, der sich, wir machen immer einen Zeilenumbruch,

01:42:11.920 --> 01:42:16.240
weil sonst spiele ich spätestens beim nächsten Argument nicht mehr durch, wo was hinkommt.

01:42:16.240 --> 01:42:32.520
Wir brauchen jetzt sowas wie CurrentMemorySize slash von MaxMemorySize. Schauen wir mal.

01:42:32.520 --> 01:43:02.200
Hä? Ach, ist das vielleicht nicht in Bytes? Hast du, äh, ich glaube nicht, dass ich das

01:43:02.200 --> 01:43:10.400
aktiv habe. Du hast recht, es macht relativ wenig Sinn, weil dann MaxSize gleich CurrentSize ist.

01:43:10.400 --> 01:43:20.720
Habe ich mich noch nicht weiter mit beschäftigt, macht es Sinn, das zu aktivieren? Bei so kleinen

01:43:20.720 --> 01:43:33.160
Test-VMs wahrscheinlich nicht, oder? Der C-Latten-Sound-Style-Guide einfach voll am

01:43:33.160 --> 01:43:39.640
Leben vorbei, ja, aber wirklich. Da stehen teilweise eh merkwürdige Dinger drin. Zum

01:43:39.640 --> 01:43:44.520
Beispiel habe ich, das habe ich letztens in einem Video gesehen, dass man, oh fuck, mir fällt das

01:43:44.520 --> 01:44:06.720
Beispiel nicht mal ein. Ach ja, dass man empty. Genau, ich weiß es wieder. Also hier, war String

01:44:06.720 --> 01:44:13.080
gleich Kekkel. So. Der Style Guide sagt wohl auch, das habe ich erst letztens in einem Video

01:44:13.080 --> 01:44:17.720
gehört, wusste ich selbst nicht, dass man, es gibt ja die Möglichkeit zum Überprüfen,

01:44:17.720 --> 01:44:28.480
ob das ein Lehrer-String ist. Könnte ich entweder so machen oder ich könnte sagen so. Und es ist

01:44:28.480 --> 01:44:34.800
anscheinend wirklich so, dass der offizielle C-Sharp-Style-Guide das hier vorschlägt an

01:44:34.800 --> 01:44:43.000
Stelle von dem hier. Und dann denke ich mir auch nur, hä? Piss dich, Aldo. Was? Ups, ich hab das,

01:44:43.000 --> 01:44:50.680
denkst du, was? Warum? Also, warum sollte man das allen Ernstes diesem da vorziehen?

01:44:50.680 --> 01:45:04.320
String, ja, die Variante gibt es ja auch noch, stimmt. Die Variante String empty gibt es ja auch

01:45:04.320 --> 01:45:13.520
noch. Man könnte auch sagen String ist null empty, würde natürlich auch funktionieren.

01:45:13.520 --> 01:45:20.600
Stimmt, man müsste eigentlich müsste man tatsächlich an der Stelle so machen. Ja,

01:45:20.600 --> 01:45:30.240
das ist richtig. Also ganz im Ernst selbst, wenn das stimmt, Chat, dass das schneller ist

01:45:30.240 --> 01:45:36.240
als das eine, als das andere. Warum, wenn das wirklich der Fall sein sollte, ob das wirklich so

01:45:36.240 --> 01:45:42.680
ist, würde ich bezweifeln, weil ich glaube, dass der C-Sharp-Compiler das macht, was ich mir schon

01:45:42.680 --> 01:45:48.200
vorstelle. Und zwar, warum kann der Compiler das nicht optimieren? Stimmt, man könnte seit

01:45:48.200 --> 01:45:56.640
neuestem kann man ja auch noch String is-dings machen oder is-not und so. Also, das ist so ein

01:45:56.640 --> 01:46:02.080
Ding. C-Sharp ist wirklich immer noch mit Abstand meine Lieblingssprache. Die haben aber die letzten

01:46:02.080 --> 01:46:08.560
Jahre so viele Features eingebaut, die dazu geführt haben, dass man einfache Dinge auf

01:46:08.560 --> 01:46:13.840
doppeldeutige Arten lösen kann. Also, das ist überhaupt nicht dafür gedacht, das so zu machen.

01:46:13.840 --> 01:46:21.960
Das kommt aus diesem Pattern-Matching-Konstrukt. Man kann es an der Stelle auch verwenden und ich

01:46:21.960 --> 01:46:30.840
meine, ey, was soll das? Das ist doch vollkommen in Ordnung. Aber weiter, weiter im Text. Warum

01:46:30.840 --> 01:46:36.800
ist das hier, vielleicht ist das gar nicht in Bytes, sondern ist das in Kilobyte oder so was,

01:46:36.800 --> 01:46:42.640
vielleicht? Könnte das sein? Ist das in Kilobyte? Gucken wir mal. Ah, schon besser.

01:46:52.960 --> 01:46:55.200
Das ergibt überhaupt

01:47:03.200 --> 01:47:10.800
keinen Sinn. Muss ich vielleicht formatieren explizit als Megabyte?

01:47:22.960 --> 01:47:35.280
Hä? Die haben doch im Leben nicht so wenig RAM-Verbrauch. Die haben 244 MB RAM-Verbrauch.

01:47:35.280 --> 01:47:42.800
Hä? Moment, in welcher Unit ist das überhaupt? Jetzt bin ich, jetzt blicke ich nehmen wir durch.

01:47:42.800 --> 01:47:53.920
Ist doch gut. Was ist denn das? Das sind Kilobyte, oder? Leute, sind das Kilobyte?

01:47:53.920 --> 01:48:03.520
Ja, das sind Megabyte und das sind Kilobyte. PTH pro Stunde, ja.

01:48:13.320 --> 01:48:25.280
Also, ich bin ja geneigt dazu, einfach von Hand es umzurechnen, aber warum? Ach so,

01:48:25.280 --> 01:48:32.880
ah, ich weiß was falsch ist. Die wollen das in, ach okay, die wollen das in Bytes. Kann

01:48:32.880 --> 01:48:48.120
man das nicht auch in? Pass? From, ah, das will ich haben. From Kilobytes will ich haben.

01:48:48.120 --> 01:49:00.720
Das ist gut. From Kilobytes. Excellent. Highfader-Time. From Kilobyte. Das ist doch

01:49:00.960 --> 01:49:09.600
schon mal besser. Geil, 250 MB von 250 MB. Gut, das können wir uns glaube ich sparen, oder?

01:49:09.600 --> 01:49:23.000
Die Von-Anzeige, die ist ziemlich, ziemlich unsinnig. Der anderen Seite, sie sieht cool aus. Hat keinen

01:49:23.000 --> 01:49:29.280
wirklich Mehrwert, aber okay, vielleicht sollten wir das wegschmeißen und einfach nur Current

01:49:29.280 --> 01:49:41.480
Memory-Size reinhauen. Prozentuale Anteile, der ist ja 100% quasi. Okay, dann lassen wir es so,

01:49:41.480 --> 01:49:52.240
250 MB. Sollte sich 200, oder ist es 200 MB? Maybe Byte vielleicht? Nee, dann weiß ich auch nicht.

01:49:52.240 --> 01:50:03.360
Es sollten 256 sein, wenn ich das jetzt hier nicht... Nee, es sind sogar nur 244.

01:50:03.360 --> 01:50:32.160
Hä? Hab ich da irgendwo einen Bug drinnen? Weil meine... Egal. Egal. Pogu ist noch eingeschaltet.

01:50:32.160 --> 01:50:43.320
3 minus M? Das sind so 212. Alter, einhalten. Ich weiß im XML, ich bin mir aber nicht sicher,

01:50:43.320 --> 01:50:58.240
warum das im XML drin steht, weil eigentlich sollte im XML drinstehen. Memory-Size in Bytes.

01:50:58.240 --> 01:51:09.240
Und das steht hier nicht drinne. Hier steht Memory-Size in Kilobytes drinne. Und in Bytes,

01:51:09.240 --> 01:51:22.080
Size in Bytes, gebe 256 MB an. Ich ignoriere den Einheitenshit einfach, da habe ich jetzt

01:51:22.080 --> 01:51:31.520
wirklich keinen Nerv drauf. Was in der XML? Jaja, aber hier in meiner XML, die ich ursprünglich

01:51:31.520 --> 01:51:54.440
anlege ist, vom Bytes, dass er das machen soll. Und hier, irgendwo, da, da passt er das auch als

01:51:54.440 --> 01:52:09.200
256 MB. Und pumpt das dann da rein, als Bytes. Ich ignoriere es. Einhalten, umrechnen, stellst.

01:52:09.200 --> 01:52:16.680
Kein Bock. Ja, im Wirtmanager hast du recht, ja. Okay, also jetzt haben wir hier eine schöne

01:52:16.680 --> 01:52:22.920
Ausgabe. Das ist doch schon mal ganz nice. Sieht auch schon mal ganz hübsch aus, alles. Horrors

01:52:22.920 --> 01:52:36.120
Time. Kennst du Cursor.io? Nee. Ist ein Editor mit AI? Braucht kein Account und funktioniert

01:52:36.120 --> 01:52:42.000
mit? Funktioniert ganz gut. Aber man muss irgendeine Windows-Software installieren.

01:52:42.000 --> 01:52:49.520
Warum braucht man einen Editor mit AI? Warum kann man nicht einfach ein

01:52:49.520 --> 01:52:54.680
Visual Studio Code Plugin für AI verwenden? Warum braucht es dafür um alles in der Welt einen

01:52:54.680 --> 01:53:06.560
eigenen Editor? Also, kann doch ein Plugin machen. Was auch immer. Es ist ein AI-Projekt,

01:53:06.560 --> 01:53:11.480
also muss mindestens 10.000 GitHub-Sterne nächste Woche haben. So, Current-Memory-Size. So,

01:53:11.480 --> 01:53:15.880
jetzt können wir noch kurz gucken, wie viele CPUs es gibt. Das ist relativ einfach. Info.

01:53:15.880 --> 01:53:30.880
Nirrwirt-CPU. Weil Number oder N zu billig ist. Eins. Okay, das ist schön, das ist schick,

01:53:30.880 --> 01:53:40.280
das gefällt mir. So, lassen wir das. Gut. Hätten wir das schon mal abgehakt? Das haben wir abgehakt.

01:53:40.280 --> 01:53:53.600
Discuses. Weiß nicht, wie man das rauskriegt. Falls überhaupt. Das hätten wir abgehakt. So,

01:53:53.600 --> 01:53:59.160
mehr Images haben wir als nächstes auf unserer To-Do-Liste. Mehr Images. Arch, by the way,

01:53:59.160 --> 01:54:08.000
Fedora, CentOS, Oracle. Okay, ja gut, das ist easy. Ich würde sagen, wir bauen aber vorher

01:54:08.000 --> 01:54:13.880
ein Reboot-Command ein, Leute. Reboot ist wirklich eine wichtige Sache. Wir bauen Reboot vorher ein.

01:54:13.880 --> 01:54:21.960
Weil Images hinzufügen ist so eine Fleißarbeit. Sei es vom Image-File für Discuses oder ist das

01:54:21.960 --> 01:54:35.960
toll, statisch. Ich könnte QEMU-Image machen tatsächlich. Ich könnte QEMU-Image-Info auf

01:54:35.960 --> 01:54:55.360
VM-Champ. VMs Pogu gucken. Ah, es lockt. Haha, deswegen geht das nicht. Wenn die Images in einer

01:54:55.360 --> 01:55:01.000
Config stehen würden, würde es nicht bei repo-updates gleich ein Rebuild, aber just. Ja gut,

01:55:01.000 --> 01:55:07.360
aber wie kommt die Config dann auf den Rechner des Anwenders? Die muss ja entweder von Hand anlegen,

01:55:07.360 --> 01:55:12.640
was schon mal doof ist, wenn du es einfach nur benutzen willst. Ja, gibt es dann halt eine neue

01:55:12.640 --> 01:55:23.440
Miner-Version, ist doch okay. So oft ändern sich jetzt die Images da auch nicht. Einmal im halben

01:55:23.440 --> 01:55:31.320
Jahr, wenn ich Bock habe. Also wir können nochmal ganz kurz gucken, ob wir irgendwie

01:55:31.320 --> 01:55:45.600
Disk Usage rausbekommen können. Das gucken wir nochmal kurz. Cloud wird pro Woche gebaut. Ja,

01:55:45.600 --> 01:55:58.040
das ist doch nicht mein Problem. Zumal ich das ja abfange, indem ich immer auf Latest gehe an

01:55:58.040 --> 01:56:06.160
der Stelle. Also das ändert sich ja wirklich nur, wenn es ein komplettes US-Update gibt. Der zieht

01:56:06.160 --> 01:56:13.320
sich ja schon immer das Latest-Cloud-Image, das Daily-Cloud-Image. Latest und hier Latest-Buster

01:56:13.320 --> 01:56:27.400
von Demian. Macht er ja schon. Ja, also gucken wir mal kurz, ob es die Möglichkeit gibt,

01:56:27.400 --> 01:56:52.120
Disk Usage rauszubekommen. Ich fürchte ja nicht. Disk, Disk, FS-Info. Ja, was ist das denn? Oh ja,

01:56:52.120 --> 01:56:58.600
Arm-Support. Das ist tatsächlich relativ easy, Arm-Support. Arm-Support können wir vielleicht

01:56:58.600 --> 01:57:05.640
heute noch einbauen. Da muss ich einfach das Bild-Docker-Image anpassen. Auf was baut man

01:57:05.640 --> 01:57:21.600
das am besten? Also ich baue die Anwendung aktuell in einem CentOS 7-Docker-File. Was

01:57:21.600 --> 01:57:31.760
ist eine gute Basis zum Bilden für Arm und Raspberry Pi zum Beispiel? Arm braucht aber

01:57:31.760 --> 01:57:37.680
andere Images, wie da unten eine andere Config in lib wird. Da hast du recht, das ist richtig,

01:57:37.680 --> 01:57:48.320
das ist richtig. Ja, dann ist es tatsächlich ein bisschen komplizierter Arm-Support. Auto-Update,

01:57:48.800 --> 01:57:56.480
kein Auto-Update. Update-Hinweis höchstens. Baust du die App eigentlich als native AOT? Ja,

01:57:56.480 --> 01:58:02.480
korrekt. Das ist auch der einzige Grund, warum ich schon .9.8 verwende. Und jetzt halte ich

01:58:02.480 --> 01:58:17.600
mal fest, das ist richtig gut mittlerweile, weil das Image am Ende nur 12 MB groß ist. Das nimmt

01:58:17.600 --> 01:58:22.480
sich zu einer Go-Anwendung fast schon nichts mehr. Ich meine, Go hat immer noch ein bisschen die Nase

01:58:22.480 --> 01:58:31.280
vorne, was das angeht, natürlich. Go ist nur ein bisschen kleiner und Go ist vor allem,

01:58:31.280 --> 01:58:39.760
ohne irgendwie große Action zu machen. Self-Contained, Standalone, lauffähig seit

01:58:39.760 --> 01:58:49.040
Linux Colonel 2, 3, 38 oder sowas. Aber nachdem ich die Anwendung baue im Docker-Container gegen

01:58:49.040 --> 01:59:01.360
eine 12 Jahre alte G-Libc-Version oder sowas, ist das auch in Ordnung. Die ist also auch lauffähig

01:59:01.360 --> 01:59:14.160
auf alle Linux-Systeme der letzten 10 Jahre. Okay, also weiter geht's. Ich wollte Disk Image

01:59:14.160 --> 01:59:30.880
gucken, ob es da irgendwas gibt. FS hier, wir domain FS Info. Das bringt mir jetzt aber nichts.

01:59:30.880 --> 01:59:42.280
Wir domain FS Info. Ich hätte jetzt eigentlich gedacht, man kriegt vielleicht raus,

01:59:42.280 --> 01:59:52.520
wie viel vom Image belegt ist. Kriegt man das vielleicht über was anderes raus? Also,

01:59:52.520 --> 02:00:08.160
Host, Event, Interface, Node. Was? Node, Devs. Was wollt ihr von mir? Storage.

02:00:08.160 --> 02:00:19.600
What? Of Storage Pools and Volumes. Da kommen wir doch der Sache schon näher.

02:00:22.520 --> 02:00:43.880
Volume Create. Volume Info. Ja, das sieht tatsächlich schon mal ganz gut aus. Volume

02:00:43.880 --> 02:00:54.680
Info. Natürlich, natürlich nice. Storage Volume Create. Das sieht Storage Volume Info.

02:00:54.680 --> 02:01:06.080
Capacity Allocated Bytes. Das wollen wir haben. So die Frage, wie komme ich an das Volume?

02:01:14.880 --> 02:01:22.560
Okay, also es gibt wir Domain. Disk hatten wir eben schon mal. Irgendwas mit...

02:01:22.560 --> 02:01:48.000
Hier, was ist das? Domain. Domain. Block Stats. Könnte das Sinner geben? Block Stats. Get Block Info.

02:01:52.920 --> 02:01:58.000
CPUs, was zum... Okay, jetzt müssen wir mal kurz gucken, wie man das rauskriegen könnte.

02:01:58.000 --> 02:02:03.840
Wie viel vom File System belegt ist. Also, nachdem ich das gesehen habe, bin ich mir relativ sicher,

02:02:03.840 --> 02:02:10.760
dass es geht. Okay, lass uns mal nachgucken. Wir Domain Get Block Info. Extract Information

02:02:10.760 --> 02:02:17.720
About a Domain's Block Device. Das klingt doch eigentlich schon mal ganz sinnvoll, oder?

02:02:17.720 --> 02:02:45.440
Disk Name of the Block Device. Blah, blah, blah. Wir Block Info. Ja! Capacity Links ist doch

02:02:45.480 --> 02:02:50.360
gut. Das ist genau das, was wir brauchen. Wir Domain Get Block Info. Das war immer noch zu...

02:02:50.360 --> 02:03:11.760
CPU Stats. Wie komme ich auf CPU Stats jetzt? Block Stats. Okay, ich habe keine Ahnung,

02:03:11.760 --> 02:03:21.680
was Block Stats sind versus Block Info. Was ist der Unterschied dazwischen? Okay,

02:03:21.680 --> 02:03:27.000
kein Plastenschimmer. Block Stats. Flex. Okay, das wird mich nicht interessieren. Also,

02:03:27.000 --> 02:03:34.240
wahrscheinlich brauchen wir das tatsächlich. Wir Domain Get Block Info. Also, da brüsten die

02:03:34.240 --> 02:03:42.320
Domain. Man braucht einen Disk. Man braucht einen Pointer. Ja. Probieren wir das doch mal aus.

02:03:42.320 --> 02:03:49.160
Probieren wir doch mal aus, ob das funktioniert. Also, ich bin gespannt, ob das funktioniert.

02:03:49.160 --> 02:03:56.200
Vielleicht kriegen wir ja doch noch die Größe raus von so einer Disk da drinnen. Könnte doch

02:03:56.200 --> 02:04:01.800
sein. Also, wir müssen wieder ein bisschen Interop Rapper Code drum herum basteln. Als erster Pointer

02:04:01.800 --> 02:04:13.400
eine Domain. Okay. Als zweites ein String mit Disk. Flex. Was für Flex? Flex. Extra Flex,

02:04:13.400 --> 02:04:24.120
not used. Okay. Not used finde ich immer gut. Weil da kann man einfach sagen. Blocks. Flex.

02:04:24.120 --> 02:04:33.960
Flex. You signed. Ja, gut. Und sein End. So, und dann brauchen wir hier ein String.

02:04:33.960 --> 02:04:45.960
An der Stelle gibt es ein String. Device heißt das bei denen, glaube ich, oder? Nee, Disk. Disk.

02:04:45.960 --> 02:04:53.400
Und als nächstes brauchen wir noch ein Vier Domain Block Info Pointer. Natürlich. Was auch

02:04:53.400 --> 02:05:04.320
sonst. Vier Domain Block Info. Okay. Legen wir das mal als Struck hier oben an. Vier Domain. Das

02:05:04.320 --> 02:05:15.640
ist immer ein bisschen eklig zum Copy Pasten. Hier. Vier Block Info. Was zum? Und da haben

02:05:15.640 --> 02:05:22.920
wir dann. Kommen wir das mal weg. Vier Block Info besteht aus, was sagt die Doku dazu? Capacity,

02:05:22.920 --> 02:05:35.320
Allocation und Physical. Alles ein unsigned Long Long. Was war das noch mal? Physical. Allocation

02:05:35.320 --> 02:05:45.480
und Capacity. Unsigned Long Long. Das ist ein Uint 128, gell? NC Sharpen. Unsigned Long Long.

02:05:45.480 --> 02:05:57.680
C-Programmierer hassen diesen Trick. Okay. So. Und darauf wollen die was? Ein Pointer. Habe ich

02:05:57.680 --> 02:06:04.920
das richtig in Erinnerung, ja? Ein Pointer auf so ein komisches Struck.

02:06:04.920 --> 02:06:16.720
Wollen die haben. Also quasi darauf. Also ein Vier Block Info Pointer Info. Meine Güte. Also

02:06:16.720 --> 02:06:23.720
C-Interop Zeug werde ich nicht vermissen. Alles gut. So. Das müsste jetzt eigentlich funktionieren.

02:06:23.720 --> 02:06:32.120
Schauen wir mal. Bin ich gespannt. Chat, was meint ihr? Memory Dinks Core Dump Crash? Oder

02:06:32.200 --> 02:06:39.680
funktioniert? Was denkt ihr? Block Info. Übrigens kann ich das nicht einfach ausgeben, sondern ich

02:06:39.680 --> 02:06:49.320
muss sagen. War Block Info gleich New Block Info? Ich hoffe mal, dass man das so aufruft. So. Jetzt

02:06:49.320 --> 02:06:58.560
die Domain. VMI-ID. Dann das Device. Da bin ich mir noch nicht sicher, was da genau rein muss. Dann

02:06:58.560 --> 02:07:07.400
ein Pointer auf Block Info und keine Flags. Okay. Was passiert dann, wenn ich das aufrufe mit,

02:07:07.400 --> 02:07:13.400
hier haben wir mal Return Code. Was passiert dann, wenn ich das aufrufe, ohne ein Device zu setzen?

02:07:13.400 --> 02:07:26.960
Erst mal gucken. Was dann? Ah. Fatal Exception. Gut. Das funktioniert so schon mal nicht. War da

02:07:26.960 --> 02:07:37.640
nicht ein Beispiel sogar drin, wie man das... Device. Wo kommt Device her? Super. Dankeschön.

02:07:37.640 --> 02:07:51.000
Super. Sehr schön gemacht. Device. Das Wichtigste gibt es kein Beispiel für. Logisch. Path to Block

02:07:52.000 --> 02:07:59.880
Device. Okay. Meine Devices heißen ja alle gleich. Die heißen ja alle... Die Disks heißen ja alle

02:07:59.880 --> 02:08:06.800
gleich. Und zwar... VDA heißen die, glaube ich. V... Kann man die drinnen nicht suchen? Hier,

02:08:06.800 --> 02:08:16.560
Disk. VDA heißen meine ganzen Devices. Immer. Also das müsste dann eigentlich gehen. VDA.

02:08:16.560 --> 02:08:29.360
Breage. Breage Chat. Breage. Fuck. Ihr seid schuld. Nicht genug Breage. Oh. Wieder vergessen zu

02:08:29.360 --> 02:08:42.440
kopieren. Null. Null was? Okay Chat, aber jetzt. Jetzt brauche ich eine Runde Breage,

02:08:42.440 --> 02:08:50.760
dass es funktioniert. Ihr seid ziemlich Breage faul heute, habe ich gesehen. Einmal Breage. Wenn

02:08:50.760 --> 02:08:58.400
ich mindestens ein Breage im Chat, dann führe ich das jetzt nicht weiter aus. So. Welches... Alles

02:08:58.400 --> 02:09:05.360
klar. Gut. Nice. Wir haben es. Jetzt muss es funktionieren. Jetzt kann es gar nicht funktionieren.

02:09:05.360 --> 02:09:20.200
Block Info. Ihr seid die besten, Chat. Nice. Kann ich dazu sagen. Block Info. Capacity.

02:09:20.200 --> 02:09:31.880
Allocation. Und was haben wir sonst noch zu bieten? Physical? Was ist denn da was von überhaupt?

02:09:31.880 --> 02:09:42.280
Was ist denn da was von? Physical. Host. Physical Size in Bites of Container Image. Host Storage

02:09:42.280 --> 02:09:52.560
in Bites occupied by the Image. Hä? Warum sind die unterschiedlich? Logical Size. Also uns

02:09:52.560 --> 02:09:56.720
interessiert wahrscheinlich hauptsächlich das obere. Alles klar. Run.

02:10:01.880 --> 02:10:17.600
Way to Denkzahl. Okay. Bites to Megabyte.

02:10:17.600 --> 02:10:46.960
Fünf. Ist es denn überhaupt in Bites? In Bites.

02:10:47.600 --> 02:11:09.760
Das ist... Das erscheint mir ein wenig sass. 2 Gigabyte. Das Zeug kann nicht richtig rechnen.

02:11:09.760 --> 02:11:21.240
Ich glaube. Ich glaube Google ist damit gerade überfordert oder? Normalerweise kann das doch

02:11:21.240 --> 02:11:43.680
2 Gigabytes. Wir können das doch einfach hier reingehen. Convert Life. Jawoll. Convert Life.

02:11:43.680 --> 02:12:08.200
Leute die Zahl stimmt nicht. Egal was es ist. Das ist auf jeden Fall zu viel. Das ist auf jeden

02:12:08.200 --> 02:12:26.440
Fall zu viel. Den Windows Rechner mal gucken ob der das kann. Ne da kann er nicht mal reinkopy

02:12:26.440 --> 02:12:34.000
pasten überhaupt. Da stimmt irgendwas nicht würde ich sagen. Da ist irgendwas mit meinem

02:12:34.000 --> 02:12:48.120
Interop Code ein bisschen falsch. Es ist auch suspekt dass das hier Null ist bei Physiql.

02:12:48.120 --> 02:13:05.400
Es funktioniert ja offensichtlich. Das ist viel zu viel. Also ich glaube das ist einfach verkehrt.

02:13:05.400 --> 02:13:16.120
Also mein Interop Code ist Müll. Das stimmt so nicht. Wir Domain Block. Also wir Domain Block

02:13:16.120 --> 02:13:24.640
Info. Es ist angeblich ein Unsigned Longlong. So und wenn ich das richtig erinnere habe ist das

02:13:24.640 --> 02:13:38.880
ein 128. Also ne ne ne. Ja 8 byte Memo. Ach Moment es ist gar kein 128. Ach deswegen stimmt das nicht.

02:13:38.880 --> 02:13:56.960
Es ist einfach nur ein Unsigned Int. Kein 128. Ne es ist ein Unsigned Int 60. Also ein Unsigned

02:13:56.960 --> 02:14:10.680
Long quasi dann. Ok. Alter Einheiten und Datentypen zwischen C und C Sharp da wird es nicht. Ja das

02:14:10.680 --> 02:14:20.120
sieht schon deutlich besser aus wie das was ich erwartet habe. Das passt jetzt schon eher. Es

02:14:20.120 --> 02:14:28.280
sind 4 Gigabyte. Das passt nämlich auch. 4 Gigabyte und davon sind so viel Allocated und so

02:14:28.280 --> 02:14:36.400
viel Physiql. Ok Physiql juckt mich jetzt nicht wirklich. Das war's. Easy. Haben wir doch einfach

02:14:36.400 --> 02:14:43.280
rausgekriegt. Das finde ich cool. Da kann man sogar noch in das List Command den Disk Space rein

02:14:43.280 --> 02:14:53.240
bauen. Wenn man das haben will. Ok das heißt wir machen noch Disk Space. Mal noch Disk Space mit rein.

02:14:53.240 --> 02:15:07.920
Mal mal einen Disk dran. Disk. Easy. Das können wir vielleicht alles dann auch mal. Das wird

02:15:07.920 --> 02:15:11.880
langsam ein bisschen lang. Wobei. Ganz ehrlich so lange ist es gar nichts. Das ist immer noch gut

02:15:11.880 --> 02:15:19.000
lesbar alles. Interop wirken VDA. Glücklicherweise heißen die Devices alles VDA. Anders kann man das

02:15:19.000 --> 02:15:34.600
nicht machen. Und jetzt müssen wir hier noch bei nach Memory. Nach Memory reinschreiben wie

02:15:34.600 --> 02:15:47.160
viel Block. Block Info Current Memory Size. Wir können uns das eigentlich die Zuweisung hier nehmen.

02:15:47.160 --> 02:15:59.000
Das machen wir hier oben. Fragen wir das ab. Das hier heißt nicht Block Info sondern das heißt jetzt

02:15:59.000 --> 02:16:18.120
tatsächlich State Info. Zumindest um das zu unterscheiden. So ok. Das machen wir die Abfrage

02:16:18.120 --> 02:16:23.600
machen wir auch hier oben. Dass das alles ein bisschen besser kopiert ist. So und jetzt brauchen

02:16:24.200 --> 02:16:41.400
war Current Disk Size und war Max Disk Size. So folgendes. Das kriegen wir hier. Ups was haben wir jetzt

02:16:41.400 --> 02:17:00.120
gemacht. Block Info Current Disk Size ist Allocation und Block Info Capacity ist das

02:17:00.120 --> 02:17:10.720
Gesamte. Heute kein MMO Kreise. Heute nicht. Heute fehlen ein paar Leute. Wäre es sinnvoll

02:17:10.720 --> 02:17:15.280
wenn sowas wie Disk Size nicht Standard bei List passiert sondern nur mit zusätzlichen Argumenten

02:17:15.280 --> 02:17:22.240
dann wäre die Tabelle nicht so. Das ist richtig. Da hast du recht. Könnte man könnte man vielleicht

02:17:22.240 --> 02:17:28.200
machen. Das ist aber gar nicht darauf ausgelegt dass du viele VMs hast. Du hast vielleicht 4-5 VMs

02:17:28.200 --> 02:17:34.200
und dann ist gut. Weil das ist ja kein quasi Docker Ersatz für VMs um es jetzt mal übertrieben zu

02:17:34.200 --> 02:17:40.000
sagen. Sondern um 2-3 Test VMs lokal zu starten was auszuprobieren und sie danach wieder zu löschen.

02:17:40.000 --> 02:17:51.000
Das ist ja keine VM Verwaltungslösung für im größeren Stil. Wo kommt eigentlich Kreisel

02:17:51.000 --> 02:17:56.760
Grind her? Das ist was was ich mit dem Friseur mir ausgedacht habe. Der Friseur mit mir sich

02:17:56.760 --> 02:18:03.440
ausgedacht hat. Je nachdem. Kreisel Grind ist in einem MMO repetitive Aufgaben immer wieder machen

02:18:03.440 --> 02:18:15.560
und wenn man das im Kreis macht dann ist es Kreisel Grind. Und nachdem heute 2 Leute fehlen

02:18:15.560 --> 02:18:25.240
können wir kein MMO Kreisel Grind machen. Aber wir können das genauso schreiben wie wir das

02:18:25.240 --> 02:18:34.560
vorhin schreiben wollen. Current Disk Size in Megabyte von Maximum Disk Size in Megabyte.

02:18:34.560 --> 02:18:44.280
Dann weiß man Bescheid. Und jetzt Run BAM. Leute wir machen das mal in Gigabyte nicht in Megabyte.

02:18:44.280 --> 02:18:51.480
Sind die VMs abgeschottet? Nein kann man nicht. Nein nein Sandbox. Die hängen alle. Naja die

02:18:51.480 --> 02:18:57.200
sind voneinander abgeschottet. VMs sind standardmäßig voneinander abgeschottet. Das sind ja keine

02:18:57.200 --> 02:19:02.800
Container. Die eine VM kann bei der anderen VM nichts machen. Du könntest dich theoretisch über

02:19:02.800 --> 02:19:07.640
das Netzwerk Interface von einer VM zur anderen über SSH connecten. Das könntest du machen.

02:19:07.640 --> 02:19:14.000
Also du könntest auf der einen VM irgendwie einen Service installieren und nicht von der

02:19:14.000 --> 02:19:18.600
anderen hin connecten über das Netzwerk. Die hängen alle an der gleichen Netzwerk Bridge.

02:19:18.600 --> 02:19:23.760
Und es bleibt auch so, weil ich kein Netzwerkmanagement hier einbauen will.

02:19:23.760 --> 02:19:34.040
Es geht um lokale kleine lokale Test VMs. Aber jetzt zum Virus testen wäre es nichts.

02:19:34.040 --> 02:19:40.960
Warum? Könntest du schon benutzen. Du hast halt das Default Interface was ins Internet kann.

02:19:40.960 --> 02:19:46.480
Das ist vielleicht keine allzu gute Idee und irgendwo auch über Umwege in der Netzwerk.

02:19:47.360 --> 02:19:53.520
Wenn du dein Default Interface so umstellst, dass es nirgendwo hinkommt, dann kannst du

02:19:53.520 --> 02:19:56.800
da drin auch ein Virus testen. Warum nicht? Aber Virus testen willst du doch höchstwahrscheinlich

02:19:56.800 --> 02:20:02.840
eh in der Windows VM und da brauchst du ein GUI für. Und Windows kannst du damit eh nicht

02:20:02.840 --> 02:20:15.920
installieren und ein GUI, dann brauchst du eh ein VM. So. Also wir machen Gigabyte.

02:20:16.160 --> 02:20:25.240
Nicht Megabyte. Wäre nicht Coarse besser als VCPUs? Ich krieg da nur VCPUs drüber raus.

02:20:25.240 --> 02:20:31.120
Ja, so gefällt mir das. Das ist nice. Das hat doch was. Guckt euch das. Das ist doch schön.

02:20:31.120 --> 02:20:36.840
Das ist doch schick. Das gefällt mir. Vielleicht soll ich mal Kekl wieder endpost champen,

02:20:36.840 --> 02:20:43.800
dass es wieder läuft. Und jetzt ist es beides running. Aber mal gucken. Ich glaube die VM,

02:20:43.800 --> 02:20:52.080
das SSH, ich glaube das SSH überlebt also die IP. Ernsthaft? Das Ding war 30 Minuten

02:20:52.080 --> 02:20:58.040
suspended und die IP und alles ist immer noch gültig. 30 Minuten ist ja nichts für die ACP.

02:20:58.040 --> 02:21:11.840
Startest du die VMs standardmäßig mit 4 Gigabyte? Ne, mit 4, nicht mit 400. Äh Moment. Moment,

02:21:11.840 --> 02:21:20.920
Moment, Moment, Moment, Moment. Ich starte die mit 4 Gigabyte, nicht mit 14, nicht mit 4 Terabyte.

02:21:20.920 --> 02:21:34.120
Irgendwas ist da falsch. Ah, ich weiß was falsch ist. From Kilo Bytes ist falsch.

02:21:34.120 --> 02:21:52.800
Ok, das sieht besser aus. Ja, das sieht besser aus. Also 128 MB belegt von 4 Gigabyte. Das

02:21:52.800 --> 02:21:59.160
sieht deutlich realistischer aus als 4 Terabyte pro VM. Ja, da habt ihr Recht. Das ist Blödsinn

02:21:59.640 --> 02:22:06.000
gewesen. Und weil jemand meint, es ist unübersichtlich, so unübersichtlich ist die Tabelle doch gar nicht.

02:22:06.000 --> 02:22:09.840
Ist doch eigentlich ganz nice. Wollen wir mal ausprobieren, ob die Anzeige auch wirklich gut

02:22:09.840 --> 02:22:17.640
funktioniert? Wollen wir mal die Festplatte voll machen? Ich, ich baue mal kurz, ich baue mal

02:22:17.680 --> 02:22:31.880
kurz eine neue Version. Bild. Ja, perfekt. Wir testen mal, wir testen jetzt gleich mal,

02:22:31.880 --> 02:22:41.200
ob das funktioniert. Wir schreiben jetzt mal die Festplatte voll und... Was?

02:22:41.200 --> 02:22:56.440
Could not retrieve. Was? Ok, mal docker restarten. Keine Ahnung, warum. Nochmal, please. Willst du

02:22:56.440 --> 02:23:00.000
die Anzeigen beim Erstellen auch noch in Megabyte machen, statt Maybebyte? Hab' ich schon,

02:23:00.000 --> 02:23:07.520
hab' ich schon. Hab' ich schon gemacht, hab' ich aber noch nicht veröffentlicht. Ist bei mir schon

02:23:07.520 --> 02:23:17.880
so... Run Command. Guck, die sind schon in MB. Maybebyte ist bescheuer, das erkennt... Das

02:23:17.880 --> 02:23:25.040
checkt doch keiner, was damit gemeint ist. Ja, hab' ich schon, hab' ich schon angepasst.

02:23:25.040 --> 02:23:35.920
Ok. So, jetzt sollte der Docker-Container hoffentlich ordentlich bilden. Zeigt mal her.

02:23:35.920 --> 02:23:44.960
Ja, macht er. Docker-Stells ist am bauen. Alles gut, nice. Daniel, gehe ich recht in

02:23:44.960 --> 02:23:49.560
der Annahme, dass du es ausprobiert hast? Weil du sagst, das ist in Maybebyte oder einfach nur vom

02:23:49.560 --> 02:23:58.480
Stream, vom Sehen? Oder hast du das auf GitHub ausprobiert? Eigentlich nice Five-Hat-Taktik,

02:23:58.480 --> 02:24:09.600
im Stream das Repo zu verlinken, da kriegt man Sterne die ganze Zeit. Maybebyte größer,

02:24:09.600 --> 02:24:21.400
Megabyte. Die Leute sind an Zahlen wie 256 einfach gewöhnt. Wobei es dann eigentlich

02:24:21.400 --> 02:24:31.720
Maybebyte sein müsste. Weil Megabyte ist ja 1000 und Maybebyte sind 1024. Ach, kein Plan. Ach,

02:24:31.720 --> 02:24:42.240
deswegen. Deswegen ist es auch verkehrt. Deswegen habe ich auch verkehrt gerechnet. Guck mal,

02:24:42.240 --> 02:24:51.120
ich müsste... Ok, das ist tatsächlich ein Fehler, weil meine Angaben sind in Maybebyte,

02:24:51.520 --> 02:24:55.800
und ich schreibe Megabyte dran. Deswegen klappt das auch nicht. Also, was heißt klappt nicht,

02:24:55.800 --> 02:25:07.520
aber deswegen sind es auch 10 MB zu wenig ungefähr. Guck mal, an der Stelle. Hier, 256 MB. Ich müsste

02:25:07.520 --> 02:25:20.600
eigentlich 256 MIB schreiben und GIP und so Zeug. Das ist stimmt. Ok.

02:25:21.120 --> 02:25:35.760
Fix the units. Default values in MIB. Also, ok. Neuer VMChamp-Version ist gebaut. Jetzt

02:25:35.760 --> 02:25:54.240
probieren wir das mal aus. VMChamp-List. Ok. Watch. Oh, bisschen größer. Watch minus C 0,1. Ne,

02:25:54.240 --> 02:26:05.200
minus N. Wie? Watch kommt nicht klar mit... Moment, Watch kann doch garantiert an C, S,

02:26:05.200 --> 02:26:12.200
color. Das geht doch bestimmt. Wunder, wenn das nicht funktioniert. Watch minus minus color.

02:26:12.320 --> 02:26:28.960
Selbstverständlich geht das. Minus minus color. Excellent. Gleich viel besser. So. Und jetzt

02:26:28.960 --> 02:26:39.000
schreien wir mal. Jetzt schreien wir mal. Ups. SSH soll es ja auch sein. Und jetzt schreien wir mal

02:26:39.000 --> 02:26:51.720
die VM voll. Was hat er? Oh, der kommt damit nicht klar, wenn man zu oft hintereinander die IP

02:26:51.720 --> 02:26:56.080
abfragt. Da spackt er ein bisschen rum, so wie es aussieht. Warum ist color nicht standard? Das ist

02:26:56.080 --> 02:27:02.280
eine sehr gute, berechtigte Frage. Ok. Schauen wir mal, ob das voll läuft jetzt. Also machen wir

02:27:02.280 --> 02:27:12.760
mal irgendwie. Yes. Oh, ne. Komm. Cut Def 0 nach PV. Ist PV überhaupt drauf? Natürlich nicht.

02:27:12.760 --> 02:27:24.760
Sudo Up Install PV. Sudo Up Update. Aber es funktioniert, Leute. Guck mal. Easy. Man hat

02:27:24.760 --> 02:27:34.440
jetzt schon gesehen, dass es gut funktioniert. Install PV. Guck mal, guck mal. Es ist fast synchron

02:27:34.440 --> 02:27:43.800
hochgegangen, hier die Anzeige für den Memory. Der Memory ist immer 250 MB. Das hat immer das

02:27:43.800 --> 02:27:52.520
reservierte. Ja, du hast recht, Phipps. Das ist aber zu pfeilfert jetzt für mich. Def 0 nach PV

02:27:52.520 --> 02:28:02.320
nach Def 0. Ne, nicht nach Def 0, nach Image Punkt bin. So, gucken wir mal, wie schnell die

02:28:02.320 --> 02:28:20.120
Disk verläuft. Oh, Alter. No-Space-Disk ist voll. Auch wenn das hier noch nicht so wirkt,

02:28:20.120 --> 02:28:25.080
aber das kann auch mit Pfeilsystem und so was. Allokierung soll nicht stimmen. Current Memory,

02:28:25.080 --> 02:28:34.040
Max Memory. Das haben wir ausprobiert. Das geht nicht, weil die VM immer das Maximum Memory

02:28:34.040 --> 02:28:55.680
reserviert. Es sei denn. Es sei denn. Guck mal, der checkt auch nicht, wenn es gelöscht wird.

02:28:55.680 --> 02:29:05.280
Seht ihr das? Na gut, das ist klar, warum das nicht funktioniert, weil. Ja, das funktioniert nicht,

02:29:05.280 --> 02:29:16.680
weil das Image immer gleich groß bleibt. Das Image, ich glaube nicht, dass das im Container geht.

02:29:16.680 --> 02:29:22.680
Das ist ja. Okay, das habe ich noch nie ausprobiert, ob man in einem Container einen Trim machen kann.

02:29:22.680 --> 02:29:31.160
Nicht im Container, in der VM. Ich glaube nicht, dass das funktioniert, aber guck mal mal.

02:29:31.160 --> 02:29:43.800
Ne, das Image geht nicht kleiner. Das müsste man mit QEMU, würde das funktionieren, könnte man die

02:29:43.800 --> 02:29:53.200
Datei wieder kleiner machen. Da gibt es ein Kommando für. Aber das shrinkt das Pfeil nicht

02:29:53.200 --> 02:30:03.160
mehr auf der Platte. Dafür, jetzt mal um zu zeigen, dafür unter Proxbox, also ob das mit QCOW 2 Image

02:30:03.160 --> 02:30:08.080
das geht, habe ich auch so meine Zweifel. Dafür seht ihr jetzt, man kann wieder das ganze Ding

02:30:08.080 --> 02:30:17.560
füllen. Er merkt da zwar nichts mehr von, aber ist wieder voll. Ja, ja, das funktioniert. Jetzt

02:30:17.560 --> 02:30:22.600
wird auch nichts mehr getrimmt. Na gut, da können wir tatsächlich noch mal kurz gucken,

02:30:22.600 --> 02:30:29.160
weil irgendjemand gemeint hat Memory. Vielleicht gibt es ja tatsächlich noch ein Memory. Na gut,

02:30:29.160 --> 02:30:41.320
Memory Toad. Ne, das ist was anderes. Memory, Memory, Soft Limit. Genau, das kannst du machen.

02:30:41.320 --> 02:30:48.120
Das kannst du, richtig. Da musst du aber die Tools dafür installiert haben, habe ich gar nicht.

02:30:48.120 --> 02:30:55.840
Kann man den Status von Running auf Connected stellen bei bestehender SSH-Verwendung? Leute,

02:30:55.840 --> 02:31:01.120
ihr habt High-IQ-Ideen. Ich bin mir nicht so sicher, ob man das umsetzen kann.

02:31:01.120 --> 02:31:12.640
Ja, ich müsste einen Test machen, ob der SSH-Port offen ist. Das würde funktionieren. Aber gute

02:31:13.640 --> 02:31:27.280
ein bisschen was zu tun. Running, Connected State. Das Tool müsste bei Cloud Images dabei sein.

02:31:27.280 --> 02:31:33.800
Bei Cloud Images bringt das nichts. Ich muss das auf meinem Host ausführen gegen das Image.

02:31:33.800 --> 02:31:47.120
FsDrim. Der gute Sido. FsDrim-VA. Hab ich doch schon. Evi-Platte kann man drin und so. Ne,

02:31:47.120 --> 02:31:56.920
das wird nicht funktionieren, weil das ist nicht der Disk Space in der VM. Der ist ja wieder

02:31:56.920 --> 02:32:11.080
freigegeben. Ist alles gut. Es ist der Disk Space von meinem Image auf dem Host. Das kann man

02:32:11.080 --> 02:32:15.760
aus der VM selbst nicht mal freigeben, glaube ich. Kurz gucken, ob man vielleicht tatsächlich was

02:32:15.760 --> 02:32:22.680
mit Memory noch hat. Memory Flex. Aber ich vermute auch nicht, dass das geht. Das könnte man höchstens

02:32:22.680 --> 02:32:31.360
machen, wenn man einen QEMU-Agent da drin hätte. Ach, so viel zum Thema QEMU-Agent. Den könnten

02:32:31.360 --> 02:32:37.440
wir eigentlich... Leute, das probieren wir heute noch mal aus. Wir könnten doch den QEMU-Agent

02:32:37.440 --> 02:32:47.080
über das Cloud-Init-File nachinstallieren lassen, weil wir wissen doch, worauf wir laufen. Ne,

02:32:47.080 --> 02:33:00.600
ich glaube, da ist standardmäßig... Nicht drauf. Ne. Absearch QEMU-Agent. Wie heißt denn das Ding?

02:33:00.600 --> 02:33:15.720
QEMU-Guest-Agent. QEMU-Guest-Agent. Den brauchen wir. Wobei, das ist doof, den zu installieren.

02:33:15.720 --> 02:33:27.080
Weil das unterscheidet sich zwischen... Ne, das will ich nicht. Das mache ich nicht. Das

02:33:27.080 --> 02:33:33.560
unterscheidet sich zwischen CentOS und zwischen... Das unterscheidet sich zwischen allen. Das ist

02:33:33.560 --> 02:33:40.360
das ist ziemlicher Sack. Ne, ne, ne, ne. Das ist... Na, vielleicht könnt ihr mal ins To Do schreiben.

02:34:04.560 --> 02:34:12.800
Naja, dann müsste man das Cloud-Image anhand der Distribution erweitern. Das ist ja durchaus

02:34:12.800 --> 02:34:19.520
denkbar, dass man das machen kann. Hi Max, darf ich doch mal fragen, warum du die Web-Klein-Klasse

02:34:19.520 --> 02:34:26.520
verwendest? Die Doku sagt, aber man soll HTTP-Klein nehmen. Das kann ich dir zeigen. Also das kann ich

02:34:26.520 --> 02:34:31.960
dir verraten, warum ich das verwende. Das ist ganz einfach. Ich verwende das und ich unterdrücke

02:34:31.960 --> 02:34:38.200
übrigens auch diese Warnung. Weil normalerweise ist das so, wenn man diese Warnung hier drin hat,

02:34:38.200 --> 02:34:44.720
dann sagt der Achtung Web-Klein ist deprecated. Das ist egal, ob das deprecated oder obsolet ist.

02:34:44.720 --> 02:34:50.280
Die werden das Ding nie, auch allein schon aus Grund der Rückwärtskompatibilität, nie aus dem

02:34:50.280 --> 02:34:56.720
Framework entfernen, Leute. Nie. Das wird für immer und ewig drin bleiben. Kann man die Films auch

02:34:56.720 --> 02:35:01.840
mit Dynamic Memory erstellen, wenn du mir sagst, wie man das theoretisch machen kann? Also ich

02:35:01.840 --> 02:35:07.040
weiß, man kann irgendwie Balloonsupport oder sowas einstellen, aber keine Ahnung, wie man das

02:35:07.040 --> 02:35:16.840
gescheit konfiguriert und was man da eintragen muss. Nächster Release entfernen. Nee, das werden

02:35:16.840 --> 02:35:34.600
die nie entfernen. Das werden die nie entfernen. Web-Klein remove.net. Für Dynamic Memory braucht

02:35:34.600 --> 02:35:43.480
man den Agent. Ja, stimmt, hast du recht. Nö. Das werden die nie entfernen. Ah ja, der Grund,

02:35:43.480 --> 02:35:46.720
warum ich's verwende, das hab ich ja noch gar nicht gezeigt. Der Grund, warum ich's verwende,

02:35:46.720 --> 02:35:54.480
ist folgendes. Normalerweise verwende ich auch immer HTTP-Kleint, aber in dem Fall ist es viel,

02:35:54.480 --> 02:36:04.360
viel einfacher, einen Download-Progress zu machen, damit als mit dem HTTP-Kleint. Mit dem HTTP-Kleint

02:36:04.360 --> 02:36:13.040
musst du einen eigenen Callback irgendwie beim Instanziieren übergeben und dich reinhängen in

02:36:13.040 --> 02:36:19.920
die Verbindung. Also einen Progress Bar zu machen mit dem HTTP-Kleint ist viel komplizierter als mit

02:36:19.920 --> 02:36:27.640
dem Web-Kleint. Deswegen hab ich einfach den Web-Kleint benutzt dafür. Chat-GPT regelt für

02:36:27.640 --> 02:36:45.280
Progress Bar. Okay, wenn Chat-GPT regelt, machen wir das doch mal. Chat-OpenAI. Okay. Chat,

02:36:45.280 --> 02:37:01.440
ich weiß, ihr versprecht, mir wegzugucken, aber... Enter your password. Okay, ich bin eingeloggt.

02:37:01.440 --> 02:37:21.080
Da sind wir wieder. Also, ähm... Ja...

02:37:21.080 --> 02:37:45.360
Was fragen wir denen denn jetzt? Okay. Ähm... Wie? Ich frage einfach wie. Wie ich sage. Wie?

02:37:45.360 --> 02:38:07.000
Wie mache ich mit dem C-Sharp-HTTP-Kleint eine Progress Bar? Jetzt bin ich mal gespannt. Um

02:38:08.000 --> 02:38:12.880
eine Progress Bar... Können sie folgende Schritt... Erstellen sie den... Ja. Weil... Chat-GPT. So weit

02:38:12.880 --> 02:38:22.920
komm ich auch noch. Fügen sie eine Event-Hentel. Chat-GPT jebaitet uns. Jebaitet. Jebaitet. Das

02:38:22.920 --> 02:38:38.480
lügt einfach. Es lügt. Das gibt es nicht. Das gibt es nicht. Guck, ich beweise euch,

02:38:38.480 --> 02:38:53.280
dass es das nicht gibt. New-HTTP-Kleint-Progress. Progress. Gibt es nicht. Jebaitet. Ist einfach

02:38:53.280 --> 02:39:01.920
Müll, was da steht. Okay, das schreiben wir jetzt auch. Das schreiben wir jetzt auch.

02:39:01.920 --> 02:39:22.360
HTTP-Kleint hat keine... Brokers... Hat kein... Brokers-Changed-Event. Es denkt. Sie haben

02:39:22.360 --> 02:39:42.800
Recht. Aha. Okay. Was? Button-Click? Äh.

02:39:53.240 --> 02:40:01.400
Das funktioniert. Okay. Ja. Das würde funktionieren. Das würde funktionieren. Tatsächlich. Das ist

02:40:01.400 --> 02:40:11.800
richtig. Ich glaube. Ich glaube, das würde funktionieren. Moment. Was ist denn... Funktioniert

02:40:11.800 --> 02:40:36.280
das wirklich so? Was ist denn Progress? Funktioniert dieser Aufruf so? Mal gucken.

02:40:41.800 --> 02:40:58.760
Wo kommt der File-Stream her? Den File-Stream gibt es einfach nirgendwo.

02:40:58.760 --> 02:41:16.320
Und vor allem, was soll bitte schön Progress sein? Das ist ein Cancellation-Talk. Das ergibt

02:41:16.320 --> 02:41:22.560
auch keinen Sinn, was Chat-GPT hier zusammenfabriziert hat. Das funktioniert auch nicht. Von der Logik her

02:41:22.560 --> 02:41:42.960
muss man sagen. Man könnte eventuell mit einem Stream-Reader oder so was bauen für eine Progress,

02:41:42.960 --> 02:41:54.160
irgendwie Stream-Reader, Response-Stream und dann irgendwie in der Schleife. Das funktioniert

02:41:54.160 --> 02:42:06.560
so nicht. Das müsste man hier oben... Und hier drin könnte man jetzt quasi...

02:42:12.960 --> 02:42:22.720
Man müsste eigentlich Bites mit Buffers lesen. Das würde dann funktionieren und dann müsste man

02:42:22.720 --> 02:42:30.200
das in den Progress-Bar rein. Von der Logik her ist es grundsätzlich gar nicht so verkehrt.

02:42:30.200 --> 02:42:39.320
Jetzt bräuchte man natürlich Chat-GPT 4-Abo, um es auszuprobieren. Wir fragen mal Stack-Overflow.

02:42:39.320 --> 02:42:51.160
HTTP-Client, Progress, C-Sharp. Können wir uns einen Gist angucken?

02:42:51.160 --> 02:43:11.560
New HTTP-Client, Progress.

02:43:21.160 --> 02:43:35.720
Achso, das sind die Extension-Methods. Alter, ja, ist klar. Ich kann Webclient verwenden für

02:43:35.720 --> 02:43:40.800
eine Progress-Sache oder mir so ein Geschiss dahin bauen. Ja, alles klar. Weiß klar, was ich verwende.

02:43:52.160 --> 02:44:00.360
Ey, die sind noch nicht mal ganz dicht. Er muss halt echt sagen, es ist ein bisschen Fail. Okay,

02:44:00.360 --> 02:44:09.120
ganz im Ernst, ich würde wahrscheinlich E-Flurl verwenden, wenn ich mehr Requests mache,

02:44:09.120 --> 02:44:15.560
wobei ich selbst da nicht sicher bin, wie man gescheit... Es hat, glaube ich, ein Progress-Event.

02:44:21.160 --> 02:44:29.360
Ach, keine Ahnung. Also, deswegen benutze ich den Webclient für solche Sachen tatsächlich ganz

02:44:29.360 --> 02:44:38.240
gerne. Manchmal ist, nur weil das ein alter Teil des Frameworks ist, das nicht unbedingt schlecht.

02:44:38.240 --> 02:44:45.400
Ja, oder eine Fake-Progress-Bar. Ja, das könnte man natürlich auch machen. Eine Fake-Progress-Bar.

02:44:45.520 --> 02:44:55.560
Aber man muss ja sagen, meine Progress-Bar kommt tatsächlich relativ gut hin. Guckt euch das mal

02:44:55.560 --> 02:45:10.720
an. Auch mit der Zeit, die sie ausrechnet und 100 Prozent, ist schon nicht verkehrt. Nun gut. Wo

02:45:10.760 --> 02:45:16.960
sind wir denn jetzt stehen geblieben, Chat? Habt ihr irgendeinen... Für meinen Boomer hierhin,

02:45:16.960 --> 02:45:27.960
habt ihr irgendwie da was? Wir sind stehen geblieben bei... Ah, Dick's Discs. Ich wollte

02:45:27.960 --> 02:45:39.760
noch kurz gucken, ob es Memory gibt. Aber gerade dabei sind History. Letzte Stunde weg. Ich wollte

02:45:39.760 --> 02:45:59.880
noch gucken, ob es was mit Memory gibt. Wird Memory... Memory. Memory-Parameter, Memory-Flex.

02:45:59.880 --> 02:46:16.000
Beardomain-Memory-Stats-Struct. Das klingt ja schon mal high IQ. Was? Int. Unsigned-Long-Value.

02:46:16.000 --> 02:46:37.600
What? Okay, das ist tatsächlich das, was wir haben wollen.

02:46:37.600 --> 02:46:50.200
Beardomain-Memory-Stats-Nummer. Okay, das können wir nicht verwenden. Das ist ein Makro im

02:46:50.200 --> 02:47:00.280
Header-File definiert, oder? Nee. Nee, doch nicht. Was? What? Legen die mal durch. Last ist Nummer?

02:47:00.280 --> 02:47:08.280
Ist... Was? Wie? Also damit könnten wir das irgendwie rauskriegen. Aber da habe ich ehrlich

02:47:08.280 --> 02:47:19.960
gesagt gerade keinen Bock drauf. Also wir müssten für das Live-Memory müssen wir abfragen. Memory

02:47:19.960 --> 02:47:35.880
available. Und Memory... Nee. Unused. Usable. Available. Ja, das könnte man abfragen. Okay,

02:47:35.880 --> 02:47:41.280
ich gucke mir nur mal kurz den Funktionsaufruf an, ob ich da theoretisch Bock habe, das überhaupt

02:47:41.280 --> 02:48:00.360
Und wo übergibt man das jetzt? Ach hier. Nee. Okay, wir haben den I-Namen, aber wir haben keine

02:48:00.360 --> 02:48:10.040
Funktion, wo man ihn benutzt. Wie waren wir deine 4090 im Idle? Wo sehe ich denn das?

02:48:10.040 --> 02:48:25.960
Overlay-NVIDIA, kann ich gerade nicht drauf zugreifen. Task-Manager? Ich kann ja das

02:48:25.960 --> 02:48:42.520
mittlerweile. Nice. Performance wahrscheinlich, ja? 42 Grad. Also recht kühl würde ich sagen.

02:48:42.520 --> 02:48:59.080
Mad Eagle. Warum? Ist das irgendein Meme, was ich nicht verstehe oder? Wofür ist das in Hex-Code

02:48:59.080 --> 02:49:06.520
angegeben? Das ist, der linke Wert ist Dezimal und der rechte ist in Hex angegeben. Ist das quasi

02:49:06.520 --> 02:49:14.760
das linke in Dezimal, was dem in Hex entsprechen würde? Das machen die wahrscheinlich nur,

02:49:14.760 --> 02:49:19.600
dass man, falls man das irgendwie braucht, in Hex wäre das einfacher, dass man nicht nachgucken

02:49:19.600 --> 02:49:33.360
muss oder so. Stat-Tag. Also es gibt keine Funktion, wo ich diesen Parameter hier irgendwie

02:49:33.360 --> 02:49:43.000
übergeben muss. Also es ist schön, dass es einen I-Namen dafür gibt, aber es gibt keine Funktion,

02:49:43.000 --> 02:49:51.240
die das als Parameter nimmt. Das heißt, da sind wir out of luck und ich vermute auch mal,

02:49:51.240 --> 02:49:59.720
dass das nur geht, wenn man einen Guest-Agent installiert hat. Gehe ich mal einfach von aus.

02:49:59.720 --> 02:50:08.920
Deswegen werden wir es jetzt einfach gut sein lassen. Und das, und das nicht machen. Es hat

02:50:08.920 --> 02:50:13.960
ja auch keinen Sinn. So ist doch vollkommen in Ordnung.

02:50:13.960 --> 02:50:34.480
Ja, ähm, das, hoch, nein, cancel. Vielleicht soll ich jetzt das doch noch kurz fixen,

02:50:34.480 --> 02:50:49.680
weil die größten Angaben nicht stimmen. Gehen wir mal in den Default. Und eigentlich wollen wir

02:50:49.680 --> 02:51:03.920
hier, ist es, ist es Kibi oder Kibi? Kibi, Kibi ist es. List. So, wenn wir jetzt noch vor einmal

02:51:03.920 --> 02:51:18.360
stellen, dann sollte das mit dem Memory eigentlich stimmen. Run, probieren wir mal kurz aus. Run,

02:51:18.360 --> 02:51:43.840
blub. Besse. Was? Ah nee, run. Ja, das sieht schon besser aus. 262 MB. Und weil es halt nicht MB

02:51:43.840 --> 02:51:57.360
sind, das ist halt tail. Es ist Mieb, ist es Mieb. Also es ist eigentlich nicht MB, sondern Mieb und

02:51:57.360 --> 02:52:06.720
Gib. Wenn ich es jetzt ausprobiere, List, dann sollte die Anzeige stimmen. Zumindest bei der letzten.

02:52:06.720 --> 02:52:19.600
Ich hasse einheitengerechten Kram. Was ist das für eine Kacke immer? Was soll das Scheiß?

02:52:19.600 --> 02:52:30.840
Hätte man nicht einfach bei 1024 bleiben können für immer? Da gibt es keine Probleme.

02:52:30.840 --> 02:52:41.000
Es ist eigentlich falsch, aber es ist mir egal, ob es falsch ist, was da steht. Wen juckt es?

02:52:41.000 --> 02:52:50.280
Mein B war klein. Oh, wirklich? Ja dann, dann lag es, dann habe ich es doch richtig gemacht.

02:52:50.280 --> 02:53:10.280
Mein B war nicht klein. Wo soll mein B klein gewesen sein? Nee, da war nichts klein. Das I war klein.

02:53:10.280 --> 02:53:36.360
Nee, nee. Kein Plan ist da. Jetzt bin ich zu doof. Das bleibt jetzt alles. Aber

02:53:36.360 --> 02:53:44.120
das war trotzdem der gleiche Wert. Egal, weg. Hör mal auf, ich habe jetzt keinen Bock auf Einheiten.

02:53:44.120 --> 02:53:53.480
Du hast vom Kilo Bites und ich habe ich, habe ich das richtig. Moment, das ist ja auch richtig,

02:53:53.480 --> 02:53:59.720
das ist auch richtig. Das hier ist ja auch in Bites, aber das Memory, das ist auch in Kilo Bites.

02:53:59.720 --> 02:54:21.800
Moment, ist es in Kilo Bites? Alter. Mann, ist das, ist das in Kilo Bites oder ist das in?

02:54:29.840 --> 02:54:38.400
Okay. Aber die Bites müssten stimmen und die stimmen ja auch schon nicht.

02:54:38.400 --> 02:55:00.840
Wobei, doch, doch, es stimmt doch, es stimmt doch, es stimmt doch. Ist alles gut. Nee,

02:55:00.840 --> 02:55:08.280
es ist alles richtig. Es ist alles korrekt. Es ist alles richtig jetzt. Ja, ja. Es ist gut,

02:55:08.280 --> 02:55:18.600
es ist gut, es ist alles richtig, alles richtig. So, so, lib wird. Das heißt im Endeffekt,

02:55:18.600 --> 02:55:32.360
ihr habt doch tatsächlich in eurer Doku gesagt, dass dieser Wert in Bites ist und es sind nicht

02:55:32.360 --> 02:55:45.760
Kilo Bites, es sind Kibi Bites. Lib wird, Anzeige ist raus. Falsche Infos. Es ist nicht in Kilo Bites,

02:55:45.760 --> 02:55:54.640
es ist in Kibi Bites. Ich weiß doch nicht mal, wie der Scheiß heißt überhaupt richtig. So geht

02:55:54.640 --> 02:56:07.760
es ja nicht. Einfach, einfach falsche Angaben in der Doku drinne hier. Könnte man das Internet

02:56:07.760 --> 02:56:17.600
in Nanometer umkundigen? Nee, nur Fußballfelder. So, aber jetzt ist die Einheit wenigstens richtig.

02:56:17.600 --> 02:56:33.840
Okay Leute, das reicht für heute. Genug, ich kann mich auch nicht mehr konzentrieren.

02:56:37.760 --> 02:56:55.080
Immer die ersten beiden Buchstaben wie immer und dann. Hä? Ach so, das heißt,

02:56:55.080 --> 02:57:19.320
okay, das ergibt natürlich Sinn. Das ist dann ein Kibi und ein MiBi. Gibt's auch

02:57:19.320 --> 02:57:26.000
irgendeine gute Videoempfehlung auf YouTube für eine halbe Stunde? Diese fünf Tools? Nee,

02:57:26.000 --> 02:57:41.280
jetzt nicht. Jetzt. Das teuerste Gehäuse.

02:57:49.320 --> 02:58:16.320
Was für ein Bademail. Ach guck mal, ich kriege meine eigenen Videos empfohlen. Das ist sehr nice.

02:58:16.320 --> 02:58:27.560
Erst mal den Viewtime boosten. YouTube hat dir gerade das hier empfohlen. Okay, zeig mal her.

02:58:27.560 --> 02:58:55.320
Why 80% of New Zealand is empty? 23 Minuten über Neuseeland. Okay, YouTube, du hast drei

02:58:55.320 --> 02:59:04.000
Refresh Zeit, mir was zu empfehlen, was ich jetzt gucken will. Das ist mit zu HRIQ jetzt.

02:59:04.000 --> 02:59:20.240
Exzellent, ich gucke jetzt einfach ein eigenes Video von mir. Das Sound ist kaputt. Oder habe

02:59:20.240 --> 02:59:36.760
ich mich gemutet. Ich habe mich tatsächlich gemutet. Ansible in 100 Sekunden. Ansible. Und immer

02:59:36.760 --> 02:59:41.200
ganz cool aussprechen, Leute. Wichtig. Nicht, dass ihr irgendwie auf die Idee kommt, dass nicht

02:59:41.200 --> 03:00:04.600
Ansible oder JavaScript auszuspringen. Okay, auf geht's, Firechip. Wer auch sonst. Und Red Hat hat

03:00:04.600 --> 03:00:11.960
ja teilweise wieder monetarisiert, as fuck. Wobei insgesamt ist es immer noch, zumindest aus meiner

03:00:11.960 --> 03:00:24.800
Sicht, das beste Tool, in klassischer Welt Server zu konfigurieren. Puppet ist ja relativ dead,

03:00:24.800 --> 03:00:31.120
zumindest wenn es darum geht, so der Hype-Faktor. Puppet war ein bisschen früher als Ansible und

03:00:31.120 --> 03:00:35.360
auch eine Zeit lang recht beliebt, aber trotzdem. Und auch im Enterprise-Umfeld immer noch bei manchen

03:00:35.360 --> 03:00:41.320
im Einsatz. Puppet ist leider ein bisschen dead die letzten Jahre über. Die haben das auch irgendwie

03:00:41.320 --> 03:00:48.960
nicht gut gemanagt. Von dem Hersteller hast du kaum was wirklich gehört. Man muss aber sagen,

03:00:48.960 --> 03:00:56.000
Puppet hat ein paar coole Sachen, die Ansible nicht hat. Zum Beispiel ordentlichen Noob-Run,

03:00:56.000 --> 03:01:01.880
wo man gucken kann, was passieren würde, wenn man das ausführt. Das geht bei Ansible zwar in der

03:01:01.880 --> 03:01:08.900
Theorie auch, aber das müssen die jeweiligen Module unterstützen und es stimmt auch nicht so

03:01:08.900 --> 03:01:18.240
richtig. Also zu gucken, was würde ein Run ausführen, ist in Puppet tatsächlich cooler. Was

03:01:18.240 --> 03:01:30.240
Trimoji ist dead? Wie jetzt? Wer sagt das? GitHub, Trimoji, Trimoji ist beste. Trimoji,

03:01:30.240 --> 03:01:42.720
warum ist das dead? Trimoji for everyone. Das ist nicht dead. Also sieht nicht dead aus. Wie

03:01:42.720 --> 03:01:53.840
kommst du darauf, dass das dead ist? Okay, das ist natürlich doof, wenn die da nichts

03:01:53.840 --> 03:02:02.000
aktualisieren. Aber Twitter selbst hat das, oder? Die haben einfach nur keinen Bock ihr Projekt zu

03:02:02.000 --> 03:02:06.000
aktualisieren. Okay, gucken wir uns das Video an.

03:02:32.000 --> 03:02:38.000
Man kann auch Playbooks von Hand ausführen.

03:03:02.000 --> 03:03:16.840
Dafür ist es tatsächlich ganz sinnig. Man könnte zwar gut den Server mit Terraform anlegen,

03:03:16.840 --> 03:03:22.760
aber den Server an sich zu konfigurieren, wenn das ein System ist, das länger da bleiben soll,

03:03:22.760 --> 03:03:28.520
ist tatsächlich Terraform nicht das Richtige. Also wenn es über einen Cloud-Init-Skript,

03:03:28.520 --> 03:03:32.720
was ausgeführt werden soll, rausgeht, ist Ansible nach wie vor das Tool der Wahl.

03:03:58.520 --> 03:04:04.840
Okay, Ansible Vault habe ich noch nie benutzt. Braucht man aber auch nicht,

03:04:04.840 --> 03:04:10.840
wenn alle Passwörter einfach 1, 2, 3, 4, 5, 6 sind. Ich benutze nur best practice Passwörter.

03:04:28.520 --> 03:04:58.080
Das würde ich tatsächlich lieber mit Terraform machen an der Stelle. Was ich mit Ansible machen

03:04:58.080 --> 03:05:03.240
würde, ist die angelegte VM konfigurieren, falls die das nötig hat.

03:05:28.640 --> 03:05:32.320
Es ist okay, das was funktioniert bei euch. Hat keinen Sinn,

03:05:32.320 --> 03:05:38.240
irgendwas anderes einzuführen, nur um des Einführungswillens.

03:05:44.920 --> 03:05:52.960
Guck mal, YouTube sagt, meine Videos sind richtig nice. Das macht eigentlich mein aktuelles Video.

03:05:52.960 --> 03:05:57.120
Wie performt denn mein aktuelles Video? Leute, ich musste leider ein eigenes Thumbnail machen,

03:05:57.120 --> 03:05:59.840
weil das Video sehr schnell entstanden ist. Sonst hätte ich auch wieder so ein cooles

03:05:59.840 --> 03:06:05.200
Kek-Thumbnail gehabt. Die Katze auf dem Thumbnail ist tatsächlich AI-generated.

03:06:05.200 --> 03:06:12.760
Sie hat nicht wirklich was mit dem Video zu tun, das gebe ich zu. Aber ich fand das tatsächlich

03:06:12.760 --> 03:06:22.080
mal ein halbwegs gut gelungenes AI-generated Bild. Ich habe einige gegeben. Katze, traurige Katze

03:06:22.160 --> 03:06:24.600
mit großen Augen sitzt vor Laptop.

03:06:30.240 --> 03:06:40.080
So, dann kam sowas raus. OBS und YouTube hat jetzt AV1. Solange das Twitch nicht hat,

03:06:40.080 --> 03:06:47.440
interessiert es mich nicht. Hi Max, was geht? Oh, wenig Comments, wenig Views. Vielleicht hätte

03:06:47.440 --> 03:06:52.280
ich doch ein gescheites Thumbnail reinmachen sollen. Das war auch ein doofes Upload-Zeitpunkt,

03:06:52.280 --> 03:06:56.240
mal ganz davon abgesehen. So, Pille wird das Thema jetzt auch nicht interessieren.

03:07:01.640 --> 03:07:16.280
Vielleicht bin ich es ja auch. Vielleicht bin ich es ja. Wir gucken jetzt nicht mein Video an.

03:07:18.440 --> 03:07:27.520
Kubernetes plus OpenAI? K8S Jeep? Nein, oder? Was soll denn das geben, wenn es fertig ist?

03:07:27.520 --> 03:07:39.880
Moment, GitHub Link? Also nur weil was geht, heißt es nicht zwangsläufig, dass es eine gute Idee ist,

03:07:39.880 --> 03:07:48.760
das zu machen. Giving Kubernetes SIE. Übrigens, wenn ich weiß, für was SIE steht, das ist coole

03:07:48.760 --> 03:08:04.760
Abkürzung für coole Leute. Das ist Site Reliability Engineering. Also wie zuverlässig deine

03:08:04.760 --> 03:08:13.200
Infrastruktur läuft sozusagen. Oh guck mal, der verwendet auch Gorlisa.

03:08:13.200 --> 03:08:21.040
Dir wurde das Video nicht angezeigt. Ja, das interessiert dich nicht.

03:08:21.040 --> 03:08:46.400
Okay, K8S GPD. Ich habe keine Ahnung, was das Wort bedeutet und was macht es?

03:08:47.400 --> 03:08:55.000
Was macht ich? Ich habe keine Ahnung, was das macht. Okay, das analysiert mein Kubernetes

03:08:55.000 --> 03:09:02.120
Klasse und sagt mir, was daran schrottig konfiguriert ist, oder? Weißt du, was das Gorlisa heißt?

03:09:02.120 --> 03:09:12.560
Error Message? Ja. Soll ich das jetzt so schnell lesen, oder? Okay, wir müssen gleich Pause drücken.

03:09:12.560 --> 03:09:30.640
Please noch kürzer. Ach so, Moment, es geht immer auf Start, wenn man Pause drückt. Okay,

03:09:30.640 --> 03:09:37.560
das ist hängen geblieben. Es analysiert dein Kubernetes Cluster und schickt erst mal alle

03:09:37.560 --> 03:09:42.200
schönen Infos aus deinem Kubernetes Cluster an Microsoft. Sehr gute Idee, sehr, sehr gute

03:09:42.200 --> 03:09:53.840
Idee. Was es nicht alles gibt. PyTorch. Ja, nee, kein PyTorch. Nur weil was geht, es war klar,

03:09:53.840 --> 03:10:02.160
dass sich irgendjemand musste es machen. Das war so klar. Irgendjemand musste es machen. Ich meine,

03:10:02.160 --> 03:10:08.800
es gibt riesen Chat-GPT-Hype und Kubernetes ist auch voll angesagt. Dass das jemand verbindet,

03:10:08.800 --> 03:10:22.640
wundert mich nicht. I tried 200 AI Modules. These are the best. Okay, das ist ein Video,

03:10:22.640 --> 03:10:27.840
das führen wir uns tatsächlich jetzt noch zu Gemüt. Okay, 200 besten AI Tools.

03:10:32.640 --> 03:10:39.240
Chat-GPT fast nicht mehr. Ich habe einen riesigen Deep-Dive gemacht und ich möchte die

03:10:39.240 --> 03:10:43.840
größten, die krassesten und die wichtigsten zeigen. Ich möchte mit ein paar anfangen, die einfach

03:10:43.840 --> 03:10:47.880
wunderschön sind. Einige sind in den frühen Stages, aber sie geben euch einen Blick auf was zu kommen ist.

03:10:47.880 --> 03:10:52.240
Ich werde diese schnell umfassen, dann gehe ich in die wirklich nützlichen. NVIDIA. Sie haben

03:10:52.240 --> 03:10:56.840
ein paar tolle AI-Produkte. Eine, die wirklich lustig ist, ist Canvas. Ihr baut einfach

03:10:56.840 --> 03:10:59.920
basic Formen und Linien und wählt von ihrem Palett Material und kreiert

03:10:59.920 --> 03:11:12.640
photorealistische Landscapes. Das ist schon cool, oder? Chat, das ist... Das ist tatsächlich cool,

03:11:12.640 --> 03:11:29.520
oder? Das sind laute. Das sieht auch cursed aus. Das sieht mega cursed aus. Wenn ihr euch das

03:11:29.520 --> 03:11:32.560
angekundigt habt, das sieht mega cursed aus mit den Augen. Was?

03:12:00.160 --> 03:12:00.520
Und nun?

03:12:00.520 --> 03:12:11.680
Metaverse, ja genau. Das würde dazu passen, dass sie den Shit auch noch AI generieren lassen.

03:12:11.680 --> 03:12:17.040
Das will jetzt schon keiner verwenden. Dann hast du jedenfalls Sinnloses mit seelenloser AI generierter

03:12:17.040 --> 03:12:18.960
Welt. Jawoll, das brauchen wir.

03:12:30.240 --> 03:12:38.040
Google's Imagine sieht absolut verrückt aus. Die beste Option, die ich je gesehen habe, ist Kyber.

03:12:38.040 --> 03:12:41.680
Du kannst einfach einen Prompter typen, oder eine Image und einen Prompter aufladen. Dann machen wir

03:12:41.680 --> 03:12:45.920
diese coolen Videos. Es gibt Raum für Verbesserungen, aber du kannst wirklich coole Sachen generieren. Du kannst

03:12:45.920 --> 03:12:50.360
sogar eine Song aufladen und deinen Stil definieren, um ein Musikvideo zu kreieren. Linkin Park hat es

03:12:50.360 --> 03:12:55.120
benutzt, um ein Musikvideo mit 22 Millionen Views zu kreieren. Ein anderes ist Leopix, das Fotos

03:12:55.120 --> 03:12:58.760
in Animatoren verwendet. Es verwendet Depth und macht sie in 3D aussehen. Dann kannst du...

03:12:58.760 --> 03:13:07.320
Hey, das ist für Background-Videos, glaube ich, was richtig Cooles. Also sowas hier. Wenn du

03:13:07.320 --> 03:13:11.880
wirklich schon ein paar Bilder hast und du willst halt, dass sich ein bisschen was bewegt, weil die

03:13:11.880 --> 03:13:16.400
Leute sonst hibbelig werden und abschalten. ... die Angle, die Geschwindigkeit und der Animationstil.

03:13:16.400 --> 03:13:19.640
Das sieht toll aus und ist frei zu verwenden, aber Google sieht eigentlich ganz gut aus.

03:13:19.640 --> 03:13:20.520
Das ist eigentlich ganz nice.

03:13:20.640 --> 03:13:27.720
This is Kevin from the future. As I was editing this video, Runway ML announced their text to be in the software and it looks incredible.

03:13:27.720 --> 03:13:32.280
I'll be talking more about them later in the video editing section, but this is from the trailer they

03:13:32.280 --> 03:13:39.000
just released and it looks as good or better than Google's. Now we'll dive into the more practical.

03:13:39.000 --> 03:13:44.200
Here's one that really demonstrates how much AI is already forcing society to change. It's called

03:13:44.200 --> 03:13:49.240
Cactus and it can help with basically all of your screen work. The AI writer can deliver essays in

03:13:49.240 --> 03:13:53.880
minutes. It can improve content you've already written, expand sentences, fix grammar. It can format for

03:13:53.880 --> 03:13:59.320
AP style and create citations. There's a similarly powerful section dedicated to STEM fields, another

03:13:59.320 --> 03:14:03.800
for coding. It does have some more wholesome uses like for studying, but for those that are using this

03:14:03.800 --> 03:14:07.880
to write their essays, there are already AI detectors out there, but they're really easy

03:14:07.880 --> 03:14:11.880
to work around. Now it doesn't matter if you think this is right or wrong, kids are already doing this.

03:14:11.880 --> 03:14:17.560
School is going to have to adapt to the times, not the other way around.

03:14:17.640 --> 03:14:19.880
Correct. Da habe ich ihm recht.

03:14:36.680 --> 03:14:38.680
Okay, aber du weißt nie, ob du stimmt, was da draufsteht.

03:14:39.160 --> 03:14:43.400
Du kannst diese dann in Anki retten und ihr Spacerepetitionssystem verwenden, um die

03:14:43.400 --> 03:14:46.200
Vergissenskurve zu zerspringen und die Information zu retten.

03:14:49.320 --> 03:14:52.760
Ich empfehle dir das sehr und es ist eine freie Extension. Okay, wir machen ein paar

03:14:52.760 --> 03:14:57.400
schreckliche Videos. Rewind ist einfach aus einem Black-Mirror-Episode. Unsere Vision ist,

03:14:57.400 --> 03:15:02.600
Menschen perfekte Erinnerungen zu geben. Das ist nur der erste Schritt. Danke, dass du Rewind versucht hast.

03:15:02.600 --> 03:15:06.280
Sie nennen es den Search-Engine für dein Leben. Es erinnert dich an alles, was du gesehen,

03:15:06.280 --> 03:15:09.080
gesagt oder gehört hast. Es sagt, sie benutzen eine Mind-Boggling-Kompression,

03:15:09.080 --> 03:15:11.240
damit es nicht so viel Platz auf deinem Computer nimmt.

03:15:36.280 --> 03:15:49.560
Es nutzt Facial Recognition, um jede Foto von dir auf der Internet zu finden. Du musst dir

03:15:49.560 --> 03:15:52.920
die Ergebnisse bezahlen und es sucht keine Social-Media-Sites, aber du kannst herausfinden,

03:15:52.920 --> 03:15:57.000
ob deine Fotos woanders verwendet werden. Deep Nostalgia ist wirklich nur seltsam für mich,

03:15:57.000 --> 03:16:01.480
aber es könnte ein paar coole Nutzungsfälle haben. Es gibt Animation für Faces in Fotos und der

03:16:01.480 --> 03:16:06.120
Ergebnis ist unabhängig. Es ist nicht so weit in der Zukunft, wo du ein Foto uploaden kannst

03:16:06.120 --> 03:16:11.640
und es wird in einem Video mit vollen Dreidimensionen gedreht und realistisch aussehen.

03:16:11.640 --> 03:16:16.040
Einige der Deep Fake-Technologien sind bereits sehr gut. DID lässt dich einen Avatar wählen,

03:16:16.040 --> 03:16:29.000
um zu visualisieren und direkt zum Chat-GPT zu sprechen. Das hört mich jetzt voll motiviert.

03:16:29.000 --> 03:16:32.200
Okay, das ist genug von diesen. Es gibt ein paar coole Video-Edit-Tools,

03:16:32.840 --> 03:16:36.920
RUNWAYML hat die größte Nutzung von Tools mit einigen sehr unieke Features.

03:16:36.920 --> 03:16:40.360
Mit Text-Color-Grade kannst du einfach alles schreiben, was du willst, um deine Szene zu sehen,

03:16:40.360 --> 03:16:44.680
und es wird die Farbe für dich verändern. Und die super-Slow-Mo-Feature ist großartig. Du kannst

03:16:44.680 --> 03:16:49.320
irgendein Video, egal welches Frame-Rate, in eine leichte Slow-Motion machen. Es wird AI benutzen,

03:16:49.320 --> 03:16:54.440
um die Missing-Frames zu generieren. Oh, das ist toll. Das ist natürlich richtig toll.

03:16:55.880 --> 03:17:00.840
Es gibt auch viele Image-Tools, wie Expanding-Images, mit Text-Prompten,

03:17:00.840 --> 03:17:05.000
Colorizing, Black-and-White-Images, Convert-Low-Resolution-Fotos-to-High-Resolution.

03:17:05.320 --> 03:17:07.640
Boah, das ist ja cool.

03:17:10.360 --> 03:17:15.160
Wenn man ein Foto hat oder wenn man ein Bild im falschen Seitenformat hat und man braucht es

03:17:15.160 --> 03:17:22.920
für ein Thumbnail, dann kann man es sich einfach erweitern lassen. Ja, das ist ja mega 5-Head.

03:17:26.120 --> 03:17:26.920
Das ist ja cool.

03:17:35.000 --> 03:17:47.880
Okay, welcher Style soll das bitte schön sein?

03:17:47.880 --> 03:17:53.880
Außer, dass es sehr MorkaW-mäßig aussieht.

03:17:53.880 --> 03:18:03.480
Das kosten nur die meisten, die haben Free-Tiers. Ich habe auch nicht aufgepasst.

03:18:05.480 --> 03:18:22.120
Das ist schon krass, oder? Was du da machen kannst, das ist schon heftig.

03:18:22.600 --> 03:18:25.400
Wenn du in die Vergangenheit gesehen hast, wie man das in der Vergangenheit gemacht hat,

03:18:25.400 --> 03:18:29.240
ist das ein grosser Schritt weiter. Es hat auch die Möglichkeit, Fotos zu uploaden.

03:18:52.120 --> 03:19:03.240
Ja, das kenne ich.

03:19:03.240 --> 03:19:19.240
Ja, nur dass ich quasi, ich habe zwar ein Office-Trad 65, aber nur dass ich es so ungern benutze.

03:19:22.120 --> 03:19:34.840
Das ist doch so, Chat. Für mich ist das in dem Fall so nützlich für jemand anderes.

03:19:52.120 --> 03:20:12.840
Ja, und alles die Frage, ob dann auch das Originale wieder rauskommt. Eher nicht.

03:20:22.840 --> 03:20:47.560
Ja, das auf jeden Fall. Also es wird jetzt deutlich mehr Apps Einzug erhalten. Gut,

03:20:47.640 --> 03:20:53.000
in Thunderbird wahrscheinlich nie direkt, weil die Thunderbird-Entwicklung lame als fuck ist,

03:20:53.000 --> 03:21:00.280
aber man kann ja auch ihren Plugin nehmen. Sehe ich genauso, vieles ist mega überhyped und was ich

03:21:00.280 --> 03:21:05.960
halt ein bisschen doof finde, ist, dass es so oft das gleiche ist, wenn du Video-Content dazu siehst.

03:21:05.960 --> 03:21:13.400
Aber es sind schon manche Sachen, die sind wirklich Hammer. Ich hätte sie doch für unmöglich gehalten

03:21:13.960 --> 03:21:40.920
oder vor dem Jahr teilweise. Ah ja, exakt das wollte ich malen. Ja, so sieht es aus. Cool. Und

03:21:40.920 --> 03:21:50.920
das macht ja den Küchendesigner von einem der letzten Videos überflüssig. Das ist auch so

03:21:50.920 --> 03:22:02.040
ein typisches Kokona Grundstück, oder? Einfach mal keine Tür und kein Eingang in Garten.

03:22:10.920 --> 03:22:22.920
Okay, also wir hatten es ja heute schon wieder im Stream, das Chat-GPT sich einfach shit ausdenkt.

03:22:22.920 --> 03:22:30.320
Ob ich damit vor Gericht gehen würde zum aktuellen Zeitpunkt? Noch nicht, aber warte mal ein paar

03:22:30.320 --> 03:22:31.240
Jahre vielleicht schon.

03:22:40.920 --> 03:22:53.000
Boah, das ist ja cool. Da kann man den Hintergrundsound zünden, passend zu, wie so der

03:22:53.000 --> 03:22:59.400
Spannungsbogen, wie der im Video verläuft. Das ist cool, das ist wirklich sehr hilfreich.

03:22:59.400 --> 03:23:08.200
Das ist toll, das ist cool. Das ist reich, das ist reich.

03:23:29.400 --> 03:23:46.200
Da habe ich schon ein paar Videos zugesehen, das ist erstaunlich akkurat, die Stimmwiedergabe.

03:23:59.400 --> 03:24:18.400
Das ist auch krass, das Zeug. Ich bin ja schon eine ganze Weile da auf dem Discord. Ich meine, man

03:24:18.400 --> 03:24:24.400
braucht, man kann glaube ich mittlerweile auch den Bot nicht selbst holen, aber ich bin ja schon eine ganze

03:24:24.400 --> 03:24:29.400
Weile auf dem Discord, guck mir da manche Creations von an. Das ist schon heftig.

03:24:55.400 --> 03:24:58.400
Das stimmt, das wird eh passieren.

03:25:19.400 --> 03:25:21.400
Es wird Zeit, dass da vor MChamp ein neues Logo bekommt.

03:25:24.400 --> 03:25:26.400
Das ist toll, das ist toll.

03:25:54.400 --> 03:25:56.400
Das ging mir jetzt zu schnell.

03:26:24.400 --> 03:26:31.400
Luca hat irgendwie ein bisschen was von Booba.

03:26:46.400 --> 03:26:49.400
Ja, das interessiert mich mal so gar nicht, was die Customer needen.

03:26:54.400 --> 03:27:09.400
Das ist Müll, das habe ich ausprobiert. Das ist komplett, wer das verwendet, keine Ahnung.

03:27:09.400 --> 03:27:18.400
Also wirklich, das war gar nichts.

03:27:18.400 --> 03:27:20.400
Das haben wir sogar im Stream ausprobiert.

03:27:39.400 --> 03:27:49.400
Ausrufezeichen Videos gibt es nicht. Guck mal, da ist der Titel.

03:27:49.400 --> 03:27:54.400
Was hast du als Text eingegeben, Max, dafür für das Bild?

03:28:09.400 --> 03:28:18.400
Also das war ein wirklich gutes Video. Und da fand ich auch sehr viele Projekte drin, also Produkte drin, wirklich beeindruckend und spannend.

03:28:18.400 --> 03:28:23.400
Leider sind die meisten AI-Videos, die ich in der Hand habe, wirklich sehr, sehr gut.

03:28:24.400 --> 03:28:36.400
Also das war ein wirklich gutes Video und da fand ich auch sehr viele Projekte drin, also Produkte drin, wirklich beeindruckend und spannend.

03:28:36.400 --> 03:28:44.400
Leider sind die meisten AI-Videos so 0-15 auf YouTube, deswegen nervt mich der ganze AI-Content mittlerweile auch so.

03:28:53.400 --> 03:29:02.400
Faster than Rust. Moment, ich denke, das geht per Definition gar nicht. Nur Rust ist blazingly fast.

03:29:02.400 --> 03:29:08.400
Faster than Rust, debated.

03:29:15.400 --> 03:29:23.400
Natürlich kannst du Sachen faster optimieren, logisch. Aber auch die Rust-Leute tun halt immer so.

03:29:23.400 --> 03:29:35.400
Gut, Leute, dann würde ich sagen, jetzt gehe ich pennen. Wir sehen uns die Tage, bis denn, macht's gut, see you.

