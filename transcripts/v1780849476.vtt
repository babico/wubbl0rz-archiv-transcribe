WEBVTT

00:30.880 --> 00:33.440
Hallo schon jemand da

00:40.440 --> 00:47.280
Anscheinend noch nicht dann warten wir mal bis twitch das mitbekomme dass das stream online ist in der Zwischenzeit entwirre ich war mein headset

01:01.000 --> 01:06.280
So jetzt habe ich sehr sehr entwirrt moin leute

01:06.280 --> 01:08.280
Die

01:23.400 --> 01:30.160
Heute wird wenn wir uns mal github actions ein wenig hat letztens jemand gefragt ob wir uns das noch mal so ganz grundlegend

01:31.000 --> 01:33.000
die die basics

01:33.040 --> 01:34.280
angucken können

01:34.280 --> 01:37.320
Das heißt wenn wir uns die basics ich kann das nicht richtig ausspringen

01:38.120 --> 01:45.480
Wenn wir uns die basics heute angucken dann hoffe ich auch ganz wichtig chat dass ihr das nötige high performer mindset mitbringt

01:46.240 --> 01:48.440
Weil sonst geht ja bekanntlichermaßen nix

01:49.800 --> 01:54.120
Also high performer modus mindset modus aktivieren please

01:56.360 --> 01:58.480
Und natürlich die gruppe join das ist schon mal klar

01:58.480 --> 02:05.800
Nur für fife logisch logisch nur für fife er

02:14.880 --> 02:21.000
High IQ only high performer mindset aktiviert leute auf geht's

02:28.880 --> 02:30.880
Wir gucken uns heute github actions an

02:31.760 --> 02:37.240
Und dann fangen an ich erzähle mal ein paar sachen zu wir haben aber ein konkretes ziel heute was wir machen wollen

02:40.080 --> 02:45.600
Ja nee nee nee nee nee das machen wir nicht mal kurz die musik entticken leiser

02:47.600 --> 02:49.600
Auch wenn es richtiger banger ist

02:53.400 --> 02:55.880
Ja aber wenn wir dazu kommen

02:56.120 --> 03:01.680
Ja aber wenn wir dazu kommen dann machen wir das heute genau das ist das ziel

03:04.160 --> 03:08.800
Wobei ich den part noch nie gemacht habe das heißt da müssen wir tatsächlich mal schauen

03:14.280 --> 03:19.360
Das ist so ein geiler soundtrack den kann man echt in endlos schleifel laufen lassen seit elf jahren

03:20.320 --> 03:22.320
theoretisch

03:22.320 --> 03:24.320
Die

03:24.520 --> 03:26.520
Hoggers

03:27.040 --> 03:32.480
Kurz audio settings checken nein nicht volume mixer warum will ich immer auf volume mixer

03:33.080 --> 03:36.800
Weil wenn los settings für den arsch sind man nicht durchblickt vielleicht könnte sein

03:45.080 --> 03:47.080
Du kannst helfen beim hour

03:48.000 --> 03:54.000
Übrigens nichts hat nichts mit der hour zu tun in dem fall geht es um das art user repo

03:54.520 --> 03:58.520
heißt überhaupt die art shoot also art user heißt heißt das repo glaub schon

03:59.400 --> 04:01.400
das hour

04:01.400 --> 04:03.520
Nee, aber wir gucken uns heute an

04:04.480 --> 04:11.560
Wie eben wir ein projekt was ich auf github habe also den vm champ was sonst ja wie wir das automatisch

04:11.760 --> 04:13.760
bilden können

04:13.760 --> 04:19.680
Und so gucken wir uns ein paar sachen drumherum an so von ganz simpel bis ein bisschen komplizierter bis

04:20.800 --> 04:24.680
docker multistage wobei weiß ich auch mal multistage bild brauchen

04:25.760 --> 04:27.760
wie man docker docker

04:28.640 --> 04:36.880
Bilds bzw. Containerbilds casht in github actions wie man artefakte hoch lädt und danach eventuell auch muss ich mal gucken

04:38.640 --> 04:43.440
Wie man beispielsweise noch eine art user repo package pushen kann mal gucken wie weit wir kommen es

04:43.480 --> 04:48.200
Könnte sein dass heute immer wo kreisel klein ist bis jetzt ist allerdings noch keiner da

04:49.800 --> 04:54.760
Deswegen vermute ich mal dass nix mehr ist

04:56.160 --> 04:57.440
aber

04:57.440 --> 04:59.440
Man weiß es nicht

05:04.880 --> 05:07.760
Du du du du du du du tu tu tu tu

05:13.440 --> 05:16.720
Was ich packetieren will genau das was wortig gerade verlinkt hat

05:17.360 --> 05:23.240
Das hier ich mache aber erstmal die vm an der stream muss ja noch richtig anlaufen sind erst 69 leute da

05:23.560 --> 05:29.120
Sehr gute zuschauerzahl ich hoffe alle haben wie gesagt das high performer mindset heute am start

05:29.760 --> 05:31.760
weil weil auch only high performer

05:32.720 --> 05:36.080
sind sind ready für den github actions crash kurs

05:36.640 --> 05:39.680
Das hast du neulich schon richtig den packen Wahnsinn

05:40.640 --> 05:45.600
den muss man normalerweise nicht groß roundig packen den kann man bauen und upload als release in github

05:46.240 --> 05:51.640
Aber das bietet sich jetzt einfach an weil das eben neues neues projekt es bringt wieder auf das große

05:52.640 --> 05:55.100
was� ach das hier oder ich kann das ja vielleicht nur machen

05:55.400 --> 05:58.160
säger ich bin into

05:58.160 --> 06:01.080
den kann man bauen und uploaden als release in github

06:01.440 --> 06:07.640
Aber das bietet sich jetzt einfach an weil das eben neues neues projekt ist übrigens gab heute tatsächlich ein pull request

06:08.160 --> 06:12.240
Guck mal da ist gar ein pull request falscher link für all mal linux

06:13.280 --> 06:18.560
Vom christ im moment ist ne ne moment das das das der christian waldmann das der christian heuse darf man nicht

06:19.000 --> 06:24.360
Hab gedacht vielleicht wärst du das gewesen im prinzip kleine sache aber das finde ich gut dass die leute hier mitmachen

06:24.920 --> 06:31.320
So pack man erste mal erst mal alle pakete update zack arch by the way gibt es immer was zum updaten

06:33.480 --> 06:35.480
Gib ihm

06:35.800 --> 06:42.680
Wichelt studio code auch bämm alles was ist denn da neu das müssen wir mal kurz gucken wie ist code 1.77

06:44.200 --> 06:46.200
Im märz okay

06:46.680 --> 06:48.680
kam raus am

06:49.240 --> 06:52.440
Datum ist overrated outdated gebaited braucht man nicht

06:52.440 --> 06:56.680
Wer will auch schon ein datum in release notes in release notes haben mensch

06:58.840 --> 07:01.640
Vermute mal heute oder gestern kam das raus

07:03.480 --> 07:09.080
Aber so datum wäre schon wäre schon echt extrem porg wenn man so was rausbringt

07:11.880 --> 07:14.440
Ja okay heute heute kam das ganze wohl raus okay

07:14.440 --> 07:19.000
Lass mal ganz kurz drüber gucken ob es irgendwas irgendwas spannendes gibt in der aktuellen wie das code version

07:19.160 --> 07:24.840
Accessibility thermal ex blablabla blablabla was except in ordentlich auch wurscht

07:26.360 --> 07:28.360
Copy github die blinks okay

07:29.080 --> 07:36.600
Ich benutze eh keine gith integration in git in in visual studio code dass ich den sinn persönlich gar nicht drinne ich bin gefühlt einer der wenigen

07:36.920 --> 07:39.320
Die komplett auf kommando zeile schwören

07:41.160 --> 07:42.680
Hat man jetzt einen

07:42.680 --> 07:45.640
Browser in github hat man jetzt habe ich das richtig

07:46.280 --> 07:52.200
Browser in github hat man jetzt habe ich das richtig gesehen leute haben die jetzt den browser in visual studio code

07:54.200 --> 07:58.920
Also ich meine das ganze ding basiert auf browser technologie es gab trotzdem lange zeit keinen browser

08:06.200 --> 08:08.200
Ach nee

08:08.600 --> 08:10.600
Die machen jetzt

08:11.720 --> 08:13.720
Was bin ich hier überhaupt sehend

08:14.200 --> 08:16.200
Was ist das hier edge

08:16.440 --> 08:18.360
Oder was?

08:18.360 --> 08:21.000
Was ist das hier was man da sieht überhaupt edge

08:21.880 --> 08:23.880
Der edge sieht aber anders aus als meiner

08:24.920 --> 08:30.520
Aber in kirby musik ist mir zu anstrengend gerade ich brauche ich brauche irgendwas irgendwas entspannendes

08:34.840 --> 08:36.840
Ja

08:37.960 --> 08:42.480
Ist ist okay hauptsache irgendwas was nicht so nicht so anstrengend ist im hintergrund

08:43.440 --> 08:50.240
Oder ich mache andere ich mache wirklich für das wort andere hintergrund musik und

08:52.560 --> 08:58.560
Machen uns jetzt erst mal fünf minuten ordentliche heavy metal an nee kann ich nicht mal ich habe keinen ich habe keinen eigenen tonspur

09:03.120 --> 09:05.120
Terminal improvements

09:05.840 --> 09:07.840
All shell null

09:08.400 --> 09:10.400
Gits file support

09:12.400 --> 09:18.320
Verwendet jemand von euch geht in visual studio code beziehungsweise irgendwelche frage erweitern wir die frage mal

09:18.760 --> 09:27.680
Verwendet von euch irgendjemand einen editor mit git integration von dem er halt auch die git integration benutzt im editor und ich meine damit jetzt nicht

09:28.240 --> 09:33.760
Merch konflikt diff das ist das ist tatsächlich was wo ich die daseinsberechtigung von einem

09:33.920 --> 09:35.920
Editor gestütztem

09:36.960 --> 09:39.520
Merch tool verstehe ich ja

09:41.120 --> 09:43.120
Ihr verwende das wirklich

09:43.120 --> 09:48.320
Okay, ich meine ich will euch jetzt ich will euch das nicht ausreden mein ihr könnt ja verwenden was ihr will was ihr wollt

09:48.320 --> 09:56.400
Aber ich mag das gar nicht ich mach git kommando zeilen die da weiß man wenigstens was passiert wir hatten wir hatten mal einen entwickler das weiß ich noch bei uns

09:57.920 --> 10:00.640
Der der war tatsächlich damals im admin team

10:00.640 --> 10:06.800
Weil er sich ums deployment von irgendwelchen anwendungen ist auch egal in der grunde ist egal zumindest er hat damals noch in klips oder

10:07.600 --> 10:09.600
IntelliJ ich glaube aber es war noch eclipse damals

10:10.160 --> 10:14.160
Verwendet mit irgend so einem git plugin und er hat immer ganz merkwürdige

10:14.720 --> 10:20.640
Rebases gemacht mit diesem mit diesem tool ich wüsste gar nicht wie ich das wie der das gemacht hat wie man das auf der kommando zeile gescheit macht

10:20.960 --> 10:24.960
Aber es war kam am ende immer nicht das raus was ich gerne haben wollte zu merchen

10:25.040 --> 10:27.040
Da weiß man wenigstens genau was passiert

10:28.320 --> 10:32.480
Notebooks interessiert mich nicht interessiert mich nicht language

10:35.440 --> 10:42.480
Aber die wollen bei typescript irgendwann z sharp überholen oder wenn die schon bei version 5 sind z sharp ist jetzt aber glaubt bei version 11 oder

10:43.040 --> 10:45.040
nächstes mal 12

10:45.280 --> 10:47.280
Git ignore support

10:48.240 --> 10:50.240
Wie geht es jetzt

10:51.200 --> 10:53.200
Git ignore support

10:54.320 --> 10:56.560
Wie gab es das die ganze zeit nicht oder was

10:57.520 --> 11:01.880
Man hat davon abgesehen was muss man bitteschön supporten an git ignore files

11:03.040 --> 11:05.040
was was

11:12.080 --> 11:18.000
Weil es das heidet das heidet dann im editor view wenn man das im git okay ganz nice

11:18.560 --> 11:20.560
Das ist das ist schick extensions

11:21.680 --> 11:24.960
Wie viel ist denn da drinnen man notebooks verwende ich in der form nicht

11:26.160 --> 11:28.800
GitHub co-pilot natürlich was auch sonst

11:30.800 --> 11:32.800
So viele features

11:35.840 --> 11:41.920
Eol warning für windows 8 und windows 8 1 ja das können die ruhig eol das mir egal

11:44.720 --> 11:46.720
Big thank you to all contributors

11:48.240 --> 11:50.160
Na gut alles klar

11:50.160 --> 11:57.360
Jetzt wissen wir bescheid visual studio 177 ist raus nichts dabei was mich groß interessiert aber heißt ja nicht dass nichts dabei ist was euch interessiert

11:59.360 --> 12:06.320
Co-pilot ist nice ja ich verspreche mich bei co-pilot immer ich sage immer co-pilot was aber plötzlich heißt ja co-pilot aber

12:06.960 --> 12:08.960
co-pilot ist irgendwie so

12:09.600 --> 12:14.520
Kommt mir eher in kopf bei dem was github co-pilot eigentlich ist als co-pilot

12:18.960 --> 12:20.600
Ja

12:20.600 --> 12:26.160
Gut das habe ich auch das das das habe ich auch in der kommando zeile ich gehe einfach in der history zurück

12:27.000 --> 12:30.640
Und suche mir das letzte kommet raus das ist dann meistens update oder update

12:31.320 --> 12:35.080
Irgendwie sowas ist auch nicht sonderlich durch sonderlich aussahre kräftig

12:37.600 --> 12:43.800
Also die besten die besten kommet messages hatte ich immer noch hier als wir ein bisschen komponente stellens gemacht haben und ich

12:44.240 --> 12:46.240
Ich github actions triggern musste

12:46.240 --> 12:51.840
Und die die besten die besten kommet messages gab es immer noch

12:53.760 --> 12:55.760
Gab es immer noch hier

12:55.760 --> 13:03.360
Best feature ever und und um nicht und um nicht zu vergessen die qtab hat auch wunder sehr gute sehr gute kommet messages

13:03.840 --> 13:05.840
Aber ich habe mich hab mich vertan glaube ich

13:07.840 --> 13:09.840
Ah ne doch nicht

13:09.840 --> 13:16.080
Ein anderes repo von mir hatte 400 400 kommets 400 kommets keckel drinne

13:18.400 --> 13:24.400
Ja warum nicht dafür dafür ist das hier tatsächlich ja ok hier wird die readme ein bisschen geupdatet ja über das

13:24.400 --> 13:28.400
über das github frontend deswegen geht es nicht anders aber ansonsten ist eigentlich alles in ordnung

13:34.080 --> 13:36.080
Nice

13:36.960 --> 13:38.960
Nice

13:45.840 --> 13:51.960
Hello empty bringt ja auch nicht wirklich was da hast du halt einen kommet ohne kommet message ein kommet ohne kommet message ist trotzdem neues kommet

13:53.960 --> 13:58.840
Das beste was man machen kann ist einfach wenn man lokal oder wenn man halt irgendwie immer wieder was pushen muss zum triggern

13:59.240 --> 14:01.240
wenn man einfach lokal

14:01.800 --> 14:07.600
Was erzähl ich lokal lokal einfach immer das letzte letzte tag überschreibt

14:07.600 --> 14:12.760
Endlich letzte tag letzte kommet immer wieder überschreibt und forst pusht in extra branche zum ausprobieren

14:12.920 --> 14:16.480
Dann saut man nicht total rum falls man das irgendwann mal merchen will und gut ist

14:19.360 --> 14:23.720
Benutzt du auch geht chat gpt für boilerplate code ehrlich gesagt selten

14:24.520 --> 14:28.600
Eigentlich gar nicht wofür ich chat gpt ganz gerne verwende ist manche sachen

14:28.960 --> 14:34.560
Wenn ich nicht so genau sicher bin wie das wie das funktioniert zum beispiel habe ich letztes verwendet

14:34.960 --> 14:39.880
Interop zwischen z libraries und z sharp da war ich mir nicht ganz sicher wie man das aufruft

14:39.880 --> 14:43.080
Chat gpt hat auch ziemlich ein mist erzählt wieder zwischendurch

14:46.520 --> 14:51.240
Aber wenn man dann schreibt so nach dem motto das und das gibt es nicht macht auch mal das beispiel in c

14:51.680 --> 14:56.120
Dann ist es manchmal ganz praktisch gerade und es ist jetzt bescheuert an aber gerade

14:56.360 --> 15:01.280
Weil chat gpt manchmal die sachen ein bisschen zu umständlich macht hat man manchmal

15:02.400 --> 15:06.400
Erkennt man einen gewissen denk ansatz drin für sich selbst weil einem auffällt

15:07.160 --> 15:13.300
Okay, der eigentliche weg geht ja auch so du schreibst dann zwar im endeffekt nicht so wie es chat gpt geschrieben hat

15:13.640 --> 15:19.360
Aber man kommt man kommt dann drauf an der stelle ach ok das ist ja eigentlich gar kein pointer sondern ist ein pointer auf ein pointer

15:19.680 --> 15:22.600
Deswegen musst du musst du die adresse nehmen an der stelle und sowas

15:23.280 --> 15:24.320
Also

15:24.320 --> 15:26.200
Für solche sachen

15:26.200 --> 15:33.320
Zumindest mal kann es nicht schaden chat gpt zu fragen hier erklär mal bitte wie ich keine ahnung lip wird das und das aufrufe

15:33.320 --> 15:38.720
Und dann versucht das chat gpt zu erklären chat gpt lügt halt auch ganz gerne wenn es keine ahnung hat

15:38.720 --> 15:44.840
Haben wir letztens erst gesehen wir haben letztens chat gpt gefragt wie man eine progress bar und dass die schaab mit dem

15:44.840 --> 15:51.720
Http klein macht für den download also progress anzeige und hat sich ganz frech einfach was ausgedacht

15:52.600 --> 15:58.560
Und wenn man es dann darauf hingewiesen hat dass es diese methode im http klein gar nicht gibt hat es halt ja das stimmen

15:58.560 --> 16:03.960
Und was anderes rausgehauen was auch nicht funktioniert also insofern ja

16:06.760 --> 16:10.080
Ja ich habe die letzten tage ein paar

16:11.600 --> 16:13.600
Image recognition

16:13.880 --> 16:20.260
Sachen ausprobiert zum beispiel open flamingo das ist zwar irgendwas aus auf lama basis

16:20.540 --> 16:24.980
Weil ich habe eine kamera bei mir im keller gegenüber von der heizung

16:25.740 --> 16:27.180
und die

16:27.180 --> 16:29.180
hat in ihrem bildbereich

16:29.700 --> 16:36.460
Die druckanzeige von der heizung die druckanzeige von der heizung ist eine ist so so so ein analoger

16:37.660 --> 16:43.700
Tacho nenne ich das mal ja von 0 bis 4 und die nadel ist meistens so zwischen 1 und 2

16:45.260 --> 16:47.260
Das machen wir heute gar nicht

16:47.820 --> 16:51.540
Lama ist ein ki model von facebook

16:53.260 --> 17:01.580
Das machen heute gar nicht heute mal high IQ github github actions und pipeline bauen mini pipeline so dass man dass man alles alles verstehen kann

17:04.220 --> 17:09.580
Und der dem dem habe ich die den hab dem habe ich die bilder hochgeladen habe gefragt so nach dem auto

17:10.820 --> 17:15.060
Auf welchem wert steht denn die nadel in diesem in dieser anzeige

17:16.060 --> 17:20.300
Und ich habe es versucht dahin zu führen dass das model erzählt

17:20.980 --> 17:27.620
Was was ich hören will so nach dem motto ich habe ihm gesagt hier sehen sie eine analoge also hier siehst hier hier sieht

17:27.620 --> 17:31.020
man eine analoge anzeige zwischen 0 und 4

17:32.340 --> 17:35.660
Aktuell befindet sich die nadel zwischen 1 und 2

17:36.540 --> 17:40.940
Auf auf welchem die schritte sind in 0,2 er steps

17:41.540 --> 17:49.020
Auf welchem wert befindet sich zur zeit die nadel so ich habe den model wirklich versucht genau zu erklären was ich haben will hat es nicht

17:49.020 --> 17:50.020
hinbekommen

17:50.020 --> 17:55.720
Also da setze ich tatsächlich ein bisschen auf gpt 4 gpt 4 hat ja ein bisschen die leute

17:55.940 --> 18:02.820
Gebetet ich weiß nicht ob ihr noch die ankündigung kennt von von gpt 4 so nach dem motto man kann bilder als input

18:02.940 --> 18:08.460
Benutzen und sowas und das ist jetzt ganz furchtbar innovativ man kann sich bilder beschreiben lassen und sowas

18:09.100 --> 18:11.100
Das geht alles noch gar nicht

18:11.820 --> 18:15.740
Das haben die in die ankündigung einfach reingepackt und jeder denkt irgendwie ja geil

18:16.300 --> 18:22.540
Gpt 4 kann bilder kann es noch gar nicht es war einfach nur eine ankündigung drin mag sein dass es das intern irgendwie kann

18:23.340 --> 18:28.980
Aber publik benutzen kann das noch niemand selbst wenn du bezahlst für gpt 4 kannst du das nicht machen

18:29.220 --> 18:33.500
bilder support ist obwohl die das angekündigt haben und obwohl die das quasi so

18:34.260 --> 18:41.460
Introduced haben als wäre das jetzt logischerweise da und dabei und für jeden benutzt war ist nicht da und wann das benutzt

18:41.460 --> 18:45.940
Bar wird es auch noch nicht klar also insofern ganz schöner tschie bait

18:46.300 --> 18:52.300
Glücklicherweise habe ich im vorfeld mal ein bisschen nachgeforscht festgestellt dass das der fall ist und habe kein sonst hätte ich nämlich in

18:52.300 --> 18:55.660
Gpt 4 aber abgeschlossen hätten wir das angeguckt weil da

18:56.460 --> 18:58.460
da hoffe

18:58.780 --> 19:00.780
Es poppt heute wieder am mikro

19:03.500 --> 19:09.420
Ah ich weiß woran es liegt jetzt weiß ich woran das immer liegt

19:11.860 --> 19:13.220
Alter

19:13.220 --> 19:18.780
Jetzt jetzt weiß ich okay ich kann es ich ich ich versuche es euch mal zu erklären woran es liegt normalerweise

19:19.260 --> 19:24.340
Habe ich das kabel vom headset also das hier jetzt poppt das wenn ich so an dem kabel mache ja

19:26.260 --> 19:31.500
Normalerweise hängt das kabel vom headset einfach so ein paar mir an der seite runter auf die erde manchmal

19:32.500 --> 19:35.460
Na moment aber nur vielleicht ist es auch nicht das richtige

19:36.380 --> 19:40.820
Aber es ist ja nur manchmal so wenn ich das kabel aus versehen

19:41.260 --> 19:44.460
Über passt mal auf jetzt jetzt lasse ich hier mal liegen

19:45.020 --> 19:51.020
Wenn ich das kabel aus versehen über die armlehne runter hängen lassen habe dann komme ich immer so

19:52.620 --> 19:54.620
Was ist

19:55.260 --> 20:01.380
Immer immer so dran das poppt nicht das das macht so dass das dürfte so so dumm für

20:01.500 --> 20:03.500
dumm für

20:04.340 --> 20:05.660
Ja

20:05.660 --> 20:10.500
Schlaggeräusche geben im hintergrund wenn ich das kabel im hintergrund jetzt hier drüber drüber

20:12.060 --> 20:15.620
Das das kabel klatscht dann immer so an den

20:17.140 --> 20:21.620
An die armeauflage vom stuhl jetzt mache ich es wieder runter jetzt sollte eigentlich nix sein hoffe ich mal

20:24.180 --> 20:26.700
Müssen mich dran erinnern ok daran scheint es wahrscheinlich zu liegen

20:27.700 --> 20:33.700
Daran scheint es wahrscheinlich die polizei ist da nice daran scheint es wahrscheinlich zu liegen also ihr könnt mich daran erinnern sollte es mal wieder komische

20:34.700 --> 20:36.700
Schlaggeräusche im hintergrund machen

20:37.340 --> 20:39.340
Dann ist das das kabel was an die

20:39.660 --> 20:41.660
armeauflage haut

20:42.500 --> 20:44.500
Scheuert

20:44.500 --> 20:45.500
Jo

20:45.500 --> 20:51.580
Also da setze ich ja ein bisschen auf gpt 4 das wenn gpt 4 dann endlich mal rauskommt mit image input

20:51.620 --> 20:56.580
Mit image input also mit image erkennung und allem das gpt 4

20:58.620 --> 21:00.620
Das kann

21:01.620 --> 21:03.620
Meine

21:05.060 --> 21:13.340
Anzeige also meine druckanzeige an der heizung im keller auslesen das das wäre äußerst hilfreich dafür gebe ich auch 20 euro im monat aus

21:13.340 --> 21:15.340
Ja

21:20.380 --> 21:28.740
Ja nice ich wie gesagt ich also gpt 4 bzw code pilot ich werde es mir auf jeden fall in nächster zeit noch mal angucken

21:31.260 --> 21:34.740
Ich will halt das aber erst abschließen wenn das image feature dabei ist

21:35.060 --> 21:41.580
Weil das image feature ist was da bin ich wirklich scharf drauf und es ist halt doof dass sie so angekündigt haben als wäre das automatisch

21:41.980 --> 21:47.980
Gleich mit dabei das haben die ja ganz selbstverständlich in der ankündigung so erwähnt als ist es jetzt da aber es ist halt einfach noch

21:47.980 --> 21:51.140
Gar nicht da und es weiß auch keiner wann es wann es genau kommt

21:51.220 --> 21:56.300
So ich mache noch mal ein update von meiner vm. Wobei. Nee habe ich das nicht gerade gemacht. Waren können update dabei. Ach scheiße

21:56.300 --> 21:58.440
War mein reboot schadet auf jeden fall nicht

21:59.940 --> 22:01.940
Einmal einmal rebooten nicht verkehrt

22:03.300 --> 22:06.300
Tut gut reboot reboot tut gut

22:11.580 --> 22:13.580
So

22:14.420 --> 22:16.420
Firefox

22:17.420 --> 22:21.420
Sack ja gebeck ok nice

22:26.700 --> 22:28.260
So

22:28.260 --> 22:35.100
Also ich hoffe ich bin auch bei github eingeloggt ich bin auch bei github eingeloggt sehr nice sonst hätten wir jetzt probleme gekriegt

22:35.300 --> 22:39.020
Weil ich mein password na doch ich habe ein password im save stehen hätte ich drüber kopieren können

22:40.020 --> 22:48.660
Also chat ich hoffe ihr habt das high performer mindset heute ausgepackt heute mal github actions das könnt ihr danach in euren lebenslauf schreiben

22:49.580 --> 22:57.820
Fortgeschrittene oder quatsch vor wer schreibt fortgeschrittene rein fortgeschrittene ist out experte in github actions gleich danach in lebenslauf rein

22:58.500 --> 23:00.500
fünf jahre experience

23:01.380 --> 23:07.940
Direkt auch auf linkedin und überall können wir direkt als referenz ihr kriegt am ende für streams auch alle ein zertifikat ausgestellt

23:08.420 --> 23:10.420
das originale wubbler zert

23:11.660 --> 23:13.660
Also ist weltweit sehr beliebt

23:14.620 --> 23:18.620
Und da werdet ihr instant eingeladen bei irgendwelchen vorstellungsgesprächen

23:19.980 --> 23:23.180
Das heißt heute muss das high performer mindset ausgepackt werden

23:24.140 --> 23:28.940
Aber nur wenn du das mit pecken wie paint alter das ist ei generiert natürlich

23:28.940 --> 23:34.340
Payne so wir sind doch wir sind im jahr 2023 da wird so was nicht mehr mit paint gebaut

23:35.700 --> 23:39.100
Das ist dann ein nft ne ne das klingen ja mehrere leute das wird ja nicht funktionieren

23:48.900 --> 23:50.900
Okay

23:50.900 --> 23:53.500
Ich muss mal kurz in mich gehen wo fangen wir denn jetzt mal

23:53.540 --> 23:55.540
Wo fangen wir denn jetzt am besten an

24:02.940 --> 24:04.940
Nfts sind schon langsam wieder out

24:05.980 --> 24:07.980
Ja der hype der hype ist rum

24:08.540 --> 24:13.020
Wobei uns das auf lange sicht sie denke ich schon erhalten bleiben wird

24:13.900 --> 24:15.900
Aber wir sind schon langsam wieder out

24:16.380 --> 24:18.380
Ja der hype der hype ist rum

24:18.980 --> 24:22.660
Wobei uns das auf lange sicht sie denke ich schon erhalten bleiben wird

24:24.500 --> 24:32.580
Also gut gehen wir mal rüber auf github ich weiß wo ich anfange ich habe hier ein projekt es ist egal was es ist

24:33.940 --> 24:37.580
Also macht heute macht heute eigentlich keinen unterschied was es ist

24:38.540 --> 24:42.380
geht einfach nur darum dass ich ein projekt auf github habe was wir heute als

24:43.700 --> 24:48.260
Grundlage für github actions benutzen wollen wenn ihr wissen wollt was es ist es ist was wo man

24:49.420 --> 24:51.820
lokal auf die schnelle sich vms erstellen kann

24:54.500 --> 25:01.580
Willst du echte github actions nehmen ja ne ne ich will kein act runner ich nehme echte github actions

25:09.980 --> 25:17.620
Ja man kann sich damit lokale test vms schnell erstellen das ist ein sicherprogramm das heißt das muss gebaut werden

25:18.500 --> 25:20.500
das muss

25:23.580 --> 25:25.580
Es muss und und push gebaut werden

25:26.340 --> 25:32.820
Das muss in vallem in dem container in dem cento 7 container gebaut werden dass das system worauf es gebaut wird schön alt ist das

25:32.820 --> 25:38.620
Ist tatsächlich wichtig dass es möglichst rückwärts kompatibel zu vielen system läuft so jetzt hat man hier lokale vm und kann rumsauen

25:42.300 --> 25:44.300
Github ist arsch lahm

25:47.180 --> 25:53.020
Ich ja ihr du hast recht aber ich finde es nicht schlecht wenn wir es in github machen wir gucken mal wenn es zu unerträglich

25:53.060 --> 25:55.060
wird machen wir das

25:55.380 --> 26:00.500
Ich finde es nicht schlecht ist auf github zu machen da sieht man nämlich auch mal was es für ein vorteil ist wenn man cashing benutzt

26:03.660 --> 26:08.860
Wie viel schneller es dann ist und ich gehe davon aus und ich hoffe wenn wir das ordentlich cashen

26:10.140 --> 26:17.660
Dann haben wir da haben wir da weniger probleme warum nicht schittier actions weil github das ist was die meisten leute verwenden

26:18.660 --> 26:23.740
Und ich glaube das bringt mehr leuten was wenn wir uns github actions angucken als

26:23.980 --> 26:27.960
Schittier actions wobei das ja im prinzip ein github actions klohn ist

26:32.380 --> 26:35.420
So also wir haben ein c-sharp projekt

26:36.460 --> 26:42.800
Und das ziel ist dass wir das projekt bauen auf möglichst alten stand in einem alten docker container

26:43.300 --> 26:45.300
dann das ganze

26:45.460 --> 26:53.380
Bild also die die das das resultierende binary also das jetzt zum beispiel ja da kommt also ein binary rausgefallen das binary

26:53.820 --> 27:01.700
Dann als artefakt an den bild dran hängen jetzt zu zeigen wie das geht die einzelnen steps cashen dass die actions

27:02.460 --> 27:07.100
schneller gehen und am ende ist das ziel dass wir ein art schuhe repo machen

27:07.860 --> 27:09.860
also ein

27:10.860 --> 27:18.380
Dass wir einen repo machen in art schuhe repo wo wir dann das binary reinpushen ob wir soweit kommen muss ich mal gucken

27:18.580 --> 27:23.060
hängt wahrscheinlich ein bisschen davon ab ob wir heute mmo kreise machen oder nicht

27:25.340 --> 27:32.100
Bevor wir anfangen mit github actions muss ich erst mal kurz erklären was ist github actions beziehungsweise warum gibt es was ist was ist der

27:32.100 --> 27:35.140
sinn von dieser ganzen geschichte also warum warum gibt es so was

27:36.460 --> 27:38.100
beziehungsweise warum

27:38.140 --> 27:43.540
Github actions ist ja nicht das erste beziehungsweise was ist ist so so geschichten gut also

27:43.820 --> 27:47.940
Github actions ich weiß gar nicht was die was sie selbst zu sagen was github actions ist

27:50.100 --> 27:52.100
Ja nee nicht wirklich

27:53.420 --> 27:59.940
Ja github actions ist continuous integration continuous delivery platform that allows automate build ok steht im prinzip alles da

28:00.220 --> 28:04.340
So wirklich so wirklich klar wenn man das noch nicht benutzt hat ist es ist es eigentlich nicht

28:05.340 --> 28:12.300
Also wenn man eine software es muss übrigens nicht zwangsläufig nur ein software projekt sein es kann durchaus auch ein software projekt mit

28:13.460 --> 28:15.460
infrastruktur definitionen sein

28:16.100 --> 28:18.100
Aber gehen wir jetzt mal voraus ein software projekt

28:19.420 --> 28:24.860
Als besteht ihr erst einmal auch source code damit man das ganze ausführen kann muss es in irgendeiner art und weise

28:26.220 --> 28:27.900
Zu einem package

28:28.500 --> 28:35.780
Zusammen geschnürt werden was auch immer das bedeutet das kann ein compiler sein der läuft es kommt eine exe am ende raus in den binary was ausführbar ist

28:37.140 --> 28:44.980
Es kann irgendein job package für javas sein es kann ein container image sein was in irgendeine registry kommt aber irgendwie muss das source code

28:46.180 --> 28:52.780
So aufbereitet werden dass man es am ende dort wo man das laufen lassen will ausführen kann ist ja logisch mit dem source code alleine kann

28:52.780 --> 28:54.780
man nicht allzu viel machen

28:55.340 --> 29:01.460
Das können verschiedene schritte sein die dazu erforderlich sind es kann compiler step sein der notwendig ist vielleicht möchten wir vorher noch

29:01.460 --> 29:03.860
Ein paar tests ausführen es kann ein image

29:04.380 --> 29:06.380
bauen notwendig sein

29:06.660 --> 29:11.740
Vielleicht muss man irgendwelche zwischen steps irgendwo hochladen vielleicht muss man irgendwelche abhängigkeiten

29:12.460 --> 29:14.460
noch überprüfen

29:14.500 --> 29:16.500
zumindest möchte man das ganze

29:17.580 --> 29:19.580
möglichst nachvollziehbar haben

29:19.980 --> 29:23.180
Also nicht jetzt dass ein entwickler das bei sich auf dem notebook baut

29:23.620 --> 29:29.140
Und dann funktioniert die anwendung am endefekt nur bei dem auf dem notebook und nicht auf irgendwie dem server wo es am ende laufen soll

29:29.780 --> 29:31.780
Man möchte das möglichst

29:31.780 --> 29:33.780
nachvollziehbar haben und möchte das vor allem auch

29:34.620 --> 29:36.620
möglichst

29:36.820 --> 29:39.740
Unabhängig von der entwickler plattform haben

29:40.540 --> 29:43.660
Und das ganze so viel oder so weit wie möglich

29:44.260 --> 29:50.820
Automatisiert dass kein entwickler oder in admin oder sonst was hingehen muss und da jeden tag von hand irgendwie die software

29:50.820 --> 29:57.260
Patchen neue package bauen die package dann irgendwo hin deployen und sowas das soll wobei das mit dem deployment noch mal ein zweiter schritt ist da

29:57.260 --> 29:59.260
hat jetzt mit dem bauen erstmal nichts zu tun und

30:00.820 --> 30:03.140
Das soll halt möglichst automatisiert passieren

30:04.060 --> 30:06.060
dass es keine gute idee ist wenn

30:06.220 --> 30:12.460
Die software auf einem entwickler notebook gebaut wird und dann irgendjemand auf den server kopiert und erhofft dass es funktioniert und dann dort andere

30:12.460 --> 30:19.340
Library versionen sind jetzt irgendwelche komischen bugs gibt es gar nicht funktioniert es vielleicht memory leaks gibt wo sonst gar keine sein sollten was auch immer

30:19.780 --> 30:23.100
Da ist man schon relativ früh drauf gekommen dass das nicht so clever ist

30:23.620 --> 30:31.380
Quasi auf auf einer auf der entwicklerkiste zu bauen oder auf unterschiedlichen kisten wenn sie immer die gleiche entwicklerkiste wäre besser noch halb so wild

30:32.100 --> 30:38.860
Auf unterschiedlichen kisten zu bauen oder gar auf produktiven system zu bauen dass es möglichst gleich ist da ist man schon relativ früh auf die

30:38.860 --> 30:42.060
Idee gekommen dass es keine allzu gute idee ist das zu machen

30:42.940 --> 30:48.580
Und dafür gibt es schon seit längerer zeit continuous integration tools sowas wie jenkins

30:49.940 --> 30:52.620
Falls das jemand noch kennt von früher

31:01.180 --> 31:08.500
Jenkins war mit das erste es war nicht das erste weil es gab noch ein vorgängerprogramm von jenkins das war hudson das wird an

31:08.500 --> 31:15.100
Irgendwann gefragt zu jenkins aber jenkins war auf jeden fall somit der erste große bekannte kontinue

31:15.540 --> 31:17.260
erste bekannte

31:17.260 --> 31:22.740
Continuous integration oder es ist ja man muss ja sagen jenkins ist ja eigentlich gar kein richtiges

31:23.260 --> 31:26.620
continuous integration programm sondern mehr oder weniger ein

31:27.860 --> 31:33.180
Task runner mit web interface du kannst den jenkins alles mögliche definieren und hast dann

31:33.700 --> 31:39.580
Verschiedene jobs die du anklicken kannst oder automatisch ausführen lassen kannst oder über das web interface starten kannst die dann

31:40.020 --> 31:46.420
Dinge erledigen die du definiert hast also in jenkins kannst du alles machen dafür musst du auch relativ viel von hand machen das war so

31:46.580 --> 31:48.140
Eines der ersten

31:48.140 --> 31:53.540
Programme in dieser richtung als die leute angefangen haben auf die idee zu kommen es ist keine gute idee

31:53.980 --> 31:57.900
Auf live system software zu kompilieren auf entwicklungsrechner das ganze zu kompilieren

31:58.300 --> 32:02.260
geschweige denn dass es auf dem einen rechner geht auf dem anderen nicht und

32:03.220 --> 32:08.340
Dass es auch gar keiner mehr von hand machen muss und da haben die leute angefangen jenkins zu verwenden jenkins

32:09.100 --> 32:11.100
ist richtig fette java software

32:14.580 --> 32:19.020
Gibt es ein video oder screenshots zu der config deiner netzwerk switch

32:22.060 --> 32:28.300
Also weder noch welchen teil der config interessiert dich denn und vor allem von welchem switch

32:28.300 --> 32:30.820
Ist ja nicht, so dass ich nur einen habe

32:34.700 --> 32:36.700
Hat jemand von euch schon mal

32:36.700 --> 32:37.700
Mikrotik

32:37.700 --> 32:39.020
Mikrotik

32:39.020 --> 32:42.300
Ich habe keine du meinst den mikrotik router den hex poe router

32:42.620 --> 32:47.100
Davon gibt es weder ein video noch kann noch kann ich den config dampf davon ziehen

32:48.100 --> 32:51.100
Wenn du was konkretes wissen willst kann ich dir vielleicht was zu sagen

32:51.740 --> 32:55.260
Wie land config ist in router us ein bisschen eklig

32:55.940 --> 33:00.520
Zu hand haben da muss man sich in paar tutorials durchlesen bis man das gecheckt hat wie das funktioniert

33:01.780 --> 33:03.780
Hat jemand von euch mal die ehre

33:04.380 --> 33:10.500
in frühe also vielleicht immer noch oder erst mal die erst mal die frage an euch hat jemand von euch schon mal die ehre gehabt

33:10.780 --> 33:12.780
hat jemand von euch schon mal die ehre gehabt

33:12.900 --> 33:14.900
dass ihr euch schon mal die ehre gehabt habt

33:14.900 --> 33:20.980
in frühe also vielleicht immer noch oder erst mal die erst mal die frage an euch hat jemand von euch schon mal die ehre gehabt

33:21.060 --> 33:23.380
die letzten jahre über jenkins zu benutzen

33:24.260 --> 33:27.100
und die zweit also wir benutzen dort kein jenkins keine sorge

33:27.620 --> 33:33.420
und die zweite frage ist hat noch jemand die ehre jenkins aktuell betreiben zu müssen beziehungsweise zu benutzen

33:35.220 --> 33:39.460
Also wir hatten jenkins schon vor ganz langer zeit habe ich sogar damals aufgesetzt

33:39.860 --> 33:43.700
weil ich ja damals schon zuständig war für unsere inför für unsere infrastruktur

33:45.780 --> 33:50.580
repos und server definitionen und so was den habe ich damals aufgesetzt den jenkins das war

33:51.220 --> 33:54.700
da gab es noch gar kein offizielles pipelines plugin da gab es ein komisches

33:55.020 --> 34:00.160
ein komisches plugin was dann grüne kästchen dargestellt hat an welcher stelle was fehlt und so was

34:01.980 --> 34:07.900
habe ich damals aufgesetzt und ich muss sagen bis heute mag ich jenkins eigentlich

34:08.500 --> 34:15.420
Es ist ein bisschen aus der mode gekommen wobei man sagen muss dadurch dass jenkins so super flexibel ist und nur nahezu alles

34:15.980 --> 34:19.420
damit machen kannst und das ganze auch gut lokal läuft

34:21.020 --> 34:27.820
Es hat es hat jenkins die zeiten ganz gut überlebt es ist jetzt sicherlich nicht mehr das das tool der wahl heute

34:28.220 --> 34:33.900
wenn man irgendwelche automatisierten builds laufen lassen muss aber wenn man vielleicht ein bisschen mehr links und rechts machen muss

34:34.140 --> 34:39.780
Aber wenn man vielleicht ein bisschen mehr links und rechts machen muss ist jenkins gar nicht so doof

34:44.540 --> 34:49.340
Ach du wechselt auch zum ersten vierten ja bei mir ist auch nächste woche erster arbeitstag

34:54.860 --> 35:00.940
Lies mal eine nachricht please wo denn da das ist doch kein zufall eben auf der arbeit gerade noch gitlab

35:01.500 --> 35:04.180
Pipelines fertig geschrieben das war so ein brainfuck aber die

35:04.980 --> 35:09.740
Saast scan reports werden jetzt in gitlab page was ist ein saast

35:10.380 --> 35:12.380
klingt nach antivirus

35:13.380 --> 35:17.700
System audit and security toolkit

35:21.540 --> 35:23.540
Saast reports

35:24.260 --> 35:26.260
Pfeifert

35:26.540 --> 35:28.540
Saast scan

35:29.540 --> 35:36.020
Irgendwelche security zeug ja wir machen aber so was so was machen wir heute nicht in github actions wir bauen eine software und pushen dann

35:36.020 --> 35:38.020
pushen dann das binary

35:40.860 --> 35:45.780
Gerade wenn man die letzten jahre über viele jenkins gemacht hat fällt es vielen da schwer von weg zu migrieren

35:46.100 --> 35:50.380
wobei ich halt auch sagen muss warum auch wenn es gut funktioniert ja es macht ja

35:51.220 --> 35:54.420
Macht ja keinen sinn was bei jenkins ein bisschen schwierig ist

35:54.820 --> 35:59.580
Zumindest in der vergangenheit ich weiß nicht wie es jetzt ist ich habe schon lange kein neuen jenkins mehr installiert

35:59.660 --> 36:07.940
Was ein bisschen schwierig war beim jenkins ist wenn du das ding skalieren wolltest also wenn die eine instanz nicht mehr ausgereicht hat

36:08.020 --> 36:10.180
Dann wurde es da wurde es ein bisschen kompliziert

36:10.500 --> 36:18.220
Beziehungsweise unmöglich du kannst zwar bei jenkins ganz viele verschiedenen runner haben also so im Prinzip so wie bei gitlab oder github actions auch

36:18.700 --> 36:25.700
Aber du hast nur einen zentralen jenkins server über die alle gehen müssen und also wenn wenn wenn jenkins von ganz vielen leuten benutzt wird hat man

36:25.700 --> 36:27.380
damit probleme

36:27.380 --> 36:29.380
wenn man aber lokal damit klarkommt

36:29.740 --> 36:33.620
Macht ja auch nicht so viel sinn muss ja auch nicht unbedingt sein dass man das abschafft ist ding

36:34.060 --> 36:36.900
lange rede kurzer sinn ich mag jenkins eigentlich immer noch

36:39.380 --> 36:44.300
Aber irgendwann vor ein paar jahren dürfte so vor drei vier jahren gewesen sein ist schon ein bisschen her

36:44.660 --> 36:50.540
Kam github auf die idee sie könnten doch auch so was machen und zwar direkt ins repo integriert

36:51.500 --> 36:58.380
Und zwar haben sie dann sich github actions ausgedacht mit github actions ich zeige euch mal so ein example

36:58.900 --> 37:02.400
gibt so in zum getting getting started oder so was

37:06.460 --> 37:08.460
Ja das ist vielleicht ein bisschen

37:09.300 --> 37:14.380
Ah hier examples gucken wir uns mal ja so sieht das zum warum wisst ihr was

37:15.540 --> 37:19.900
Wir gucken uns einfach ein beispiel von einem von einem repo bei mir an

37:20.340 --> 37:24.100
Hat der typ 1 geantwortet? Ah der typ hat gar nicht geantwortet ich muss mal kurz lesen was er geschrieben hat

37:24.260 --> 37:26.260
Und

37:36.580 --> 37:42.140
Weil das einer geschrieben hat wird viere das nicht machen so ich sage ich zeige jetzt mal ein beispiel bisschen bisschen längeres

37:42.340 --> 37:46.000
絶対 ein kompliziertes beispiel so sieht das ganze in github actions aus

37:47.220 --> 37:49.140
und zwar macht man dort

37:49.140 --> 37:51.140
diesen ganz die ganzen build step

37:51.900 --> 37:55.580
In jammel definiert man das wobei das auch nur zur halb

37:56.300 --> 38:02.140
Halbwahrheit ist ja man definiert das hier alles in jammel und wir gucken uns das gleich auch im detail an wie man das alles macht

38:02.580 --> 38:07.940
Aber man kann auch nach wie vor man sieht es hier man kann auch nach wie vor einfach shell kommandos reinschreiben

38:07.940 --> 38:13.620
Das ist also ein bisschen wie in jenkins wo man auch best scripts untereinander sich sachen zusammen frickelt nur

38:13.980 --> 38:17.900
der große also es ist jammel config ist schon mal der unterschied nur

38:18.020 --> 38:25.420
Der der neiße die neiße geschichte ist dass hier repo und quasi die bildanweisung

38:26.340 --> 38:30.780
alles im gleichen repot also der source code und die bildanweisung sind alles im gleichen repo drinne

38:31.900 --> 38:39.340
Das ist aber jenkins nicht so bei jenkins hast du eine job config ich glaube es gibt mittlerweile sowas wie jenkins files wo man das auch machen

38:39.340 --> 38:41.740
Kann habe ich nie benutzt keine ahnung wie das funktioniert

38:42.740 --> 38:48.660
Aber das ist so ein neuer ansatz gewesen damals im vergleich zu jenkins man hat die definitionen

38:50.300 --> 38:52.540
Direkt im repo beim source code mit drinnen

38:53.620 --> 39:01.140
So man hat nicht nur ein also man kann mehrere workflows haben github actions müssen immer unter punkt github slash workflows

39:01.140 --> 39:05.380
Und dann in den jammel daten kann man mehrere haben die output sieht man dann am ende hier

39:07.420 --> 39:10.100
Und das gucken wir uns aber gleich an wenn man es wenn man es laufen lässt

39:11.740 --> 39:16.980
So und so sieht zum beispiel eine kleine github action aus das geht deutlich geht deutlich komplexer

39:17.380 --> 39:24.940
Das schöne ist an github actions warum es auch meine lieblingsplattform ist um solche um builds zu automatisieren oder generell um sachen

39:25.060 --> 39:29.140
Automatisch laufen zu lassen wir haben da mittlerweile auf der arbeit dinger drinne die gar nicht wirklich

39:29.540 --> 39:36.740
Was mit software builds zu tun haben wir generieren da zum beispiel neue neue inventarlisten und sowas rüber über github actions

39:37.740 --> 39:42.380
Einfach alle viertelstunde laufen dass das ist äußerst praktisch das ganze

39:44.900 --> 39:46.580
Und was man

39:46.580 --> 39:49.780
Was unterscheidet sich das von der github umsetzung

39:50.620 --> 39:56.380
Ehrlich gesagt ich habe persönlich noch nicht so viel github gemacht aber es hält was ich gesehen habe hält sich in grenzen

39:59.140 --> 40:01.140
Es hält es hält sich in grenzen

40:01.380 --> 40:07.940
Also ja es ist anders aber es ist doch verkleidet es ist ziemlich ziemlich ähnlich vom aufbau her

40:09.620 --> 40:11.620
Was ich bisher gesehen habe

40:13.460 --> 40:15.460
Was war denn die frage

40:19.060 --> 40:21.060
Ach so hier das ja

40:21.060 --> 40:25.740
Ja also es ist relativ ähnlich es ist relativ ähnlich also github sind auch jammel files

40:26.060 --> 40:30.700
Es sind halt ist es ja nicht job build strategy ist das irgendwas anderes aber es ist doch recht ähnlich

40:30.700 --> 40:33.580
Also wenn man das eine verstanden hat kommt man mit dem anderen auch ganz gut klar

40:34.220 --> 40:36.220
so

40:37.020 --> 40:41.980
Ein weiterer eine weitere sache die man wissen muss zu github actions

40:50.620 --> 40:55.060
Also ähnlich ja genau also eine weitere sache die man zu github actions wissen muss

40:57.100 --> 40:59.100
Das was hier definiert ist

40:59.860 --> 41:01.860
Muss ja irgendwo ausgeführt werden

41:02.860 --> 41:08.500
Also hier steht ja nur drin was passieren soll beispielsweise bei einem push auf diesen branche

41:09.460 --> 41:14.500
Irgendwo muss das ganze ja noch ausgeführt werden dafür gibt es runner bei github

41:15.220 --> 41:20.740
Und bei github und bei gtea mittlerweile ist überall das gleiche du brauchst runner dafür irgendwo

41:21.060 --> 41:24.020
Muss dieser krempel ja ausgeführt werden der hier definiert wurde

41:24.860 --> 41:26.860
Wenn man das in der cloud benutzt

41:27.500 --> 41:33.260
Gibt es runner bei github die man auch benutzen kann bis zu

41:35.140 --> 41:37.900
Müssen wir die limits angucken die weiß ich aus dem kopf nicht

41:41.020 --> 41:43.020
Also man kann

41:44.940 --> 41:47.620
Bis zu 2000 minuten im monat

41:48.260 --> 41:55.420
Kostenlos das ganze verwenden hat bis zu 500 mb storage das reicht in der regel locker aus für alles was man machen will also das ist

41:55.420 --> 41:58.900
Sehr großzügig und damit kann man eigentlich alles machen das gibt es kostenlos

42:01.140 --> 42:04.780
Und mit minuten ist gemeint die laufzeit deiner

42:07.860 --> 42:10.980
Die laufzeit deiner sachen hier in einem runner

42:11.580 --> 42:16.140
Also sobald man das pusht der runner anfängt das auszuführen das sind die minuten die dann zählen

42:18.500 --> 42:20.500
Was man auch noch wissen muss ist

42:20.900 --> 42:27.540
Also das ist halt eben nicht unendlich funktioniert aber mehr als genug großzügiges free tier was man auch noch wissen muss ist

42:28.460 --> 42:31.740
Das sind vms und das ist auch gut dass das vms sind

42:33.380 --> 42:37.700
Also man sieht hier beispielsweise run on ubuntu latest

42:38.340 --> 42:40.820
das sind vms es gibt soweit ich weiß in

42:41.860 --> 42:43.860
github gibt es drei vm typen

42:44.420 --> 42:45.780
ubuntu

42:45.780 --> 42:49.380
windows 11 oder so oder windows server oder e-mails

42:49.380 --> 42:54.020
oder windows server oder in windows ubuntu windows 11 und mac os

42:54.900 --> 42:59.740
Also man kann mit github action software bauen für alle drei großen betriebssysteme

43:01.780 --> 43:09.620
Und nachdem man da drin aber auch container starten kann kann man ja eigentlich für alles bauen zumindest linux technisch aber

43:10.700 --> 43:14.580
Standardmäßig ist das ding hier unter ubuntu nein das sind keine docker images

43:15.300 --> 43:17.300
Das was man da drin ausführen kann später

43:17.940 --> 43:23.380
Kommen wir noch zu aber das hier sind keine docker images und das sind auch keine container das sind vms

43:23.580 --> 43:25.700
ich bin mir nicht sicher was das für eine

43:27.740 --> 43:33.380
Ressourcen zuteilung hat diese vms also wie viel cpus wie viel ram und so man benutzen kann

43:33.500 --> 43:37.380
Ich muss sagen ich bin bisher in github actions noch nie an die grenzen gestoßen

43:37.540 --> 43:41.100
Wenn man da drinne jetzt allerdings komplett verrückte sachen macht

43:42.100 --> 43:44.100
Beispielsweise

43:44.340 --> 43:48.220
Open street maps sich runterladen und irgendwie

43:49.140 --> 43:54.580
preprocessen für einen routen planer wo man eigentlich mindestens mindestens 64 g ram

43:55.340 --> 44:00.420
Und keine ahnung 500 gigabyte ssd storage braucht dass es gut funktioniert

44:00.860 --> 44:08.780
Dann würde ich sagen gerät man mit github actions wahrscheinlich an seine grenzen aber für normale build shops ist das vollkommen ausreichend

44:09.780 --> 44:11.780
Aber es sind vms

44:12.620 --> 44:15.260
Sollte einem sollte man den hinterkopf behalten

44:15.420 --> 44:20.100
Es ist im prinzip eigentlich nur gut dass es vms sind weil dann hat man keine probleme mit

44:20.540 --> 44:27.660
Beschränkungen die man vielleicht in containern hat containern kann man nicht alles machen in vms kannst du eigentlich alles ausführen deswegen ist es

44:27.980 --> 44:33.860
Eigentlich eine gute wahl dass es vms sind das muss man ein bisschen hinterkopf weil das sind vms deswegen dauert es auch ein bisschen bis

44:34.100 --> 44:36.100
Beispielsweise bis es startet und sowas

44:39.140 --> 44:41.140
Ja

44:52.220 --> 44:54.220
Gut

44:54.740 --> 45:01.060
Theoretisch könnte man können ich sage jetzt einfach mal ja theoretisch könntest du können module in github actions bauen

45:01.780 --> 45:02.980
und

45:02.980 --> 45:07.220
Gucken ob sie der korn laden kann also das müsste wahrscheinlich gehen ja ja ja

45:07.500 --> 45:12.340
Da ich sage jetzt einfach mal ja genau wissen tue ich nicht aber ich denke schon ja

45:15.660 --> 45:20.180
Ja du kannst da auch sehr abgedrehte sachen machen du kannst zum beispiel dann auch mit q emo

45:20.860 --> 45:25.140
in einem container in dieser vm cross kompilen beispielsweise von

45:26.100 --> 45:28.100
Für arm dass dann ein raspberry pie

45:28.860 --> 45:30.860
image rausfällt und sowas ganz viele geschichten

45:32.980 --> 45:37.100
Bevor wir uns bevor wir jetzt eine action anlegen für hier für den für den vier champ

45:38.140 --> 45:46.780
Formen in action anlegen eine sache sollte man sich noch angucken und zwar dass alle das den start hier oben es gibt verschiedene

45:49.180 --> 45:52.300
Einstellungen wie github actions getriggert werden können

45:57.020 --> 46:00.460
Also es gibt es gibt mehrere es gibt glaube ich drei

46:00.460 --> 46:08.460
Oft viel verwendete trigger es gibt noch viel mehr es gibt noch viel viel mehr kann man

46:12.900 --> 46:14.900
Ja also kannst

46:17.300 --> 46:19.700
Events wenn issues aufgemacht werden

46:20.420 --> 46:28.460
Und sowas also gibt alle möglichen aber es gibt drei es gibt drei sachen wie die oft verwendet werden das erste ist und push

46:29.300 --> 46:35.940
Branches also sprich sobald jemand in einem dieser branches neue changes pusht soll dieser job laufen

46:36.900 --> 46:42.180
Das nächste ist und pusht tags wenn eine neun tag pusht das ist das werden wir wahrscheinlich heute auch benutzen

46:42.540 --> 46:49.700
Wenn eine einen neuen tag pusht dann sollen die soll das sollen die jobs laufen und das dritte ist so eine art grondjob alle

46:49.820 --> 46:51.820
Viertel stunde

46:52.660 --> 46:56.540
In fusion ich weiß nicht genau was du meinst meinst du dass du das selbst aus dass du das selbst hausen kannst doch das gibt's

47:01.940 --> 47:07.780
Ja und da gibt es und wie gesagt da gibt es noch so eine art grondjob dass man sagen kann alle viertel stunde ausführen oder einmal am

47:07.780 --> 47:12.580
Tag oder einmal um zwei uhr nachts und sowas das gibt es auch das verwenden wir zum beispiel auf

47:12.580 --> 47:19.460
Haben wir zumindest ich muss jetzt sagen auf meine alten arbeit verwendet wobei auf meiner aktuellen arbeit heute bin ich heute also ich bin ja ich bin ja noch

47:19.500 --> 47:26.820
Ich bin ja noch drei stunden und 25 minuten dort angestellt ja also bei meiner aktuellen arbeit haben wir das auch verwendet um beispielsweise

47:28.020 --> 47:30.020
automatisiert alle viertel stunde

47:30.300 --> 47:33.980
irgendwelche inventar hostlisten zu erstellen aus mehreren datenquellen

47:34.460 --> 47:39.340
Es ist tatsächlich sehr nützlich github actions nicht nur für das bauen von software sondern für alles mögliche

47:40.820 --> 47:45.620
Ja so und ich glaube das war es jetzt eigentlich so was man an basics zu github actions wissen muss

47:45.740 --> 47:48.460
Fangen wir mal an uns das uns das ganze anzugucken

47:49.780 --> 47:53.380
Ich überlege gerade gibt es noch gibt es noch irgendwas also wir fangen jetzt simpel an

47:58.380 --> 48:03.980
Achso in future habe ich noch nie gemacht das habe ich das habe ich noch nicht so ausprobiert keine ahnung

48:04.380 --> 48:05.820
Ok

48:07.260 --> 48:09.540
Alles klar so ich überlege gerade gibt es so etwas was manくs thấy

48:10.660 --> 48:10.820
Es tut mir leid dass es gibt etwas wacha

48:11.140 --> 48:12.240
Das macht überhaupt nichts besser

48:13.540 --> 48:14.940
aber

48:14.940 --> 48:17.540
wenn ich mal erscheint

48:17.680 --> 48:23.640
In die

48:23.640 --> 48:25.760
diaw Rogue

48:28.180 --> 48:31.060
Ganz schnell

48:31.660 --> 48:38.220
Alles klar so ich überlege gerade gibt es so irgendwas was ich im vorfeld sagen muss ich glaube nicht

48:45.780 --> 48:49.740
Ach ja doch eine sache eine sache sollte ich noch im vorfeld sagen

48:51.540 --> 48:59.900
Dadurch dass das ganze recht eng verzahnt ist mit github also sprich die jobs sind im gleichen repo definiert wie das sourcecode

49:01.700 --> 49:05.660
Können diese jobs auch auf viele github

49:06.980 --> 49:12.180
Interne sachen zugreifen oder auf viele infos die in github gespeichert sind zugreifen was enorm praktisch ist

49:12.620 --> 49:19.620
Zum beispiel könnt ihr wenn ihr die passenden permissions anfordert mit eurer action das ist eine wissenschaft für sich deswegen erwähne ich jetzt einfach

49:19.620 --> 49:21.340
nur mal und

49:21.340 --> 49:25.420
Teilweise muss man manche sachen in den settings freigeben aber ihr könnt dort zum beispiel

49:25.980 --> 49:32.900
Für eine action ein one-time-talken bekommen wo ihr dann in eine container registry pushen könnt das heißt ihr müsst euch nicht irgendwie um die

49:33.540 --> 49:37.380
Alternifizierung über die github api und sowas kümmern das steht alles in der action zur verfügung

49:37.700 --> 49:44.900
Ihr könnt beispielsweise auch zugreifen ihr guckt ihr seht noch sie hier hier hier sieht man es wunderbar ich lock mich hier in der github container registry

49:44.900 --> 49:50.540
Ein und zwar gibt es hier zwei globale variablen die in dieser action zur verfügung gestellt werden einmal

49:50.740 --> 49:58.340
Username github repository owner das bin ich und einmal secrets github talken das ist nichts was im vorfeld angelegt werden muss

49:58.340 --> 50:00.340
das injected github

50:00.420 --> 50:09.260
Dynamisch beim start der action in ja als als environment variablen quasi dass ich sie da drin benutzen kann das heißt man kann viele sachen die github zur

50:09.260 --> 50:10.580
verfügung stellt

50:10.580 --> 50:17.100
Relativ easy ohne dass man sich mit der github api beschäftigen muss direkt aus github actions benutzen wir dürfen nicht vergessen

50:17.660 --> 50:19.660
github hat mittlerweile eine menge

50:19.980 --> 50:21.980
Was es gibt

50:22.100 --> 50:24.820
Also neben pull requests issues

50:25.940 --> 50:27.620
wikis

50:27.620 --> 50:29.620
verschiedene bild environments

50:29.740 --> 50:31.740
deployment container registry

50:33.860 --> 50:40.820
Releases alles mögliche was man über die github api steuern kann kann man relativ einfach aus github actions an

50:42.740 --> 50:46.940
Anfahren ja ohne dass man sich da im detail mit beschäftigen muss wie das ganze funktioniert

50:47.700 --> 50:54.140
Und ein weiterer vorteil und das gucken wir uns heute heute an ein weiterer vorteil von github actions ist

50:54.580 --> 50:56.340
dass es sehr viele

50:56.340 --> 51:00.660
Actions schon vorgefertigt gibt man muss nämlich nicht wie bei jenkins

51:00.940 --> 51:06.020
alles von hand machen sondern es gibt viele actions die sind schon fix und fertig

51:06.300 --> 51:10.140
das kann man sich nämlich zum beispiel angucken wenn man auf den marketplace geht

51:11.140 --> 51:13.140
und dann mal reinguckt

51:13.340 --> 51:15.340
damit man es mal geplendet

51:16.340 --> 51:18.660
Und dann sieht man guckt mal da es gibt

51:20.100 --> 51:24.500
17910 vorgefertigte actions gut die meisten davon wird man wahrscheinlich

51:25.580 --> 51:29.020
wird wahrscheinlich nie verwenden aber wenn man hier mal

51:31.940 --> 51:33.940
Durchguckt

51:37.820 --> 51:43.500
Ja es ist es sehr nahe es gibt zum beispiel eine action wo man seinen source code prüfen lassen kann auf

51:44.500 --> 51:50.300
Nein das meine ich nicht ob man auch sich an die coding guidelines gehalten hat und

51:52.420 --> 51:54.420
Dass man sein output cashen kann

51:55.140 --> 52:02.020
Und dass man neue github pages anlegen kann dass man sich psh irgendwo hin verbinden kann und solche geschichte das ist halt alles schon fix

52:02.020 --> 52:06.260
Und fertig ich muss dann meistens nur zwei drei variablen als in input

52:06.860 --> 52:12.500
hinzufügen und dann geht das ist natürlich schon enormer vorteil wenn man sich das hier anguckt also man kann relativ sicher sein

52:12.660 --> 52:19.100
Wenn man jetzt keinen ganz super abstrakten anwendungspfahl hat dann gibt es wahrscheinlich schon was zu

52:20.460 --> 52:25.260
Und wir gucken übrigens jetzt aber ob es was für art user repos gibt das habe ich nämlich noch nie nachgeguckt

52:26.780 --> 52:31.020
Aber publisch gibt es hier zum beispiel okay wir sorten mal nach maus start

52:31.540 --> 52:36.660
Bild auf packet ist publisch auch okay nicht so wahnsinnig nicht so wahnsinnig beliebt

52:37.660 --> 52:44.620
Aber ihr seht es gibt eine fix und fertige action aha das nice können wir später vielleicht verwenden es gibt eine fix und fertige action wie ich

52:44.620 --> 52:50.180
Im art user repo dann meine gebaute software veröffentlichen kann gibt es auch was für cobalt wasch gucken wir ziemlich sicher gibt es was für cobalt

52:50.180 --> 52:56.260
Das heißt es muss muss ich dann gar nicht mehr von hand machen sondern kann es einfach über diesen job machen die jobs selber

52:56.260 --> 53:01.500
Also die nicht die jobs die die actions selber die sind auch alle versioniert ihr seht hier

53:01.500 --> 53:03.500
Den den link zum

53:04.140 --> 53:08.540
Zum jeweiligen github repo wo es das ganze gibt aktuell ist version 2.7 2

53:09.180 --> 53:11.180
Und wenn ihr hier unter

53:11.180 --> 53:16.540
Wo sie möglich tags kann man auch gucken wenn man sich jetzt anguckt die sind die dinger sind immer getagged

53:17.020 --> 53:21.180
Das heißt man kann sich sicher sein und das finde ich ist wirklich eine coole sache

53:21.660 --> 53:26.340
Wenn man seine actions die man verwendet also die sachen die andere leute schon haben

53:26.420 --> 53:31.380
Wenn man die taggt mit einem mit einem version stack dann kann man sich sicher sein

53:32.020 --> 53:34.020
dass auch bei updates

53:34.340 --> 53:40.900
Der eigene workflow hier weiterhin funktioniert also sprich wenn ich jetzt zum beispiel sage hier ich verwende die

53:42.020 --> 53:44.020
die action für

53:44.340 --> 53:46.820
dort net installieren in meiner ubuntu vm

53:48.100 --> 53:49.980
Und die habe ich festgelegt hier die action

53:50.460 --> 53:52.820
Dort net installieren in meiner ubuntu vm

53:54.220 --> 53:57.940
Und die habe ich festgelegt hier action nennt sich dort net setup

53:58.460 --> 54:05.460
Version 3 dann heißt das der verwendet ich glaube version 3 bedeutet bedeutet dass der auch patch version nimmt

54:06.260 --> 54:13.380
Da kann ich mir sicher sein selbst wenn die diesen parameter umbenannt haben in einer der neueren versionen dadurch dass ich explizit hier

54:14.100 --> 54:16.100
referenziere auf v3

54:16.420 --> 54:20.580
Dass das eben nicht so ist dass das weiter funktioniert und das ist wirklich eine coole geschichte

54:21.900 --> 54:25.660
So und jetzt das letzte damit sich der chat freut

54:28.580 --> 54:32.980
Marketplace github actions wir gucken mal nach cobalt

54:34.900 --> 54:39.940
Setup cobalt guck mal hier sogar für cobalt gibt es was also es gibt wirklich für alles was

54:40.940 --> 54:46.820
Also wenn sogar wenn sogar für cobalt was fertiges drinne ist da kann es dir sicher sein du wirst für das meiste was finden

54:49.980 --> 54:54.820
Jetzt braucht man nur noch die action um die action zu updaten du wirst lachen das gibt es

54:57.020 --> 55:01.260
Nennt sich nennt sich renovate unter anderem gibt es gibt es dafür gibt es gibt es dafür

55:03.780 --> 55:05.780
Das ist das richtige renovate

55:05.780 --> 55:07.780
Kannst du benutzen für sowas

55:09.980 --> 55:11.980
Renovate scannt dein repo

55:12.780 --> 55:17.740
Nach config files die versionsnummern enthalten und macht dann einen pull request in einem repo auf

55:18.140 --> 55:24.060
Ob du nicht die versionsnummer updaten willst ich kann dir das sogar in action zeigen ich glaube wir haben das sogar in einem repo mal kurz getestet

55:24.660 --> 55:26.660
Ja hier sieht man es hier sieht man es

55:29.660 --> 55:31.660
Pull requests

55:32.660 --> 55:34.660
Pull requests

55:36.980 --> 55:39.940
Genau so so sieht das so sieht das ganze aus

55:41.540 --> 55:45.380
Also renovate hat mein repo gecheckt hat festgestellt es gibt eine datei

55:45.740 --> 55:52.060
Wo eine versionsnummer hardcoded drin steht und da gibt es jetzt eine neue version möchte ich das möchte ich das ganze nicht updaten

55:52.060 --> 55:55.500
Und soweit ich weiß kann renovate auch github action files

55:55.500 --> 55:59.660
Das heißt ich kann mit renovate github act ich kann mit der github github

56:00.780 --> 56:06.380
Mit der renovate bot github action kann ich an kann ich den restlichen github actions updaten lassen

56:07.180 --> 56:09.500
Dann wird es dann wird aber extrem feif her

56:12.020 --> 56:14.020
Das ist das ist schon sehr nice

56:17.980 --> 56:21.140
So dass mal kurz in ob's jetzt habe ich das irgendwie zugemacht

56:21.620 --> 56:24.880
So dass mal kurz in ob's jetzt habe ich das irgendwie zugemacht

56:26.660 --> 56:29.300
Das mal kurz cobalt gucken set up cobalt

56:29.940 --> 56:34.540
This action sets up a set up a new cobalt programming language environment

56:36.660 --> 56:41.220
Nice gut lange rede kurzer sinn ich guck mal kurz in discord

56:42.340 --> 56:44.980
Hat keiner geschrieben heute also anscheinend gibt es

56:46.260 --> 56:48.260
Kein kreisel grind

56:51.140 --> 56:53.140
Na dann

56:54.700 --> 56:57.780
I put the action in my action to action while action

57:00.420 --> 57:03.740
Ja genau genau hier sieht man das hier sieht man es

57:12.700 --> 57:17.580
Gut dann fangen wir mal an ich würde sagen wir fangen mal sehr simpel an

57:18.580 --> 57:24.460
Und zwar legen wir eine wir machen mal kurz wir machen mal einen neuen branche davon

57:26.020 --> 57:28.020
geht pull github

57:30.220 --> 57:32.220
Wir haben den def branche

57:35.580 --> 57:42.300
Haben wir dinger gemacht brauchen wir alles nicht mehr geht wenn ich jetzt richtig schreiben kann geht check out

57:42.420 --> 57:48.620
Out master geht branche minus d def

57:49.740 --> 57:52.800
Jetzt pull github master

57:57.260 --> 58:01.740
Aktuell stand geht check out wobei ich ich hoffe ich habe meine alias hier

58:02.420 --> 58:05.420
geht check out minus b def

58:05.980 --> 58:07.980
Ich habe meine alias hier

58:08.140 --> 58:11.820
So jetzt haben wir in def branche und ich würde sagen da legen wir jetzt mal eine

58:13.780 --> 58:15.780
Github action drin an

58:16.540 --> 58:21.820
Und wie gesagt damit github actions funktionieren muss das ganze in diesem verzeichnis liegen

58:22.500 --> 58:26.140
github slash workflows also wir sind hier in

58:28.500 --> 58:32.260
Quasi in diesem repo drinne jetzt ich habe das lokal bei mir geklont also

58:32.740 --> 58:40.260
Mk dir github also versteckter ordner github mk dir workflow workflows oder workflow

58:41.860 --> 58:43.620
Workflows

58:43.620 --> 58:47.660
Workflows und da können wir jetzt was drin anlegen zum beispiel eine

58:48.620 --> 58:50.620
Ja bild punkt jammel

58:51.340 --> 58:56.180
Leere datei macht noch nichts wir schreiben jetzt was ganz simples rein

58:56.620 --> 59:00.780
Und zwar also wir machen jetzt auch gar nicht viel in diese action dass man sieht dass es funktioniert

59:00.980 --> 59:04.660
Das ding braucht ein name dass es das es funktioniert

59:07.460 --> 59:12.420
Gibt es für die workflows es gibt lokale runner ja zum beispiel das hier

59:14.700 --> 59:21.620
Machen wir aber heute nicht also du kannst github actions lokal ausführen du kannst diesen runner in deinem repo auch registrieren

59:21.980 --> 59:27.500
Dass es dann da drüber ausgeführt wird aber da muss man ein bisschen vorsichtig sein also falls ihr auf die idee kommt

59:27.820 --> 59:33.500
Bei einem public repo einen lokalen runner zu verwenden da müsst ihr euch im klaren drüber sein

59:34.060 --> 59:38.260
Dass es quasi in einem public repo jemand zugriff auf eine lokale vm

59:39.100 --> 59:45.820
Über umwege bei euch bekommt also da müsst ihr euch das wirklich überlegen ob ihr das so machen wollt zum beispiel wenn ihr das eingestellt

59:45.820 --> 59:47.820
Habt dass bei jedem pull request

59:48.260 --> 59:55.060
Irgendetwas ausgeführt wird so und ihr habt jetzt ein public repo und lokalen runner dort registriert und irgendjemand

59:55.580 --> 59:57.180
pusht jetzt

59:57.180 --> 01:00:00.980
ein pull request oder macht ein pull request auf und hat dort

01:00:01.460 --> 01:00:06.620
Irgendein mist in den mist drinne stehen dann führt das euer lokaler runner aus und im zweifelsfall

01:00:07.020 --> 01:00:13.620
Könnte das negative auswirkung haben auf eure lokale umgebung also mit public repos und lokalen runner muss man ein bisschen aufpassen

01:00:13.620 --> 01:00:15.620
Mit den cloud runner ist das kein problem

01:00:21.140 --> 01:00:24.260
Wir nehmen uns einfach mal ein beispiel hier aus dem

01:00:25.940 --> 01:00:27.940
Die hälfte

01:00:28.980 --> 01:00:36.500
Boah man die schwätzen eigentlich hier voll im leben okay ich mach die ich mach die minimal action selbst hat hat keinen sinn also

01:00:38.740 --> 01:00:40.740
Wir pushten das ding einfach

01:00:41.580 --> 01:00:48.420
Wir pushten das ding einfach dort net heißt es beim pamphlet so wir bauen jetzt einfach bild ist egal wie das heißt

01:00:50.180 --> 01:00:53.540
Rest editieren wir über github weil dann sieht man das ganze ein bisschen schöner

01:00:54.380 --> 01:00:56.380
geht status geht

01:00:56.740 --> 01:00:58.740
so was haben wir denn

01:00:58.900 --> 01:01:00.900
geht komm mit

01:01:01.460 --> 01:01:07.340
bester temp bester name so heißt das jetzt temp git push github def

01:01:08.340 --> 01:01:10.840
Okay so github actions

01:01:12.060 --> 01:01:17.380
Temp oh nein temp ist fehlgeschlagen also wir sehen jetzt an der an der stelle schon mal zwei sachen

01:01:19.340 --> 01:01:27.700
Wir haben in unserem def branche einen workflow oder einem github action angelegt beziehungsweise workflow angelegt mit dem namen bild

01:01:29.100 --> 01:01:31.100
Leider steht halt noch sonst nichts drinne

01:01:32.020 --> 01:01:39.460
Und sobald man das gemacht hat seht ihr hier taucht unter actions was auf und zwar dass es fehlgeschlagen ist

01:01:39.620 --> 01:01:44.620
Ja gut es ist völlig fehlgeschlagen weil naja es steht ja auch noch gar nicht drinne was gemacht werden soll

01:01:45.740 --> 01:01:47.740
Das musste ja im endeffekt fehlschlagen

01:01:49.860 --> 01:01:52.020
Jetzt können wir das ganze hier über github editieren

01:01:52.700 --> 01:01:59.460
Waren wir mal ein bisschen ein bisschen größer hier die schlagen einem die schlagen einem hier auch beispielsweise immer sachen vor wenn man selbst nicht genau

01:01:59.460 --> 01:02:03.300
Weiß wie das funktioniert aber am besten ist am besten man guckt einfach auf marketplace

01:02:04.420 --> 01:02:06.660
Wie das wie das wie das ganze funktioniert

01:02:09.780 --> 01:02:13.780
Also wir fangen jetzt ganz simpel an abriss johnny moin

01:02:15.980 --> 01:02:22.820
Wir üben actions ja champ gut dass du da bist aber nicht teste dass ich teste das ganze nicht lokal

01:02:23.820 --> 01:02:30.180
Also das erste was man angehen muss für so eine action ist wann die ausgeführt werden soll das habe ich euch ja eben schon gezeigt

01:02:30.420 --> 01:02:36.780
Es ist jammel es ist auch alles dofe dabei was jammel so ausmacht eindrückungen die nicht stimmen und sowas

01:02:37.100 --> 01:02:44.500
Ja man ist ja heutzutage immer jammel engineer als irgendwas anderes insofern ist es selbst das hier natürlich auch selbstverständlich jammel was sonst

01:02:44.580 --> 01:02:48.780
So und jetzt kann man hier sagen zum beispiel und push jetzt müssen wir uns überlegen ok

01:02:49.780 --> 01:02:51.700
Wann wollen wir

01:02:51.700 --> 01:02:53.700
dass unsere software gebaut wird

01:02:54.180 --> 01:03:00.580
Bei jedem push alle viertel stunde bei einem tech push in der regel würde ich sagen entweder

01:03:00.860 --> 01:03:05.300
Alle einmal am tag für irgendwie so ein daily bild nachts das können wir nachher auch machen

01:03:05.620 --> 01:03:11.540
Oder aber bei einem push von einem tech wenn es eine neue version gibt gibt es in der regel einen neuen tech

01:03:11.860 --> 01:03:16.140
Also könnte man sagen ok wir wollen unsere software bauen lassen wenn es einen neuen tech gibt

01:03:16.500 --> 01:03:18.500
Und das funktioniert folgendermaßen

01:03:20.340 --> 01:03:23.740
Moment ich habe das falsch geschrieben muss ja auch texte vor habe ich vergessen so

01:03:24.620 --> 01:03:32.060
Ich kann sagen und push wenn neue text gepusht werden und dann kann man wildcards verwenden wenn ein tech gepusht wird der mit v

01:03:32.060 --> 01:03:37.620
anfängt das heißt wenn wir unsere unsere software jetzt taggen zum beispiel mit

01:03:38.740 --> 01:03:40.740
V

01:03:42.740 --> 01:03:44.740
3 oder sowas

01:03:46.220 --> 01:03:53.540
Ja genau ganz toll und das dann pushen dann wird github actions erkennen aha siehe an

01:03:55.340 --> 01:04:00.340
Da hat er mal den tech gepusht und der workflow match darauf deswegen führen wir jetzt den workflow aus

01:04:02.420 --> 01:04:05.260
Also wir wollen das ganze ausführen wenn ein tech gepusht wird

01:04:06.780 --> 01:04:08.780
Als nächstes muss man angeben

01:04:09.900 --> 01:04:12.700
Permissions falls man welche braucht brauchen wir jetzt erstmal nicht

01:04:12.860 --> 01:04:17.500
Jetzt muss man seine jobs definieren also jobs ist im endeffekt das was ausgeführt werden soll

01:04:18.180 --> 01:04:23.940
definieren wir mal ein job bild es kann ja durchaus sein dass man mehrere jobs hat zum beispiel ein job für bild

01:04:25.620 --> 01:04:31.940
Und ein job für oder was weiß ich bild man könnte sagen man hat einen job für bild

01:04:34.820 --> 01:04:41.100
Amd 64 und bild raspberry pi oder sowas ja keine verschiedene verschiedene jobs geben

01:04:42.100 --> 01:04:44.100
Jobs können

01:04:47.660 --> 01:04:52.780
Wenn man das wenn man das richtig definiert können jobs parallel ausgeführt werden

01:04:55.820 --> 01:04:57.820
Innerhalb eines jobs

01:05:01.620 --> 01:05:08.900
Ist allerdings alles streng sequenziell ja genau man könnte erst testen dann bilden und wenn man das je nachdem wie man das angibt kann

01:05:09.260 --> 01:05:11.940
Jobs parallel ausführen lassen also man kann zum beispiel

01:05:12.740 --> 01:05:15.860
ein bild wenn man jetzt sagen würde ich will meine software bauen für

01:05:17.180 --> 01:05:19.180
x86 64

01:05:19.620 --> 01:05:24.760
Und ja bla bla bla und dann habe ich noch einen bild shop für bild

01:05:28.260 --> 01:05:33.900
Bild arm oder sowas das würde funktionieren das kann man wenn man es richtig definiert

01:05:35.340 --> 01:05:37.340
Dann auch

01:05:39.100 --> 01:05:41.900
Parallel laufen lassen aber das machen wir nicht wir machen heute einen job

01:05:42.540 --> 01:05:47.060
Wir machen also ein workflow mit einem job drinne und der ist dafür da um die software zu bauen

01:05:47.540 --> 01:05:51.740
Gut jetzt muss ich noch angeben ich glaube hier gibt sogar autocomplete wenn man control

01:05:52.420 --> 01:05:58.140
Leertaste drückt kriegt man kriegt man hier bei github ein bisschen ein bisschen autovervollständigung was an der stelle erlaubt ist

01:05:59.980 --> 01:06:05.420
So wir wollen haben run runs on aber du hörst dann auch schon wieder auf mit autocomplete

01:06:05.980 --> 01:06:11.060
Da gibt es an der stelle nur was uns interessiert und to latest

01:06:13.300 --> 01:06:19.260
Github actions vms man hat auch irgendwo eine übersicht was es gibt

01:06:21.340 --> 01:06:23.340
Ubuntu

01:06:27.420 --> 01:06:30.060
Genau also folgende folgende sachen stehen zur verfügung

01:06:30.500 --> 01:06:36.100
Die man hier benutzen kann die github für einen kostenlos zur verfügung stellt bis zu 500 minuten

01:06:36.900 --> 01:06:43.420
Bis zu 2000 minuten im monat also man kann das ganze entweder unter windows server bauen lassen man kann das ganze laufen lassen

01:06:43.420 --> 01:06:49.420
Und dann ist oder man kann das ganze unter ubuntu laufen lassen bunt gibt es latest das zeigt immer auf das letzte

01:06:49.780 --> 01:06:56.740
Lts release in dem fall ist es 2204 also man könnte wenn ich hier auf nummer sicher gehen will dass es immer mit dem gleichen

01:06:57.180 --> 01:07:02.900
Den gleichen voraussetzungen ausgeführt wird kann ich auch sagen ich will ubuntu 2204 anstatt

01:07:03.140 --> 01:07:06.100
Also es könnte ja sein dass jetzt demnächst irgendwann ubuntu

01:07:06.820 --> 01:07:12.980
24 04 rauskommt das nächste lts ist 24 04 dauert noch ein jahr aber ziemlich so bald

01:07:13.500 --> 01:07:20.300
Demnächst in einem jahr 24 und dann könnte es ja sein dass mein workflow nicht mehr funktioniert weil ich auf irgendwelche

01:07:20.500 --> 01:07:26.660
Eigenheiten zurückgreife von ubuntu 22 04 die sich dann in 24 04 geändert hat das heißt man kann auch hier

01:07:27.580 --> 01:07:30.220
Relativ statisch reinschreiben was man haben wird muss sagen ok

01:07:30.700 --> 01:07:36.020
Worauf soll denn dieser job ausgeführt werden und zwar auf einer vm mit ubuntu 22 04

01:07:36.300 --> 01:07:41.940
So und jetzt als nächstes muss ich meine build steps definieren also sprich was soll nacheinander

01:07:42.740 --> 01:07:49.820
Ausgeführt werden die erste action die man nahezu immer braucht deswegen copy copy paste ich die mir auch die erste action die man

01:07:49.820 --> 01:07:51.820
nahezu immer braucht ist die hier

01:07:52.660 --> 01:08:00.140
Check out repo beziehungsweise check out action die check out action macht nichts anderes wie den inhalt von eurem repo

01:08:01.740 --> 01:08:05.060
In die vm hier zu kopieren

01:08:05.540 --> 01:08:10.980
Und nachdem wir in der regel immer was machen wollt mit dem inhalt des repos wobei nicht immer

01:08:11.100 --> 01:08:17.460
Es gibt ja durchaus auch leute haben ich euch ja gerade erzählt dort wo ich aktuell noch arbeite für drei stunden nicht für

01:08:17.900 --> 01:08:19.580
vier stunden noch genau

01:08:19.780 --> 01:08:23.900
Für vier stunden und für vier stunden und ne für drei stunden und vier minuten

01:08:25.980 --> 01:08:30.540
Kann ich rechnen für vier stunden und vier minuten das macht quasi einen git clone im endeffekt genau

01:08:30.860 --> 01:08:34.500
ich also dort wo ich auch für vier stunden arbeite wir benutzen das zum beispiel um

01:08:35.220 --> 01:08:40.940
Inventarlisten zu generieren alle viertel stunde und dass man muss nicht zwangsläufig den repo inhalt kopieren aber

01:08:42.500 --> 01:08:49.380
Du willst ja meistens den kram aus deinem repo benutzen das heißt die erste action die man nahezu immer braucht ist den repo inhalt

01:08:49.820 --> 01:08:51.820
in die ubuntu vm kopieren

01:08:52.820 --> 01:08:54.500
immer

01:08:54.500 --> 01:08:56.500
im endeffekt also

01:08:56.860 --> 01:09:01.300
Ich glaube ich habe ich habe keine action am start wo das nicht mindestens gemacht wird

01:09:02.140 --> 01:09:04.940
so und jetzt können wir uns mal angucken

01:09:06.660 --> 01:09:10.180
Das war schon mehr müssen wir an der stelle gar nicht machen jetzt können wir uns mal angucken

01:09:10.700 --> 01:09:17.660
Wie man kommandos da drin ausführt weil es gibt ja nicht zwangsläufig für alles vorgefertigte actions was man machen will das wäre ja

01:09:17.700 --> 01:09:19.700
Blöd wenn die einfachsten sachen

01:09:20.300 --> 01:09:26.120
Nicht möglich wären von hand auszuführen und es für alles in der action braucht was man jetzt machen kann ist folgendes man kann

01:09:26.120 --> 01:09:29.780
Einen neuen step anlegen nennen wir jetzt mal command command keckel

01:09:30.740 --> 01:09:33.180
und das kriegt eine ein ein

01:09:34.740 --> 01:09:38.140
Sieht das hier feld run und da kann man jetzt

01:09:39.060 --> 01:09:41.660
Befehle beziehungsweise shell befehle reinschreiben

01:09:42.100 --> 01:09:46.460
Das ist jammel synthax wenn man hier so einen pipe dahinter macht ist das was da drunter kommt ein

01:09:47.300 --> 01:09:52.100
Multi multiline string das heißt ich kann jetzt einfach hier sowas machen wie lsl a

01:09:53.060 --> 01:09:55.060
echo 1 2 3

01:09:58.100 --> 01:10:00.100
Jaja

01:10:00.260 --> 01:10:02.460
huge and prams ab so

01:10:03.260 --> 01:10:08.460
Kann ich jetzt machen jetzt speichere ich das ganze mal und dann gucken wir uns an ob es funktioniert

01:10:12.660 --> 01:10:18.300
Dann baut github das in einer eigenen vm kurz zusammen richtig github actions

01:10:19.860 --> 01:10:21.860
Übergibt das an den runner

01:10:25.700 --> 01:10:32.140
Wir müssen es gar nicht so kompliziert sagen github github actions startet eine vm und führt den kram hier drinnen aus genau

01:10:32.900 --> 01:10:34.900
Ja so jetzt

01:10:35.180 --> 01:10:39.580
Committen wir das ganze mal wenn man jetzt in actions guckt passiert noch nichts

01:10:42.260 --> 01:10:45.220
Also wenn man jetzt jetzt passiert noch nix an der stelle

01:10:45.940 --> 01:10:49.340
Warum chat wer wer hat ahnung warum noch nix passiert

01:11:07.980 --> 01:11:09.180
Kein tag richtig

01:11:10.180 --> 01:11:12.100
Kein tag richtig

01:11:12.100 --> 01:11:17.820
Mach workflow dispatch dann ist es einfacher workflow dispatch ist dass man einen knopf hat zum manuell starten

01:11:24.740 --> 01:11:28.220
Aber das ist richtig chat es gibt noch kein tag also das heißt hier an der stelle

01:11:29.220 --> 01:11:32.980
An der stelle hier gibt es noch nix das heißt wenn wir jetzt

01:11:33.500 --> 01:11:39.100
Sonst musst du immer taggen ja können wir gleich einfügen aber du hast recht es ist sinnvoll das einzufügen

01:11:39.180 --> 01:11:44.380
Aber jetzt erst einmal zeigen wir mal dass das auch prinzipiell funktioniert alles so das heißt wenn ich das ganze jetzt tagge

01:11:44.780 --> 01:11:46.780
Ich ich ich pull mal kurz

01:11:48.180 --> 01:11:50.580
So wenn ich jetzt wenn ich jetzt sage

01:11:51.940 --> 01:11:53.700
Gith tag

01:11:53.700 --> 01:11:57.500
Minus a ja machen wir das hier mal minus a minus m

01:11:59.020 --> 01:12:04.860
V3 neue version wird getaggt und dann pushen wir die pushen wir den tag

01:12:06.180 --> 01:12:08.340
Ich will ich zu origin ich will zu

01:12:09.980 --> 01:12:11.540
Github

01:12:11.540 --> 01:12:13.140
Ja

01:12:13.140 --> 01:12:15.020
Po tag

01:12:15.020 --> 01:12:17.020
Alter

01:12:17.060 --> 01:12:19.060
Ok

01:12:19.260 --> 01:12:21.460
Gith tag minus d

01:12:23.300 --> 01:12:27.380
Ich löscht das ding jetzt einfach geht push geht ab minus minus delete

01:12:28.140 --> 01:12:32.860
V0.0.3 ignoriert es einfach mal jetzt ist der tag weg und wird neu gepusht

01:12:33.260 --> 01:12:38.240
So jetzt habe ich meine software neu getaggt neu gepusht und ihr werdet feststellen bäm

01:12:40.180 --> 01:12:43.740
Da tut sich was da läuft jetzt was

01:12:44.340 --> 01:12:51.140
Das dauert jetzt ein bisschen bis das ganze startet das ding muss eine vm für uns anlegen beziehungsweise muss erst mal uns warten bis platz

01:12:51.140 --> 01:12:53.780
Auf vorgefertigten vms ist je nachdem wir dies intern

01:12:54.220 --> 01:13:00.300
gemacht haben aber ihr seht auch der job ist durchgelaufen es ist ja auch nicht viel passiert hier setup job

01:13:02.060 --> 01:13:05.700
Checkout repo den step hat er gemacht er hat quasi unser repo geklont

01:13:10.020 --> 01:13:19.140
Wo man es genau sieht hier in ich in ich leise den repo fett schrieb und das ist er repo geklont und dann hat er

01:13:19.140 --> 01:13:23.500
Unseren keckel step ausgeführt der im prinzip genau das gemacht hat was wir reingeschrieben haben

01:13:23.980 --> 01:13:29.940
ls ls minus la auf root und 1 2 3 rr q chat primes ab ausgegeben

01:13:30.900 --> 01:13:35.220
Das ist übrigens der moment chat wenn es euch gefällt und weiterhilft

01:13:36.220 --> 01:13:38.220
Wo ihr primes haben könnt

01:13:38.220 --> 01:13:40.060
Aber natürlich nicht müsst

01:13:40.060 --> 01:13:45.740
Trotzdem wenn ihr den primes habt nicht dass ich mich nicht drüber freuen würde oder so ihr könnt in mir gerne geben ich habe da

01:13:45.740 --> 01:13:49.060
Keine schmerzen mit ich finde das freue mich über jeden primes ab aber

01:13:50.620 --> 01:13:57.740
Ihr solltet euren primes ab zumindest verwenden einmal im monat wenn auch nicht wenn auch nicht unbedingt jetzt auf mich weil ansonsten überweist

01:13:57.740 --> 01:14:00.980
Ihr direkt 2 euro 50 an besos das wollt ihr wahrscheinlich nicht

01:14:01.460 --> 01:14:06.620
Deswegen könnt ihr euren primes ab irgendwo auf twitch raushauen ich freue mich natürlich auch wenn ich euren primes abklicke

01:14:09.060 --> 01:14:11.540
Ab letztens einen workflow für einen

01:14:12.380 --> 01:14:14.860
cd prerelease für einen minecraft bot gemacht

01:14:15.140 --> 01:14:21.540
Hab aber noch keinen plan wie ich das wirklich bequem hinbekomme mit automatischer versionierung bezug auf meinen brandstruktur gut

01:14:21.780 --> 01:14:27.980
Das ist immer eine sehr individuelle sache das sagen die übrigens auch in ihrer hilfedatei das github actions eine

01:14:28.220 --> 01:14:31.180
Boah wie sagt die marketing abteilung von github dazu

01:14:35.020 --> 01:14:40.140
Github ich glaube die marketing abteilung von github nennt das github actions

01:14:42.980 --> 01:14:49.820
Ist ich kriege sie zusammen zu nennen zumindest nennen die das github actions ist choose your own adventure style

01:14:50.660 --> 01:14:57.060
Irgendjemand in der marketing abteilung dachte sich choose your own adventure ist eine gute beschreibung dafür wie github actions vom ansatz er ist

01:14:57.100 --> 01:15:04.300
Also was sie damit sagen wollen ist es gibt keine starre vorgefertigte struktur wie du bestimmte sachen machen muss sondern du musstest dir selbst

01:15:04.620 --> 01:15:07.140
zusammenstellen aus den aus den bauplöcken die da sind

01:15:07.740 --> 01:15:10.820
Was auch gut ist weil so kann man es ziemlich individuell anpassen

01:15:11.220 --> 01:15:15.820
Ja so dankeschön für den sub jonathan proga subscription und liest das normal

01:15:16.460 --> 01:15:17.980
auch am start

01:15:17.980 --> 01:15:19.980
dankeschön leute für die primes subs

01:15:20.940 --> 01:15:23.860
So und jetzt hat er das ganze ausgeführt was wir hier reingeschrieben haben

01:15:24.820 --> 01:15:26.820
was er machen soll so

01:15:27.740 --> 01:15:30.420
Das ist so ziemlich die simpelste form von einem

01:15:30.940 --> 01:15:35.980
Jcon dankeschön pox subscription jetzt kommt gleich der scam train um die ecke ich sehe schon hier

01:15:36.500 --> 01:15:37.900
pass auf

01:15:37.900 --> 01:15:39.900
der jebait train fährt an

01:15:43.460 --> 01:15:46.740
Oder an die stufe eins abgeschlossen

01:15:49.420 --> 01:15:54.180
Wo ist der jebait train hat kein bock mehr ach da oben ok

01:15:57.220 --> 01:16:04.220
So das ist jetzt so ziemlich die simpelste art und weise eine github actions anzulegen die es gibt also

01:16:04.660 --> 01:16:08.420
Ist ja nicht viel bei aber man sieht jetzt schon eine ganz coole sache hier dran

01:16:08.820 --> 01:16:16.420
Man könnte jetzt prinzipiell wenn man zum beispiel noch lokale jenkins jobs oder so was hat die nicht viel großartig kompliziertes machen

01:16:16.420 --> 01:16:19.100
noch nicht auf lokale ressourcen angewiesen sind

01:16:19.980 --> 01:16:26.380
Man könnte auch hier seine shell befehle reinschreiben das heißt man muss nicht zwangsläufig für alles eine action benutzen

01:16:26.900 --> 01:16:34.180
oftmals ist es auch einfacher wenn man drei vier befehle shell script reinschreibt und dann ist fertig das schöne ist dass es immer

01:16:34.740 --> 01:16:37.780
nachvollziehbar es muss nicht auf einer lokalen entwicklerkiste laufen

01:16:39.180 --> 01:16:43.060
Und es ist zentral im repo gepflegt also das hat schon hat schon seine vorteile

01:16:43.060 --> 01:16:47.700
Versand mal github actions zu sehen wie gesagt dafür habe ich github noch nicht soviel benutzt

01:16:50.860 --> 01:16:51.860
Ja

01:16:51.860 --> 01:16:57.900
Also man könnte jetzt alles man könnte jetzt alles mögliche machen man könnte jetzt zum beispiel auch sagen ihr drehen ab install

01:16:58.500 --> 01:17:01.620
oder sagt mir mal irgendein gutes package was man installieren könnte

01:17:02.300 --> 01:17:07.860
Aski aquarium gibt es leider gibt es leider gibt es leider nicht unter unter debian startmäßig also ist ja auch egal

01:17:07.860 --> 01:17:12.660
Also ist ja auch egal man könnte man könnte jetzt alles mögliche hier keine ahnung hardtop zum beispiel

01:17:12.660 --> 01:17:20.180
Man könnte jetzt alles mögliche hier installieren falls man das braucht für für seinen weitere weiteren schritt neo gibt gibt es neofetch

01:17:20.980 --> 01:17:22.980
neofetch

01:17:30.740 --> 01:17:37.660
Wo muss ein workflow workflow dispatch über ein workflow dispatch über ein workflow dispatch über ein workflow dispatch über ein workflow dispatch

01:17:37.860 --> 01:17:39.860
überhaupt hin hier oben

01:17:40.100 --> 01:17:42.100
ne wahrscheinlich

01:17:43.500 --> 01:17:45.500
Wo muss denn das hin

01:17:52.580 --> 01:17:54.580
Wo muss workflow dispatch hin

01:17:57.100 --> 01:18:02.260
Ach on ach so ja ist ja eigentlich logisch jaja

01:18:02.260 --> 01:18:04.260
Ja

01:18:06.700 --> 01:18:08.980
Und workflow dispatch inputs

01:18:13.660 --> 01:18:15.660
Kannst du leer lassen

01:18:16.060 --> 01:18:19.340
Ok also im prinzip so dann müsste es auch funktionieren

01:18:22.220 --> 01:18:24.220
Oder oder muss ich jetzt hier irgendwie

01:18:24.940 --> 01:18:26.940
Ne wahrscheinlich ich glaube nicht

01:18:28.100 --> 01:18:30.380
Ne muss man nicht verbrannt das muss man glaube ich auch nicht

01:18:32.260 --> 01:18:36.100
Es ist eine map und keine liste ok start kommet

01:18:37.820 --> 01:18:39.820
Zack

01:18:41.900 --> 01:18:49.340
Jetzt können wir hier zu actions zu actions gehen und das wahrscheinlich auch manuell triggern wo triggert man das jetzt manuell

01:18:51.380 --> 01:18:57.020
5 hat high IQ chats chatters wie triggert man das jetzt manuell

01:19:03.260 --> 01:19:06.140
Wer ist so high IQ nur ist das ich hab das noch nicht benutzt

01:19:09.180 --> 01:19:11.700
Man hier wenn man reinklickt kann man es rerun

01:19:14.340 --> 01:19:16.340
You don't

01:19:21.620 --> 01:19:25.340
Ja anscheinend anscheinend don'ten wir

01:19:25.340 --> 01:19:34.220
Aber gut gut das was das ist wahrscheinlich weil es nicht im master ist kann ich mir vorstellen vielleicht zählt nur das was im master ist

01:19:38.420 --> 01:19:43.980
Ist aber auch egal wir pushen einfach text und gut ist juckt mich juckt mich jetzt nicht weiter

01:19:45.380 --> 01:19:47.380
Dann nehme ich ich nehme das mal wieder raus

01:19:47.380 --> 01:19:54.740
Und editieren editieren wir das weiter mal lokal wir pushen wir pushen einfach neue text ist doch egal so pull

01:19:58.100 --> 01:20:00.180
Jetzt machen wir was ganz was ganz eklig ist

01:20:01.500 --> 01:20:03.500
Gits komm mit

01:20:04.780 --> 01:20:06.780
Minus a minus m

01:20:07.900 --> 01:20:09.900
Kekkel beste beste name

01:20:10.660 --> 01:20:14.580
Minus minus amend dass auch alles dran ist geht push

01:20:14.660 --> 01:20:17.220
Minus minus force bam in your face give him

01:20:21.380 --> 01:20:23.380
Als funst wieder getriggert

01:20:25.020 --> 01:20:28.100
So und jetzt werden wir sehen sagt es wieder gepusht

01:20:28.820 --> 01:20:31.860
Jetzt macht er genau das der installiert neo fetsch

01:20:33.060 --> 01:20:39.420
Und führt neo fetsch aus sofern es das package gibt wenn es fehlt schlägt falls es fehlt schlagen soll es nicht fehlen

01:20:39.500 --> 01:20:45.380
Und führt neo fetsch aus sofern es das package gibt wenn es fehlt schlägt falls es fehlt schlagen sollte wir gar nicht so

01:20:45.380 --> 01:20:47.380
schlecht es schlägt fehl nice

01:20:47.940 --> 01:20:49.940
nice weil

01:20:51.620 --> 01:20:53.340
Ich nicht gut bin ok

01:20:53.340 --> 01:20:59.820
Es ist gut zu sehen dass das ganze mal fehl schlägt weil so sieht das aus wenn irgendwie ein fehler drinne ist in euren in euren actions

01:21:00.060 --> 01:21:06.660
Das bricht einfach an der stelle ab aber ihr könnt euch im nachhinein immer noch den output angucken und gucken wo das ganze fehl

01:21:06.660 --> 01:21:08.660
geschlagen ist man muss sagen die

01:21:08.900 --> 01:21:15.580
Ausgabe von manchen konsolen tools sehen wir jetzt gleich auch wenn man docker content docker image bauen oder sowas die man die ausgabe von manchen

01:21:15.860 --> 01:21:19.180
Cli tools ist in github actions ein bisschen abartig

01:21:19.700 --> 01:21:25.060
Weil das ja kein terminal ist das heißt wenn du eine progress anzeige hast dann macht das pro progress update

01:21:25.460 --> 01:21:28.540
Eine neue zeile und spammt sich spammt sich hier erst mal voll

01:21:30.020 --> 01:21:34.020
Gut aber ich würde sagen dann machen wir was sinnvolles in unseren actions

01:21:34.700 --> 01:21:38.220
Wim github workflows nee nicht docker image

01:21:39.180 --> 01:21:46.020
Workflow bild so also was können wir denn sinnvolles machen das ziel heute ist ja dass wir unsere

01:21:48.220 --> 01:21:50.220
Software bauen

01:21:51.100 --> 01:21:54.580
Und dass wir zum im ersten im ersten zwischenschritt mal

01:21:55.180 --> 01:22:01.140
Ein bild hier in so einem workflow veröffentlichen das geht nämlich man kann aus einem workflow

01:22:02.300 --> 01:22:07.140
Die software die man gebaut hat quasi exportieren das nennt sich ein artefakt

01:22:07.620 --> 01:22:14.220
Und das hängt dann wenn man hier unter summary geht man sieht jetzt noch nichts weil ich nichts exportiert habe hier unter summary steht dann unten

01:22:14.220 --> 01:22:19.020
Noch der output der binary output also quasi das kompilierte von von dem job

01:22:19.620 --> 01:22:25.420
Das ist so das erste zwischendritt bevor wir uns das art user repo angucken weil da habe ich dann echt keine ahnung wie es funktioniert

01:22:25.860 --> 01:22:27.860
wie das funktioniert also

01:22:28.300 --> 01:22:34.260
Machen wir diesen blödsinn machen wir diesen blödsinn mit neo fetsch mal wieder weg also wie bauen wir

01:22:34.260 --> 01:22:38.700
Unsere software aktuell bauen wir unsere software so

01:22:39.380 --> 01:22:43.580
Kann ich euch mal zeigen es gibt ein docker feil da passiert folgendes drin

01:22:44.380 --> 01:22:48.180
Er nimmt cento s7 als grundlage warum cento s7

01:22:54.820 --> 01:22:59.780
Er nimmt cento s7 als grundlage warum cento s7 das kann ich mal schnell erklären und zwar

01:23:00.780 --> 01:23:05.260
Ich benutze hier eine brifu version von dotnet 8

01:23:06.180 --> 01:23:09.860
dotnet 8 hat ein neues oder was kein neues feature ein

01:23:11.220 --> 01:23:13.220
verbessertes feature

01:23:13.420 --> 01:23:15.420
für single

01:23:16.460 --> 01:23:18.460
Teil executables

01:23:22.580 --> 01:23:28.620
Und zwar kannst du deine komplette dotnet anwendung wie bei go im endeffekt wobei es nicht ganz so cool ist wie bei go

01:23:28.940 --> 01:23:34.500
In eine in eine einzelne exe zusammen bauen lassen und bei windows bei windows sprache zu bleiben

01:23:35.820 --> 01:23:37.900
Und das haben die jetzt verbessert die

01:23:39.220 --> 01:23:41.220
Dateien sind deutlich kleiner

01:23:41.860 --> 01:23:48.340
Zeige euch das mal das binary wenn man das kompiliert ist nur noch 12 mb groß

01:23:49.220 --> 01:23:55.820
Das ist auch nicht so viel größer als als eine go als ein go binary vor allem was da alles da ist ja alles mögliche drin

01:23:56.780 --> 01:23:58.300
So

01:23:58.300 --> 01:24:04.380
Also das docker feil das docker feil ist nicht nicht super optimal aber es macht das was es machen soll

01:24:06.060 --> 01:24:08.060
Es zieht sich cento s7

01:24:08.780 --> 01:24:13.060
Und es zieht sich cento s7 ach so ich müsste es vielleicht mal ergänzen was ich gerade sagen wollte

01:24:14.300 --> 01:24:15.620
und

01:24:15.620 --> 01:24:22.540
Wenn er das kompiliert zu so einer single binary dann hat er eigentlich keine abhängigkeit außer ein ding

01:24:23.140 --> 01:24:25.140
und zwar

01:24:25.220 --> 01:24:26.980
Die aktuelle

01:24:26.980 --> 01:24:31.700
gelibc version unter dem us wo es gebaut wird

01:24:32.100 --> 01:24:36.000
das heißt wenn ich das hier jetzt bauer auf meinem art standung sind so ziemlich

01:24:36.820 --> 01:24:42.420
Aktuelleres system kannst du nicht haben dann läuft die software höchstwahrscheinlich auf älteren system nicht mehr

01:24:43.540 --> 01:24:49.260
Weil mindestens gelibc version so neu ist dass es halt zum beispiel schon auf dem umbundung von letztem jahr wahrscheinlich nicht mehr laufen wird

01:24:49.660 --> 01:24:54.940
Deswegen baue ich das unter was ganz altem deswegen baue ich es unter dem cento s cento s hat gelibc

01:24:56.700 --> 01:25:04.420
2.17 oder sowas dies von 2012 das ist uralt das heißt das ist übrigens auch ein super anwendungsbeispiel für container

01:25:04.740 --> 01:25:09.020
das heißt nämlich auch wenn ich das hier baue und das ente 7

01:25:09.500 --> 01:25:15.020
Muss ich den ganzen muss ich muss schon mal dieses ganze alte zeug nicht auf meinem host system installieren sondern kann es im container machen

01:25:15.340 --> 01:25:21.180
Und die software die am ende raus fällt ist lauffähig unter allen linux systemen die die letzten

01:25:22.220 --> 01:25:24.220
zehn jahre rausgekommen sind

01:25:25.460 --> 01:25:31.780
Und da kannst du dich nicht beschweren binary drauf kopieren wunderbar funktioniert oder aus dem repo installieren wenn man arsch verwendet

01:25:34.380 --> 01:25:36.380
Also das ist der grund

01:25:38.020 --> 01:25:40.220
Warum genau cento s und nicht irgendein debian

01:25:41.140 --> 01:25:43.340
weil nur cento s noch

01:25:43.900 --> 01:25:50.580
Aktive repos hat und noch halbwegs gepflegt wird mit einer so alten gelibc version

01:25:53.860 --> 01:25:59.380
Die anderen debian sind alle out out of support und bei den alten ubuntu gibt es beispielsweise schon gar kein

01:26:01.220 --> 01:26:03.220
Repo mehr was funktioniert

01:26:04.060 --> 01:26:08.300
Zumal die alten ubuntu teilweise zu alte gelibc versionen haben

01:26:09.180 --> 01:26:16.180
Gelibc 2.17 ist genau richtig alt so dass es noch von dotnet 8 supportet wird ja und es ist bald out of support

01:26:16.420 --> 01:26:20.260
Raus aber solange dotnet 8 läuft kann man dort mit 8 damit bauen das ist ja nicht schlimm

01:26:22.740 --> 01:26:25.460
Macht ja nix die abhängig ist sonst hat es ja keine abhängigkeit

01:26:27.340 --> 01:26:29.340
So und in diesem docker image

01:26:29.420 --> 01:26:36.820
Passiert eigentlich nichts großartiges wird erst mal das system geupdatet dann wird dort net installiert dann wird die software in das container image also in

01:26:37.580 --> 01:26:39.580
Container rüber kopiert

01:26:39.580 --> 01:26:45.140
Und dann wird dotnet kompiliert also das das programm kompiliert fertig aus das war es

01:26:45.300 --> 01:26:48.540
So dazu gibt es noch ein build script was wir heute aber nicht weiter verwenden werden

01:26:48.820 --> 01:26:51.660
Build script was ich was ich dann in binary da raus kopiert

01:26:51.940 --> 01:26:57.100
So also im prinzip wird es mit dem docker file gebaut das heißt wir müssen jetzt gucken wie kriegen wir

01:26:58.540 --> 01:27:04.500
Dieses docker bild wie kriegen wir das ganze in github actions untergebracht

01:27:05.380 --> 01:27:10.980
Und da zeige ich euch jetzt ein paar tricks zu das heißt wir machen jetzt mal von von von null auf

01:27:11.460 --> 01:27:14.860
Naja von nicht von null auf 100 aber wir machen jetzt ein bisschen ein bisschen advancederes zeug

01:27:16.020 --> 01:27:20.820
Das kann das muss ich sagen das kann ich nicht auch wenn es jetzt vielleicht so aussehen das kann ich nicht alles aus dem

01:27:20.820 --> 01:27:26.060
Kopf runterschreiben da muss ich zwischendurch in dem bei ein bisschen abgucken wie das funktioniert aber ich erkläre euch alles und zwar

01:27:26.260 --> 01:27:28.260
Wir wollen jetzt in docker image bauen

01:27:28.260 --> 01:27:31.380
Also wir wollen quasi in docker image anlegen in github actions

01:27:32.580 --> 01:27:37.940
Mit cento s7 darin die software bauen und am ende wenn das fertig ist

01:27:38.340 --> 01:27:42.100
Die software aus dem container image raus kopieren und veröffentlichen

01:27:43.700 --> 01:27:47.940
Also anhängen eine github action ich nenne es mal veröffentlichen das ist das ziel

01:27:48.740 --> 01:27:55.780
So bauen mit docker in github actions ist relativ easy da gibt es eine fertige fertige action

01:27:55.860 --> 01:27:59.940
Beziehungsweise man braucht eigentlich gar nichts weil ich werde es euch mal zeigen

01:28:01.220 --> 01:28:04.100
Gehen wir mal zu unserer keckel action zurück ich kann einfach sagen

01:28:04.900 --> 01:28:06.900
docker bild punkt

01:28:07.940 --> 01:28:12.100
Lasst euch nicht jebaiten es wird nicht funktionieren ich zeige es euch nur was jetzt passiert

01:28:16.100 --> 01:28:16.820
So

01:28:16.820 --> 01:28:18.820
Jetzt läuft eine neue action los

01:28:19.140 --> 01:28:22.660
Und docker ist schon vorinstalliert in dem ubuntu image was

01:28:22.660 --> 01:28:27.380
In github actions benutzt wird werdet ihr werdet ihr gleich sehen der bild das bild wird nicht gehen

01:28:28.420 --> 01:28:30.420
sei ich gleich dazu

01:28:30.740 --> 01:28:32.740
so check out

01:28:33.220 --> 01:28:38.100
Guck jetzt macht da gerade einen docker pull und ihr seht jetzt vielleicht schon eine sache

01:28:39.300 --> 01:28:41.300
Es ist abartig langsam

01:28:42.180 --> 01:28:49.860
So ein großes container image zu bauen guckt euch das mal an es ist abartig langsam ein großes container image in github actions zu bauen

01:28:49.860 --> 01:28:53.940
Und wenn man sich jetzt überlegt der muss das jedes mal jetzt machen

01:28:54.580 --> 01:29:01.540
Da muss jedes mal weil der baut das in der vm dieses container image und schmeißt die vm danach weg

01:29:02.580 --> 01:29:04.100
heißt ja auch

01:29:04.100 --> 01:29:09.380
Das docker image ist weg das heißt wenn ich das nächste mal das ganze ausführe da muss er das wieder machen

01:29:10.100 --> 01:29:12.100
Das kostet euch drei minuten

01:29:13.940 --> 01:29:16.740
Und es ist nervig wenn ihr drei vier minuten wartet

01:29:17.380 --> 01:29:21.460
Und es ist nervig wenn ihr drei vier minuten warten müsst bis eure software fertig gebaut ist

01:29:22.180 --> 01:29:27.140
Ich glaube gebt ihr mir recht oder ist schon ein bisschen doof wenn man jedes mal so lang darauf warten muss

01:29:28.660 --> 01:29:33.220
Deswegen gibt es jetzt was neues das ist tatsächlich relativ neu das gibt es glaube ich erst seit ein paar monaten

01:29:35.780 --> 01:29:41.140
Man kann docker verwenden um das container image zu bauen mit github actions support

01:29:41.140 --> 01:29:45.380
Die haben mittlerweile in docker eingebaut beziehungsweise in build x oder in buildkit

01:29:45.940 --> 01:29:52.900
Haben die github action support eingebaut das ist eine ganz neisse geschichte früher musste man das alles von hand machen

01:30:00.500 --> 01:30:03.540
Hier könntest du auch ein base image für bauen es wäre auch total easy

01:30:04.020 --> 01:30:06.020
Du musstest halt in irgendeine registry pushen

01:30:06.740 --> 01:30:08.740
Können wir vielleicht auch mal machen

01:30:09.140 --> 01:30:11.140
Können wir vielleicht auch mal machen

01:30:12.340 --> 01:30:17.460
Chat nicht weggehen ich muss mal kurz den chat refreshen ich sehe euch mal kurz nicht nix anstellen

01:30:18.420 --> 01:30:22.680
Okay wieder da chat hat gerade verabschiedet bei mir im vorschau bildschirm

01:30:27.380 --> 01:30:29.380
So ihr seht wie lahm das ist

01:30:30.740 --> 01:30:37.380
Ihr seht wie lahm das ist das willst nicht das willst nicht guck mal hier zwei minuten drei sekunden es wird übrigens auch gleich kaputt gehen

01:30:39.540 --> 01:30:41.540
Was sind github actions

01:30:42.100 --> 01:30:47.700
Github actions ist quasi der jenkins von github kennst du jenkins soll es ist kaputt gegangen

01:30:49.140 --> 01:30:55.220
Das ist blazing die store wenn du jenkins kennst dann ist das der jenkins von github nur dass man ihn in jammel konfiguriert

01:30:56.660 --> 01:30:58.500
So er sagt weil

01:30:58.500 --> 01:31:04.820
Targetversion fallt also es hat nicht funktioniert so jetzt überlegt euch mal ich habe jetzt zwei minuten 16 gewartet

01:31:05.300 --> 01:31:11.260
Das ding ist fehlgeschlagen ich würde jetzt was anpassen das wieder pushen und ich müsste noch einmal

01:31:11.900 --> 01:31:17.000
2 minuten 16 warten bis ich sehe ob es wieder funktioniert da drehst du durch dabei da wirst du verrückt

01:31:18.540 --> 01:31:21.340
Deswegen gibt es einen richtig nice trick

01:31:21.980 --> 01:31:29.300
Wie man das ganze beschleunigen kann und zwar wenn ihr mal hier unter action guckt also es ist logisch oder warum das so langsam ist

01:31:30.460 --> 01:31:32.460
weil das ist eine vm

01:31:32.700 --> 01:31:33.700
und

01:31:33.700 --> 01:31:39.540
Der baut das image in der vm und wenn ich das image wieder bauen wenn ich das neu anstoße ist die vm ja weg

01:31:39.540 --> 01:31:45.060
Der hat den letzten stand nicht mehr wenn ich das lokal bei mir machen würde da würde an der stelle hier weitermachen und wäre ziemlich schnell

01:31:45.300 --> 01:31:49.500
Aber so muss er das alles wieder neu machen weil ihm der inhalt von der vm weg ist

01:31:49.940 --> 01:31:53.680
Das kann man beheben das gibt nämlich wenn ihr unter action guckt so was hier caches

01:31:54.460 --> 01:31:56.460
aktuell gibt es noch keine caches

01:31:57.940 --> 01:32:02.260
Aber naja man sieht dadurch dass da schon so ein button für caches ist man kann das ganze irgendwie cashen

01:32:02.420 --> 01:32:05.100
Es gibt unter github die cache action

01:32:10.380 --> 01:32:16.420
Da die kann man manuell benutzen für alles was man so will das sieht dann beispielsweise

01:32:19.940 --> 01:32:23.020
Das sieht dann beispielsweise so aus ja da kann ich hier sagen

01:32:23.540 --> 01:32:29.940
Restore von diesem cache und wenn du fertig bist dann speichere das ganze unter diesem key im cache

01:32:30.180 --> 01:32:34.980
Das heißt das ist universell einsetzbar für alle outputs nicht nur zwangsläufig für docker

01:32:35.900 --> 01:32:41.580
Also das geht das geht für alle also wenn ihr wenn ihr java programme baut mit mehreren zwischenstabs oder wenn ihr generell mehrere bild

01:32:41.580 --> 01:32:48.060
Stabs habt und das cashen wollte so was könnt ihr manuell cashen mit der mit der caching action ist kein problem

01:32:48.940 --> 01:32:50.940
was viel nicer ist

01:32:51.220 --> 01:32:53.220
docker hat das mittlerweile eingebaut

01:32:53.900 --> 01:33:00.460
Guck mal docker bild x nicht das normale bild die bildkit extension hat das eingebaut

01:33:02.220 --> 01:33:04.220
Das will ich eigentlich nicht das will ich haben

01:33:05.300 --> 01:33:09.440
Und das nennt sich docker bild x bild

01:33:10.180 --> 01:33:12.180
Und da gibt es jetzt sowas

01:33:12.300 --> 01:33:13.820
cache from

01:33:13.820 --> 01:33:15.820
cache to

01:33:15.820 --> 01:33:22.580
Man sieht schon irgendwie können die sich an speziellen ordnern kann man dort

01:33:23.300 --> 01:33:27.300
Zwischenstände von seinem container bild von seinem container bild zwischenspeichern

01:33:28.940 --> 01:33:31.820
Und das neueste feature das ist wirklich noch nicht lang drinne

01:33:32.660 --> 01:33:36.300
Ein halbes jahr oder so vielleicht die können jetzt

01:33:37.060 --> 01:33:42.140
GitHub actions cache direkt benutzen früher musste man das bild quasi machen

01:33:42.380 --> 01:33:48.700
Früher musste man das bild quasi machen dann sich eine caching action einbauen die

01:33:49.260 --> 01:33:50.540
die

01:33:50.540 --> 01:33:53.780
Zwischenstände kopiert hat in den cache beim nächsten rand wieder

01:33:54.220 --> 01:34:02.680
Restored hat das caching directory umgebogen hat und daraus gelesen hat mittlerweile ist github actions cache direkt in bild x eingebaut

01:34:03.500 --> 01:34:05.500
Das heißt man kann jetzt hier direkt angeben

01:34:06.500 --> 01:34:13.100
Das heißt man muss außer das richtige docker bild kommando gar nichts mehr verwenden dass das ding auf den

01:34:13.660 --> 01:34:17.700
github actions cache zugreift ich glaube standardmäßig ist da cache 500 mb

01:34:19.180 --> 01:34:21.180
Aber das reicht ja auch

01:34:21.660 --> 01:34:27.860
Ne im moment das stimmt nicht der cache ist nicht 500 mb der cache ist größer der cache ist glaube ich 10 gigabyte für

01:34:28.420 --> 01:34:30.420
github actions cache

01:34:31.380 --> 01:34:36.220
Giga bei für für jetzt habe actions cache free

01:34:42.300 --> 01:34:44.300
Ok steht ich nicht irgendwo

01:34:44.820 --> 01:34:46.820
Github actions cache

01:34:46.860 --> 01:34:52.860
3 tier ich glaube 10 gigabyte ist das freetier und das reicht das reicht eigentlich in der regel so

01:34:53.220 --> 01:34:56.520
Also das heißt wir müssen uns reaction anpassen dass der es

01:34:57.520 --> 01:35:01.800
Einmal bild x verwendet für docker und nicht normales docker bild

01:35:03.400 --> 01:35:10.680
Und dass das ganze gecached wird das heißt als erstes fangen wir an dass bild x installiert wird weil normales docker bild

01:35:10.680 --> 01:35:15.600
Tut es nicht mehr wenn ihr normales docker bild macht wird euch vielleicht noch auffallen dass der mittlerweile

01:35:19.200 --> 01:35:24.320
Dass der mittlerweile meckert dass das der legacy bilder ist und man auch gefällig bild x verwenden soll

01:35:25.320 --> 01:35:28.880
Den install ich ne bild bild x auch mal lokal

01:35:30.560 --> 01:35:36.120
Ihr müsst euch keine gedanken machen ich gehe nicht davon aus dass die es jemals aus einem future release

01:35:36.960 --> 01:35:42.760
Entfernen werden es gibt so viele scripts wo docker bild direkt verwendet wird das ist bescheuert wäre total bescheuert das zu entfernen

01:35:43.080 --> 01:35:51.040
Wobei man sagen muss die company hinter docker macht die letzten jahre über viel sinnlosen scheiß es könnte also auch sein dass die docker bild irgendwann

01:35:51.040 --> 01:35:52.400
Mal entfernen

01:35:52.560 --> 01:35:56.960
Zutrauen würde ich es ihnen habt ihr übrigens mitbekommen die haben die haben zurück gerudert

01:35:57.680 --> 01:35:59.840
die haben zurück gerudert mit ihrem

01:36:00.920 --> 01:36:05.320
docker team accounts entfernen und sowas das wird jetzt wird jetzt weiter bei behalten

01:36:08.360 --> 01:36:12.800
Also als erstes müssen wir jetzt bild x installieren das ist easy das kopiere ich mir raus

01:36:15.960 --> 01:36:21.640
Das funktioniert nämlich genauso fertig man gibt hier einfach an dass man diese action verwenden möchte

01:36:21.920 --> 01:36:27.960
install bild x docker set up bild x fertig mehr muss man nicht machen jetzt hat man einen docker mit bild x in seiner

01:36:29.000 --> 01:36:31.000
Ubuntu vm auf github zur verfügung

01:36:32.080 --> 01:36:34.560
So und jetzt wird es ein bisschen komplizierter

01:36:35.080 --> 01:36:42.960
Jetzt müssen wir sagen wie er unser unsere anwendung zusammenbauen soll ich kann euch schon gleich sagen direkt so wird es nicht funktionieren wir müssen das nachher

01:36:42.960 --> 01:36:49.720
Noch das docker file anpassen dass es funktioniert vielleicht vielleicht machen wir das auch erst lokal mit dem docker file

01:36:52.360 --> 01:36:57.080
Vielleicht passen wir auch das docker file erst mal an dass wir da auch gleich gucken können ob es funktioniert

01:37:00.280 --> 01:37:07.080
Also wir müssen jetzt nicht mehr docker bild aufrufen sondern wir müssen aufrufen docker bild x bild

01:37:07.880 --> 01:37:12.600
Punkt sieht jetzt ein bisschen anders aus aber im großen und ganzen macht es immer noch das gleiche

01:37:13.960 --> 01:37:15.960
Es ist immer noch play singly slow

01:37:16.240 --> 01:37:18.240
Es ist immer noch play singly slow

01:37:19.400 --> 01:37:23.360
Aber wir können das lokal mit cash mit mit mit mit cashing schon mal ausprobieren

01:37:23.720 --> 01:37:27.320
Ich lasse es jetzt einmal lahm durchlaufen das einmal durchlaufen muss was machen

01:37:32.560 --> 01:37:36.620
Zum glück zum glück geht das ganze lokal ein bisschen schneller wie über github actions

01:37:37.400 --> 01:37:44.220
Damage ist dann ja ist so die sind die sind auch total bescheuert also dass sie das angekündigt haben haben sich weitere leute

01:37:44.460 --> 01:37:50.060
Nachdem sie ja schon nicht mehr die hauptanlauf stelle für docker images sind weil sie sich selbst verschissen haben die letzten jahre über

01:37:51.100 --> 01:37:57.340
Es gab keine es gab keine docker es gab keine github container registry keine github konnte die haben alle docker images

01:37:57.540 --> 01:38:05.420
Auf github auf docker hab gehostet bis die auf die glorreiche idee gekommen sind zu sagen ach nee wir schaffen mal das free tier ab

01:38:07.540 --> 01:38:12.700
Bild oder ein es ist kaputt weil ich keine richtige version angegeben habe siehste geht schon los

01:38:13.180 --> 01:38:17.420
Geht schon los also unser docker bild kommando ist verkehrt

01:38:18.260 --> 01:38:21.900
dort net compile möchte eine target version haben bei mir

01:38:23.060 --> 01:38:26.540
Die target version ist relativ einfach anzugeben bild args

01:38:28.020 --> 01:38:30.020
Bild arg

01:38:32.260 --> 01:38:38.860
Target target version gleich 0.0.3 nennen wir das ganze jetzt mal

01:38:39.860 --> 01:38:45.900
Und ihr seht bei mir lokal ist es jetzt gecasht geht es viel schneller ist euch vielleicht aufgefallen

01:38:47.460 --> 01:38:54.420
Ich habe jetzt alle steps bis zum compile übersprungen weil mein bild gecasht ist das ist ja auch kein ding mein lokaler state

01:38:54.900 --> 01:38:57.700
bleibt ja vorhanden ich habe ja nicht meine vm kurz gelöscht und

01:38:58.020 --> 01:39:02.620
Und wieder neu gestartet so wie das so wie das unter github github actions der fall ist

01:39:02.620 --> 01:39:05.580
also es ist viel viel schneller dieses ganze einrichten des

01:39:06.780 --> 01:39:08.780
docker containers

01:39:08.900 --> 01:39:14.620
Ist mir erspart geblieben und wenn ich jetzt noch mal ausführe ist es blazingly fast written in rust

01:39:15.100 --> 01:39:17.100
Weil es ist ja im prinzip schon fertig

01:39:18.580 --> 01:39:24.620
So das kommando ist allerdings immer noch nicht ganz korrekt es fehlen noch ein paar dinger was wir brauchen einmal

01:39:24.940 --> 01:39:29.820
Brauchen wir die ganzen angaben zum cash die können wir jetzt noch nicht machen weil ich lokal

01:39:30.260 --> 01:39:34.380
Kein github actions cache gescheit benutzen kann wie soll das funktionieren

01:39:35.260 --> 01:39:38.140
Aber wir haben ein problem an der stelle jetzt

01:39:38.860 --> 01:39:41.580
Ich habe jetzt ein image gebaut so passt mal auf

01:39:42.340 --> 01:39:49.220
Vielleicht vielleicht fällt euch das problem auf so ich habe ein image gebaut und ich kompiliere mein dotnet programm

01:39:49.980 --> 01:39:51.380
in

01:39:51.380 --> 01:39:53.380
den ordner bild

01:39:54.980 --> 01:40:01.460
Ja was ist jetzt das problem also an der stelle also hat jemand eine idee was was jetzt

01:40:06.300 --> 01:40:08.300
Was ich jetzt nicht machen kann

01:40:08.940 --> 01:40:10.940
Ich weiß nicht wie ich es anders ausdrücken soll

01:40:12.620 --> 01:40:15.540
Vielleicht hat der user der user ist immer das problem

01:40:18.220 --> 01:40:22.180
Peppkack problem exist betwen chair und keyboard ne betwen

01:40:22.820 --> 01:40:24.820
doch betwen chair und keyboard

01:40:24.860 --> 01:40:28.540
also das problem ist ich habe die software gebaut

01:40:29.580 --> 01:40:33.260
in meinem content also beim erstellen meines container images

01:40:34.260 --> 01:40:40.340
Ich muss die software die ich gebaut habe da irgendwie wieder raus bekommen weil ich will gar kein container image

01:40:40.500 --> 01:40:44.820
Das ist bei mir nur ein notwendiges übel dass ich es unter sento s7 baue

01:40:45.700 --> 01:40:50.900
Sie ist jetzt aber die software ist jetzt im container ich will die gar nicht im container haben sie ist im container image

01:40:50.900 --> 01:40:55.940
Ich will die wieder raus kriegen aus dem container image so und bisher habe ich mich da eines kleinen

01:40:58.460 --> 01:41:02.900
Eines kleinen hacks beholfen und zwar ich habe das ich habe das gebaut

01:41:03.260 --> 01:41:10.540
das container image danach habe ich docker run gemacht mit dem container image und dann mit docker cp aus dem erstellten

01:41:11.500 --> 01:41:12.620
container

01:41:12.620 --> 01:41:17.380
Es wieder raus kopiert das ist allerdings nicht so schön und das ist glücklicherweise

01:41:18.180 --> 01:41:21.140
mit bild x auch nicht mehr notwendig

01:41:21.740 --> 01:41:24.140
Kann ich euch mal einen kleinen trick zeigen an der stelle

01:41:24.140 --> 01:41:26.900
Geht docker cp nur bei laufendem container

01:41:27.220 --> 01:41:34.180
Ne es geht nicht nur bei laufendem container aber das muss einmal ein container angelegt worden sein mit diesem image dass es funktioniert du kannst

01:41:34.180 --> 01:41:41.260
Kein docker cp von einem image machen du kannst nur ein docker cp machen von einem container der du vor allem image also mit

01:41:41.260 --> 01:41:43.260
einem image gestartet hast

01:41:43.860 --> 01:41:45.860
also natürlich

01:41:45.860 --> 01:41:49.180
Ebenfalls doof, aber mit bild x ist das ganz einfach

01:41:49.340 --> 01:41:51.340
Natürlich

01:41:51.340 --> 01:41:54.940
Ebenfalls doof, aber mit bild x ist das gar kein problem mehr

01:41:56.060 --> 01:41:58.060
weil man jetzt

01:41:58.060 --> 01:42:00.060
folgendes machen kann

01:42:00.980 --> 01:42:04.940
Ich mal kurz abgucken weil ich das aus dem kopf wahrscheinlich nicht hinkriege

01:42:06.300 --> 01:42:08.780
Genau was man jetzt machen kann ist folgendes

01:42:09.740 --> 01:42:11.900
Belegen wir benutzen multi multi

01:42:12.580 --> 01:42:17.020
Wie heißt das multistage bild multistage bild also wir bauen quasi

01:42:18.020 --> 01:42:20.020
Mehrere images zusammen

01:42:21.300 --> 01:42:25.660
Und wir möchten jetzt die datei die wir hier erzeugt haben

01:42:26.140 --> 01:42:32.860
Auf den host zurück kopieren so und das geht in zwei steps man muss hier einmal ein fake

01:42:33.780 --> 01:42:36.140
image anlegen in seinem

01:42:37.860 --> 01:42:44.660
Was heißt ein fake image ja ein fake image ein fake container image anlegen in seinem docker file auf das man dann mit bild x

01:42:44.780 --> 01:42:47.500
Zugreifen kann und dafür gibt es habe ich übrigens auf

01:42:48.420 --> 01:42:51.540
Inspiration habe ich von stag overflow bin ich nicht bin ich nicht selbst drauf gekommen

01:42:52.500 --> 01:42:59.660
Es gibt ein scratch image seit irgendwie ein paar docker versionen das ist kein image was auf gett auf docker haplikt

01:42:59.980 --> 01:43:02.620
Das ist quasi ein nicht existentes image

01:43:03.420 --> 01:43:09.620
Warum die so genannt haben ich habe keine ahnung aber es heißt so das heißt an der stelle wird nicht wirklich ein image angelegt

01:43:09.620 --> 01:43:13.060
Es ist aber in der syntax von wie als würde ich ein image anlegen

01:43:13.780 --> 01:43:19.100
Das muss ich nicht output nennen ich muss dem ding nur namen geben also from scratch als output

01:43:19.340 --> 01:43:25.660
copy jetzt muss ich ihm sagen was für dateien ich aus diesem bild step in dieses fake image kopieren will nämlich

01:43:26.380 --> 01:43:27.700
from

01:43:27.700 --> 01:43:30.500
Bild wir nennen das ganze übrigens mal bild nicht bild ent

01:43:31.140 --> 01:43:34.140
from bild also quasi von von diesem bild step

01:43:34.820 --> 01:43:38.500
von dem filesystem in diesem bild step will ich jetzt kopieren

01:43:38.620 --> 01:43:45.980
Slash ab weil ihr seht hier work work directory ab also von da will ich will ich sachen kopieren slash app

01:43:46.780 --> 01:43:48.340
slash bild

01:43:48.340 --> 01:43:53.040
Warum slasch bild na ja weil ich den output von meinem compile kommando nach bild geschrieben habe

01:43:54.180 --> 01:43:57.060
Slash bild und dann legt eine

01:43:58.100 --> 01:44:04.700
Binary rum was ich vm champ nennt und das ganze will ich hier in dieses image kopieren einfach unter root slash vm champ

01:44:05.580 --> 01:44:07.580
fertig wenn ich das jetzt bilde

01:44:07.940 --> 01:44:10.980
wird hoffentlich funktionieren ja

01:44:12.780 --> 01:44:17.100
Hat funktioniert ging sehr zackig und wie kriege ich das ganze jetzt raus

01:44:18.380 --> 01:44:24.100
Dazu kann man bild x erweitern und zwar kann man an bild x hinten noch angeben target

01:44:24.980 --> 01:44:33.060
Gleich output das output hier ist der name von diesem fake environment was ich gerade in meinem docker file angelegt habe

01:44:33.580 --> 01:44:35.580
minus minus target output

01:44:35.980 --> 01:44:44.180
Und jetzt muss ich angeben minus minus output gleich und nee so rum type gleich local

01:44:45.900 --> 01:44:51.260
Destination das weiß aus dem kopf das weiß ich nicht aus dem kopf das schreibe ich gerade ab aus aus dem anderen docker file also

01:44:51.980 --> 01:44:58.340
Also aus einem anderen script das weiß aus dem kopf jetzt alle wieder das genau funktioniert jetzt kann ich sagen wohin das ganze kopiert werden soll ja

01:44:58.580 --> 01:45:03.900
nach tmp out zum beispiel wenn ich das jetzt ausführe zack

01:45:04.340 --> 01:45:06.340
Dann habe ich unter tmp out

01:45:09.500 --> 01:45:17.500
Das executable liegen was ich haben will und das ist ein enormer fortschritt versus dem klassischen docker bild

01:45:19.580 --> 01:45:24.540
Wo man einen container erstellen muss und das erst danach aus kopieren kann viel einfacher

01:45:25.340 --> 01:45:31.780
Ohne dass ich das image überhaupt jemals in docker laden muss und ohne dass ich doch starten muss oder sowas einfach aus dem image raus kopieren

01:45:32.180 --> 01:45:38.700
Was ist denn mit docker create und dann docker cp das kannst du auch machen aber dazu musst du das image erst mal in docker importieren den container starten

01:45:40.700 --> 01:45:46.180
Stoppen und dann wieder raus kopieren das ist so viel einfacher viel schneller und geht in einem befehl

01:45:47.540 --> 01:45:51.380
So also das brauchen wir jetzt an der stelle für unser

01:45:54.620 --> 01:45:57.460
Bild in github actions

01:46:01.780 --> 01:46:03.780
So sieht's aus

01:46:04.740 --> 01:46:08.860
Gut dann gehen wir mal in unsere github actions rein

01:46:11.380 --> 01:46:13.860
Da und fügen das fügen das ganze mal

01:46:15.340 --> 01:46:17.340
Hinzu habe ich hier nicht

01:46:18.500 --> 01:46:21.980
Wo ist meine keckel action ich brauche meine keckel action sonst geht hier gar nichts

01:46:24.100 --> 01:46:26.420
So das ding nennen wir jetzt step

01:46:27.300 --> 01:46:31.820
Bilds release oder sowas so und da fügen wir jetzt

01:46:34.980 --> 01:46:38.180
Docker bild x bild bild args target version ein

01:46:39.700 --> 01:46:46.500
Target output des output ja wunderbar das fügen wir ein wir sehen an der stelle schon ok das kann auch nicht so ganz funktionieren uns fehlen

01:46:46.500 --> 01:46:52.300
Noch ein paar sachen uns fehlt nämlich zum beispiel die target version ist jetzt hier hardcoded auf 0.0.3

01:46:53.300 --> 01:47:01.620
Das bringt uns ja nichts weil vielleicht ist es ja irgendwann mal 0.0.4 das heißt an der stelle wollen wir eigentlich gar keine hardcoded version benutzen

01:47:03.540 --> 01:47:09.260
Sondern wir möchten das benutzen was uns github zur verfügung stellt und zwar nennt sich das ganze

01:47:09.580 --> 01:47:15.440
Also das ist eine globale variabler die uns github zur verfügung stellt und zwar nennt sich das an der stelle

01:47:15.440 --> 01:47:21.760
Jetzt haben wir noch etwas kleines machen dass das richtig funktioniert weil der tag den wir pushen der ist ja ihr seht es ja

01:47:21.760 --> 01:47:23.760
0.0.3

01:47:25.760 --> 01:47:27.760
Und das v also

01:47:29.760 --> 01:47:31.520
0.0.3

01:47:31.520 --> 01:47:33.520
0.0.3

01:47:33.520 --> 01:47:35.520
0.0.3

01:47:35.520 --> 01:47:37.520
0.0.3

01:47:37.520 --> 01:47:39.520
0.0.3

01:47:39.520 --> 01:47:41.520
0.0.3

01:47:41.600 --> 01:47:51.080
Und das v also das v das mag dotnet bild nicht das heißt wir müssen das v irgendwie abschneiden

01:47:54.600 --> 01:47:56.600
Das wir können jetzt sowas hier machen

01:47:57.600 --> 01:48:00.880
Docker kann das vom zweiten character bis zum schluss

01:48:02.000 --> 01:48:04.000
Jetzt haben wir jetzt haben wir nur noch

01:48:04.600 --> 01:48:06.600
haben wir nur noch

01:48:06.760 --> 01:48:10.960
0.3 das heißt wir machen jetzt hier eine environment variable die nennen wir

01:48:11.400 --> 01:48:15.080
Target wörscht das ist ganz normales bash was ihr an der stelle seht ja

01:48:15.640 --> 01:48:21.960
Ganz normales bash sonst sonst nix also muss man sich keine großartigen gedanken was mache ich denn hier keine großartigen gedanken machen

01:48:23.040 --> 01:48:25.040
target target versions

01:48:27.000 --> 01:48:33.680
Echo ups wenn man das auch richtig schreiben kann echo nicht punkt 3 was mache ich denn hier

01:48:33.680 --> 01:48:41.640
Github revs so target version stehen jetzt da drinnen und hier können wir jetzt einfach reinschreiben dollar target

01:48:45.680 --> 01:48:47.440
Version

01:48:47.440 --> 01:48:54.960
Leerzeichen machen dass man es einfacher lesen kann gut das heißt wir holen uns jetzt aus der information welcher tech bash geht auch ja

01:48:55.840 --> 01:48:57.840
Bash magic geht immer irgendwie

01:48:58.080 --> 01:49:03.920
Wir holen uns hier aus der leute ich habe bauchwehe ich habe heute abend noch ein stück pizza gefressen und richtig fettige

01:49:06.080 --> 01:49:10.000
Pizza Hut pizza alle das war keine gute idee

01:49:13.080 --> 01:49:15.080
Painge

01:49:17.880 --> 01:49:23.560
Es kann sein dass ich gleich erstmal eine runde pepo pepo toilet fire zoom machen muss

01:49:28.840 --> 01:49:30.840
Ah

01:49:33.320 --> 01:49:35.320
Ob das so poggers ist weiß ich nicht

01:49:46.960 --> 01:49:53.040
Da warten wir mal ab wie es wird okay also target version

01:49:58.400 --> 01:50:02.040
Stim vom klo ich gucke aber in chat vom klo aus

01:50:02.720 --> 01:50:06.560
Targetversion so das passt jetzt eigentlich schon mal ganz gut was wir hier haben

01:50:08.200 --> 01:50:11.000
Jetzt ist nur die frage wie machen wir das mit dem cash

01:50:11.600 --> 01:50:18.840
Wie machen wir das mit dem cash dass er nicht jedes mal neu diese ganze sache bildet und da muss ich ehrlich sagen

01:50:19.720 --> 01:50:24.760
Hab ich nicht das habe ich mir nicht alles selbst ausgedacht das habe ich mal auf

01:50:25.000 --> 01:50:27.880
Stag overflow gefunden wer hätte wer hätte das gedacht ja

01:50:29.840 --> 01:50:35.560
Das heißt credit wo credit gebührt ich versuche mal ob ich den stag overflow post wieder von finde

01:50:37.200 --> 01:50:39.200
Stag overflow hier

01:50:41.160 --> 01:50:45.600
Der beschreibt wie man dieses cashing feature von docker bild x benutzt

01:50:47.480 --> 01:50:51.680
Und ich habe mir das hier gerippt aus dem stag overflow

01:50:51.920 --> 01:50:59.840
Post von ihm wie das funktioniert das ist nämlich äußerst äußerst magic wie das funktioniert

01:51:00.080 --> 01:51:04.680
Und ich gehe ihr könnt euch ihr könnt euch lest euch lest euch durch was was er schreibt

01:51:05.520 --> 01:51:08.440
Ich gehe jetzt mal eine runde pepo toilet zoom machen

01:51:12.120 --> 01:51:14.520
Gleich gleich gleich gleich wieder da

01:51:15.480 --> 01:51:19.560
Ich mach euch komm mach ich das ascii aquarium an ich bin gleich wieder da

01:55:51.680 --> 01:55:58.900
Jetzt schon sagen ich glaube das war es noch nicht er ich glaube ich muss da demnächst noch mal ok machen wir weiter

01:56:05.440 --> 01:56:07.440
Wo sind wir stehen geblieben

01:56:09.760 --> 01:56:15.880
Wie läuft auf der neuen arbeit ich habe den ersten arbeitstag nächsten montag dann dann weil dann kann ich ihr bescheid sagen

01:56:22.080 --> 01:56:27.920
So wo sind wir stehen geblieben also beim cashen von unserem von unserem docker bild

01:56:32.200 --> 01:56:36.880
Also wie gesagt das habe ich hier aus das habe ich hier aus github wie das wie das funktioniert ich habe das allerdings ein

01:56:36.880 --> 01:56:37.640
bisschen ein bisschen

01:56:37.640 --> 01:56:42.400
abgeändert ja ich laute das nicht in mein docker und sowas rein ich beschreibe auch nicht das docker feil so

01:56:42.600 --> 01:56:45.840
also das das hier muss man machen dass man zugriff hat auf

01:56:46.600 --> 01:56:52.600
Den docker cash was auch immer irgendwie super krasse krasse magic mit irgendwelchen tokens was auch immer

01:56:52.800 --> 01:56:59.400
stack overflow triffen programming wir glauben ihm das einfach was er da geschrieben hat und gut ist jetzt muss ich den cash konfigurieren

01:56:59.840 --> 01:57:02.120
und den cash konfiguriert man folgendermaßen

01:57:05.600 --> 01:57:09.520
Moment zeige ich euch ist eigentlich auch recht easy den cash konfiguriert man so

01:57:10.520 --> 01:57:12.520
wir können auch mal irgendwie einen

01:57:13.520 --> 01:57:20.680
Zeilen und proben machen den cash konfiguriert man so also man muss die richtigen environment variablen setzen die kann man eins zu eins also das geht

01:57:20.680 --> 01:57:27.760
Das ist jetzt nicht explizit auf meine repo zugeschnitten das geht in eurem repo eins zu eins auch so so docker bild x

01:57:28.760 --> 01:57:30.760
target version da bla bla bla

01:57:31.000 --> 01:57:40.440
cash to type github actions mode alle layer cash from type github actions so fertig das war es und wenn ich das jetzt ausführe

01:57:40.720 --> 01:57:48.800
Dann wird euch auffallen es ist gleich viel schneller wohlgemerkt beim zweiten bild im ersten bild ist ja der cash noch nicht also

01:57:49.800 --> 01:57:51.800
ist ja noch nichts im cash

01:57:56.960 --> 01:58:00.800
Wir machen noch wir machen noch einen zweiten step dass das man hier sieht

01:58:00.800 --> 01:58:06.760
ups wir machen noch einen zweiten step dass man sieht dass auch was passiert nennen wir das jetzt mal irgendwie copy file

01:58:07.240 --> 01:58:11.400
Copy file und da machen wir erstmal nix anderes wie ein

01:58:13.000 --> 01:58:19.760
ls minus la auf tmp out ja tmp out ist ja das wo wir die

01:58:21.000 --> 01:58:28.800
Das binary das das binary was in dem container gebaut wurde hin kopieren so fertig aus das reicht jetzt jetzt pushen wir das ganze

01:58:32.080 --> 01:58:34.080
Und nun

01:58:35.080 --> 01:58:40.840
Gucken wir was in den actions so abgeht

01:58:42.880 --> 01:58:45.120
Wie gesagt der erste step dauert lang

01:58:45.680 --> 01:58:50.560
Der erste step dürfte jetzt wieder zwei minuten 15 dauern ungefähr weil er muss das image

01:58:50.880 --> 01:58:57.640
Initial einmal bauen aber danach wir können es schon mal aufmachen danach gucken wir den cash aktuell ist der cash noch leer

01:58:57.960 --> 01:59:04.600
Danach gucken wir den cash und ihr werdet feststellen danach ist das image gecasht und jeder weitere bild geht

01:59:05.160 --> 01:59:09.120
Super viel schneller nicht einfach nur schneller sondern wirklich mega viel schneller

01:59:11.280 --> 01:59:13.280
So kann er mal anfangen jetzt please

01:59:14.240 --> 01:59:16.240
So ihr bild bild release

01:59:16.520 --> 01:59:22.000
So er macht wieder den gleichen mist also theoretisch könnte man jetzt eigentlich sagen ist ja eine gute sache dass er so lahm ist

01:59:22.000 --> 01:59:24.000
Da kann man wenn man auf der arbeit ist

01:59:24.240 --> 01:59:30.320
Faken dass man beschäftigt ist man kann mal aufs klo gehen oder manche leute trinken ja auch kaffee ich weniger

01:59:31.080 --> 01:59:35.920
Man kann ein bisschen schwätzen mit irgendwelche leuten man kann den screen output

01:59:36.280 --> 01:59:41.120
Rekorden und in der loop abspielen wenn sein chef mal reinkommt also das hat ja durchaus hat er durchaus

01:59:41.760 --> 01:59:48.760
Vorteile wenn man mal ein bisschen zeit hat aber vielleicht möchte nicht jeder zweieinhalb minuten warten bis sein bild fertig ist

01:59:49.760 --> 01:59:54.400
Und deswegen cashen wir das ganze jetzt

02:00:02.600 --> 02:00:04.600
Völlig detaillierte tricks

02:00:19.000 --> 02:00:21.440
Patrick dankeschön 45 monat subscription

02:00:27.400 --> 02:00:29.400
So wir sind bei fast zwei minuten schon

02:00:33.360 --> 02:00:37.360
Und da hat man nicht jeder hat man doch wirklich keinen bock drauf sich dass sich das öfters zu geben

02:00:37.360 --> 02:00:39.360
Was wird hier

02:00:41.200 --> 02:00:43.000
Was wird hier

02:00:43.000 --> 02:00:48.000
Irgendein testbruch, ne der vm champ aber es geht hauptsächlich um bisschen github actions zeigen

02:00:49.840 --> 02:00:56.640
Aktuell sind wir gerade beim cashen von container builds in github actions und hier sieht man wieder eine schöne

02:00:56.640 --> 02:00:59.920
Demonstration wie lahm das ganze ist aber es ist auch ein bisschen

02:00:59.960 --> 02:01:02.340
Nach dem cashen von container builds in

02:01:03.000 --> 02:01:09.120
github actions und hier sieht man wieder ein schöne demonstration wie lahm das ganze ist also es hat jetzt es hat ungefähr zwei

02:01:09.200 --> 02:01:12.260
Minuten 30 gebraucht bis das ganze durch ist dass es halt ab

02:01:12.560 --> 02:01:17.960
Zaag langsam aber ihr seht das bild hat funktioniert vm champ ist gebaut und so alles gut

02:01:20.720 --> 02:01:27.520
Also ich baue einen arch user repo ist das ziel ja wobei wir das heute wahrscheinlich nicht. Mehr hinkriegen

02:01:28.520 --> 02:01:35.280
Heute machen wir nur github actions und hängen das art bild artefakt an den an den job an den job dran das muss dann muss dann

02:01:35.280 --> 02:01:40.960
Reichen also ich habe gesehen es ist richtig richtig langsam das ganze also ab ab fack langsam

02:01:41.880 --> 02:01:45.040
Und jetzt zeige ich euch mal dass das cashen was gebracht hat guckt bei

02:01:49.160 --> 02:01:51.160
Warum ist da nix im cash

02:01:57.520 --> 02:01:59.520
Also

02:02:15.840 --> 02:02:17.840
Habe ich mich irgendwie

02:02:27.680 --> 02:02:29.680
Hab ich mich irgendwo vertan

02:02:34.480 --> 02:02:36.480
Dr. Bild x

02:02:39.680 --> 02:02:41.680
Ne das habe ich doch sogar kopiert

02:02:47.920 --> 02:02:54.160
Ich habe was vergessen leute jetzt weiß ich ich habe keine permissions auf dem cashen

02:02:54.320 --> 02:02:57.400
Jetzt weiß ich ich habe keine permissions auf den cash

02:02:57.960 --> 02:02:59.960
Da habe ich ja noch gar nicht drüber geredet ja

02:03:00.400 --> 02:03:06.800
Bei muss für manche sachen wie zum beispiel schreibrechte muss man explizit für github actions anfordern

02:03:08.440 --> 02:03:14.320
Ich hatte keine schreibrechte auf den cash deswegen ging das nicht ist natürlich doof dass er da kein fehler schmeißt

02:03:14.320 --> 02:03:21.680
Okay jetzt jetzt sollte es funktionen jetzt müssen wir das ganze noch mal angucken okay optimaler zeitpunkt leute

02:03:22.400 --> 02:03:24.960
Ich warte auf den pusher und gehe ich noch mal kacken schnell

02:03:27.520 --> 02:03:31.920
Die die pizza hut pizza muss raus af af klo

02:03:36.960 --> 02:03:39.680
Wir warten noch bis der bild gestartet ist okay

02:03:39.680 --> 02:03:44.240
Wir warten noch bis der bild gestartet ist okay hier so gleich wieder da

02:06:39.680 --> 02:06:41.680
Fertig

02:06:41.680 --> 02:06:48.080
Komm mal ich komme genau richtig ich bin genau richtig am start bild ist fertig und klo ist fertig

02:06:49.040 --> 02:06:51.040
exzellent

02:06:51.120 --> 02:06:56.320
Diesmal hat sogar noch länger gedauert was wahrscheinlich daran liegt dass es was in cash geschrieben hat cashes

02:06:56.960 --> 02:07:00.080
Ja guck mal da wir haben was im cash stehen

02:07:00.960 --> 02:07:07.360
Bin auch in der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle

02:07:07.520 --> 02:07:09.200
Kleintivalente

02:07:09.200 --> 02:07:10.240
J an deržeist

02:07:10.240 --> 02:07:17.640
die stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle der stelle

02:07:17.760 --> 02:07:18.000
Diss

02:07:18.000 --> 02:07:23.760
Der gerade be opinionetene

02:07:23.920 --> 02:07:25.920
{\an8</ realizes

02:07:26.720 --> 02:07:28.400
sailed

02:07:28.400 --> 02:07:36.820
Ei

02:07:37.360 --> 02:07:40.560
Teraform anschmeißen um irgendwas zu professionieren

02:07:41.760 --> 02:07:43.760
zu professionieren oder

02:07:44.200 --> 02:07:51.760
Konfigurieren oder was auch immer es gibt bestimmt sogar eine fertige ansible action oder sowas aber github action selbst ist dafür nicht gedacht und kann

02:07:51.760 --> 02:07:57.680
Man dafür auch nicht gut verwenden um ähnliche sachen zu wachen wie mit terraform und auch nicht ähnliche sachen wie mit ansible

02:07:59.560 --> 02:08:01.560
Dafür ist es nicht da

02:08:01.960 --> 02:08:06.120
So und jetzt werde ich euch zeigen ihr habt gesehen das bild dauert

02:08:06.800 --> 02:08:10.000
Fast drei minuten 30 und jetzt passt mal auf

02:08:10.720 --> 02:08:12.720
Wir pushen das ganze jetzt einfach noch mal

02:08:13.440 --> 02:08:15.680
Und ihr werdet feststellen das bild

02:08:16.200 --> 02:08:18.040
geht jetzt

02:08:18.040 --> 02:08:20.040
erstaunlich viel schneller

02:08:23.560 --> 02:08:25.560
Bild

02:08:33.360 --> 02:08:35.360
Check out repo install bild x

02:08:37.120 --> 02:08:39.120
Guck mal da

02:08:41.720 --> 02:08:43.720
Guck mal da

02:08:44.720 --> 02:08:46.720
Und er ist fertig

02:08:48.680 --> 02:08:54.820
Er ist durch in 18 sekunden also so so ein bild zu cashen ist schon nicht verkehrt

02:08:56.160 --> 02:09:02.160
Also drei drei drei minuten 30 versus versus 28 sekunden ist schon ein kleiner unterschied

02:09:03.160 --> 02:09:08.720
Also es lohnt sich auf jeden fall den cash von github actions zu benutzen wie man jetzt hier sieht

02:09:10.400 --> 02:09:12.480
Das ist das ist eine sehr sinnvolle geschichte

02:09:15.960 --> 02:09:19.320
Cache das denn auch für den nächsten tag ja

02:09:22.040 --> 02:09:24.040
Wobei ob es für den nächsten tag

02:09:25.280 --> 02:09:30.720
Es casht auf jeden fall für den gleichen branche ob es für den nächsten tag casht

02:09:32.480 --> 02:09:37.640
Müssen wir mal gucken für den gleichen branche casht es auf jeden fall testen wir das doch mal

02:09:39.360 --> 02:09:41.360
0.4

02:09:45.200 --> 02:09:52.640
0.4 wenn er pro tag einen full bild macht wäre ja nicht so schlimm weil tags nicht oft kommen

02:09:52.640 --> 02:09:59.200
Ja warum sollte ich jetzt mehrere jobs oder gar mehrere workflows machen für sowas kleines

02:10:04.640 --> 02:10:07.400
Mal gucken ob das jetzt greift beim nächsten tag

02:10:09.040 --> 02:10:15.120
Schauen wir mal also im gleichen branche greift es auf jeden fall bei tags bin ich mir nicht sicher

02:10:16.520 --> 02:10:21.240
Das ist ein bisschen ein bisschen ein bisschen ein bisschen ein bisschen ein bisschen ein bisschen ein bisschen

02:10:22.640 --> 02:10:29.760
Das ist gescoped pro branche also es durchaus möglich dass es auch gescoped ist pro tag und deswegen jetzt nicht schneller ist

02:10:31.200 --> 02:10:33.200
Sehen wir ja gleich

02:10:36.800 --> 02:10:38.800
Ne oder

02:10:39.920 --> 02:10:41.920
Ne okay

02:10:41.960 --> 02:10:49.680
Tags wenn man unterschiedliche tags pusht dann ist es nicht gecasht weil das immer gescoped ist auf den jeweiligen branche und tag ist ja

02:10:49.680 --> 02:10:52.960
Quasi so eine art branche nur dass du dran ändern kannst

02:10:53.400 --> 02:10:59.300
Okay also für tags bringt es nicht so viel für branches bringt es allerdings sehr viel wir können das jetzt mal umstellen um das

02:10:59.300 --> 02:11:06.620
Um das zu zeigen also wir wir pushen jetzt hier nicht und und tag sondern wir pushen wir pushen und branche also

02:11:07.840 --> 02:11:14.480
Ich habe kein bock selbst kaputt zu machen aber wir könnten das umstellen auf branches pushen und dann wäre es

02:11:15.520 --> 02:11:17.520
gecasht

02:11:19.960 --> 02:11:22.120
Also anscheinend pro tag ist es wohl nicht so

02:11:26.080 --> 02:11:31.560
Was aber eigentlich logisch ist weil sie sagen ja es ist es ist gescoped pro branche also

02:11:33.840 --> 02:11:35.840
Ergibt ergibt eigentlich sinn

02:11:40.640 --> 02:11:42.760
Zumindest der bild ist sehr viel schneller

02:11:44.920 --> 02:11:48.640
Wenn auch nicht von tag zu tag aber von pusht zu pusht im gleichen branche

02:11:50.080 --> 02:11:53.280
Als letztes müssen wir uns jetzt noch angucken wie

02:11:55.120 --> 02:11:59.680
Kriegen wir jetzt das binary was wir hier raus kopiert haben wie kriegen wir das binary

02:12:00.240 --> 02:12:07.160
Irgendwie hier veröffentlicht auf github zum beispiel für den nightly bild oder den daily bild oder sowas und dafür gibt es eine

02:12:07.600 --> 02:12:09.600
upload action

02:12:10.280 --> 02:12:12.280
Und die sieht so aus

02:12:13.640 --> 02:12:17.480
Name nehmen wir es einfach mal upload binary

02:12:17.480 --> 02:12:23.120
Uses das muss ich mir jetzt kopieren uses action

02:12:28.000 --> 02:12:33.200
Uses action upload artifact hier auch wenn er versioniert auf 3.1.2 dass da nicht aus

02:12:33.800 --> 02:12:39.920
irgendwie aus versehen was kaputt geht so jetzt muss man den name angeben unter welchem name das

02:12:40.720 --> 02:12:46.160
Binary beziehungsweise dass das zip file dann hochgeladen werden soll das ist immer ein zip file

02:12:47.000 --> 02:12:50.520
Das soll hochgeladen werden unter vm champ

02:12:51.680 --> 02:12:53.680
Minus linux

02:12:54.040 --> 02:12:59.680
Minus und jetzt wollen wir an der stelle auch wieder die github tag version minus minus ref name

02:13:02.360 --> 02:13:06.120
Minus amd 64 soll das ganze heißen

02:13:06.920 --> 02:13:12.760
Wirst du noch sagen wo er das ganze her bekommt und zwar bekommst du das her unter temp out vm champ

02:13:13.760 --> 02:13:17.680
Und dann brauchen wir noch retention days das brauchen wir nicht

02:13:18.120 --> 02:13:23.280
Aber mehr als einen tag aufheben ist jetzt relativ sinnlos ich will ja nicht mal einen speicherplatz unnötig belasten

02:13:23.840 --> 02:13:25.920
Ich hoffe der bildjob ist gleich mal durch

02:13:26.800 --> 02:13:28.800
immer noch in progress

02:13:32.240 --> 02:13:34.240
Hoffentlich haben wir es jetzt gleich mal

02:13:43.760 --> 02:13:45.760
Ja jetzt ist er fertig

02:13:49.880 --> 02:13:55.760
Müsste der cash nicht in der branche auch in weil also im branche ist das mit dem cash bei jedem push

02:13:56.480 --> 02:14:02.560
Ist das so also der kann auf den cash zugreifen dass das schreiben die auch explizit auf der seite

02:14:03.120 --> 02:14:09.640
Von docker bild und der implementierung von diesem von diesem cash dass das gescopt ist pro pro branche

02:14:09.760 --> 02:14:16.000
Ja gut über text schreiben sie nichts aber in dem fall ergibt es irgendwie sinn ja jeder tag ist ja wenn das so wills für sich

02:14:16.000 --> 02:14:18.000
genommen sein eigener branche

02:14:25.720 --> 02:14:28.080
So dann kommenden wir das ganze jetzt war

02:14:31.120 --> 02:14:36.160
Wir haben jetzt ja nichts großartig geändert außer dass er den output upload

02:14:36.160 --> 02:14:45.120
Bei dockerfile change doch bei dockerfile change je nachdem wo du das dockerfile nicht nicht dickerfile

02:14:48.000 --> 02:14:55.200
Yep, jepp cock je nachdem wo du das dockerfile änders da speichert sich schon die einzelnen steps da cashe sich die einzelnen steps

02:14:55.520 --> 02:15:00.160
Also wenn du jetzt hier was änderst dann ist es dann ist es können wir gleich ausprobieren

02:15:00.400 --> 02:15:04.080
Dann ist es nur ab hier wo was neu machen muss können wir gleich können wir gleich ausprobieren

02:15:05.080 --> 02:15:09.800
So also ich pusht das ganze jetzt noch mal pusht blablabla tag

02:15:17.040 --> 02:15:22.480
Und jetzt werden wir ich habe ja nur das hier hinzugefügt dass sie die sache uploadet und jetzt werdet ihr sehen haben wir

02:15:22.480 --> 02:15:24.480
eine sehr schnelle github action wieder laufen

02:15:25.240 --> 02:15:27.520
Innerhalb von 20 sekunden ist die wieder durch

02:15:34.080 --> 02:15:38.000
Wenn er dann anfängt install zack

02:15:40.880 --> 02:15:42.880
Ach shit oh nee

02:15:44.000 --> 02:15:46.000
Hä

02:15:49.440 --> 02:15:53.520
Warum macht er das jetzt noch mal ne doch ist okay er hat es aus dem cash geholt

02:15:54.000 --> 02:15:57.880
Ist viel viel zu schnell ist er hat es aus dem cash geholt ich war jetzt erst verwirrt was macht er denn da

02:15:57.960 --> 02:16:04.040
Nee der ist hier durch so zack 32 sekunden fertig und jetzt haben wir hier an dieser action guckt mal da

02:16:04.680 --> 02:16:07.240
Ein artefact hängen und ich darf nicht scrollen

02:16:08.440 --> 02:16:14.360
Vm champ linux v004 amd 64 da hat mir das mal runter das ist eine zip datei

02:16:18.280 --> 02:16:20.280
CD downloads

02:16:20.520 --> 02:16:22.520
Ist es anzip

02:16:23.960 --> 02:16:25.640
Anzip

02:16:25.640 --> 02:16:28.680
ch mod x vm champ

02:16:29.560 --> 02:16:35.000
vm champ minus minus version und sie da es ist lauffähig und version 4

02:16:36.120 --> 02:16:42.760
Also das hat funktioniert wir haben das ding gebaut im container mit mit cash dass es schon schnell baut

02:16:43.400 --> 02:16:50.120
Also das hat funktioniert wir haben das ding gebaut im container mit mit cash das ist schön schnell baut

02:16:52.040 --> 02:16:55.400
Und danach aus dem container extra hier und hochgeladen

02:16:58.200 --> 02:17:02.200
Ach so ja und das alle stimmt stimmt stimmt das allerwichtigste ist natürlich kekwe

02:17:02.200 --> 02:17:07.480
Und das ist bestimmt bild und release action oder sowas

02:17:09.000 --> 02:17:12.360
An die bild und pusht action ja die kann man auch verwenden

02:17:13.560 --> 02:17:17.240
Da musste auch nicht diesen ganzen blödsinn machen den ich in bash gemacht habe

02:17:22.840 --> 02:17:24.840
Die artefacts noch testen

02:17:25.560 --> 02:17:28.280
Ja wenn ich das noch testen kann ich das noch testen

02:17:28.920 --> 02:17:30.920
Die artefacts noch testen

02:17:31.480 --> 02:17:35.840
Ja wenn du wenn du wenn du tests hast genau dafür ist github action star

02:17:36.400 --> 02:17:42.640
Also wenn du jetzt sagst bevor ich das hoch lade möchte ich mit dem binary noch ein paar tests durchführen so nach dem motto

02:17:44.160 --> 02:17:51.800
Steht in der hilfe ausgabe das und das drin ist die version auch wirklich wirklich vier und sowas ja das das wäre natürlich sinnvoll da könnte

02:17:51.800 --> 02:17:53.800
man jetzt hier entweder

02:17:54.360 --> 02:17:59.240
Ups entweder könnte man das hier was mache ich denn

02:18:01.080 --> 02:18:05.960
Entweder könnte man hier noch ein testing step einbauen oder man macht für den testen komplett neuen workflow

02:18:06.480 --> 02:18:08.480
Ja, aber das wäre tatsächlich sehr sinnvoll

02:18:09.160 --> 02:18:15.920
Wenn man da wenn sie also wenn es bei der software sinnvoll ist ja man könnte das jetzt testen tatsächlich was da rauskommt am besten testen natürlich

02:18:16.440 --> 02:18:22.360
Bevor man bevor man das das das artefakt hoch lädt also hier dazwischen hier können wir noch einen test step machen

02:18:23.040 --> 02:18:27.120
Könnte man dann könnte man dann step machen für das testen dass man dann sagt ok

02:18:30.360 --> 02:18:33.160
Test und da könnte man dann so dinge machen wie

02:18:34.000 --> 02:18:37.160
Finden den vm champ ausführen temp out

02:18:37.680 --> 02:18:44.960
Vm champ minus minus help und er hält greppen oder mit minus minus version und dann greppen ob der auch wirklich

02:18:46.720 --> 02:18:50.360
Die richtige versionsnummer hat oder sowas könnte man jetzt machen

02:18:51.120 --> 02:18:58.360
Ja und ganz wichtig wichtig ob ob ob auch keck keck w ausgeführt werden kann keck w ganz enorm wichtig ob das geht

02:18:58.480 --> 02:19:03.840
Aber nachdem es an der stelle keinen sinn macht das zu testen lassen wir es mal aus wir probieren jetzt mal eine sache aus das was

02:19:03.840 --> 02:19:07.240
Der wort die geschrieben hat oder irgendwer hat es geschrieben die wort cs hat es geschrieben

02:19:07.560 --> 02:19:12.360
Was passiert denn jetzt wenn wir das docker file anpassen also mal angenommen man ändert jetzt hier irgendwas im docker file

02:19:13.680 --> 02:19:16.160
Beleg gerade was wir sinnvoll im docker file ändern können

02:19:20.360 --> 02:19:27.640
Ja hier wir wollen wir wollen minus minus p anstatt slash p hier verwenden weil ganz ganz essenziell

02:19:29.160 --> 02:19:31.160
Ja und und minus minus p

02:19:32.920 --> 02:19:36.720
Also wovon da bin ich mir jetzt nicht der wovon ich jetzt ausgehe ist folgendes

02:19:38.040 --> 02:19:43.640
Das kompilieren muss er neu machen weil sich die zeile im docker file geändert hat der muss ab hier alles neu machen

02:19:44.000 --> 02:19:46.680
Das davor kann er aus dem cache benutzen

02:19:47.040 --> 02:19:50.320
Warum denke ich das weil ich gesagt habe

02:19:50.880 --> 02:19:52.000
hier

02:19:52.000 --> 02:19:56.360
Cache tu max und da sollte er angeblich alle zwischen steps

02:19:57.640 --> 02:20:04.480
Cache wobei ich mir nicht sicher bin ob er wirklich alle zwischen steps cached oder alle zwischen images falsches welche gibt cached

02:20:05.640 --> 02:20:09.800
Das müssen wir jetzt mal ausprobieren ob änderungen im docker file den kompletten

02:20:11.720 --> 02:20:13.720
Cache quasi

02:20:14.080 --> 02:20:20.320
Aushebeln sehen wir jetzt gleich also wenn es jetzt drei minuten läuft dann wissen wir geht auf jeden fall nicht

02:20:28.360 --> 02:20:32.560
Aber so weit zu den absoluten basics was

02:20:35.480 --> 02:20:37.480
Github actions angeht

02:20:37.880 --> 02:20:41.920
Das ist wirklich sehr übersichtlich an der stelle hier was wir gemacht haben das ist alles

02:20:42.160 --> 02:20:48.360
Aber ich glaube es sind schon die wichtigsten sachen ok das ging sehr schnell also anscheinend hat das funktioniert hier bild release

02:20:50.280 --> 02:20:52.280
Zack zack zack zack

02:20:52.840 --> 02:20:55.880
Ging ging mega mega zackig alles

02:20:58.120 --> 02:21:01.920
Also er hat aber noch er hat neu kompiliert also wahrscheinlich war das genauso

02:21:07.200 --> 02:21:11.000
Moment ich habe ich habe miss erzählt hat noch gar nicht angefangen

02:21:12.720 --> 02:21:16.000
War das falsche ok ich habe nichts gesagt

02:21:20.760 --> 02:21:22.760
Ja

02:21:24.600 --> 02:21:26.600
Docker bild

02:21:28.160 --> 02:21:30.160
War der alte bild habe ich verguckt

02:21:33.560 --> 02:21:39.600
Ok ja es ist so wie ich gesagt habe er macht am kompilier step weiter

02:21:40.160 --> 02:21:42.760
Er macht dem kompilier step weiter er macht nicht alles

02:21:43.080 --> 02:21:50.320
Er macht das das den compile step machte nur das heißt der cache bringt was auch wenn man das docker file ändert bringt der cache was

02:21:50.400 --> 02:21:54.280
Den ganzen shit davor hat er nicht gemacht er hat hier beim kompilieren angefangen

02:21:56.680 --> 02:21:58.680
So eigentlich nice

02:21:59.160 --> 02:22:04.280
Gut jetzt brauche ein bisschen weil er den cache refreshen muss aber es ist halbwegs geschwind

02:22:04.280 --> 02:22:07.280
Ja gut schön dass das funktioniert hat

02:22:09.000 --> 02:22:11.800
Warten wir mal wie viel er wie viel er wirklich am ende jetzt braucht

02:22:16.440 --> 02:22:19.320
Weil so viel so viel langsamer ist er jetzt auch nicht

02:22:21.000 --> 02:22:23.000
Ja toll

02:22:23.000 --> 02:22:26.920
So also so viel zeit spart man nicht ein bisschen was eine halbe minute spart man

02:22:26.920 --> 02:22:29.640
Na wobei vorher hat es drei minuten noch was gebraucht

02:22:29.720 --> 02:22:36.000
Ja zwischen eineinhalb und zwei minuten spart man ist ist also durchaus ist also durchaus ok auch wenn man das docker file ändert

02:22:36.000 --> 02:22:38.000
Das docker file ändert man nicht so oft

02:22:38.000 --> 02:22:41.160
Ja, also das war es jetzt zur absoluten basics was

02:22:41.800 --> 02:22:43.800
GitHub actions angeht

02:22:44.280 --> 02:22:49.480
Wir haben jetzt auch advancedere topics heute dabei gehabt zum beispiel wie man docker docker files geht

02:22:49.480 --> 02:22:51.480
Also das war es jetzt zur absoluten basics was

02:22:52.040 --> 02:22:54.040
GitHub actions angeht

02:22:54.440 --> 02:23:00.920
Wir haben jetzt auch advancedere topics heute dabei gehabt zum beispiel wie man docker docker files cached also docker build

02:23:01.520 --> 02:23:06.120
Cached normalerweise wollte ich mich jetzt darum kümmern wie man ein arch user repo

02:23:09.400 --> 02:23:12.280
Package bild oder wie auch immer erstellt von arch user repo

02:23:14.280 --> 02:23:19.000
Das können heute allerdings nicht mehr machen weil ich habe immer noch probleme mit meiner pizza

02:23:19.000 --> 02:23:22.940
Und ich habe jetzt kein bock mit bauchweh weiter zu streben das guckt man es dann morgen oder so an wie man

02:23:22.940 --> 02:23:35.720
Wie man ein arch user repo package baut und ein arch user repo automatisch erzeugt per github actions

02:23:36.680 --> 02:23:41.980
Ich vermute mal dass ich mein ssh key per secret im github repo hinterlegen muss

02:23:42.880 --> 02:23:44.760
und

02:23:44.760 --> 02:23:47.960
Ja dann irgendwie package bild customisem und und pushen

02:23:49.440 --> 02:23:53.440
Aber ich denke man hat jetzt ein bisschen ahnung davon wenn man vor allem noch gar nichts mit github actions gemacht hat

02:23:53.440 --> 02:23:59.480
Wie das so aussieht und man hat eine sache zumindest schon mal gelernt caching bei docker container lohnt sich enorm

02:24:05.480 --> 02:24:08.840
Alles klar, ich habe immer noch bauchweh ich gehe jetzt

02:24:08.840 --> 02:24:11.880
Ich gehe jetzt off und noch mal aufs klo bis dann machts gut see you

