WEBVTT

01:09.420 --> 03:20.340
Ja, doch. Die letzte Woche habe ich 600 Euro Tierarztrechnung ausgegeben. Aber ich will ja, dass es Chico gut geht. Ja, aber das ist schon echt ordentlich.

03:20.340 --> 03:30.850
Ich meine, bei mir ist es nicht so wild, ja. Die Kohle muss eh irgendwo hin. Aber schon ganz schön heftig, wenn man sich das überlegt.

03:30.850 --> 03:33.850
Wie macht man das, wenn man jetzt nicht so viel Geld hat?

03:33.850 --> 03:57.800
Ich meine, es war ja nicht zum Fenster rausgeschmeißt. Es war für die Katz sozusagen. Aber 600 Euro Tierarztkost, schon krass. Ich war... Ich habe einmal... Einmal habe ich das... Ne, ich will keine neue Katz.

03:57.800 --> 04:26.110
Einmal waren die hier, haben sich Chico angeguckt. Dann war ich beim Augenarzt mit Chico. Moment, die Musik ist zu laut. Wait. Dann war ich beim Augenarzt mit Chico.

04:26.110 --> 04:35.770
Dann war ich beim Augenarzt mit Chico. Also, also das Ding war, ich habe letzte Woche, hat Chico hier auf dem Schrank... Ich war mal nicht vor M an.

04:35.770 --> 04:42.770
Letzte Woche hat Chico, letztes letzte Wochenende hat Chico hier auf dem Schrank gehockt und hat so ein bisschen, habe ich gesehen, die hat so ein bisschen Blut im Auge gehabt.

04:42.770 --> 04:49.770
Denkt man sich ja erstmal nichts großartiges dabei. Man kann sich gekratzt haben oder irgendwie sonst was. Also unten rechts ein bisschen Blut im Auge.

04:49.770 --> 05:03.770
Aber, nachdem Chico ja bekanntermaßen ein bisschen Nierenprobleme hat und auch nur Diätfutter und alles kriegt. Chico ist ja 13 mittlerweile schon. Er ist jetzt zwar kein alter wirklich für Katzen, aber schon alt.

05:03.770 --> 05:29.770
Also sie sind alt, sie können durchaus noch älter werden, aber auf jeden Fall schon Oma. Und zumindest, dann habe ich im Internet geguckt, dass gerade Katzen mit Nierenerkrankung oftmals auch unter Bluthochdruck leiden und Bluthochdruck bei Katzen sehr oft auf das Auge geht und das Auge blutet und manchmal löst sich auch tatsächlich die Netzhaut ab.

05:30.770 --> 05:48.660
Zumindest war ich dann beim Tierarzt, wo wir sonst hingehen und hab gesagt, ihr Katz hat Blut im Auge und Blutdruck messen. Da haben die irgendwie gesagt, doch nö, wir können gar keinen Blutdruck messen. Fand ich schon sehr pipega, dass sie das so alles überhaupt nicht interessiert hat.

05:48.660 --> 06:01.660
Hab ich mir gesagt, so gut dann, neuen Tierarzt suchen. Hab ich mir neuen Tierarzt gesucht und die sind tatsächlich sogar daheim vorbeigekommen, weil die haben gesagt, dass Blutdruck messen ist am besten, wenn die Katz halt entspannt ist.

06:01.660 --> 06:21.660
Leider war Chico sehr unkooperativ, was Blutdruck messen angeht. Da mussten sie erstmal in ihr Auto hocken und dann haben sie da gemessen und Chico hat halt richtig krass hohen Blutdruck. Chico hat über 250 Blutdruck, normalerweise ist 150 gerade so noch okay. Chico hat super krass hohen Blutdruck.

06:21.660 --> 06:47.350
Jetzt kriegt Chico zusätzlich zu ihren Schilddrüsen und Nierenmedikamenten noch Blutdruck senkende Mittel und für das Blut im Auge war ich mit der Katze beim Augenarzt, ja es gibt Augenärzte für Katzen. Die hat das Auge untersucht, hat gemeint, oh ja, da ist schon ein bisschen blutig und hat auch nochmal Blutdruck gemessen, war auch wieder viel zu hoch.

06:47.350 --> 07:07.350
Und jetzt muss sie noch ein paar Cortison-Tabletten schlucken, dass das alles wieder schön abschwillt im Auge und die Netzhaut auf jeden Fall dran bleibt und sie nicht blind wird. Und jetzt kriegt die halt Blutdruck senkende Mittel und morgen gehe ich schon wieder zum Tierarzt und Mittwoch wieder zum Augenarzt.

07:07.350 --> 07:35.510
Also ich habe wahrscheinlich innerhalb von 14 Tagen bin ich 1000 Euro los, was Tierarzt angeht. Die ist 13, die ist schon älter, da haben die ja öfters mal die ein oder anderen probiert. Oh nee, C++, geh mal weg, ich mache, ich mache, ich mache weg.

07:35.510 --> 07:52.730
Gibt es eine Krankenversicherung? Ey, keine Ahnung, ob es das gibt, aber wenn, ist es wahrscheinlich so unsinnig teuer. Ich bezahle das selbst. Irgendwo muss die Kohle ja hin.

07:52.730 --> 08:17.580
Also ich hoffe, dass es morgen, wenn Blutdruck gemessen wird, dass, also wir waren ja da nochmal letzte Woche Blutdruck messen, und zwar am Freitag, da war er schon runter ein bisschen, aber noch nicht genug. Aber das dauert immer ein bisschen, bis das Blutdruckmedikament bei der Katze im Blut ist, bei Menschen übrigens nicht anders, bis das alles ordentlich wirkt.

08:18.580 --> 08:35.580
Chico bewegt sich auch viel zu wenig, ja. Chico hängt immer nur rum. Und ich hoffe, der Blutdruck ist da noch ein bisschen runter gegangen und beim Augenarzt stellen sie fest, dass alles wieder, alles wieder soweit okay ist und, weil, ganz ehrlich, die Katze klickt halt sehr viel im Medikament und die Katze hat keinen Bock da drauf, die zu nehmen.

08:35.580 --> 09:07.700
Ja, du hast aber sicherlich nicht einmal 80 Euro bezahlt, oder? Ist er Freigänger? Ne, es ist eine Sie, auch wenn sie Chico heißt, ergibt keinen Sinn, aber was weiß ich, was die Vorbesitzer sich dabei gedacht haben. Kann man aber wahrscheinlich auch nur für die junge, für eine junge Katze abschließen, wenn du das für eine 13-jährige Katze abschließt. Da wollen die fast was für sich dafür haben, Alter. Das ist so, wie wenn du mit 70 sagst, ich möchte noch Krankenversicherung abschließen.

09:08.700 --> 09:14.700
Ne, ist er nicht. Das Einzige, was Chico kann, ist, die kann hier auf die Terrasse, aber die Terrasse hat so ein Netz drumherum.

09:14.700 --> 09:49.230
Ich bin ganz schön kaputt heute. Gestern Abend, ähm, ja, wie gesagt, ich bin ganz schön kaputt. Gestern Abend Fahrrad gefahren, 45 Minuten volle Pulle und heute Morgen 10 Kilometer gerannt. Ich merk's echt in den Beinen, das reicht jetzt erstmal. Morgen mach ich nix. Morgen mach ich gar nix. Reicht echt. Ich merk's auch voll im Schienbein.

09:50.230 --> 10:12.230
Du warst heute Morgen nicht da, gell? Heute Morgen hat mich die Waage übelst debatet. Ich bin rübergegangen, hab mich auf die Waage gestellt, hatte noch Socken und Unterhose an. Da hat die Waage 90 Kilo angezeigt. Dann bin ich weg, hab das Handy geholt zum Fotografieren, hab Socken und Unterhose ausgezogen, hat 90,2 oder 90,3.

10:13.230 --> 10:44.460
Das heißt, ich hatte weniger an, hab mehr gewogen. Null. War nix. Es war ganz knapp, es war ganz knapp über 90. Das heißt, noch ein paar Wochen, also bis Ende des Jahres sollte ich dieses Mal unter 90 auf jeden Fall schaffen, wenn das so weitergeht. Ja, wird's ja auch.

10:44.460 --> 11:06.460
Es war nicht so krass wie zu Corona-Zeiten, wo ich angefangen hab mit allem. Ja, man darf nicht vergessen, dass wenn man sich ordentlich bewegt, man kriegt ja auch Muskel. Man tradet ja auch ein bisschen Speck gegen Muskel. Ja, kenn ich, hab ich aber noch nie großartig was mitgemacht.

11:06.460 --> 11:38.270
Excellent. So, dann erstmal Finger aufwärmen für krasse Progress-Action. So, Finger aufgewärmt. Auf geht's. Ich zeig euch mal, für alle, die nicht dabei waren, war jemand beim letzten Rust-Stream dabei und hat mir zugeguckt, wie ich nix gecheckt hab.

11:38.270 --> 12:06.310
Ich zeig euch kurz, was Sache ist und heute wird's nicht so super kompliziert, weil erstens bin ich ziemlich kaputt und hab wahrscheinlich auch jetzt 19 Uhr nicht mehr die größten Brain-Resources übrig. Heute versuchen wir das mal ein bisschen aufzuräumen. Dazu braucht man aber auch Rust-Spezialitäten.

12:06.310 --> 12:36.030
Und dementsprechend schauen wir mal. So, also, hab ich jetzt Package-Updates gemacht? Arch-Linux, by the way, falls jemand Fragen hat. Schon wieder Package-Updates? Meine Güte. Hast du mal zwei Minuten keine Package-Updates gemacht? Ja. Arch use ich, by the way. Packages 171. Ich weiß wahrscheinlich von gerade mal 20 oder so, dass ich die wirklich wissentlich installiert hab.

12:36.030 --> 13:13.580
Übrigens, Leute, jetzt, wo ich ttf-Tweemojis sehe, pass mal auf. Wisst ihr, was ich gesehen hab? Es gibt bald eine neue Tweemoji-Version auf GitHub. Endlich neue Unicode-15-Emojis. Tweemoji-GitHub. Und zwar Discord macht Gigachat-Move. Ja. Discord macht Gigachat-Move und addet den Großteil der fehlenden Unicode-15-Emojis.

13:15.580 --> 13:35.580
Steven from Discord ist am Start. Steven from Discord und sagt, ihr In-House-Artist, der Kevin VQ-Damm, geiler Name, VQ-Damm, hat Emojis open-sourced für Tweemoji.

13:36.580 --> 13:54.580
Also, wer sich fragt, was das Problem ist eigentlich, das Ding ist, Tweemoji ist eigentlich der Twitter-Emoji-Font. Das dumme ist nur, seit Elon Twitter übernommen hat, wurde jegliches Open-Sourcing von ihrem Emoji-Font eingestellt.

13:55.580 --> 14:02.580
Und dementsprechend können die neuesten Emojis nicht einfach kopiert werden von Twitter, weil die halt copyrighted sind. Bei Twitter oder bei X.

14:03.580 --> 14:22.580
Witzigerweise, der Fork auf GitHub ist von alten Twitter-Mitarbeitern, die rausgeschmissen wurden von Twitter und sich damals um den Emoji-Font gekümmert haben.

14:22.580 --> 14:32.580
Und die Discord-Leute haben neue Emojis beigesteuert. Ich glaube, es sind jetzt nahezu alle Unicode-15-Emojis. Das heißt, sie müssen jetzt nur noch einen neuen Font bauen.

14:33.580 --> 14:43.850
Und dann gibt es endlich eine neue Version von Tweemoji, die Unicode-15-kompatibel ist.

14:44.850 --> 14:48.850
Wie sieht es eigentlich mit Unicode-16 aus?

14:49.850 --> 14:57.140
Okay, kommt September 2024 raus.

15:00.290 --> 15:06.290
Aha, guck mal, 2024 gibt es neue Emojis. Gucken wir mal, ob es da schon welche gibt zum angucken.

15:07.290 --> 15:12.290
Fingerprint-Emoji gibt es noch kein Beispiel für. Emoji-16 gibt es noch nicht.

15:13.290 --> 15:18.290
Face with backs under eyes gibt es dann. Aha, alles klar, gibt es auch noch keine Implementierung.

15:19.290 --> 15:31.430
Blätter, Leafless-Tree, Harp, eine Schaufel und irgendwelche Veganer-Sachen.

15:32.430 --> 15:35.430
Unbedingt Unicode-16 braucht es.

15:38.000 --> 15:46.000
Da bin ich wirklich froh, dass hier Discord-Leute den Giga-Chat-Modus gezündet haben und neue Emojis beisteuern.

15:46.000 --> 15:54.000
Dann heißt das Ding zwar Tweemoji, hat aber nicht die Emojis von Twitter, wobei Twitter auch nicht mehr Twitter, sondern X heißt.

15:55.000 --> 15:58.000
Also Chat, weiter geht's.

15:59.000 --> 16:01.000
Hier sind wir stehen geblieben. Ich zeige euch, wie wir stehen geblieben sind.

16:02.000 --> 16:09.000
Das Ziel ist eine WebRTC-Anwendung zu bauen mit Low-Level-WebRTC in Rust.

16:10.000 --> 16:12.000
Frontend ist ein bisschen HTML-JavaScript.

16:13.000 --> 16:18.000
Backend, weil ein bisschen mehr Backend erforderlich ist, als nur Seite auszuliefern, ist eine .NET-Anwendung.

16:19.000 --> 16:22.000
Und die .NET-Anwendung macht Interop mit Rust.

16:23.000 --> 16:29.000
Ich zeige euch das Ganze mal. Wir machen hier mal Rust auf.

16:30.000 --> 16:39.000
Mal kurz in die JetBrains-Toolbox looken, ob es neue Versionen von den IDEs gibt.

16:40.000 --> 16:44.630
Massive. Es gibt neue Versionen von PyCharm und Golan.

16:45.630 --> 16:50.630
Ja, brauche ich jetzt ehrlich gesagt. Aber komm, wir machen Update.

16:50.630 --> 16:53.630
So, dann müssen wir Rider starten.

16:54.630 --> 16:57.630
Frontend mit dem Framework oder Plain?

16:58.630 --> 17:04.630
In dem Fall Plain, weil das Frontend gerade 30 Zeilen ist. Da ist nicht viel zu sehen.

17:05.630 --> 17:07.630
Ich zeige dir gleich, wie das aussieht.

17:08.630 --> 17:12.630
Also das hier ist aktuell alles, was das Frontend beinhaltet.

17:13.630 --> 17:15.630
Das macht zur Zeit nichts anderes als WebRTC-Verbindungsaufbau.

17:15.630 --> 17:17.630
Und dann auf die Webseite schreiben.

17:18.630 --> 17:20.630
Boah, laggy im Hintergrund.

17:21.630 --> 17:23.630
Alter, wie das... What the f...

17:24.630 --> 17:26.630
Das Update... Alter.

17:27.630 --> 17:30.630
JetBrains. Java. Keck Java.

17:33.200 --> 17:34.200
Was ist da los?

17:36.960 --> 17:39.960
Die brauchen beim Updaten der IDEs einfach mal alle 8 CPU-Cores.

17:49.820 --> 17:50.820
So gehört sich das.

17:54.740 --> 17:55.740
Ich habe das All-Products-Pack, ja.

18:07.900 --> 18:09.900
Was genau macht das da jetzt 3 Stunden beim Updaten?

18:09.900 --> 18:11.900
Oh, es gibt eine neue Sea Lion.

18:14.660 --> 18:15.660
Interesting.

18:29.430 --> 18:31.430
So. Update ist gelaufen.

18:32.430 --> 18:35.430
Gut. Also, ich zeige euch mal, wie das aktuell aussieht.

18:36.430 --> 18:37.430
Das Frontend ist äußerst unspektakulär.

18:38.430 --> 18:40.430
Da sieht man nicht viel, aber ich zeige es euch mal trotzdem.

18:41.430 --> 18:42.430
.NET Run.

18:44.430 --> 18:45.430
Aktuell sieht das...

18:46.430 --> 18:47.430
Äh, Moment. Ist das überhaupt...

18:48.430 --> 18:49.430
Moment, Moment. Das geht ja gerade gar nicht.

18:49.430 --> 18:55.870
Geht ja gerade gar nicht, weil ich gestern in weiser Voraussicht die Hälfte auskommentiert habe.

18:56.870 --> 18:57.870
Keck, wait.

18:58.870 --> 18:59.870
Die wir jetzt wieder einkommentieren müssen.

19:09.100 --> 19:10.100
Wait a minute. Ich glaube, es ist gerade kaputt.

19:11.100 --> 19:13.100
Wir haben doch gestern noch mit UIDs rumgewurschtelt, oder?

19:14.100 --> 19:19.780
Ja, es ist gar kein UN64 mehr.

19:20.780 --> 19:21.780
Das wird jetzt gar nicht funktionieren.

19:22.780 --> 19:23.780
Pass mal auf, das crasht jetzt.

19:31.540 --> 19:34.540
Okay. Wir haben das etwas unfertig hinterlassen gestern.

19:35.540 --> 19:36.540
Das Ganze.

19:38.540 --> 19:40.540
Wir haben so halb aufgehört.

19:41.540 --> 19:42.540
Zwischendrin.

19:43.540 --> 19:44.540
Zumindest, dass das Frontend...

19:45.540 --> 19:49.540
Oh, wir müssen gerade mal kurz eine Sache im Frontend machen. Das ist mir viel zu hell.

19:50.540 --> 19:51.540
Ähm, Style.

19:52.540 --> 19:54.540
Wie macht man das? Background, Color.

19:55.540 --> 19:56.540
Und jetzt?

19:57.540 --> 19:58.540
Keine Ahnung.

19:59.540 --> 20:00.540
Gray, oder sowas?

20:03.810 --> 20:08.420
Okay, schon besser.

20:09.420 --> 20:11.420
Okay, ja, ein bisschen nicht ganz so anstrengend.

20:12.420 --> 20:13.420
Okay.

20:14.420 --> 20:16.420
Also das Frontend ist äußerst simpel.

20:17.420 --> 20:18.420
Das ist alles an JavaScript.

20:19.420 --> 20:21.420
Der baut eine WebRTC-Verbindung auf.

20:22.420 --> 20:23.420
Im Detail werdet ihr es wahrscheinlich gleich sehen.

20:24.420 --> 20:25.420
Dann ist das hier das .NET-Backend.

20:26.420 --> 20:27.420
Moment, das hier ist das .NET-Backend.

20:28.420 --> 20:29.420
Da passiert auch nicht viel.

20:30.420 --> 20:32.420
Und das hier ist die Raster-Anwendung. Das ist da, wo wir heute drin rumbauen werden.

20:33.420 --> 20:34.420
Und ich glaube,

20:35.420 --> 20:38.420
ich glaube, Chad, wir müssen das erstmal wieder funktional machen.

20:39.420 --> 20:40.420
Bevor wir jetzt weitermachen.

20:40.420 --> 20:42.420
Deswegen, ich schmeiß

20:43.420 --> 20:45.420
diesen Krempel hier mit

20:47.990 --> 20:49.990
mit der UID schmeiß ich wieder raus.

20:52.880 --> 20:54.880
Wir machen da wieder ein U64 draus.

20:55.880 --> 20:58.880
Sodass, sodass, erstmal, erstmal kurz machen, dass es wieder funktioniert.

20:59.880 --> 21:03.790
Okay, ja.

21:04.790 --> 21:05.790
Wozu baust du das denn?

21:06.790 --> 21:07.790
Erstens, um ein bisschen Rust zu lernen.

21:08.790 --> 21:09.790
Und zweitens, weil ich vorhabe, alle meine Webcams

21:10.790 --> 21:12.790
realtime zu streamen auf eine Webseite.

21:20.220 --> 21:22.220
ID. ID kommt hier her.

21:23.220 --> 21:24.220
ID ist einfach 1. Jetzt hardcoded.

21:25.220 --> 21:27.220
Gucken, ob es noch

21:28.220 --> 21:30.220
ob es noch compiled.

21:31.220 --> 21:32.220
Cargo.

21:33.220 --> 21:34.220
Nope.

21:38.940 --> 21:40.940
UID mal wieder rausschmeißen.

21:41.940 --> 21:45.280
1.

21:49.130 --> 21:51.130
Und wo hat er jetzt noch Schmerzen?

21:54.980 --> 21:55.980
Client ID.

21:56.980 --> 21:59.670
Hä?

21:59.670 --> 22:00.670
Wie?

22:03.370 --> 22:05.370
Wie kommt er da drauf, dass es ein U128 sein soll?

22:06.370 --> 22:07.370
Will er mich gebanen?

22:08.370 --> 22:12.020
Achso!

22:13.020 --> 22:15.020
Weil hier oben die Collections noch U128 sind, gell?

22:16.020 --> 22:17.020
Ah, okay, alles klar.

22:18.020 --> 22:19.020
Nice. Und jetzt?

22:20.020 --> 22:21.020
Okay, was ist jetzt für ein Problem?

22:22.020 --> 22:25.620
Und?

22:26.620 --> 22:31.100
71. Pounds.

22:32.100 --> 22:33.100
128. Ah.

22:34.100 --> 22:35.100
U64.

22:36.100 --> 22:37.100
U64.

22:37.100 --> 22:41.060
So, ich glaube, wir sollten nirgendwo mal U128 benutzen.

22:42.060 --> 22:43.060
So, und wenn das jetzt funktioniert,

22:44.060 --> 22:46.060
dann sollte auch alles wieder klappen

22:47.060 --> 22:48.060
und das sollte laufen.

22:49.060 --> 22:50.060
Zwar nicht perfekt,

22:51.060 --> 22:52.060
aber laufe ich sein?

22:53.060 --> 22:57.390
Oh man! Alter, ich hab's kaputt gemacht gestern.

22:58.390 --> 22:59.390
Jetzt müssen wir das...

23:00.390 --> 23:02.390
Jetzt müssen wir das erst mal fixen wieder.

23:03.390 --> 23:04.390
Okay, also.

23:13.810 --> 23:14.810
Na geil, na geil.

23:15.810 --> 23:16.810
Jetzt haben wir das irgendwie zerstört.

23:17.810 --> 23:18.810
Warum?

23:19.810 --> 23:20.810
Was haben wir hier zerstört?

23:21.810 --> 23:22.810
Was will er eigentlich von mir, man?

23:23.810 --> 23:24.810
Achso, ich weiß warum.

23:25.810 --> 23:26.810
Weil ich das falsche returne.

23:27.810 --> 23:29.810
Wir returnen jetzt kein U128 mehr,

23:30.810 --> 23:31.810
sondern ein U46.

23:32.810 --> 23:33.810
U in 46.

23:34.810 --> 23:35.810
So, jetzt geht's wieder.

23:39.850 --> 23:40.850
Nice. Guck, passt wieder.

23:41.850 --> 23:44.540
Also, folgendermaßen.

23:45.540 --> 23:46.540
Frontend?

23:47.540 --> 23:48.540
Das Cray.

23:49.540 --> 23:51.540
Gibt das nicht irgendwie Light Cray oder sowas?

23:54.560 --> 23:55.560
Azure.

23:56.560 --> 23:59.380
Äh.

24:00.380 --> 24:01.380
Okay, wir können einfach...

24:02.380 --> 24:03.380
Wir können einfach...

24:08.190 --> 24:09.190
Wie geht das? RGB?

24:10.190 --> 24:11.190
Ich wollte gerade sagen,

24:12.190 --> 24:13.190
Visual Studio hat doch da so einen Selektor.

24:15.950 --> 24:16.950
Perfekt.

24:17.950 --> 24:18.950
Hä?

24:19.950 --> 24:27.320
Das ist doch im Leben nicht die gleiche Farbe, oder?

24:28.320 --> 24:29.320
Hä?

24:30.320 --> 24:34.360
Moment, was...

24:35.360 --> 24:36.360
Was zum...

24:37.360 --> 24:49.850
Hat da Visual Studio Code gerade draus gemacht?

24:50.850 --> 24:51.850
Okay, ja, so ist es okay.

24:52.850 --> 24:53.850
So lass ich mir das gefallen.

24:54.850 --> 24:55.850
Das ist ganz...

24:56.850 --> 24:57.850
Es ist wirklich easy, es macht nicht viel.

24:58.850 --> 25:00.850
Es versucht eine WebRTC-Verbindung aufzubauen.

25:01.850 --> 25:03.850
Dazu holt es sich vom Backend die Informationen,

25:04.850 --> 25:07.850
was der Server für Codecs und alle möglichen Sachen unterstützt.

25:08.850 --> 25:13.850
Dann subscribes es zum ConnectionState-Event

25:14.850 --> 25:17.850
und ändert hier ein bisschen die Farbe und den Text auf der Webseite,

25:18.850 --> 25:19.850
wenn sich da was ändert.

25:20.850 --> 25:21.850
Dann schickt es eine Antwort an den Server zurück,

25:22.850 --> 25:23.850
was der Browser selbst für Codecs unterstützt.

25:24.850 --> 25:25.850
Und...

25:26.850 --> 25:27.850
Ja, das war's.

25:28.850 --> 25:29.850
Mehr macht das Frontend nicht.

25:30.850 --> 25:33.850
Das Ganze wird quasi mehr oder weniger durch die .NET-Anwendung durchgeschleift.

25:34.850 --> 25:35.850
Das ist alles.

25:36.850 --> 25:37.850
Das ist alles, was einen hier großartig interessieren muss.

25:38.850 --> 25:40.850
Und das landet dann in der jeweiligen Rust.

25:41.850 --> 25:43.850
In der jeweiligen Rust-Endpunkt.

25:44.850 --> 25:46.850
Rust ist deutlich komplizierter gewesen gestern,

25:47.850 --> 25:48.850
als ich mir das vorgestellt habe.

25:49.850 --> 25:50.850
Und zwar...

25:51.850 --> 25:52.850
Die Main-Funktion brauchen wir nicht.

25:52.850 --> 25:53.850
Das ist ein asynchrones Rust.

25:54.850 --> 25:55.850
Das heißt, das läuft mit Tokio.

25:56.850 --> 26:01.850
Und damit Tokio funktioniert, braucht man eine Tokio-Runtime.

26:02.850 --> 26:03.850
Leute, ich habe bis heute nicht gecheckt, was es genau macht

26:04.850 --> 26:05.850
und wofür das Ganze gut ist.

26:06.850 --> 26:07.850
Aber es hat funktioniert,

26:08.850 --> 26:11.850
nachdem wir gestern sehr viel Try-and-Error rumgefuddelt haben.

26:15.120 --> 26:17.120
Und jetzt funktioniert es.

26:21.030 --> 26:23.030
Und man sieht hier die entsprechenden Sachen,

26:24.030 --> 26:25.030
die in C-Sharp aufgerufen werden.

26:26.030 --> 26:27.030
Hier wird beispielsweise aufgerufen Get-Offer.

26:28.030 --> 26:32.030
Hier wird Create-Connection aufgerufen.

26:33.030 --> 26:34.030
Hier wird Set-Answer aufgerufen.

26:35.030 --> 26:37.030
Wenn man sich das hier in Rust anguckt, sieht man das auch.

26:38.030 --> 26:39.030
Das ist eigentlich das Einzige.

26:40.030 --> 26:41.030
Hier passiert eigentlich das meiste.

26:42.030 --> 26:44.030
Der erstellt eine neue WebRTC-Connection.

26:50.570 --> 26:52.570
Hier, der erstellt eine neue WebRTC-Connection.

26:53.570 --> 26:54.570
Warum habe ich hier Tracks?

26:55.570 --> 27:01.850
Das ergibt überhaupt keinen Sinn.

27:02.850 --> 27:03.850
Ah, Tracks, weil ich die...

27:04.850 --> 27:05.850
Okay, ergibt doch Sinn.

27:05.850 --> 27:06.850
Hier erstelle ich eine WebRTC-Connection

27:07.850 --> 27:11.850
und hole mir dann raus, was der Server für Codecs unterstützt.

27:12.850 --> 27:13.850
Was für Codecs unterstützt werden, stelle ich hier ein.

27:14.850 --> 27:18.850
Es wird genau ein Codec unterstützt, und zwar H.264

27:19.850 --> 27:21.850
mit 90.000 Clockrate, das ist alles.

27:22.850 --> 27:26.800
Hier wird die WebRTC-Verbindung aufgebaut

27:27.800 --> 27:30.800
und hier wird die Sache, die der Browser antwortet, gesetzt.

27:31.800 --> 27:32.800
Ist aber alles nicht so wild,

27:33.800 --> 27:34.800
weil heute geht es um syntaktische Rust-Geschichte,

27:34.800 --> 27:36.800
weniger um die WebRTC-Sache an sich.

27:37.800 --> 27:39.800
Denn, was ich mir überlegt habe, ist,

27:40.800 --> 27:41.800
das hier ist ja kein schönes Rust hier oben.

27:42.800 --> 27:44.800
Also, schön ist hier vieles nicht dran,

27:45.800 --> 27:48.800
beispielsweise diese ganzen Calls mit GetUnwrap, ReadUnwrap.

27:49.800 --> 27:50.800
Das sieht schon abartig aus.

27:51.800 --> 27:58.080
Was willst du da absichern?

27:59.080 --> 28:01.080
Es macht keinen Sinn, die abzusichern, weil es...

28:02.080 --> 28:04.080
Es darf durchaus crashen, wenn...

28:05.080 --> 28:06.080
Also, wenn das hier nicht funktioniert, was soll er machen?

28:07.080 --> 28:08.080
Dann muss er ja crashen im Endeffekt.

28:08.080 --> 28:10.080
Ach so, gut. Ja doch, du hast insofern recht.

28:11.080 --> 28:12.080
Stimmt schon.

28:13.080 --> 28:15.080
Man könnte gucken, wenn es aus irgendwelchen Gründen nicht klappt,

28:16.080 --> 28:17.080
dass das Main-Programm nicht crasht.

28:18.080 --> 28:20.080
Aber ganz ehrlich, das sind solche Dinger,

28:21.080 --> 28:22.080
die sollten eigentlich nicht crashen.

28:23.080 --> 28:24.080
Also, die sollten eigentlich nicht fehlschlagen.

28:25.080 --> 28:26.080
Wenn sie doch fehlschlagen, ist irgendwas kaputt,

28:27.080 --> 28:28.080
dann soll es halt crashen.

28:29.080 --> 28:30.080
Ist schon okay.

28:31.080 --> 28:33.080
Dass hier eine hardcoded-ID drin ist, ist übrigens auch nicht so sinnvoll.

28:34.080 --> 28:38.930
Java ist gigalangsam, das stimmt überhaupt nicht.

28:38.930 --> 28:39.930
Java ist gar nicht so lahm.

28:40.930 --> 28:41.930
Java ist...

28:42.930 --> 28:43.930
Sag mal so aus...

28:44.930 --> 28:45.930
Historisch wurde gerne über Java geflamed.

28:46.930 --> 28:47.930
Und...

28:48.930 --> 28:49.930
Gerade über Memory-Consumption.

28:50.930 --> 28:52.930
Aber die reine CPU-Performance ist Java gar nicht so schlecht.

28:53.930 --> 28:54.930
Genauso wie C-Sharp und .NET.

28:55.930 --> 28:56.930
.NET ist sogar ziemlich schnell.

28:57.930 --> 28:58.930
Sogar einen Ticken schneller als Java, je nachdem,

28:59.930 --> 29:00.930
was man sich für Benchmarks anguckt.

29:01.930 --> 29:03.930
So, und zwar, wir haben hier ganz viele globale Variablen.

29:04.930 --> 29:06.930
Das ist nicht gerne gesehen in Rust.

29:06.930 --> 29:07.930
Mal ganz davon abgesehen,

29:08.930 --> 29:09.930
dass mich das nicht wirklich interessiert,

29:10.930 --> 29:13.930
ob das irgendwelche Rust-Experten als schön oder nicht schön empfinden.

29:14.930 --> 29:16.930
Das Ding ist, es geht nicht anders als globale Variablen.

29:17.930 --> 29:18.930
Denn, es ist ja nicht...

29:19.930 --> 29:20.930
Es liegt ja hier nicht in der Hand,

29:21.930 --> 29:23.930
von Rust das alles zu machen,

29:24.930 --> 29:27.930
sondern, ich call ja in den Rust-Code von außen rein.

29:28.930 --> 29:31.930
Das heißt, ich brauche irgendwie den State vom letzten Call

29:32.930 --> 29:34.930
und den kann Rust nicht tracken für mich.

29:34.930 --> 29:35.930
Wie soll es das machen?

29:36.930 --> 29:38.930
Das wird aufgerufen von C aus

29:39.930 --> 29:43.930
und geht dann zurück mit ein paar Sachen zu dem C-Interface zurück.

29:44.930 --> 29:47.930
Das heißt, wir brauchen ein paar statische Variablen.

29:48.930 --> 29:49.930
Was ich mir jetzt überlegt habe,

29:50.930 --> 29:51.930
und da bin ich mal gespannt, ob ich das hinkriege.

29:52.930 --> 29:54.930
Was mir hier persönlich am allerwenigsten gefällt,

29:55.930 --> 29:57.930
sind diese ganzen Unwrap-Orgien.

29:59.930 --> 30:01.930
Das sieht einfach total unreadable und eklig aus.

30:01.930 --> 30:02.930
Und was mir auch nicht gefällt,

30:03.930 --> 30:05.930
sind diese Ultra-Deep-Nested-Typen.

30:06.930 --> 30:07.930
Guckt euch das mal an.

30:08.930 --> 30:09.930
Da rast es da aus.

30:10.930 --> 30:13.930
Once-Log, Rw-Log, Hash-Map, Arc-Track...

30:14.930 --> 30:17.930
Im Prinzip will ich einfach nur einen Dictionary haben

30:18.930 --> 30:21.930
mit int64 als Key

30:22.930 --> 30:26.930
und diesem Struct hier als Value.

30:27.930 --> 30:28.930
Damit das funktioniert,

30:28.930 --> 30:31.930
musst du das in diesen ganzen Krempel reinwrappen.

30:32.930 --> 30:33.930
Das ist echt nicht normal.

30:34.930 --> 30:35.930
Deswegen habe ich mir überlegt,

30:42.460 --> 30:43.460
wir machen folgendes.

30:44.460 --> 30:47.460
Wir haben nämlich aktuell da so einen kleinen Bug drin,

30:48.460 --> 30:49.460
der daraus resultiert,

30:50.460 --> 30:51.460
dass ich gestern nicht besser darüber wusste,

30:52.460 --> 30:53.460
was ich machen soll.

30:54.460 --> 30:56.460
Und zwar jede Connection und jeder Track,

30:57.460 --> 30:58.460
der angelegt wird.

30:59.460 --> 31:00.460
Also mit Track ist in Video gemeint.

31:01.460 --> 31:02.460
Das Ziel ist ja im Endeffekt,

31:02.460 --> 31:04.460
mit FFmpeg Webcams auslesen,

31:05.460 --> 31:08.460
auf Serverseite RTSP Webcams auslesen

31:09.460 --> 31:12.460
und dann auf Serverseite das Ganze in einen Stream schreiben,

31:13.460 --> 31:14.460
rüber streamen an den Browser.

31:15.460 --> 31:16.460
Und der Browser rendert die Videos

31:17.460 --> 31:19.460
dann in einem Canvas oder einem Video-Element.

31:20.460 --> 31:22.780
Das Ding, damit das funktioniert,

31:23.780 --> 31:25.780
ist, es braucht jeder Track und jede Connection

31:26.780 --> 31:27.780
eine eindeutige ID.

31:28.780 --> 31:34.150
Und aktuell ist es kaputt.

31:35.150 --> 31:39.150
Weil jeder Track hardcoded die ID 2 bekommt.

31:40.150 --> 31:41.150
Das kann ja schon mal gar nicht funktionieren.

31:42.150 --> 31:46.150
Und jede neue Connection hardcoded die ID 1 bekommt.

31:47.150 --> 31:49.150
Das kann auch schon nicht richtig funktionieren.

31:50.150 --> 31:53.360
Also insofern,

31:54.360 --> 31:57.360
und diese unwraps und read und get und unwrap,

31:58.360 --> 31:59.360
das ist auch eklig.

32:00.360 --> 32:01.360
Deswegen habe ich mir überlegt,

32:02.360 --> 32:03.360
wir machen folgendes, wir probieren das mal zumindest.

32:04.360 --> 32:05.360
Wir legen heute in Rust zwei neue Typen an.

32:06.360 --> 32:10.360
Und zwar einmal so eine Art AppState.

32:11.360 --> 32:13.360
Hier so etwas wie AppState.

32:14.360 --> 32:17.360
Und da fassen wir diese ganzen Dinger hier drinnen zusammen.

32:18.360 --> 32:19.360
Gucken, wie das funktioniert.

32:20.360 --> 32:22.360
Und dann würde ich gerne noch ein Struct,

32:23.360 --> 32:27.360
so etwas wie zum Beispiel Registry bauen

32:28.360 --> 32:29.360
und das generic machen.

32:30.360 --> 32:32.360
Ich habe keine Ahnung, wie das in Rust funktioniert.

32:33.360 --> 32:34.360
Geht das vielleicht sogar so?

32:35.360 --> 32:36.360
Moment, Punkt.

32:37.360 --> 32:38.360
Geht das etwa so?

32:39.360 --> 32:40.360
Das ist die gleiche,

32:41.360 --> 32:42.360
das ist die Sharp-Syntax für generics.

32:44.360 --> 32:45.360
So.

32:46.360 --> 32:49.360
Und dann will ich eine generic Collection machen,

32:50.360 --> 32:51.360
die ich jetzt mal Registry nenne.

32:52.360 --> 32:53.360
Wir können sie auch einfach List nennen oder so.

32:54.360 --> 32:55.360
Letztendlich ist es egal, wie das Ding heißt.

32:56.360 --> 32:57.360
Die folgendes macht.

32:58.360 --> 32:59.360
Ich nenne es lieber Registry.

33:00.360 --> 33:01.360
Das ist deutlich sinniger in dem Fall.

33:01.360 --> 33:03.360
Die Tracks und Connections sammelt.

33:04.360 --> 33:06.360
Also dass man quasi eine Collection machen kann,

33:07.360 --> 33:09.360
entweder auf Tracks oder auf Per-Connections.

33:10.360 --> 33:13.360
Und die automatisch eine ID-Such, die frei ist

33:14.360 --> 33:16.360
und eine freie ID für die jeweilige Connection

33:17.360 --> 33:18.360
und für den jeweiligen Track vergibt.

33:19.360 --> 33:20.360
Gestern habe ich mir kurzzeitig überlegt,

33:21.360 --> 33:24.360
man könnte einfach eine JuJu-ID generieren für alles.

33:25.360 --> 33:29.360
Das Problem ist, dass eine JuJu-ID ein 128-Bit-Int ist.

33:30.360 --> 33:34.360
Und man das interop-technisch nicht gescheit hinbekommt.

33:35.360 --> 33:38.360
Man muss es ja über einen C-Interface quasi mit C-Sharp dann sharen.

33:39.360 --> 33:40.360
Und es geht, haben wir gestern gebaut.

33:41.360 --> 33:42.360
Aber schön ist was anderes.

33:43.360 --> 33:46.760
Oh ne.

33:47.760 --> 33:48.760
Da habe ich...

33:49.760 --> 33:50.760
Ich setze mich jetzt erstmal mit Rust auseinander.

33:51.760 --> 33:53.760
Und wenn mich Rust irgendwann so abfuckt,

33:54.760 --> 33:55.760
dass ich Erholung brauche,

33:56.760 --> 33:57.760
dann gehe ich nicht zu Java.

33:58.760 --> 34:02.970
Dann baue ich irgendwas in irgendeiner Webseite

34:03.970 --> 34:04.970
in irgendeiner Sprache, auf die ich Bock drauf habe.

34:05.970 --> 34:06.970
Oder wir bauen mal wieder Microcontroller,

34:07.970 --> 34:08.970
löten irgendwelche Sachen,

34:09.970 --> 34:10.970
spielen mal wieder Battlefield oder sonst was.

34:14.240 --> 34:16.240
Gibt es irgendwo ein FAQ mit Setup und so weiter?

34:17.240 --> 34:18.240
Ne.

34:19.240 --> 34:21.240
Aber es gibt ein Archiv, falls du alte Streams angucken willst.

34:22.240 --> 34:25.240
Und das Archiv ist absolut gigachat-nice gebaut hier.

34:28.900 --> 34:30.900
Mit AI-generated Thumbnails für die Streams.

34:31.900 --> 34:38.900
Ja, hier hat Whisper ein bisschen gefailt, oder?

34:41.720 --> 34:43.720
Whisper hat es ja prinzipiell nicht so mit Text.

34:47.250 --> 34:48.250
Rrrri.

35:02.210 --> 35:04.210
Ne, ne, ne. Kein Java.

35:05.210 --> 35:07.210
Ja, da wurde wahrscheinlich keins für generated.

35:10.480 --> 35:11.480
Ja. Ja.

35:12.480 --> 35:13.480
Steht auch noch aus.

35:14.480 --> 35:15.480
Neowim-Stream steht ja auch noch drin.

35:16.480 --> 35:17.480
Guck. Irgendwo, glaube ich.

35:20.560 --> 35:22.560
Neowim mit Plugins. Pimp mein Neowim. Ja.

35:29.860 --> 35:30.860
Das ist auf GitHub.

35:31.860 --> 35:33.860
Du kannst ja das klonen, wenn du willst.

35:34.860 --> 35:36.860
Okay, so. Das ist der Plan heute.

35:37.860 --> 35:40.860
Ich auch. Es ist nicht so, als hätte ich super Ahnung von Neowim.

35:41.860 --> 35:43.860
Ich habe früher halt meinen Wim auch mega aufgebohrt mit Plugins.

35:44.860 --> 35:45.860
Aber das war alles Wim-Skript.

35:46.860 --> 35:48.860
Und Neowim ist ja zum größten Teil Lua.

35:49.860 --> 35:51.860
Okay. Also das ist der Plan.

35:52.860 --> 35:53.860
So stelle ich mir das vor. Ja.

35:54.860 --> 35:56.860
Das heißt, wir fangen jetzt mal an.

35:57.860 --> 35:58.860
Mit was fangen wir jetzt einfach an?

35:59.860 --> 36:00.860
Kompiliert das jetzt eigentlich gerade?

36:01.860 --> 36:02.860
Wenn ich das auskommentiere?

36:03.860 --> 36:04.860
Ja. Okay. Nice.

36:04.860 --> 36:08.860
Also. Ich würde sagen, wir machen erstmal einen Struct Upstate.

36:09.860 --> 36:13.860
Okay. Und wir hauen jetzt mal diesen ganzen Krempel,

36:14.860 --> 36:20.500
der hier aktuell so in global Sachen hängt.

36:21.500 --> 36:23.500
Wir machen es mal testweise.

36:24.500 --> 36:25.500
Nehmen wir einfach mal die API.

36:26.500 --> 36:27.500
Die hauen wir hier rein.

36:28.500 --> 36:29.500
Static brauchen wir nicht. Nehmen wir mal API.

36:30.500 --> 36:31.500
Wir brauchen auch kein Oneslock mehr,

36:31.500 --> 36:38.580
sondern einfach nur API, oder?

36:39.580 --> 36:40.580
Sonst nichts, glaube ich.

36:41.580 --> 36:42.580
Das Ding müsste thread-safe sein.

36:43.580 --> 36:44.580
Das heißt im Endeffekt,

36:45.580 --> 36:47.580
wir brauchen jetzt einmal noch das hier für den AppState.

36:48.580 --> 36:49.580
AppState.

36:50.580 --> 36:51.580
So.

36:54.400 --> 36:55.400
Machen wir mal hier die API weg,

36:56.400 --> 36:58.400
um zu checken, ob da alles funktioniert.

36:59.400 --> 37:00.400
Da sollte es ein paar rote Sachen geben.

37:01.400 --> 37:04.400
So. Jetzt müssen wir das Ganze noch initialisieren.

37:05.400 --> 37:14.220
Let AppState set AppState.

37:15.220 --> 37:19.390
Okay. Gut.

37:20.390 --> 37:22.390
Was hat er hier? Use shorthand. Alles klar.

37:23.390 --> 37:24.390
So. Hoffen wir mal, ob das jetzt funzt.

37:25.390 --> 37:27.390
Nein. Funktioniert nicht, weil Zeile 95.

37:28.390 --> 37:29.390
Obviously. Zeile 95.

37:30.390 --> 37:32.390
Ach so. Ja. Das brauchen wir jetzt gar nicht mehr, oder?

37:33.390 --> 37:34.390
Wir brauchen jetzt AppState.

37:36.390 --> 37:37.390
Get

37:38.390 --> 37:39.390
Unwrap API.

37:41.390 --> 37:44.390
Nee. Das wäre jetzt auch zu einfach,

37:45.390 --> 37:46.390
wenn das einfach funktionieren würde, oder?

37:47.390 --> 37:48.390
Gag wait.

37:49.390 --> 37:51.390
Das wäre deutlich way too easy,

37:52.390 --> 37:55.390
wenn das auf first try irgendwie klappen würde.

37:56.390 --> 37:59.600
Was ist denn das Problem,

38:00.600 --> 38:01.600
was er jetzt schon wieder hat?

38:11.340 --> 38:12.340
Da fehlt der BorrowOperator.

38:13.340 --> 38:14.340
Das heißt, ich muss da einen...

38:15.340 --> 38:16.340
Ach. Wie?

38:16.340 --> 38:17.340
Okay.

38:21.250 --> 38:22.250
Der Chat weiß Bescheid.

38:30.320 --> 38:31.320
Der Chat ist wirklich schlau.

38:35.550 --> 38:37.550
Nee. Die sind teilweise nicht wirklich useful.

38:38.550 --> 38:39.550
Aber es funktioniert.

38:40.550 --> 38:42.550
Ich meine, findest du das useful?

38:50.310 --> 38:52.310
Eindeutiger Hinweis, dass man einen Unten nehmen soll.

39:02.430 --> 39:03.430
Oh. Okay.

39:04.430 --> 39:05.430
Ach ja.

39:06.430 --> 39:07.430
Okay. Ich habe nichts gesagt. Ihr habt recht.

39:08.430 --> 39:09.430
Steht ja wirklich da.

39:13.790 --> 39:14.790
Es steht wirklich darunter.

39:15.790 --> 39:17.790
Okay. Ich gebe zu, die Rust-Fehlermeldung in dem Fall war hilfreich.

39:18.790 --> 39:19.790
Alles klar. Gut. Gut.

39:21.790 --> 39:22.790
Keck G.

39:23.790 --> 39:24.790
Ja. Ist okay.

39:25.790 --> 39:27.790
Ich gebe zu, die war wirklich hilfreich.

39:33.700 --> 39:40.860
Also, das hat schon mal funktioniert.

39:41.860 --> 39:42.860
Das in AppState zu moven.

39:43.860 --> 39:44.860
So. Jetzt packen wir die Runtime.

39:46.860 --> 39:48.860
Kannst du nochmal das Backinserter-Meme machen?

39:48.860 --> 39:49.860
Nee.

39:50.860 --> 39:51.860
Das Backinserter-Meme?

39:52.860 --> 39:54.860
Du meinst das auf Stackoverflow, das C++-Zeug?

39:55.860 --> 39:57.860
Ja. Ich habe jetzt keinen Bock. Das kann ich in jedem Stream zeigen.

39:58.860 --> 39:59.860
Welche Idee ist das eigentlich?

40:04.090 --> 40:05.090
Das ist Rust-Rover.

40:06.090 --> 40:09.090
Das ist die Rust-Idee von JetBrains für Rust.

40:10.090 --> 40:12.090
Die hat aber noch so ein paar etwas...

40:13.090 --> 40:14.090
Ja.

40:16.090 --> 40:18.090
Vielleicht etwas unrunde...

40:19.090 --> 40:20.090
Ist auch etwas unrunde.

40:20.090 --> 40:21.090
Ist auch etwas unrund an manchen Stellen.

40:22.090 --> 40:23.090
Ja.

40:24.090 --> 40:32.610
So. Die API haben wir jetzt da reingepackt.

40:33.610 --> 40:35.610
Jetzt packen wir noch die Runtime da rein.

40:36.610 --> 40:37.610
Wobei, Leute. Ich habe eine Idee.

40:38.610 --> 40:39.610
Passt mal auf. Six-Head-Time.

40:40.610 --> 40:43.610
Wenn das klappt in Rust, dann habe ich Rust verstanden.

40:44.610 --> 40:45.610
Ja. Da dauert es noch ein bisschen hin.

40:46.610 --> 40:47.610
Gucke mal. Guck dir mal. Guck dir mal.

40:48.610 --> 40:49.610
Ich sage doch jedes Mal hier,

40:50.610 --> 40:53.610
wenn ich diese Async-Runtime starte,

40:54.610 --> 40:55.610
ich sage jedes Mal,

40:55.610 --> 40:57.610
Runtime.get.unwrap.plogon.

40:58.610 --> 41:00.610
Ich habe eine Idee. Ich habe eine Idee.

41:01.610 --> 41:03.610
Und zwar. Und zwar. Passt mal auf.

41:04.610 --> 41:08.610
Wir gucken uns die Funktionsdefinition von Plogon an.

41:09.610 --> 41:10.610
Kopieren die uns.

41:11.610 --> 41:12.610
Und jetzt.

41:15.880 --> 41:18.880
Und jetzt geben wir unserem API-State eine Funktion,

41:19.880 --> 41:20.880
die Plogon heißt.

41:23.770 --> 41:24.770
Das funktioniert. Ach, Moment. Das ist ja Rust.

41:25.770 --> 41:26.770
Moment. Das ist ja Rust.

41:27.770 --> 41:28.770
Das ging doch irgendwie so, oder?

41:32.040 --> 41:33.040
Moment.

41:34.040 --> 41:35.040
Ich will kein Makro, ne.

41:38.040 --> 41:39.040
So. Das kriegt jetzt eine Funktion.

41:40.040 --> 41:41.040
Plogs on.

41:42.040 --> 41:45.040
Dann braucht das hier API-State.

41:46.040 --> 41:48.040
Dann braucht das hier noch Runtime,

41:49.040 --> 41:50.040
als, ja, für Klassenvariable.

41:51.040 --> 41:52.040
Wie auch immer das heißt in Rust.

41:54.040 --> 41:55.040
Als Instanzvariable.

41:56.040 --> 41:57.040
Kein Schimmer, wie man das korrekt in Rust nennt.

41:58.040 --> 41:59.040
Trade-Variable. Struct-Variable.

41:59.040 --> 42:01.040
Struct-Failed. Weiß nicht.

42:02.040 --> 42:03.040
So.

42:05.040 --> 42:06.040
Und.

42:07.040 --> 42:08.040
Jetzt sagen wir.

42:09.040 --> 42:10.040
Moment. Self. Passt doch.

42:11.040 --> 42:12.040
Jetzt sagen wir. Self.

42:13.040 --> 42:14.040
Runtime.

42:15.040 --> 42:16.040
Und jetzt kopieren wir das, was ich hier immer mache.

42:17.040 --> 42:18.040
Plogon.

42:19.040 --> 42:20.040
Wobei, ne. Muss ich ja gar nichts machen.

42:22.990 --> 42:23.990
Plogon.

42:26.560 --> 42:28.560
Und da schieben wir das jetzt rein.

42:29.560 --> 42:30.560
Und hoffen, dass es noch kompiliert.

42:30.560 --> 42:31.560
Ne. Shit.

42:32.560 --> 42:34.560
Ah ne. Moment. Missing Runtime.

42:35.560 --> 42:36.560
Hier. Missing Runtime.

42:37.560 --> 42:38.560
Runtime.

42:40.870 --> 42:41.870
So.

42:42.870 --> 42:56.170
Ach so. Ich muss. Hä?

42:58.170 --> 42:59.170
Wait a minute.

43:00.170 --> 43:01.170
Ah.

43:02.170 --> 43:03.170
Moment.

43:06.500 --> 43:07.500
Das beißt sich jetzt ein bisschen in den Schwanz.

43:08.500 --> 43:09.500
Gutschi.

43:10.500 --> 43:11.500
Was?

43:11.500 --> 43:14.010
Äh.

43:15.010 --> 43:17.010
Die Runtime setze ich hier oben.

43:18.010 --> 43:21.980
Und.

43:22.980 --> 43:26.980
Hier unten lege ich erst den App-State an.

43:27.980 --> 43:37.270
Ich mein.

43:40.290 --> 43:41.290
Das muss aber nicht so sein.

43:42.290 --> 43:47.600
Kann ich nicht einfach den ganzen Crample hier raus kopieren?

43:51.830 --> 43:52.830
Und da rein.

43:56.870 --> 44:04.020
Und dann. Ja. Okay.

44:05.020 --> 44:08.040
Äh. Und dann brauche ich das hier.

44:09.040 --> 44:10.040
Dann brauche ich das doch eigentlich gar nicht.

44:11.040 --> 44:13.040
Ach doch. Ach. Moment. Moment. Moment. Moment.

44:14.040 --> 44:16.040
Doch. Doch. Das muss in der Runtime gecallt werden.

44:17.040 --> 44:19.040
Sonst hab ich wieder so diesen komischen Bug. Ne. Ne. Ne. Ne. Ne.

44:20.040 --> 44:23.500
Nopos.

44:31.190 --> 44:34.190
Das Rust-Buch. Ja. Soll ich jetzt das Rust-Buch im Stream lesen oder wie?

44:35.190 --> 44:41.470
Aber was wir machen können ist.

44:42.470 --> 44:45.550
Kann man.

44:49.080 --> 44:50.080
Okay. Jetzt bin ich mal gespannt.

44:51.080 --> 44:54.080
Kann ich das hier einfach die Runtime als Parameter übergeben?

44:56.080 --> 44:57.080
Runtime.

44:57.080 --> 44:58.080
Runtime.

44:59.080 --> 45:00.080
Alter. Ich.

45:01.080 --> 45:02.080
Mir pegelt das zu schreiben.

45:03.080 --> 45:04.080
Und jetzt. Runtime.

45:05.080 --> 45:06.080
Da reinschreiben.

45:07.080 --> 45:10.030
Ne. Weil.

45:11.030 --> 45:12.030
Achso. Äh. Is missing.

45:14.980 --> 45:17.940
Runtime.

45:18.940 --> 45:19.940
Used after move.

45:20.940 --> 45:22.940
Okay. Dann muss. Dann. Dann muss das hier.

45:26.270 --> 45:28.270
MonkaS. Alter. Ich hab mir das so einfach vorgestellt.

45:29.270 --> 45:32.800
Ist es aber nicht.

45:37.420 --> 45:39.420
Ich. Okay. Wir lassen das. Wir lassen das sein. Ja.

45:39.420 --> 45:41.420
Wir. Wir lassen. Wir. Wir lassen das sein.

45:42.420 --> 45:49.140
Wir lassen das. Wir lassen das sein.

45:50.140 --> 45:54.140
Weil. Ich. Ich will ja Runtime get. Ich. Ich will das ja wegschmeißen.

45:55.140 --> 45:56.140
Ich will das ja. Ich will das ja gar nicht mehr haben.

46:01.020 --> 46:03.020
Ähm. Okay. Wir. Wir lassen das mal kurz hier jetzt weg.

46:04.020 --> 46:06.020
Das ist eigentlich gar nicht das. Vielleicht fällt mir das später noch was zu ein.

46:07.020 --> 46:12.340
Das. Das darf jetzt so bleiben.

46:13.340 --> 46:15.340
Und das. Das. Das hier fliegt jetzt erstmal wieder weg. Okay.

46:17.340 --> 46:18.340
Und das. Das hier auch.

46:19.340 --> 46:21.340
Da. Da bin ich grad noch nicht high IQ Rust-mäßig genug für.

46:22.340 --> 46:31.470
Das muss ich mal schauen, wie man das später noch macht.

46:33.470 --> 46:35.470
Weil das beißt sich. Ich kann nicht die Runtime hier anlegen.

46:36.470 --> 46:37.470
Das ist. Das ist halt echt blöd.

46:42.470 --> 46:43.470
Egal. Das waren wir jetzt nicht.

46:44.470 --> 46:46.470
Vielleicht. Vielleicht. Vielleicht fällt mir das später noch was zu ein.

46:47.470 --> 46:49.470
Wir. Wir. Also was mich viel mehr interessiert ist.

46:50.470 --> 46:52.470
Wie man ein Custom. Custom Type implementiert in Rust.

46:53.470 --> 46:56.470
Eine Custom Collection wohlgemerkt in Rust implementiert.

46:57.470 --> 46:59.470
Eine Generic Custom Collection in Rust.

46:59.470 --> 47:01.470
Ich würde mal vorschlagen.

47:02.470 --> 47:04.470
Wir kopieren das Ganze in ein eigenes.

47:05.470 --> 47:07.470
In ein eigenes File.

47:08.470 --> 47:12.230
Kann man das nicht kopieren?

47:13.230 --> 47:15.230
Refactor. Move.

47:16.230 --> 47:18.230
To ähm.

47:19.230 --> 47:23.700
Registry.rs.

47:24.700 --> 47:28.840
So. Jaja. Add.

47:29.840 --> 47:31.840
Jetzt bin ich mal gespannt. Jetzt. Jetzt bin ich mal gespannt.

47:32.840 --> 47:34.840
Also. Warte nicht. Runtime. Moment.

47:35.840 --> 47:37.840
Äh.

47:38.840 --> 47:40.840
Also. Was ich haben will.

47:41.840 --> 47:43.840
Ich will ein Generic. Ich will ein Generic Type.

47:44.840 --> 47:46.840
In Rust. Ich habe keine Ahnung wie man Generic.

47:47.840 --> 47:49.840
Rust. Rust. Generic Type. Wie geht das?

47:50.840 --> 47:52.840
Generic Data Types.

47:55.470 --> 48:00.000
Strukt. Äh.

48:01.000 --> 48:03.000
Ja. T.

48:04.000 --> 48:06.000
Also im Prinzip ein bisschen wie in .NET.

48:07.000 --> 48:09.000
Registry. T. Okay. So.

48:10.000 --> 48:12.000
Dann machen wir hier mal eine Variable drin.

48:13.000 --> 48:15.000
Die nennen wir einfach Storage. Oder Store.

48:16.000 --> 48:18.000
Storage. Keine Ahnung. Store. Wir nennen es Store.

48:19.000 --> 48:21.000
Und.

48:22.000 --> 48:24.000
Das wird eine Hash Map.

48:25.000 --> 48:27.000
Das wird eine Hash Map.

48:28.000 --> 48:30.000
Vom Typ. Ähm. Tja. Wie viele IDs brauche ich?

48:31.000 --> 48:33.000
Wahrscheinlich reicht ein U32 Log da aus.

48:34.000 --> 48:36.000
U32 Max.

48:37.000 --> 48:39.000
Nicht Z32. Was auch immer ich da gerade gegoogelt habe.

48:40.000 --> 48:42.000
Z32 Max ist. Ja. Ja.

48:43.000 --> 48:45.000
Ich glaube das reicht.

48:46.000 --> 48:48.000
Ich glaube ich werde nie so viele Connections gleichzeitig haben.

48:49.000 --> 48:51.000
Dass das irgendwie Probleme macht.

48:52.000 --> 48:54.000
So. Also.

48:55.000 --> 48:58.440
Wir brauchen eine extra ID pro Connection.

48:59.440 --> 49:01.440
Wenn das Compile. Das wird auf jeden Fall nicht Compile.

49:02.440 --> 49:04.440
So. Ähm. Und dann.

49:05.440 --> 49:07.440
Ein Value auf Type T. Okay.

49:08.440 --> 49:10.440
So weit sollte es noch Compilieren. Da haben wir noch nichts gemacht.

49:11.440 --> 49:13.440
So. Aber. Aber generic das ganze.

49:14.440 --> 49:16.440
So. Und jetzt.

49:17.440 --> 49:19.440
Kann das mal machen. Was ich will.

49:20.440 --> 49:22.440
Registry of Type T.

49:23.440 --> 49:25.440
Moment. Jetzt geht das nicht. Warum?

49:26.440 --> 49:28.440
Unresolved Reference.

49:34.980 --> 49:36.980
Ach. Hier muss T vorne noch hin.

49:37.980 --> 49:39.980
Implement. Okay.

49:40.980 --> 49:42.980
Implement T. Implement Type T.

49:43.980 --> 49:45.980
Registry of Type T. So. Also.

49:46.980 --> 49:48.980
Connection.

49:49.980 --> 49:51.980
Muss man da Public eigentlich da vorschreiben?

49:52.980 --> 49:54.980
Ja ne. Ich muss da Pub da vorschreiben.

49:55.980 --> 49:57.980
Damit das exportiert wird nachher.

49:58.980 --> 50:00.980
Dass ich das benutzen kann. Glaube ich.

50:01.980 --> 50:03.980
Oder muss ich. Muss ich nur hier.

50:04.980 --> 50:06.980
Pub da vorschreiben.

50:07.980 --> 50:09.980
Also nicht genau. So. Fn.

50:10.980 --> 50:12.980
Also was brauchen wir in so einer Collection?

50:13.980 --> 50:15.980
Wir brauchen einmal New.

50:24.820 --> 50:26.820
So. Wir machen das mal so ein bisschen wie in Go.

50:27.820 --> 50:29.820
Also. Es. Boah. Ich habe keine Ahnung wie das geht.

50:30.820 --> 50:32.820
Rust. New. Constructor.

50:36.540 --> 50:38.540
Ja. Jawohl. Genau das will ich haben.

50:39.540 --> 50:41.540
Excellent. Copy. Paste.

50:42.540 --> 50:44.540
So. Wir wollen kein Value. Wir returnen Self. Okay.

50:45.540 --> 50:47.540
Und Self ist immer. Okay. Store.

50:48.540 --> 50:50.540
Ist eine Hash Map.

50:51.540 --> 50:53.540
Ein neues Dictionary im Endeffekt.

50:54.540 --> 50:56.540
Okay. Funs. Nice. Was hat er für Schmerzen?

50:57.540 --> 50:59.540
Function is never used.

51:00.540 --> 51:02.540
Kompiliert. Alles gut.

51:03.540 --> 51:05.540
Das heißt wir können jetzt das ganze neu anlegen.

51:06.540 --> 51:08.540
Übrigens um das zu testen.

51:09.540 --> 51:11.540
Machen wir hier einfach mal eine Funktion.

51:12.540 --> 51:14.540
Und rufen das auf. Wir tun einfach mal so.

51:17.490 --> 51:19.490
Registry new. Achso. Registry of type.

51:20.490 --> 51:22.490
Ah. Int. Oder so.

51:28.640 --> 51:30.640
Ähm.

51:31.640 --> 51:33.640
Wie schreibt man das jetzt?

51:34.640 --> 51:52.290
In. Muss man das hier vorne

51:52.290 --> 51:55.980
irgendwie schreiben?

51:55.980 --> 51:57.980
Type annotation needed.

51:57.980 --> 51:59.980
Ah ja.

51:59.980 --> 52:01.980
Okay. Das muss man hier machen.

52:01.980 --> 52:03.980
Das ist auch ein bisschen gewöhnungsbedürftig.

52:04.980 --> 52:06.980
Off. Ja. Hier.

52:06.980 --> 52:08.980
U32.

52:08.980 --> 52:10.980
Oder machen wir local static track

52:11.980 --> 52:13.980
Sample. So. Perfekt.

52:13.980 --> 52:15.980
Kompiliert noch. Kompiliert noch.

52:15.980 --> 52:17.980
So.

52:17.980 --> 52:19.980
Also.

52:19.980 --> 52:21.980
Was braucht man für eine Collection?

52:21.980 --> 52:27.790
Wir brauchen im Prinzip

52:27.790 --> 52:29.790
ähm. Wir brauchen im Prinzip

52:29.790 --> 52:31.790
drei Methoden. Vier. Vier Methoden.

52:31.790 --> 52:33.790
Wir brauchen add Elemente,

52:33.790 --> 52:35.790
get Elemente,

52:35.790 --> 52:37.790
delete Elemente und

52:37.790 --> 52:39.790
loop

52:39.790 --> 52:41.790
oder sowas. Ja.

52:41.790 --> 52:43.790
Alles klar.

52:43.790 --> 52:45.790
Also. Pop.

52:45.790 --> 52:47.790
Fangen wir mal an. Pop.

52:47.790 --> 52:49.790
Fn. Machen wir mal add.

52:49.790 --> 52:51.790
Add dürfte ja noch relativ easy sein.

52:51.790 --> 52:57.020
Und jetzt. Ne Moment.

52:57.020 --> 52:59.020
Wo kommt jetzt hier der

52:59.020 --> 53:01.020
der Type hin?

53:01.020 --> 53:04.720
Also bei .net kommt er

53:04.720 --> 53:06.720
dahin glaube ich. Ja. Okay. Kommt den Rust

53:06.720 --> 53:12.660
auch dahin. So. Add.

53:12.660 --> 53:14.660
So. Und dann kriegen wir als Parameter

53:14.660 --> 53:16.660
ein

53:16.660 --> 53:18.660
ein Element.

53:18.660 --> 53:23.630
Oh fuck. Wie war man das jetzt?

53:23.630 --> 53:33.280
Ähm.

53:33.280 --> 53:35.280
Also wir kriegen Element of T im Endeffekt.

53:35.280 --> 53:37.280
So.

53:37.280 --> 53:39.280
Was hat er hier für Schmerzen?

53:39.280 --> 53:42.720
T is already used.

53:42.720 --> 53:44.720
Hä? Ach brauche ich das

53:44.720 --> 53:46.720
hier gar nicht mehr?

53:46.720 --> 53:48.720
Ah. Ich brauche das gar nicht mehr.

53:48.720 --> 53:50.720
So. Und dann brauchen wir aber noch

53:50.720 --> 53:52.720
irgendwie und self.

53:52.720 --> 53:54.720
Das ist übrigens das gleiche wie

53:54.720 --> 53:56.720
this in C Sharp oder self in Python

53:56.720 --> 53:58.720
oder me glaube ich

53:58.720 --> 54:00.720
in Lua oder sowas.

54:00.720 --> 54:02.720
So.

54:02.720 --> 54:04.720
Das heißt jetzt sagen wir self

54:04.720 --> 54:06.720
store

54:06.720 --> 54:08.720
insert

54:08.720 --> 54:10.720
Das findest du doch so im Leben nicht.

54:10.720 --> 54:12.720
Jetzt brauchen wir. Achtung Moment. Eine ID

54:12.720 --> 54:14.720
brauchen wir noch. Eine ID die

54:14.720 --> 54:16.720
muss ich generieren.

54:16.720 --> 54:18.720
Let ID gleich 1. Die generiere ich.

54:18.720 --> 54:20.720
ID und dann fügen

54:20.720 --> 54:22.720
wir das Element ein.

54:22.720 --> 54:24.720
Das geht natürlich nicht.

54:24.720 --> 54:28.220
Weil das nicht mutt ist.

54:28.220 --> 54:30.220
Ich glaube in Lua heißt es me.

54:30.220 --> 54:42.300
Leute. Das kann

54:42.300 --> 54:44.300
so nicht funktionieren.

54:44.300 --> 54:46.300
Das ist verkehrt was ich mache.

54:46.300 --> 54:48.300
Also okay. Das würde funktionieren

54:48.300 --> 54:50.300
im Chat. Das würde funktionieren

54:50.300 --> 54:52.300
aber spätestens

54:52.300 --> 54:59.840
wie will Rust das handeln

54:59.840 --> 55:01.840
wenn ich das von verschiedenen Threads

55:01.840 --> 55:06.240
aufrufe?

55:06.240 --> 55:08.240
Moment. Das testen wir jetzt mal.

55:08.240 --> 55:12.640
Ja.

55:12.640 --> 55:14.640
Weil ich glaube schon dass man das hier locken muss.

55:14.640 --> 55:16.640
HashMap ist ja sicherlich nicht

55:16.640 --> 55:18.640
thread safe. Probieren wir das mal.

55:18.640 --> 55:20.640
Jetzt irgendwie

55:20.640 --> 55:22.640
1 oder so.

55:22.640 --> 55:24.640
Moment. Let mutt

55:24.640 --> 55:32.300
R mutt. Ja gut.

55:32.300 --> 55:34.300
Hier weiß er ja

55:34.300 --> 55:36.300
dass es nicht multithreaded ist, weil das in der gleichen

55:36.300 --> 55:39.870
Funktion ist.

55:39.870 --> 55:43.820
Der wird mich das

55:43.820 --> 55:45.820
schlicht und ergreifend nicht anlegen lassen.

55:45.820 --> 55:47.820
Vermute ich einfach mal.

55:47.820 --> 55:49.820
Ich glaube wir brauchen

55:49.820 --> 55:51.820
da einen Lock drum.

55:51.820 --> 55:53.820
Ich glaube damit ersparen wir uns schon

55:53.820 --> 55:55.820
einige Probleme.

55:55.820 --> 55:57.820
Wir brauchen da

55:57.820 --> 55:59.820
einen Lock drum. Lassen wir das mal

55:59.820 --> 56:01.820
so. Also Ziel muss sein dass

56:01.820 --> 56:03.820
die Registry selbst nicht mutable ist.

56:03.820 --> 56:05.820
Aber er hat trotzdem funktioniert.

56:05.820 --> 56:07.820
So. Heißt im Endeffekt

56:07.820 --> 56:09.820
wir brauchen hier wahrscheinlich ein

56:09.820 --> 56:11.820
RwLock. Ne oder wie ist das Ding

56:11.820 --> 56:13.820
was wir hier hatten? Doch RwLock.

56:13.820 --> 56:15.820
RwLock

56:15.820 --> 56:23.490
HashMap.

56:23.490 --> 56:25.490
Und jetzt ist es RwLock

56:25.490 --> 56:33.020
new. Du könntest

56:33.020 --> 56:35.020
auch nur self machen und dann versuchen mit get

56:35.020 --> 56:37.020
mutt die Referenz

56:37.020 --> 56:39.020
zu holen. Was?

56:39.020 --> 56:41.020
Wie jetzt?

56:41.020 --> 56:43.020
Das kann aber doch auch multithreaded nicht

56:43.020 --> 56:48.380
funktionieren. Was soll ich

56:48.380 --> 56:50.380
machen? Add? Also quasi

56:50.380 --> 56:52.380
das muss

56:52.380 --> 56:54.380
übrigens weg hier.

56:54.380 --> 56:56.380
Self.

56:56.380 --> 56:58.380
Get.

56:58.380 --> 57:00.380
Okay was ist das

57:00.380 --> 57:02.380
für schwarze Magie?

57:02.380 --> 57:04.380
Returns a mutable

57:04.380 --> 57:06.380
reference to the value. The key may be

57:06.380 --> 57:08.380
any borrowed form of

57:08.380 --> 57:10.380
the map key partitionable.

57:10.380 --> 57:12.380
Wie soll das funktionieren?

57:12.380 --> 57:15.700
Get mutt.

57:15.700 --> 57:21.820
Geht auch nicht.

57:21.820 --> 57:23.820
Ach Moment.

57:23.820 --> 57:25.820
Das ist

57:25.820 --> 57:30.480
das ist

57:30.480 --> 57:32.480
jetzt aus

57:32.480 --> 57:34.480
der HashMap raus.

57:34.480 --> 57:38.240
Das ist was anderes.

57:38.240 --> 57:40.240
Ne ne das

57:40.240 --> 57:44.510
ich check es auch nicht.

57:44.510 --> 57:46.510
Ne ne das gibt es überhaupt nicht.

57:46.510 --> 57:50.020
Try?

57:50.020 --> 57:52.020
Ne das muss in den Lock.

57:52.020 --> 57:54.020
Das muss in den Lock rein sonst funzt das nicht.

57:54.020 --> 57:56.020
Wir hatten es doch eben

57:56.020 --> 57:58.020
gerade hier schon.

57:58.020 --> 58:00.020
Lock.

58:00.020 --> 58:02.020
LWLock. Also

58:02.020 --> 58:04.020
Self.

58:04.020 --> 58:06.020
Store.

58:06.020 --> 58:08.020
Store ist jetzt allerdings nicht mehr

58:08.020 --> 58:10.020
direkt eine HashMap sondern

58:10.020 --> 58:12.020
ein ThreadSaveLock.

58:12.020 --> 58:14.020
Das holen wir jetzt.

58:14.020 --> 58:16.020
Write. Die Referenz raus.

58:16.020 --> 58:22.460
Unwrap. Okay.

58:22.460 --> 58:24.460
Und jetzt sagen wir MapInsert

58:24.460 --> 58:26.460
ID

58:26.460 --> 58:28.460
und Element E. So und das funzt

58:28.460 --> 58:30.460
jetzt wahrscheinlich. Ja. Ach shit.

58:30.460 --> 58:32.460
Was ist das? CannotBorrowMutable.

58:32.460 --> 58:34.460
Make mutable. Ja. Sehr schön.

58:34.460 --> 58:36.460
Fuck.

58:36.460 --> 58:38.460
CannotBorrow

58:38.460 --> 58:40.460
as mutable. Achso.

58:40.460 --> 58:42.460
Weil dann noch. Das brauchen wir doch jetzt gar nicht mehr.

58:42.460 --> 58:44.460
Oder? Ah. Nice. Funzt.

58:44.460 --> 58:46.460
Sehr schön. Also.

58:46.460 --> 58:48.460
Jetzt müssen wir die Registry selbst

58:48.460 --> 58:50.460
nicht mutable machen. Können aber

58:50.460 --> 58:52.460
trotzdem Sachen einfügen.

58:52.460 --> 58:56.480
Boah. Meine Güte.

58:56.480 --> 59:01.520
Der fliegt jetzt auf die Schnauze

59:01.520 --> 59:03.520
wenn es von einem anderen gelockt ist.

59:03.520 --> 59:05.520
Ich hab ehrlich gesagt keine Ahnung wie sich

59:05.520 --> 59:07.520
wie sich das verhält.

59:07.520 --> 59:11.600
Ob das einfach nur

59:11.600 --> 59:13.600
hängt an der Stelle.

59:13.600 --> 59:15.600
Oder ob

59:15.600 --> 59:17.600
das. Oh.

59:17.600 --> 59:19.600
Ne.

59:19.600 --> 59:21.600
Locks

59:21.600 --> 59:23.600
das LWLock with exclusive

59:23.600 --> 59:25.600
write access. Blocking the current thread

59:25.600 --> 59:27.600
until it can be acquired. Ne.

59:27.600 --> 59:29.600
Ne. Ne. Ne. Hier. Blocking the current

59:29.600 --> 59:31.600
thread until it can be

59:31.600 --> 59:37.020
acquired. This function

59:37.020 --> 59:39.020
will not return while other writers

59:39.020 --> 59:41.020
or other readers currently have access to the

59:41.020 --> 59:43.020
lock.

59:43.020 --> 59:45.020
Okay. Das hängt einfach an der Stelle.

59:45.020 --> 59:47.020
Das ist aber auch okay, dass das hängt.

59:47.020 --> 59:49.020
Weil wir wollen ja

59:49.020 --> 59:51.020
die einzige mutable reference haben,

59:51.020 --> 59:53.020
dass wir was einfügen können.

59:53.020 --> 59:55.020
Rast5head.

59:55.020 --> 59:57.020
Ja. So. Also. Jetzt haben wir

59:57.020 --> 59:59.020
unsere Add-Methode. Das war erstaunlich

59:59.020 --> 01:00:01.020
einfach. Das war erstaunlich

01:00:01.020 --> 01:00:03.020
erstaunlich einfach bis jetzt.

01:00:03.020 --> 01:00:05.020
So.

01:00:05.020 --> 01:00:07.020
Als nächstes brauchen wir

01:00:07.020 --> 01:00:09.020
ein Get. Muss ich hier überhaupt

01:00:09.020 --> 01:00:11.020
public davor schreiben?

01:00:11.020 --> 01:00:13.020
Pub. Fn.

01:00:13.020 --> 01:00:15.020
Get.

01:00:15.020 --> 01:00:17.020
Und self.

01:00:17.020 --> 01:00:20.590
Jetzt brauch ich ne ID.

01:00:20.590 --> 01:00:27.040
Jetzt brauch ich ne ID.

01:00:27.040 --> 01:00:31.890
Moment. Wait a minute.

01:00:31.890 --> 01:00:33.890
Wait a minute. Ich hab doch die ID gar nicht.

01:00:33.890 --> 01:00:35.890
Moment. Hier muss die

01:00:35.890 --> 01:00:37.890
ToDo

01:00:37.890 --> 01:00:39.890
generate ID.

01:00:39.890 --> 01:00:41.890
Das funktioniert nicht so wie gedacht

01:00:41.890 --> 01:00:43.890
gerade.

01:00:43.890 --> 01:00:47.200
Wobei. Muss ich

01:00:47.200 --> 01:00:49.200
jemals überhaupt einzelne Elemente

01:00:49.200 --> 01:00:51.200
daraus getten? Ja klar.

01:00:51.200 --> 01:00:53.200
Für die Connections.

01:00:53.200 --> 01:00:55.200
Das heißt, mein Add muss

01:00:55.200 --> 01:00:57.200
eigentlich die ID returnen,

01:00:57.200 --> 01:00:59.200
dass das funktioniert.

01:00:59.200 --> 01:01:01.200
Return ID.

01:01:01.200 --> 01:01:06.050
So.

01:01:06.050 --> 01:01:08.050
Jetzt weiß ich die ID.

01:01:08.050 --> 01:01:10.050
So. Jetzt hab ich die ID.

01:01:10.050 --> 01:01:12.050
Und jetzt kann ich wahrscheinlich sagen

01:01:12.050 --> 01:01:14.050
self

01:01:14.050 --> 01:01:16.050
store. Read.

01:01:16.050 --> 01:01:18.050
Reicht jetzt. Unwrap.

01:01:18.050 --> 01:01:20.050
Get.

01:01:20.050 --> 01:01:22.050
Element oder sowas. Get.

01:01:22.050 --> 01:01:24.050
Key value.

01:01:24.050 --> 01:01:28.830
Was? Get.

01:01:28.830 --> 01:01:30.830
Wat?

01:01:30.830 --> 01:01:32.830
Get.

01:01:32.830 --> 01:01:34.830
Und jetzt ID.

01:01:34.830 --> 01:01:36.830
Das ganze dann returnen.

01:01:38.830 --> 01:01:40.830
Return. Func. Wat?

01:01:40.830 --> 01:01:42.830
Unwrap. Unwrap.

01:01:42.830 --> 01:01:46.720
Was?

01:01:46.720 --> 01:01:48.720
Found.

01:01:48.720 --> 01:01:53.500
Wat?

01:01:53.500 --> 01:01:57.650
Expected.

01:01:57.650 --> 01:01:59.650
Found.

01:01:59.650 --> 01:02:01.650
Achso.

01:02:01.650 --> 01:02:05.860
Der Return Type fehlt.

01:02:05.860 --> 01:02:07.860
Was hat er hier unten für Schmerzen?

01:02:07.860 --> 01:02:09.860
Ah.

01:02:09.860 --> 01:02:11.860
Moment.

01:02:11.860 --> 01:02:13.860
Get muss eine Referenz sein.

01:02:13.860 --> 01:02:15.860
Okay.

01:02:15.860 --> 01:02:17.860
Und jetzt

01:02:17.860 --> 01:02:19.860
kann ich auch eine Reference

01:02:19.860 --> 01:02:21.860
returnen dazu.

01:02:21.860 --> 01:02:23.860
Geht aber immer noch nicht.

01:02:23.860 --> 01:02:25.860
Cannot return value reference.

01:02:25.860 --> 01:02:27.860
Oh je, oh je. Was will er von mir?

01:02:27.860 --> 01:02:35.840
Ne, was soll ich denn sonst machen

01:02:35.840 --> 01:02:41.070
außer Unwrap?

01:02:41.070 --> 01:02:43.070
Moment, Moment. Das kann ja nicht funktionieren.

01:02:43.070 --> 01:02:46.830
Wobei, warum eigentlich

01:02:46.830 --> 01:02:48.830
nicht?

01:02:48.830 --> 01:02:50.830
Das ist eine Referenz.

01:02:50.830 --> 01:02:52.830
Achso, ich weiß warum das nicht

01:02:52.830 --> 01:02:54.830
funktionieren kann.

01:02:54.830 --> 01:02:56.830
Das ist eine Referenz und ich könnte

01:02:56.830 --> 01:02:58.830
ja jederzeit

01:02:58.830 --> 01:03:00.830
den Inhalt löschen hier drin zum Beispiel.

01:03:00.830 --> 01:03:04.140
Heißt im Endeffekt,

01:03:04.140 --> 01:03:06.140
dann wäre die Referenz ungültig

01:03:06.140 --> 01:03:08.140
und das mag Rust ja nicht.

01:03:08.140 --> 01:03:10.140
Also, was muss ich jetzt machen?

01:03:10.140 --> 01:03:12.140
Cannot return. Was schlägt mir

01:03:12.140 --> 01:03:14.140
denn der Compiler vor?

01:03:14.140 --> 01:03:16.140
Returns the value

01:03:16.140 --> 01:03:18.140
referencing data owned by the

01:03:18.140 --> 01:03:26.770
current function.

01:03:26.770 --> 01:03:28.770
Okay, ich habe was gelernt. Ich glaube ich weiß,

01:03:28.770 --> 01:03:30.770
wie wir das fixen können.

01:03:30.770 --> 01:03:32.770
Ich glaube ich weiß, wie wir das fixen können.

01:03:32.770 --> 01:03:34.770
Genauso wie wir es hier gefixt haben.

01:03:34.770 --> 01:03:36.770
Ein Arc drum herum

01:03:36.770 --> 01:03:42.960
wrappen. Also es ist jetzt

01:03:42.960 --> 01:03:44.960
nicht

01:03:44.960 --> 01:03:46.960
es ist jetzt nicht

01:03:46.960 --> 01:03:48.960
Type T, sondern es ist Type

01:03:48.960 --> 01:03:50.960
Arc

01:03:50.960 --> 01:03:54.590
of T.

01:03:54.590 --> 01:03:56.590
Und dann hier ist es Arc

01:03:56.590 --> 01:03:58.590
new.

01:03:58.590 --> 01:04:00.590
Ey, gibt das so Sinn?

01:04:00.590 --> 01:04:02.590
Und jetzt, und jetzt

01:04:02.590 --> 01:04:04.590
kriege ich den Arc

01:04:04.590 --> 01:04:06.590
zurück

01:04:06.590 --> 01:04:08.590
und den können wir klonen,

01:04:08.590 --> 01:04:10.590
was den Referenz-Counter

01:04:10.590 --> 01:04:12.590
erhöht.

01:04:12.590 --> 01:04:14.590
Und dann sollte es

01:04:14.590 --> 01:04:16.590
funktionieren?

01:04:16.590 --> 01:04:18.590
Hey, es kommt

01:04:18.590 --> 01:04:23.120
bald!

01:04:23.120 --> 01:04:25.120
Five-Head-Time!

01:04:25.120 --> 01:04:27.120
Es funktioniert!

01:04:27.120 --> 01:04:29.120
Ob es genau das macht,

01:04:29.120 --> 01:04:31.120
was ich haben will? Chat, hat irgendjemand

01:04:31.120 --> 01:04:33.120
einen Plan, was der Unterschied ist zwischen

01:04:33.120 --> 01:04:35.120
Box

01:04:35.120 --> 01:04:37.120
und Arc? Also Arc ist

01:04:37.120 --> 01:04:39.120
ein Reference-Counter, das weiß ich.

01:04:39.120 --> 01:04:41.120
Genauso wie RC. Warum es unterschiedliche Sachen

01:04:41.120 --> 01:04:43.120
gibt, habe ich auch noch nicht gecheckt.

01:04:43.120 --> 01:04:46.560
Aber,

01:04:46.560 --> 01:04:48.560
ich vermute mal, dass Box

01:04:48.560 --> 01:04:54.430
ne, keine Ahnung.

01:04:54.430 --> 01:04:56.430
Ich wollte gerade sagen, ich vermute, ne.

01:04:56.430 --> 01:04:58.430
Würde das

01:04:58.430 --> 01:05:00.430
auch so funktionieren mit Box?

01:05:00.430 --> 01:05:02.430
Box of T?

01:05:02.430 --> 01:05:04.430
Ja, Arc ist Atomic, aber was das in dem

01:05:04.430 --> 01:05:15.300
Fall bedeuten soll? Keine Ahnung.

01:05:15.300 --> 01:05:17.300
Okay, das funktioniert. Expected Box,

01:05:17.300 --> 01:05:19.300
Found und Box.

01:05:19.300 --> 01:05:24.720
Und Box.

01:05:24.720 --> 01:05:26.720
Ne, das ist das gleiche Problem.

01:05:26.720 --> 01:05:28.720
Ja, wir müssen das

01:05:28.720 --> 01:05:30.720
mit Arc machen, weil Threat Safety.

01:05:30.720 --> 01:05:32.720
Genau, so.

01:05:32.720 --> 01:05:34.720
Wunderbar. Also wenn ich

01:05:34.720 --> 01:05:36.720
das richtig verstehe, passiert jetzt Folgendes.

01:05:36.720 --> 01:05:40.160
Der

01:05:40.160 --> 01:05:42.160
speichert jetzt, also

01:05:42.160 --> 01:05:44.160
der Arc, also das ist ein

01:05:44.160 --> 01:05:46.160
Atomic Reference-Counter.

01:05:46.160 --> 01:05:48.160
Der Arc

01:05:48.160 --> 01:05:50.160
übernimmt Ownership of T.

01:05:50.160 --> 01:05:53.600
Das ist so Rust-Logik für,

01:05:53.600 --> 01:05:55.600
ja, gibt es eigentlich in anderen Sprachen oftmals

01:05:55.600 --> 01:05:57.600
nichts direkt Vergleichbares.

01:05:57.600 --> 01:05:59.600
Also,

01:05:59.600 --> 01:06:01.600
T gehört dem Arc und Arc

01:06:01.600 --> 01:06:03.600
selbst ist ein Reference-Counter und jedes Mal,

01:06:03.600 --> 01:06:05.600
wenn ich den klone,

01:06:05.600 --> 01:06:07.600
wird der Reference-Counter um 1

01:06:07.600 --> 01:06:09.600
hochgezählt und erst wenn der Reference-Counter

01:06:09.600 --> 01:06:11.600
bei 0 ist, wird

01:06:11.600 --> 01:06:13.600
das freigegeben. Das heißt, jetzt

01:06:13.600 --> 01:06:15.600
kann ich Save

01:06:15.600 --> 01:06:17.600
das Returnen, weil dadurch, dass

01:06:17.600 --> 01:06:19.600
es in einem Arc ist, immer sichergestellt

01:06:19.600 --> 01:06:21.600
ist, solange ich noch irgendwo

01:06:21.600 --> 01:06:23.600
ne gültige Referenz habe, bisschen wie der

01:06:23.600 --> 01:06:25.600
Garbage-Collector in C-Sharp,

01:06:25.600 --> 01:06:27.600
naja, ganz, ganz

01:06:27.600 --> 01:06:29.600
light, ja.

01:06:29.600 --> 01:06:31.600
Sobald ich

01:06:31.600 --> 01:06:33.600
quasi noch irgendwie einen Reference-Counter habe,

01:06:33.600 --> 01:06:35.600
dann

01:06:35.600 --> 01:06:37.600
ist das quasi sicher

01:06:37.600 --> 01:06:41.940
und kann nie out of scope gehen.

01:06:41.940 --> 01:06:43.940
Oh man, die Musik ist vorbei.

01:06:43.940 --> 01:06:48.910
Sack.

01:06:48.910 --> 01:06:55.740
Gut.

01:06:55.740 --> 01:06:57.740
So, jetzt können wir das Element

01:06:57.740 --> 01:07:02.530
getten, auch schon mal nice.

01:07:02.530 --> 01:07:04.530
RC cannot be shared

01:07:04.530 --> 01:07:06.530
between threads. Ja, deswegen braucht

01:07:06.530 --> 01:07:08.530
man wahrscheinlich Arc, dass

01:07:08.530 --> 01:07:10.530
der Reference-Counter irgendwie

01:07:10.530 --> 01:07:12.530
Atomic-mäßig erhöht wird

01:07:12.530 --> 01:07:14.530
und damit thread-safe ist. Rate

01:07:14.530 --> 01:07:18.100
ich jetzt einfach mal. So.

01:07:18.100 --> 01:07:20.100
Soweit, so gut. Was hat er hier?

01:07:20.100 --> 01:07:22.100
Registry is never constructed.

01:07:22.100 --> 01:07:24.100
Die IDE ist auch schon ein bisschen pp-iger,

01:07:24.100 --> 01:07:26.100
oder? Ja gut, die Funktion

01:07:26.100 --> 01:07:28.100
wird nicht aufgerufen. Ja, okay. Okay, okay.

01:07:28.100 --> 01:07:30.100
Lasst mir gefallen. So,

01:07:30.100 --> 01:07:32.100
das brauchen wir als nächstes. Delete.

01:07:32.100 --> 01:07:34.100
Delete brauchen wir als nächstes.

01:07:34.100 --> 01:07:36.100
Fn.

01:07:36.100 --> 01:07:38.100
Nennen wir einfach Dell.

01:07:38.100 --> 01:07:40.100
U32, die ID.

01:07:40.100 --> 01:07:42.100
Und jetzt, das dürfte relativ easy

01:07:42.100 --> 01:07:45.540
sein. Das dürfte relativ easy

01:07:45.540 --> 01:07:47.540
sein. Self. Moment, das kann ich doch eigentlich

01:07:47.540 --> 01:07:49.540
so lassen. Self, so. Jetzt

01:07:49.540 --> 01:07:51.540
wahrscheinlich write.

01:07:51.540 --> 01:07:53.540
Ähm.

01:07:53.540 --> 01:07:55.540
Wie löscht man? Wie löscht

01:07:55.540 --> 01:07:57.540
man da was? Get, insert,

01:07:57.540 --> 01:07:59.540
ether, clear. Ne.

01:07:59.540 --> 01:08:01.540
Ich will sowas wie erase, delete

01:08:01.540 --> 01:08:03.540
oder sowas. Remove.

01:08:03.540 --> 01:08:05.540
Remove.

01:08:05.540 --> 01:08:15.440
Remove entry.

01:08:15.440 --> 01:08:17.440
Oh.

01:08:17.440 --> 01:08:22.420
Was ist der Unterschied?

01:08:22.420 --> 01:08:24.420
Removes the key from the map, returning the stored

01:08:24.420 --> 01:08:26.420
key and value if the key was previously

01:08:26.420 --> 01:08:29.860
in the map. Okay.

01:08:29.860 --> 01:08:31.860
Und, und.

01:08:31.860 --> 01:08:33.860
Remove is,

01:08:33.860 --> 01:08:35.860
removes the key from the map, returning the

01:08:35.860 --> 01:08:37.860
value at the key. Achso,

01:08:37.860 --> 01:08:39.860
das eine returned key value und das andere

01:08:39.860 --> 01:08:41.860
returned nur den value. Ich will überhaupt

01:08:41.860 --> 01:08:43.860
nichts returnen.

01:08:43.860 --> 01:08:45.860
Gibt es sowas wie drop oder so? Hey.

01:08:45.860 --> 01:08:47.860
Moment, ist wieder was anderes.

01:08:47.860 --> 01:08:49.860
Was zum Teufel macht drop?

01:08:49.860 --> 01:08:51.860
Drop

01:08:51.860 --> 01:08:53.860
ist so Nische, das hat auch nicht mal

01:08:53.860 --> 01:08:59.660
irgendeinen Hilfetext.

01:08:59.660 --> 01:09:01.660
Also, remove.

01:09:01.660 --> 01:09:03.660
Einfach nur remove.

01:09:03.660 --> 01:09:05.660
ID.

01:09:05.660 --> 01:09:07.660
Und da muss auch gar nichts returned werden. Einfach

01:09:07.660 --> 01:09:09.660
so. Easy.

01:09:09.660 --> 01:09:13.300
Eats. Eats.

01:09:13.300 --> 01:09:15.300
Easy as fuck.

01:09:15.300 --> 01:09:18.670
Easy as fuck.

01:09:18.670 --> 01:09:20.670
Moment, das funds wieder nicht. Warum?

01:09:20.670 --> 01:09:24.620
Achso, und.

01:09:24.620 --> 01:09:26.620
Mit was? Mit STRG Q kannst du...

01:09:26.620 --> 01:09:31.280
Meinst du hier?

01:09:31.280 --> 01:09:38.980
Nö.

01:09:38.980 --> 01:09:40.980
Ich habe Visual Studio Key Mappings.

01:09:40.980 --> 01:09:42.980
Keine Ahnung. Ich glaube, das war keine gute Idee.

01:09:42.980 --> 01:09:44.980
Okay.

01:09:44.980 --> 01:09:46.980
Ja, das war es doch im Großen und

01:09:46.980 --> 01:09:48.980
Ganzen schon. Und jetzt,

01:09:48.980 --> 01:09:50.980
jetzt eigentlich nur noch sowas wie

01:09:50.980 --> 01:09:52.980
public

01:09:52.980 --> 01:09:54.980
function.

01:09:54.980 --> 01:09:56.980
Ja.

01:09:56.980 --> 01:09:58.980
All oder so.

01:09:58.980 --> 01:10:00.980
All.

01:10:00.980 --> 01:10:02.980
Irgendwas in der Richtung.

01:10:02.980 --> 01:10:04.980
All.

01:10:04.980 --> 01:10:10.590
Und jetzt

01:10:10.590 --> 01:10:12.590
quasi return self.

01:10:12.590 --> 01:10:16.420
Ach Moment.

01:10:16.420 --> 01:10:18.420
Self.

01:10:18.420 --> 01:10:20.420
Store.

01:10:20.420 --> 01:10:22.420
Ähm.

01:10:22.420 --> 01:10:24.420
Read.

01:10:24.420 --> 01:10:26.420
Vermutlich.

01:10:26.420 --> 01:10:30.240
Unwrap.

01:10:30.240 --> 01:10:33.680
Eater. Klingt gut.

01:10:33.680 --> 01:10:38.660
Und das jetzt einfach

01:10:38.660 --> 01:10:40.660
zurückgeben, oder? Das müsste doch sein.

01:10:40.660 --> 01:10:42.660
Nee.

01:10:42.660 --> 01:10:44.660
Ist es nicht. Warum nicht?

01:10:44.660 --> 01:10:46.660
Oh Gott, Rust.

01:10:46.660 --> 01:10:48.660
Warum ist das wieder kompliziert?

01:10:48.660 --> 01:10:50.660
Returns a value

01:10:50.660 --> 01:10:52.660
referencing data owned by the current

01:10:52.660 --> 01:10:54.660
function.

01:10:54.660 --> 01:10:56.660
Was ist das eigentlich für ein

01:10:56.660 --> 01:10:58.660
ultra hässlicher Return Wert?

01:10:58.660 --> 01:11:00.660
Eater.

01:11:00.660 --> 01:11:02.660
Ähm. Single quotes.

01:11:02.660 --> 01:11:04.660
Underscore.

01:11:04.660 --> 01:11:06.660
What?

01:11:06.660 --> 01:11:10.160
Kann man es nicht einfach löschen?

01:11:10.160 --> 01:11:12.160
Äh, prägt nichts.

01:11:12.160 --> 01:11:14.160
Okay, Rust.

01:11:14.160 --> 01:11:16.160
Ich habe legit keine Ahnung,

01:11:16.160 --> 01:11:18.160
wie das funktioniert.

01:11:18.160 --> 01:11:20.160
Leute, ich habe

01:11:20.160 --> 01:11:22.160
eine absolute Pipega-Idee, was

01:11:22.160 --> 01:11:24.160
wir machen könnten.

01:11:24.160 --> 01:11:26.160
Wir können sagen, unwrap.

01:11:26.160 --> 01:11:32.030
Clone.

01:11:32.030 --> 01:11:34.030
Und wir returnen eine neue Hash Map

01:11:34.030 --> 01:11:36.030
jedes Mal, wenn wir all. Aber das kann es ja nicht

01:11:36.030 --> 01:11:38.030
sein, oder?

01:11:38.030 --> 01:11:43.390
Ich will einfach

01:11:43.390 --> 01:11:45.390
nur außerhalb

01:11:45.390 --> 01:11:47.390
eine Schleife machen können über alle

01:11:47.390 --> 01:11:49.390
Elemente in der Registry.

01:11:49.390 --> 01:11:53.340
Wie funktioniert das?

01:11:53.340 --> 01:11:55.340
Ich will sagen können,

01:11:55.340 --> 01:11:58.660
for.

01:11:58.660 --> 01:12:00.660
Äh, Moment.

01:12:00.660 --> 01:12:04.800
Äh, for.

01:12:04.800 --> 01:12:06.800
Er.

01:12:06.800 --> 01:12:08.800
All.

01:12:08.800 --> 01:12:10.800
Äh, ja, blub.

01:12:10.800 --> 01:12:12.800
Das will ich

01:12:12.800 --> 01:12:14.800
sagen können. Das funzt jetzt

01:12:14.800 --> 01:12:16.800
an der Stelle. Klar, weil ich eine neue Map

01:12:16.800 --> 01:12:18.800
mache. Aber ich will

01:12:18.800 --> 01:12:20.800
ja nicht wirklich

01:12:20.800 --> 01:12:22.800
die Map einmal komplett klonen.

01:12:22.800 --> 01:12:24.800
Bei jedem Aufruf.

01:12:24.800 --> 01:12:26.800
Das ist ja nicht Sinn und Zweck der Sache.

01:12:26.800 --> 01:12:30.620
Okay, stack overflow.

01:12:30.620 --> 01:12:32.620
Rust. Return

01:12:32.620 --> 01:12:40.160
iterator.

01:12:40.160 --> 01:12:44.620
Oh. Returning

01:12:44.620 --> 01:12:46.620
iterator. Was? Returning

01:12:46.620 --> 01:12:48.620
Rust iterators. Depth

01:12:48.620 --> 01:12:50.620
first. Returning an iterator.

01:12:50.620 --> 01:12:54.380
Ja, genau.

01:12:54.380 --> 01:12:56.380
Genau das will ich machen. Und das habe ich

01:12:56.380 --> 01:12:58.380
auch gerade gemacht, aber das funzt nicht.

01:12:58.380 --> 01:13:03.040
The compiler produces an error.

01:13:05.040 --> 01:13:07.040
The type is contained within the error

01:13:07.040 --> 01:13:09.040
messages. Ja, genau das

01:13:09.040 --> 01:13:11.040
habe ich gerade gemacht.

01:13:11.040 --> 01:13:13.040
Genau das

01:13:13.040 --> 01:13:15.040
habe ich gerade gemacht.

01:13:15.040 --> 01:13:17.040
Beifällige Webseite.

01:13:17.040 --> 01:13:19.040
Aber.

01:13:19.040 --> 01:13:21.040
Moment.

01:13:21.040 --> 01:13:23.040
Ne, ne, ne.

01:13:23.040 --> 01:13:25.040
Moment, das funzt. Ne, das funzt nicht.

01:13:25.040 --> 01:13:27.040
Das ist nicht das, was ich haben will.

01:13:29.040 --> 01:13:31.040
Oh man.

01:13:31.040 --> 01:13:33.040
IDE, please.

01:13:33.040 --> 01:13:35.040
Genau das habe ich gemacht,

01:13:35.040 --> 01:13:37.040
aber das funzt nicht.

01:13:37.040 --> 01:13:39.040
Gibt es da nicht

01:13:39.040 --> 01:13:41.040
Intuiter? Ja, aber ich will ja nicht

01:13:41.040 --> 01:13:46.340
Ownership zurückgeben.

01:13:46.340 --> 01:13:48.340
Ich will ja nicht Ownership zurückgeben.

01:13:48.340 --> 01:13:51.780
Sondern einfach nur

01:13:51.780 --> 01:13:53.780
eine.

01:13:53.780 --> 01:13:55.780
Ja.

01:13:55.780 --> 01:13:57.780
Jede Menge. Die Referenzen

01:13:57.780 --> 01:13:59.780
auf die Elemente in diesem

01:13:59.780 --> 01:14:01.780
in dieser HashMap.

01:14:01.780 --> 01:14:08.610
So, also. Das was

01:14:08.610 --> 01:14:10.610
die Seite vorschlägt funzt nicht, weil

01:14:10.610 --> 01:14:12.610
dann returns a value

01:14:12.610 --> 01:14:14.610
referencing data

01:14:14.610 --> 01:14:16.610
owned by the current function.

01:14:16.610 --> 01:14:21.390
Und da bin ich mir nicht sicher, was

01:14:21.390 --> 01:14:23.390
es mir sagen möchte, ehrlich gesagt.

01:14:23.390 --> 01:14:25.390
Muss ich vielleicht das hier erst nochmal.

01:14:25.390 --> 01:14:27.390
Moment. Muss ich sagen let m irgendwie so.

01:14:27.390 --> 01:14:32.940
Und dann.

01:14:32.940 --> 01:14:34.940
Ne, das funktioniert natürlich auch nicht.

01:14:34.940 --> 01:14:36.940
Okay. Und wie geht das weiter?

01:14:36.940 --> 01:14:40.900
Das habe ich probiert.

01:14:40.900 --> 01:14:42.900
Laut der Seite geht das so.

01:14:42.900 --> 01:14:44.900
Ist das irgendwie

01:14:44.900 --> 01:14:46.900
so eine AI generierte Webseite?

01:14:46.900 --> 01:14:48.900
Aber von 2020 eher nicht.

01:14:48.900 --> 01:14:50.900
Irgendeine AI generierte Webseite.

01:14:50.900 --> 01:14:57.860
Das ist gut.

01:14:57.860 --> 01:14:59.860
How to implement iterator

01:14:59.860 --> 01:15:01.860
over

01:15:01.860 --> 01:15:03.860
wrapped vector in Rust.

01:15:03.860 --> 01:15:05.860
Genau. Hier. Wrapped.

01:15:05.860 --> 01:15:07.860
Und jetzt

01:15:07.860 --> 01:15:09.860
will der, dass man das iteraten kann.

01:15:09.860 --> 01:15:11.860
Genau das will ich. Genau sowas will ich haben.

01:15:11.860 --> 01:15:24.900
Actual to call it

01:15:24.900 --> 01:15:26.900
as you described. You don't need to

01:15:26.900 --> 01:15:28.900
implement iterator.

01:15:28.900 --> 01:15:30.900
For it, you just need to return

01:15:30.900 --> 01:15:32.900
the iterator of the inner vec.

01:15:32.900 --> 01:15:38.770
Ja, ich habe das schon gesehen,

01:15:38.770 --> 01:15:45.150
den Link. Okay, six hat time.

01:15:45.150 --> 01:15:50.060
Okay, probieren wir

01:15:50.060 --> 01:15:52.060
das doch mal so aus.

01:15:52.060 --> 01:15:54.060
Das sollte doch nicht allzu kompliziert

01:15:54.060 --> 01:15:59.420
sein. So, self.

01:15:59.420 --> 01:16:01.420
Jetzt brauchen wir erstmal hier den,

01:16:01.420 --> 01:16:06.980
probieren, planten wir das mal aus hier.

01:16:06.980 --> 01:16:08.980
So, zack.

01:16:08.980 --> 01:16:10.980
M iter.

01:16:10.980 --> 01:16:14.670
Funzt nicht,

01:16:14.670 --> 01:16:16.670
weil

01:16:16.670 --> 01:16:18.670
unelide

01:16:18.670 --> 01:16:20.670
lifetimes.

01:16:20.670 --> 01:16:29.230
What?

01:16:29.230 --> 01:16:32.860
Ich weiß nicht mehr, was es will von mir.

01:16:32.860 --> 01:16:36.180
Ich lass mal hier den.

01:16:36.180 --> 01:16:38.180
Okay, und jetzt geht das?

01:16:38.180 --> 01:16:40.180
Method not found.

01:16:40.180 --> 01:16:42.180
Achso. Moment.

01:16:42.180 --> 01:16:47.280
Nee. Returns a value

01:16:47.280 --> 01:16:49.280
referencing data owned by the current function.

01:16:49.280 --> 01:16:51.280
Okay, das funzt schon mal

01:16:51.280 --> 01:16:53.280
nett.

01:16:53.280 --> 01:16:55.280
So, das geht nicht. Also,

01:16:55.280 --> 01:16:57.280
stackoverflow fail.

01:16:57.280 --> 01:16:59.280
Nee, da fehlt kein return.

01:16:59.280 --> 01:17:01.280
Wenn man das Semikolon

01:17:01.280 --> 01:17:03.280
weglässt, wird die letzte

01:17:03.280 --> 01:17:05.280
Zeile automatisch als return

01:17:05.280 --> 01:17:07.280
verwendet. Ist auch

01:17:07.280 --> 01:17:09.280
ein bisschen, weiß nicht, bisschen

01:17:09.280 --> 01:17:11.280
pp-iger irgendwie, dass es dafür was extra

01:17:11.280 --> 01:17:15.810
gibt. Aber das funktioniert

01:17:15.810 --> 01:17:26.100
nicht. Also, stackoverflow

01:17:26.100 --> 01:17:28.100
Antwort three hat.

01:17:28.100 --> 01:17:30.100
Okay,

01:17:30.100 --> 01:17:32.100
nächste Antwort. Accepted Antwort.

01:17:32.100 --> 01:17:34.100
Accepted Antwort.

01:17:34.100 --> 01:17:36.100
Vec itself does not implement

01:17:36.100 --> 01:17:38.100
iterator. However, it implements into

01:17:38.100 --> 01:17:43.070
iterator in three ways.

01:17:43.070 --> 01:17:45.070
You probably wanted to implement

01:17:45.070 --> 01:17:47.070
these for your wrapper as well.

01:17:47.070 --> 01:17:50.510
Nee, into iterator will ich

01:17:50.510 --> 01:17:52.510
schon mal nett.

01:17:52.510 --> 01:17:56.340
Deref. Wie?

01:17:56.340 --> 01:17:58.340
Deref to slice so that we can.

01:17:58.340 --> 01:18:02.290
Ich. Was?

01:18:02.290 --> 01:18:05.660
Was bin ich überhaupt sehend

01:18:05.660 --> 01:18:10.130
hier gerade? Implementier

01:18:10.130 --> 01:18:12.130
doch den iterator für arc iterator.

01:18:12.130 --> 01:18:14.130
Oder bin ich gerade dumm?

01:18:14.130 --> 01:18:21.790
Ja, wie denn?

01:18:21.790 --> 01:18:26.000
Alter, was? Okay.

01:18:26.000 --> 01:18:28.000
Implement iterator.

01:18:28.000 --> 01:18:30.000
So, okay.

01:18:30.000 --> 01:18:32.000
Also, so einfach wie stackoverflow das macht, geht das

01:18:32.000 --> 01:18:34.000
schon mal nett. Also, implement

01:18:34.000 --> 01:18:36.000
iterator for registry

01:18:36.000 --> 01:18:38.000
of

01:18:38.000 --> 01:18:46.430
t.

01:18:46.430 --> 01:18:51.340
Ähm, was?

01:18:51.340 --> 01:18:53.340
Okay, item type.

01:18:53.340 --> 01:18:55.340
Type item gleich

01:18:55.340 --> 01:19:01.980
u32.

01:19:03.980 --> 01:19:05.980
Nee, mein item type ist t.

01:19:05.980 --> 01:19:10.130
Und dementsprechend ist es auch einfach

01:19:10.130 --> 01:19:12.130
option of t.

01:19:12.130 --> 01:19:19.020
Und das da oben lass ich weg.

01:19:19.020 --> 01:19:27.840
Und was? Ich check's nicht,

01:19:27.840 --> 01:19:29.840
was der hier macht.

01:19:29.840 --> 01:19:31.840
Was soll das?

01:19:31.840 --> 01:19:33.840
Was soll das heißen?

01:19:33.840 --> 01:19:35.840
Ach, man muss das?

01:19:35.840 --> 01:19:37.840
Moment, man braucht das hier.

01:19:37.840 --> 01:19:39.840
Okay, das ist erforderlich.

01:19:39.840 --> 01:19:41.840
Hast du Tipps,

01:19:41.840 --> 01:19:43.840
wie man am besten anfangen kann, zu programmieren?

01:19:43.840 --> 01:19:45.840
Ja, der beste Tipp ist,

01:19:45.840 --> 01:19:47.840
du hast irgendwie eine coole Idee, was

01:19:47.840 --> 01:19:49.840
du schon immer mal machen wolltest,

01:19:49.840 --> 01:19:51.840
und suchst dir die beste Technologie dafür raus

01:19:51.840 --> 01:19:53.840
und fängst damit an. Weil dann hast du auch

01:19:53.840 --> 01:19:55.840
immer Motivation, was zu machen,

01:19:55.840 --> 01:19:57.840
weil das ja was ist, was du letztendlich

01:19:57.840 --> 01:19:59.840
schon immer mal machen wolltest. Also, wenn du

01:19:59.840 --> 01:20:01.840
sagst, ich würde gerne microcontroller

01:20:01.840 --> 01:20:03.840
programmieren, eine eigene Webseite machen,

01:20:03.840 --> 01:20:05.840
meinen Rollladen hoch- und runterfahren

01:20:05.840 --> 01:20:07.840
automatisch, das ist natürlich am besten,

01:20:07.840 --> 01:20:09.840
wenn du so ein Ziel schon im Kopf hast.

01:20:09.840 --> 01:20:11.840
Das ist motivierend. Wenn du gar keine Ahnung

01:20:11.840 --> 01:20:13.840
hast, wie du anfangen sollst und einfach

01:20:13.840 --> 01:20:15.840
nur gucken willst, ob das was für dich

01:20:15.840 --> 01:20:17.840
ist, kann ich dir nur empfehlen,

01:20:17.840 --> 01:20:19.840
lad dir Visual Studio Code runter

01:20:19.840 --> 01:20:23.340
und fang mit JavaScript an.

01:20:23.340 --> 01:20:25.340
JavaScript, bisschen HTML, CSS

01:20:25.340 --> 01:20:27.340
hat die mit Abstand

01:20:27.340 --> 01:20:29.340
niedrigste Einstiegshürde. Du brauchst

01:20:29.340 --> 01:20:31.340
einen ordentlichen Texteditor, wie gesagt,

01:20:31.340 --> 01:20:33.340
nimm Visual Studio Code, ist alles out of the box

01:20:33.340 --> 01:20:35.340
für JavaScript dabei.

01:20:35.340 --> 01:20:37.340
Und du brauchst einen Browser, und einen Browser hast du,

01:20:37.340 --> 01:20:39.340
sonst wärst du hier nicht im Twitch-Chat.

01:20:39.340 --> 01:20:49.380
Und dann legst du los.

01:20:49.380 --> 01:20:51.380
Ich check nicht, was ich machen muss, Chat.

01:20:51.380 --> 01:20:53.380
Was will das hier von mir?

01:20:53.380 --> 01:20:59.950
Here we define a sequence using

01:20:59.950 --> 01:21:05.380
current und next.

01:21:05.380 --> 01:21:07.380
Fn next. Okay,

01:21:07.380 --> 01:21:09.380
option will ich doch gar nicht, oder?

01:21:09.380 --> 01:21:11.380
Ich will einfach

01:21:11.380 --> 01:21:13.380
t return.

01:21:13.380 --> 01:21:17.840
Nee, das geht nicht. Es muss

01:21:17.840 --> 01:21:22.940
eine Option sein.

01:21:22.940 --> 01:21:24.940
Moment, kann ich nicht...

01:21:24.940 --> 01:21:33.630
Was will...

01:21:33.630 --> 01:21:40.560
Current next?

01:21:40.560 --> 01:21:44.060
Self current? What?

01:21:44.060 --> 01:21:46.060
Kann ich nicht das einfach

01:21:46.060 --> 01:21:48.060
re-usen?

01:21:48.060 --> 01:21:50.060
Store? Kann ich das nicht

01:21:50.060 --> 01:22:02.910
einfach re-usen von...

01:22:02.910 --> 01:22:04.910
Read? Kann ich das

01:22:04.910 --> 01:22:06.910
nicht einfach re-usen?

01:22:06.910 --> 01:22:18.160
Von dem anderen?

01:22:18.160 --> 01:22:20.160
Und so?

01:22:20.160 --> 01:22:22.160
De-referencen?

01:22:22.160 --> 01:22:25.730
Wobei, das braucht man eigentlich nicht.

01:22:25.730 --> 01:22:27.730
Dass ich jetzt sagen kann, irgendwie, return

01:22:27.730 --> 01:22:37.540
m next.

01:22:37.540 --> 01:22:39.540
Ja, das kann man doch

01:22:39.540 --> 01:22:49.440
einfach reppen, oder?

01:22:49.440 --> 01:22:51.440
Return n.

01:22:51.440 --> 01:22:53.440
Wobei, nee. Moment.

01:22:53.440 --> 01:23:04.180
Was muss man returnen?

01:23:04.180 --> 01:23:08.060
Hier return was?

01:23:08.060 --> 01:23:10.060
Option of

01:23:10.060 --> 01:23:12.060
u 32

01:23:12.060 --> 01:23:14.060
t.

01:23:14.060 --> 01:23:16.060
Oh man, was ist denn jetzt?

01:23:16.060 --> 01:23:18.060
Method next has an incomparable

01:23:18.060 --> 01:23:20.060
expected time

01:23:20.060 --> 01:23:24.780
found.

01:23:24.780 --> 01:23:26.780
Ach so. Moment.

01:23:26.780 --> 01:23:30.800
Ähm.

01:23:30.800 --> 01:23:32.800
Was muss ich sagen? Wie haben die gesagt?

01:23:32.800 --> 01:23:36.430
Self? Item?

01:23:36.430 --> 01:23:38.430
Item? Nee.

01:23:38.430 --> 01:23:41.940
Wie haben die das hier gemacht?

01:23:41.940 --> 01:23:43.940
Oh man, shit. Das ist ja super

01:23:43.940 --> 01:23:56.530
komplizierter shit wieder.

01:23:56.530 --> 01:23:58.530
Self. Self cross.

01:23:58.530 --> 01:24:00.530
Okay.

01:24:00.530 --> 01:24:02.530
Item. Und item ist quasi

01:24:02.530 --> 01:24:04.530
u 32

01:24:04.530 --> 01:24:06.530
t.

01:24:06.530 --> 01:24:08.530
Okay. Ist nicht,

01:24:08.530 --> 01:24:10.530
weil... Ach so.

01:24:10.530 --> 01:24:12.530
Weil es und

01:24:12.530 --> 01:24:14.530
es ist und u 32

01:24:14.530 --> 01:24:16.530
aus irgendwelchen Gründen

01:24:16.530 --> 01:24:18.530
und a t.

01:24:18.530 --> 01:24:20.530
Alter, what the fuck, man.

01:24:20.530 --> 01:24:22.530
Found was?

01:24:22.530 --> 01:24:24.530
Okay, u 32.

01:24:24.530 --> 01:24:29.440
What the hell?

01:24:29.440 --> 01:24:31.440
Alter, Rust, man.

01:24:31.440 --> 01:24:33.440
Ich will einfach ne Schleife drüber machen.

01:24:33.440 --> 01:24:35.440
Was will das denn von mir?

01:24:37.440 --> 01:24:41.780
Was will das von mir, man?

01:24:41.780 --> 01:24:48.740
Oh, fucking shit.

01:24:48.740 --> 01:25:11.250
Ich mein, okay.

01:25:11.250 --> 01:25:13.250
Würde das dann prinzipiell überhaupt

01:25:13.250 --> 01:25:18.160
funktionieren? Würde das...

01:25:18.160 --> 01:25:23.140
Nee, all ist auskommentiert.

01:25:23.140 --> 01:25:28.820
Meine Güte.

01:25:28.820 --> 01:25:30.820
Okay, also.

01:25:30.820 --> 01:25:35.020
Was will das von mir?

01:25:35.020 --> 01:25:38.850
Und. Okay. Und und

01:25:38.850 --> 01:25:40.850
ist nicht erlaubt. Warum ist und

01:25:40.850 --> 01:25:42.850
nicht erlaubt? Weil missing

01:25:42.850 --> 01:25:44.850
lifetime specifier.

01:25:44.850 --> 01:25:48.290
Okay, Rust, hilf mir.

01:25:48.290 --> 01:25:50.290
Rust, please.

01:25:50.290 --> 01:25:52.290
Was? Und not

01:25:52.290 --> 01:25:54.290
a.

01:25:54.290 --> 01:25:56.290
MonkaW.

01:25:56.290 --> 01:26:14.670
Oh. So.

01:26:14.670 --> 01:26:18.690
Okay. Okay.

01:26:18.690 --> 01:26:20.690
Ich habe absolut keine Ahnung, was ich

01:26:20.690 --> 01:26:22.690
da gerade mache.

01:26:22.690 --> 01:26:24.690
Okay. Okay. Moment. Moment, Leute.

01:26:24.690 --> 01:26:33.250
Nee, was ist jetzt?

01:26:33.250 --> 01:26:36.750
Leute.

01:26:36.750 --> 01:26:38.750
Mann, das kann doch nicht so schwierig

01:26:38.750 --> 01:26:45.580
sein.

01:26:45.580 --> 01:26:47.580
Ich habe absolut keine Ahnung, was Rust von mir will, man.

01:26:47.580 --> 01:26:56.020
Nehme mal oben das

01:26:56.020 --> 01:26:58.020
a raus. Habe ich. Aber

01:26:58.020 --> 01:27:00.020
das geht nicht.

01:27:00.020 --> 01:27:02.020
Dann will er

01:27:02.020 --> 01:27:04.020
nicht, weil lifetime

01:27:04.020 --> 01:27:06.020
specifier missing.

01:27:06.020 --> 01:27:08.020
So. Und jetzt sagt

01:27:08.020 --> 01:27:10.020
er mir hier.

01:27:16.020 --> 01:27:18.020
Alles klar. Jetzt sofort.

01:27:18.020 --> 01:27:20.020
Muss man vielleicht so machen? Hier so?

01:27:20.020 --> 01:27:23.970
Nee.

01:27:23.970 --> 01:27:25.970
Ich habe keine Ahnung, man.

01:27:25.970 --> 01:27:27.970
Alter, Rust. Die Sprache fuckt

01:27:27.970 --> 01:27:32.690
jedenfalls hier so krass ab, ey.

01:27:32.690 --> 01:27:34.690
Also, ich habe wirklich, ich habe absolut keine Ahnung,

01:27:34.690 --> 01:27:47.280
was das Ding von mir will, man.

01:27:47.280 --> 01:27:49.280
Du musst es auch embracen.

01:27:49.280 --> 01:27:51.280
Naja.

01:27:51.280 --> 01:28:01.890
Massive embracing am Start.

01:28:01.890 --> 01:28:03.890
Okay. Keine Ahnung. Wir gucken mal.

01:28:03.890 --> 01:28:05.890
Wir gucken mal weiter.

01:28:05.890 --> 01:28:07.890
Also, das funzt ja schon mal nett.

01:28:07.890 --> 01:28:12.350
Wie das hier.

01:28:12.350 --> 01:28:14.350
Was haben wir hier sonst noch so zur Auswahl?

01:28:14.350 --> 01:28:16.350
Imple deref for binary.

01:28:16.350 --> 01:28:18.350
Okay, dann probieren wir. Okay. Wenn das mit dem iterator

01:28:18.350 --> 01:28:20.350
nicht funktioniert, dann probieren wir einfach was anderes.

01:28:20.350 --> 01:28:22.350
For registry

01:28:22.350 --> 01:28:30.460
t.

01:28:30.460 --> 01:28:32.460
Probier mal. Moment, was?

01:28:32.460 --> 01:28:34.460
Moment. Wo soll ich das

01:28:34.460 --> 01:28:36.460
probieren? Wir kommentieren das mal aus,

01:28:36.460 --> 01:28:38.460
weil vielleicht brauchen wir das gleich nochmal.

01:28:38.460 --> 01:28:40.460
Probier mal self next

01:28:40.460 --> 01:28:42.460
map.

01:28:42.460 --> 01:28:48.590
What?

01:28:48.590 --> 01:28:53.820
Was? Zeile 26.

01:28:53.820 --> 01:29:05.580
Fiver time. Das ist ja nicht self.

01:29:05.580 --> 01:29:27.460
Das ist ja nur m. C++

01:29:27.460 --> 01:29:29.460
Level types, würde ich sagen.

01:29:29.460 --> 01:29:31.460
So.

01:29:31.460 --> 01:29:33.460
Das wird jetzt auskommentiert. Okay.

01:29:33.460 --> 01:29:35.460
Next. Also, probieren wir das mit dem

01:29:35.460 --> 01:29:37.460
deref.

01:29:37.460 --> 01:29:39.460
Implement deref for. Okay.

01:29:39.460 --> 01:29:41.460
t.

01:29:41.460 --> 01:29:43.460
Registry.

01:29:43.460 --> 01:29:45.460
t.

01:29:45.460 --> 01:29:49.280
Output.

01:29:49.280 --> 01:30:22.190
Moment.

01:30:22.190 --> 01:30:27.040
Das sind die Elemente.

01:30:27.040 --> 01:30:29.040
Das sind die Elemente.

01:30:29.040 --> 01:30:31.040
Also, mein Element ist

01:30:31.040 --> 01:30:33.040
Output ist dann

01:30:33.040 --> 01:30:35.040
ein

01:30:35.040 --> 01:30:37.040
32 Vector of t.

01:30:37.040 --> 01:30:52.640
Self.

01:30:52.640 --> 01:30:57.230
Self.

01:30:57.230 --> 01:30:59.230
Warum hat er hier noch ein und davor?

01:30:59.230 --> 01:31:01.230
Warum ist hier nochmal ein und

01:31:01.230 --> 01:31:03.230
davor?

01:31:03.230 --> 01:31:06.930
Ich check's nicht. Okay.

01:31:06.930 --> 01:31:08.930
Self.

01:31:08.930 --> 01:31:15.120
Store. Achso, ja.

01:31:15.120 --> 01:31:17.120
Moment. Hä?

01:31:17.120 --> 01:31:20.940
Deref ist gar nicht

01:31:20.940 --> 01:31:22.940
importiert. Okay. Nice.

01:31:22.940 --> 01:31:30.990
Das gibt's überhaupt nicht.

01:31:30.990 --> 01:31:32.990
Output is not

01:31:32.990 --> 01:31:34.990
member.

01:31:34.990 --> 01:31:36.990
Implement members. Ja, ganz toll.

01:31:36.990 --> 01:31:38.990
Target. Heißt das jetzt

01:31:38.990 --> 01:31:40.990
Target? Wurde das umbenannt oder wie?

01:31:40.990 --> 01:31:46.740
Moment. Was macht

01:31:46.740 --> 01:31:48.740
deref eigentlich?

01:31:48.740 --> 01:31:54.030
Deref. Rust.

01:31:54.030 --> 01:31:56.030
Was zum...

01:31:56.030 --> 01:31:58.030
Alter. Ich will einfach nur

01:31:58.030 --> 01:32:00.030
ne Schleife da drüber machen

01:32:00.030 --> 01:32:06.100
können, man.

01:32:06.100 --> 01:32:08.100
Ist das so kompliziert in fucking Rust

01:32:08.100 --> 01:32:14.160
ne Schleife zu machen?

01:32:14.160 --> 01:32:16.160
Type targets.

01:32:16.160 --> 01:32:18.160
Target self.

01:32:18.160 --> 01:32:25.380
Okay. Okay.

01:32:25.380 --> 01:32:27.380
Type t.

01:32:27.380 --> 01:32:29.380
Type t. Okay.

01:32:29.380 --> 01:32:31.380
Type t. Sehr gut. Sehr gut. Exzellent.

01:32:31.380 --> 01:32:33.380
Deref.

01:32:33.380 --> 01:32:35.380
Self target.

01:32:37.380 --> 01:32:39.380
Aus welchen Gründen auch immer.

01:32:39.380 --> 01:32:41.380
Reference.

01:32:41.380 --> 01:32:44.880
Und jetzt self store.

01:32:44.880 --> 01:32:55.620
Was ich programmiere?

01:32:55.620 --> 01:32:57.620
Eine Schleife in Rust.

01:32:57.620 --> 01:32:59.620
Für nen eigenen Typ. Aber

01:32:59.620 --> 01:33:01.620
aus irgendwelchen Gründen mag

01:33:01.620 --> 01:33:03.620
Rust das nicht wirklich.

01:33:03.620 --> 01:33:05.620
Also.

01:33:07.620 --> 01:33:09.620
Und jetzt?

01:33:09.620 --> 01:33:11.620
Store unwrap.

01:33:11.620 --> 01:33:13.620
Self store get.

01:33:13.620 --> 01:33:15.620
Hä? Sekunde.

01:33:15.620 --> 01:33:17.620
Bin verwirrt.

01:33:17.620 --> 01:33:21.250
Self store read.

01:33:21.250 --> 01:33:23.250
Ach read. Read.

01:33:23.250 --> 01:33:31.100
Unwrap.

01:33:31.100 --> 01:33:38.000
Das wird so nicht funktionieren.

01:33:38.000 --> 01:33:40.000
Expected but found it.

01:33:40.000 --> 01:33:42.000
Mann.

01:33:42.000 --> 01:33:51.200
Wofür machst du das überhaupt?

01:33:51.200 --> 01:33:53.200
Lass die wrapper Funktion weg.

01:33:53.200 --> 01:33:55.200
Ich will ne Schleife machen da drüber.

01:33:55.200 --> 01:33:59.470
Mann. Und das geht ja nicht.

01:33:59.470 --> 01:34:01.470
Irgendwie hier

01:34:01.470 --> 01:34:03.470
muss der Kram ja da drankommen.

01:34:03.470 --> 01:34:07.300
Am liebsten

01:34:07.300 --> 01:34:09.300
hätte ich

01:34:09.300 --> 01:34:11.300
ne Funktion, die irgendwie all oder so

01:34:11.300 --> 01:34:17.040
heißt. Deref hat nix

01:34:17.040 --> 01:34:19.040
mit ner Schleife zu tun. Laut Stack Overflow

01:34:19.040 --> 01:34:21.040
schon. Hier will auch ein Typ ne Schleife

01:34:21.040 --> 01:34:23.040
machen. Und das

01:34:23.040 --> 01:34:25.040
legt vor, dass man das entweder so macht

01:34:25.040 --> 01:34:27.040
so macht oder so macht.

01:34:27.040 --> 01:34:29.040
Moment.

01:34:29.040 --> 01:34:31.040
Der Typ

01:34:31.040 --> 01:34:33.040
transferiert. Ne der Typ

01:34:33.040 --> 01:34:38.340
der Typ ähm. Warte

01:34:38.340 --> 01:34:42.290
mal. Was hatten wir da vor?

01:34:42.290 --> 01:34:48.030
Moment. Wie hatten wir das gerade

01:34:48.030 --> 01:34:53.840
nochmal hier unten?

01:34:53.840 --> 01:34:58.370
Iterator next. Ne.

01:34:58.370 --> 01:35:00.370
Hab ich doch. Das ist doch das allererste

01:35:00.370 --> 01:35:02.370
was ich gemacht hab hier unten. Das funktioniert

01:35:02.370 --> 01:35:04.370
nicht.

01:35:04.370 --> 01:35:08.000
Das funktioniert nicht.

01:35:08.000 --> 01:35:10.000
Das allererste was ich probiert hab. Das

01:35:10.000 --> 01:35:15.940
klappt nicht. Ich mein kann ich nicht

01:35:15.940 --> 01:35:17.940
kann ich nicht einfach sowas hier machen?

01:35:17.940 --> 01:35:23.940
Wir klauen

01:35:23.940 --> 01:35:28.210
das jetzt einfach von hier.

01:35:28.210 --> 01:35:30.210
Da sagt er bestimmt, dass es nicht matcht oder?

01:35:30.210 --> 01:35:33.900
Er ist ein incompatibel

01:35:33.900 --> 01:35:39.580
Typ. Was ist das da

01:35:39.580 --> 01:35:43.020
vorne überhaupt? Kann das mal weg?

01:35:43.020 --> 01:35:46.340
Er ist inkompatibel. Okay.

01:35:46.340 --> 01:35:48.340
Moment. T. Moment. Moment.

01:35:48.340 --> 01:35:50.340
Moment. Moment. Moment. Target T ergibt ja

01:35:50.340 --> 01:35:52.340
auch überhaupt keinen Sinn.

01:35:52.340 --> 01:35:54.340
Target ist

01:35:54.340 --> 01:35:56.340
was? Target? Ne Output.

01:35:56.340 --> 01:35:58.340
Was? Das stimmt doch nicht nochmal

01:35:58.340 --> 01:36:06.130
überhaupt hier. Target ist

01:36:06.130 --> 01:36:25.820
was? Target ist das

01:36:25.820 --> 01:36:29.200
was man zurück gibt oder?

01:36:29.200 --> 01:36:31.200
Also im Prinzip

01:36:31.200 --> 01:36:36.110
ein

01:36:36.110 --> 01:36:40.830
Was haben wir denn hier bei?

01:36:40.830 --> 01:36:52.340
Bei Keys? What the fuck man?

01:36:52.340 --> 01:36:54.340
Was beim ersten Ansatz

01:36:54.340 --> 01:36:56.340
mit der Hashmap. Du meinst das da unten?

01:36:56.340 --> 01:36:58.340
Was den

01:36:58.340 --> 01:37:00.340
Iterator muss ich klonen? Man kann den

01:37:00.340 --> 01:37:05.630
klonen? Okay. Nice.

01:37:05.630 --> 01:37:09.460
I? Ne.

01:37:09.460 --> 01:37:11.460
Ne. Ne. Ne.

01:37:15.460 --> 01:37:25.200
Nope.

01:37:25.200 --> 01:37:27.200
Du musst die Referenz zur Hashmap klonen.

01:37:27.200 --> 01:37:29.200
Die was bitte? Die Referenz?

01:37:29.200 --> 01:37:32.960
Was soll ich

01:37:32.960 --> 01:37:40.940
klonen?

01:37:40.940 --> 01:37:42.940
M.Clone

01:37:42.940 --> 01:37:44.940
Ja Moment. Dann klone ich die Hashmap.

01:37:44.940 --> 01:37:46.940
Das will ich doch nicht.

01:37:46.940 --> 01:37:48.940
Ich will doch nicht die Hash...

01:37:48.940 --> 01:37:50.940
Das ist doch das allererste was ich gemacht hab.

01:37:50.940 --> 01:37:52.940
Das ist doch das allererste was ich gemacht hab.

01:37:52.940 --> 01:37:54.940
Dass das geht ist klar aber dann

01:37:54.940 --> 01:37:56.940
erstellt er doch eine neue Hashmap.

01:37:56.940 --> 01:37:58.940
Das ist doch komplett für den Arsch.

01:37:58.940 --> 01:38:00.940
Der soll keine neue Hashmap erstellen.

01:38:00.940 --> 01:38:02.940
Das ist doch das allererste was ich gemacht hab.

01:38:02.940 --> 01:38:04.940
Das hat auch funktioniert.

01:38:04.940 --> 01:38:06.940
Aber das ist doch bescheuert.

01:38:06.940 --> 01:38:08.940
Ich will doch nicht eine komplett neue Hashmap

01:38:08.940 --> 01:38:10.940
anlegen wenn ich einfach nur die Elemente

01:38:10.940 --> 01:38:12.940
durchlaufen will von einer schon bestehenden Hashmap.

01:38:12.940 --> 01:38:14.940
Warum soll ich das machen?

01:38:14.940 --> 01:38:16.940
Das funktioniert.

01:38:16.940 --> 01:38:18.940
Das habe ich schon ausprobiert. Das funktioniert.

01:38:18.940 --> 01:38:22.510
Guck das geht.

01:38:22.510 --> 01:38:24.510
Das ist das allererste was ich gemacht hab.

01:38:24.510 --> 01:38:26.510
Ich will ne Schleife

01:38:26.510 --> 01:38:28.510
machen man.

01:38:28.510 --> 01:38:30.510
Ne Schleife. Eine stinknormale

01:38:30.510 --> 01:38:32.510
Schleife über nen Customtyp.

01:38:32.510 --> 01:38:34.510
Und ich hab keine Ahnung wie man das in Rust

01:38:34.510 --> 01:38:42.370
gescheit macht. Also das ist schon mal

01:38:42.370 --> 01:38:47.920
nix. Ja genau.

01:38:47.920 --> 01:38:49.920
Ich will ne Schleife machen. Guck ich will

01:38:49.920 --> 01:38:51.920
vor...

01:38:51.920 --> 01:38:53.920
Keine Ahnung. Vor Blub in...

01:38:53.920 --> 01:38:55.920
Alter.

01:38:55.920 --> 01:38:57.920
Das will ich machen können. Okay?

01:38:57.920 --> 01:38:59.920
So und das geht nicht.

01:38:59.920 --> 01:39:01.920
Weil it's not a iterator.

01:39:01.920 --> 01:39:03.920
Okay alles klar.

01:39:03.920 --> 01:39:05.920
Iterator implementieren.

01:39:05.920 --> 01:39:07.920
Habe ich absolut keine Ahnung gehabt.

01:39:07.920 --> 01:39:13.220
Was der von mir will.

01:39:13.220 --> 01:39:15.220
Und was sie hier auch immer mit deref

01:39:15.220 --> 01:39:17.220
wollen. Ich habe auch keine Ahnung.

01:39:17.220 --> 01:39:19.220
Okay wir machen jetzt einfach mal.

01:39:19.220 --> 01:39:21.220
Wir suchen jetzt. Rust deref

01:39:21.220 --> 01:39:23.220
Vector

01:39:23.220 --> 01:39:25.220
wrapped

01:39:25.220 --> 01:39:27.220
Was hast du lieber?

01:39:27.220 --> 01:39:29.220
C++ oder Rust?

01:39:29.220 --> 01:39:31.220
Auf keinen Fall C++.

01:39:31.220 --> 01:39:33.220
Aber Rust in dem Fall jetzt gerade auch nicht.

01:39:33.220 --> 01:39:35.220
How to create a new

01:39:35.220 --> 01:39:37.220
instance of wrapped vector in Rust.

01:39:37.220 --> 01:39:43.600
Oh was ist das?

01:39:43.600 --> 01:39:53.120
5 hat time.

01:39:53.120 --> 01:39:55.120
After the creation of such an object you can use

01:39:55.120 --> 01:39:57.120
the object somewhat transparently by

01:39:57.120 --> 01:39:59.120
implementing deref.

01:39:59.120 --> 01:40:01.120
Moment hier ist target.

01:40:01.120 --> 01:40:03.120
Wait a minute.

01:40:03.120 --> 01:40:05.120
Hier ist target

01:40:05.120 --> 01:40:07.120
nicht T.

01:40:07.120 --> 01:40:17.950
Sondern. Moment.

01:40:17.950 --> 01:40:19.950
Return self store.

01:40:19.950 --> 01:40:21.950
Ne und.

01:40:21.950 --> 01:40:26.100
Und self store.

01:40:26.100 --> 01:40:30.300
Moin Kirolo.

01:40:30.300 --> 01:40:33.620
Was für ein Typ ist das jetzt?

01:40:33.620 --> 01:40:35.620
Kann er nicht mal den Typ davon ordentlich ableiten?

01:40:35.620 --> 01:40:37.620
Oder was?

01:40:37.620 --> 01:40:39.620
Das ist ein hier.

01:40:39.620 --> 01:40:41.620
RwLogHashMap irgendwas.

01:40:41.620 --> 01:40:43.620
Aber und. Und okay.

01:40:43.620 --> 01:40:48.980
Jaja.

01:40:48.980 --> 01:40:50.980
So.

01:40:50.980 --> 01:40:54.740
Shit. Fast. Fast.

01:40:54.740 --> 01:40:59.580
Äh.

01:40:59.580 --> 01:41:05.460
RwLogHashMap.

01:41:05.460 --> 01:41:09.730
Ah ne.

01:41:09.730 --> 01:41:11.730
Und self.

01:41:11.730 --> 01:41:16.700
Kann ich nicht einfach so das

01:41:16.700 --> 01:41:18.700
ganze Ding returnen?

01:41:18.700 --> 01:41:22.850
Ne das geht nicht.

01:41:22.850 --> 01:41:24.850
Über den internen.

01:41:24.850 --> 01:41:26.850
Über meine interne HashMap.

01:41:26.850 --> 01:41:28.850
Ich hab eine interne HashMap

01:41:28.850 --> 01:41:30.850
gerappt quasi in einem eigenen

01:41:30.850 --> 01:41:32.850
Struct und ich will über meinen Struct iteraten.

01:41:32.850 --> 01:41:34.850
So. Angeblich stimmt das so.

01:41:34.850 --> 01:41:36.850
Ne natürlich.

01:41:36.850 --> 01:41:56.350
Was?

01:41:56.350 --> 01:41:58.350
Ey super.

01:41:58.350 --> 01:42:00.350
Jetzt kompiliert er so eine Fehler aber.

01:42:00.350 --> 01:42:02.350
Gehen. Gehen tut es trotzdem

01:42:02.350 --> 01:42:23.970
nicht.

01:42:23.970 --> 01:42:33.810
Und die Funktion gibt es hier nicht.

01:42:33.810 --> 01:42:35.810
Okay und was war jetzt der Sinn davon?

01:42:35.810 --> 01:42:37.810
Gibt es wenigstens D-Ref? Ah D-Ref gibt es okay.

01:42:37.810 --> 01:42:49.440
Wait a minute.

01:42:49.440 --> 01:42:56.530
Was? Ich weiß nicht ob ich D-Ref brauche.

01:42:56.530 --> 01:42:58.530
Das hat irgendjemand aus Sega overflow

01:42:58.530 --> 01:43:20.210
vorgeschlagen.

01:43:20.210 --> 01:43:24.420
Und jetzt? Ey Leute ich hab keine Ahnung

01:43:24.420 --> 01:43:26.420
was das für ein Scheiß.

01:43:26.420 --> 01:43:32.480
Übrigens Rotzsprache alter.

01:43:32.480 --> 01:43:34.480
Was? Read?

01:43:34.480 --> 01:43:36.480
Und was will

01:43:36.480 --> 01:43:38.480
er hier von mir? Read?

01:43:38.480 --> 01:43:40.480
Log Result?

01:43:40.480 --> 01:43:42.480
Achso.

01:43:42.480 --> 01:43:44.480
Moment.

01:43:44.480 --> 01:43:48.180
Moment. Weil ich.

01:43:48.180 --> 01:43:52.000
Wait a minute.

01:43:52.000 --> 01:43:54.000
Weil ich ja das

01:43:54.000 --> 01:43:57.630
returne mit dem Log.

01:43:57.630 --> 01:43:59.630
Sag bloß wenn das ja. Wait a minute.

01:43:59.630 --> 01:44:01.630
Ich wollte mir jetzt erzählen. Das funktioniert oder was?

01:44:01.630 --> 01:44:03.630
Haha.

01:44:03.630 --> 01:44:05.630
What the fuck?

01:44:05.630 --> 01:44:17.330
Ich hab. Alter.

01:44:17.330 --> 01:44:19.330
Was bin ich sehend

01:44:19.330 --> 01:44:21.330
überhaupt man?

01:44:21.330 --> 01:44:24.770
Das geht auf jeden Fall besser.

01:44:24.770 --> 01:44:26.770
Ich hab keine Ahnung was das überhaupt.

01:44:26.770 --> 01:44:28.770
Was mir das überhaupt sagen soll.

01:44:28.770 --> 01:44:33.940
What the fuck?

01:44:33.940 --> 01:44:35.940
What?

01:44:35.940 --> 01:44:47.060
Was ist der Hashmap iter?

01:44:47.060 --> 01:44:49.060
Naja, ein Iterator über die Typ in der Hashmap.

01:44:49.060 --> 01:44:53.970
Also der Typ ist das hier.

01:44:53.970 --> 01:44:55.970
Guck das da.

01:44:55.970 --> 01:44:59.860
Ich hab keine Ahnung was ich hier gemacht

01:44:59.860 --> 01:45:01.860
habe, warum es kompiliert und was ich

01:45:01.860 --> 01:45:03.860
jetzt. Was das überhaupt tut unter der Haube.

01:45:03.860 --> 01:45:09.730
Okay.

01:45:09.730 --> 01:45:11.730
What the fuck?

01:45:11.730 --> 01:45:17.090
Ich versteh es auch nicht.

01:45:17.090 --> 01:45:19.090
Macht dir nichts draus.

01:45:19.090 --> 01:45:21.090
Was musst du? Okay. Chatgear

01:45:21.090 --> 01:45:23.090
ist pfeifert. Ich glaube im Next von dem

01:45:23.090 --> 01:45:25.090
Iterator implementierst du nur

01:45:25.090 --> 01:45:27.090
arg s ref.

01:45:27.090 --> 01:45:29.090
Okay. Done. Wenn ich das nur

01:45:29.090 --> 01:45:31.090
nur das machen muss. Easy.

01:45:31.090 --> 01:45:34.850
Es holt

01:45:34.850 --> 01:45:36.850
den rwLog, umwrapped den readAxis

01:45:36.850 --> 01:45:38.850
iteriert. Ja, ja, ja.

01:45:38.850 --> 01:45:40.850
Im Prinzip habe ich damit die Hash

01:45:40.850 --> 01:45:42.850
Im Prinzip könnte ich auch

01:45:42.850 --> 01:45:44.850
so

01:45:44.850 --> 01:45:46.850
Das ist nichts anderes wie

01:45:46.850 --> 01:45:48.850
direkt auf die

01:45:48.850 --> 01:45:50.850
Struct Variable zugreifen im Endeffekt.

01:45:50.850 --> 01:45:52.850
Also eigentlich komplett unsinnig.

01:45:52.850 --> 01:45:59.870
Okay.

01:45:59.870 --> 01:46:01.870
Implement Iterator for Registry.

01:46:01.870 --> 01:46:07.740
So, was muss ich?

01:46:07.740 --> 01:46:09.740
Arg s ref.

01:46:09.740 --> 01:46:11.740
Was? Wo?

01:46:11.740 --> 01:46:13.740
Wie? Wo muss ich

01:46:13.740 --> 01:46:17.630
hier was machen?

01:46:17.630 --> 01:46:19.630
Arg s ref. HashMap fällt

01:46:19.630 --> 01:46:21.630
vom Struct. Okay. Arg s.

01:46:21.630 --> 01:46:23.630
Alles klar. Easy. Easy.

01:46:23.630 --> 01:46:25.630
Arg s ref

01:46:25.630 --> 01:46:27.630
self

01:46:27.630 --> 01:46:29.630
store

01:46:29.630 --> 01:46:34.930
ähm

01:46:34.930 --> 01:46:36.930
read

01:46:36.930 --> 01:46:41.460
unwrap

01:46:41.460 --> 01:46:43.460
Mäh.

01:46:43.460 --> 01:46:45.460
Das funktioniert

01:46:45.460 --> 01:46:47.460
nicht. Chat, ich bin froh, dass ihr auch

01:46:47.460 --> 01:46:49.460
nicht schlauer seid wie ich, was das angeht.

01:46:49.460 --> 01:46:51.460
Also hier weiß ich auch noch nicht mal,

01:46:51.460 --> 01:46:53.460
was die Referenz überhaupt ist.

01:46:53.460 --> 01:46:55.460
Es ist

01:46:55.460 --> 01:46:57.460
b auf unknown.

01:46:57.460 --> 01:46:59.460
Alles klar, ja.

01:46:59.460 --> 01:47:03.150
Ich meine, es kann doch

01:47:03.150 --> 01:47:05.150
nicht so schwer sein.

01:47:05.150 --> 01:47:12.750
Das hier ist die HashMap

01:47:12.750 --> 01:47:14.750
doch.

01:47:14.750 --> 01:47:16.750
Ah ne, das ist das VamaletMap.

01:47:16.750 --> 01:47:18.750
Gleich.

01:47:18.750 --> 01:47:20.750
Ah ne, das ist die rwLogGuard.

01:47:20.750 --> 01:47:22.750
Ähm.

01:47:22.750 --> 01:47:24.750
Das da ist die HashMap.

01:47:24.750 --> 01:47:26.750
Zumindest eine Referenz

01:47:26.750 --> 01:47:30.510
auf die HashMap.

01:47:30.510 --> 01:47:32.510
Aber das checkt er trotzdem nicht.

01:47:32.510 --> 01:47:34.510
Mismatch.

01:47:34.510 --> 01:47:36.510
ExpectedArg.

01:47:36.510 --> 01:47:39.820
Was? Was? Was?

01:47:39.820 --> 01:47:41.820
Was expected er?

01:47:41.820 --> 01:47:43.820
Expected und? Ne, ne, ne.

01:47:43.820 --> 01:47:47.650
Okay, so funktioniert das schon mal nicht.

01:47:47.650 --> 01:47:49.650
Chat, ne, ne, ne.

01:47:49.650 --> 01:47:51.650
So klappt das nicht.

01:47:51.650 --> 01:47:53.650
Ich hab

01:47:53.650 --> 01:47:55.650
wirklich keine Ahnung, wie es funktioniert.

01:47:55.650 --> 01:47:57.650
Echt nicht. Kein Schimmer.

01:47:57.650 --> 01:48:03.330
Okay, wir suchen nochmal

01:48:03.330 --> 01:48:05.330
stackr. Rust iterator.

01:48:05.330 --> 01:48:07.330
Implement

01:48:07.330 --> 01:48:09.330
iterator Rust.

01:48:09.330 --> 01:48:11.330
Iterators.

01:48:11.330 --> 01:48:13.330
Rust by example.

01:48:13.330 --> 01:48:15.330
Ja, das, Moment. Das Exampel habe ich ja schon

01:48:15.330 --> 01:48:17.330
wrapped

01:48:17.330 --> 01:48:24.930
HashMap. So.

01:48:24.930 --> 01:48:26.930
Okay, genau das. Hier.

01:48:26.930 --> 01:48:28.930
Der hat eine HashMap in einem struct.

01:48:28.930 --> 01:48:30.930
Und jetzt will er für sein

01:48:30.930 --> 01:48:37.950
struct.

01:48:37.950 --> 01:48:39.950
Jetzt will er für sein struct

01:48:39.950 --> 01:48:49.380
äh, response.

01:48:49.380 --> 01:48:51.380
Ah, response headers.

01:48:51.380 --> 01:48:54.940
Will er das? Okay.

01:48:54.940 --> 01:48:56.940
Genau das. Im Prinzip genau

01:48:56.940 --> 01:48:58.940
das, was

01:48:58.940 --> 01:49:00.940
was ich auch machen will.

01:49:00.940 --> 01:49:02.940
You are doing

01:49:02.940 --> 01:49:04.940
right. Was?

01:49:04.940 --> 01:49:06.940
What you are doing right now is delegating to

01:49:06.940 --> 01:49:08.940
the into iterator implement.

01:49:08.940 --> 01:49:10.940
But you need to delegate to the

01:49:10.940 --> 01:49:12.940
into iterator implementation

01:49:12.940 --> 01:49:14.940
of on HashMap

01:49:14.940 --> 01:49:16.940
string. Because

01:49:16.940 --> 01:49:18.940
you can't get

01:49:18.940 --> 01:49:20.940
an own version. Ja, ja, ja.

01:49:20.940 --> 01:49:22.940
This is easy to fix.

01:49:22.940 --> 01:49:24.940
Thankfully. Leute.

01:49:24.940 --> 01:49:26.940
Easy.

01:49:26.940 --> 01:49:32.620
Es ist easy to fix.

01:49:32.620 --> 01:49:34.620
Alles klar.

01:49:34.620 --> 01:49:40.820
Easy to fix.

01:49:40.820 --> 01:49:42.820
Dann machen wir das doch mal. Easy to fix.

01:49:42.820 --> 01:49:44.820
Let's go. Easy.

01:49:44.820 --> 01:49:46.820
And for

01:49:46.820 --> 01:49:48.820
ähm

01:49:48.820 --> 01:49:50.820
Wait a minute.

01:49:50.820 --> 01:49:52.820
For registry

01:49:52.820 --> 01:49:58.460
of T.

01:49:58.460 --> 01:50:00.460
Okay.

01:50:00.460 --> 01:50:02.460
Was ist das eigentlich

01:50:02.460 --> 01:50:06.100
für hässliche Sachen wieder?

01:50:06.100 --> 01:50:08.100
Irgendwelche Lifetime Sachen. Okay.

01:50:08.100 --> 01:50:10.100
ItemType.

01:50:10.100 --> 01:50:16.800
Ach, hier oben.

01:50:16.800 --> 01:50:18.800
HeaderMap.

01:50:18.800 --> 01:50:20.800
ItemType ist

01:50:20.800 --> 01:50:22.800
Hash. Okay. Ich kopiere das mal.

01:50:22.800 --> 01:50:24.800
U32 of T.

01:50:24.800 --> 01:50:26.800
Ja, gut. Das ähm.

01:50:26.800 --> 01:50:32.930
Das funktioniert so nicht.

01:50:32.930 --> 01:50:34.930
Not member of. Okay.

01:50:34.930 --> 01:50:36.930
Kann man das vielleicht

01:50:36.930 --> 01:50:38.930
hier irgendwie reinpappen? Nein.

01:50:38.930 --> 01:50:40.930
Kann man das irgendwie

01:50:40.930 --> 01:50:42.930
äh hier reinpappen?

01:50:42.930 --> 01:50:44.930
Nein.

01:50:44.930 --> 01:50:46.930
Okay. Es ist ja auch wurscht.

01:50:46.930 --> 01:50:48.930
Wir können das copy-pasten.

01:50:48.930 --> 01:50:54.860
Was ich da mache, das frage ich mich auch.

01:50:54.860 --> 01:50:56.860
HeaderMap.

01:50:56.860 --> 01:50:58.860
Okay. Okay. Das ist okay. Alles klar.

01:50:58.860 --> 01:51:00.860
Okay.

01:51:00.860 --> 01:51:02.860
Ja. Nice. Nice. Nice.

01:51:02.860 --> 01:51:04.860
Okay. Ja.

01:51:04.860 --> 01:51:06.860
Und self.

01:51:06.860 --> 01:51:08.860
Okay.

01:51:08.860 --> 01:51:10.860
Self. Store.

01:51:10.860 --> 01:51:12.860
Read.

01:51:12.860 --> 01:51:17.260
Unwrap.

01:51:17.260 --> 01:51:23.900
Ey, das wäre jetzt zu einfach, wenn es funktioniert.

01:51:23.900 --> 01:51:25.900
Ist das hier überhaupt die Map?

01:51:25.900 --> 01:51:27.900
Map gleich.

01:51:27.900 --> 01:51:29.900
Ey, wir brauchen

01:51:29.900 --> 01:51:40.380
wieder hier.

01:51:40.380 --> 01:51:42.380
Und jetzt. Moment. Jetzt brauche ich doch eigentlich.

01:51:42.380 --> 01:51:48.380
Das wäre jetzt viel zu einfach, wenn

01:51:48.380 --> 01:51:50.380
das funktioniert.

01:51:50.380 --> 01:51:52.380
ItemMismatch.

01:51:52.380 --> 01:51:56.660
Ne, ne.

01:51:56.660 --> 01:51:58.660
Der Store ist nicht die HashMap.

01:51:58.660 --> 01:52:02.290
Der Store ist ein RwLog.

01:52:02.290 --> 01:52:04.290
Was?

01:52:06.290 --> 01:52:08.290
Ah.

01:52:08.290 --> 01:52:10.290
Siehste?

01:52:10.290 --> 01:52:12.290
Hab's ja auch verkehrt gemacht.

01:52:12.290 --> 01:52:28.660
Äh.

01:52:28.660 --> 01:52:30.660
Aber. Aber.

01:52:30.660 --> 01:52:45.490
Warum geht das jetzt nicht?

01:52:45.490 --> 01:52:55.780
Wieder genau der gleiche

01:52:55.780 --> 01:52:59.410
Scheiß wie vorher, Mann.

01:52:59.410 --> 01:53:04.510
Was will er hier jetzt?

01:53:04.510 --> 01:53:06.510
TemporaryValueCreated

01:53:06.510 --> 01:53:12.320
Ja und?

01:53:12.320 --> 01:53:36.560
Was will er?

01:53:36.560 --> 01:53:38.560
Das kann doch nicht so schwer sein.

01:53:40.560 --> 01:53:42.560
Meine Fresse, Alter.

01:53:42.560 --> 01:53:44.560
Ich will eine Schleife machen.

01:53:44.560 --> 01:53:50.430
Ich meine.

01:53:50.430 --> 01:53:52.430
Ich bin ja froh, dass das easy to fix ist.

01:53:52.430 --> 01:54:00.160
Glücklicherweise

01:54:00.160 --> 01:54:40.340
ist es easy to fix.

01:54:40.340 --> 01:54:42.340
Ich weiß nicht, was das von mir

01:54:42.340 --> 01:54:55.760
will, Mann.

01:54:55.760 --> 01:55:00.610
Es ist ja noch nicht mal AsyncRust.

01:55:00.610 --> 01:55:05.840
Und?

01:55:05.840 --> 01:55:07.840
Echt. Ich hab. Ich hab. Seriously.

01:55:07.840 --> 01:55:11.220
Ich hab keinen blassen Schimmer.

01:55:11.220 --> 01:55:13.220
SetCursorOfHashMap.

01:55:13.220 --> 01:55:17.940
I'm trying a simple thread.

01:55:17.940 --> 01:55:19.940
SaveMemoryKeyValue.

01:55:19.940 --> 01:55:21.940
My code looks like this.

01:55:21.940 --> 01:55:28.450
Jeder macht.

01:55:28.450 --> 01:55:30.450
Obviously. Simple. Implement.

01:55:30.450 --> 01:55:35.100
Cursor.

01:55:35.100 --> 01:55:37.100
Okay. Ist vielleicht.

01:55:37.100 --> 01:55:46.690
Ich will die Werte nicht klonen, Mann.

01:55:46.690 --> 01:55:48.690
Ich check die Antwort noch nicht mal.

01:55:48.690 --> 01:55:52.580
Die Antwort ist mir

01:55:52.580 --> 01:55:54.580
schon zu sick.

01:55:54.580 --> 01:55:56.580
Okay.

01:55:56.580 --> 01:56:00.590
Okay.

01:56:00.590 --> 01:56:02.590
Okay.

01:56:02.590 --> 01:56:04.590
Okay.

01:56:04.590 --> 01:56:06.590
Okay.

01:56:06.590 --> 01:56:18.610
Okay.

01:56:18.610 --> 01:56:42.530
Okay.

01:56:42.530 --> 01:56:44.530
Okay.

01:56:44.530 --> 01:56:56.930
Okay.

01:56:56.930 --> 01:57:02.290
Okay.

01:57:02.290 --> 01:57:04.290
Okay.

01:57:04.290 --> 01:57:09.900
Okay.

01:57:09.900 --> 01:57:15.010
Okay.

01:57:15.010 --> 01:57:17.010
Okay.

01:57:17.010 --> 01:57:19.010
Okay.

01:57:19.010 --> 01:57:21.010
Okay.

01:57:21.010 --> 01:57:23.010
Okay.

01:57:23.010 --> 01:57:25.010
Okay.

01:57:25.010 --> 01:57:37.540
Okay.

01:57:37.540 --> 01:57:39.540
Okay.

01:57:39.540 --> 01:57:41.540
Okay.

01:57:41.540 --> 01:57:45.420
Okay.

01:57:45.420 --> 01:57:49.500
Okay.

01:57:49.500 --> 01:57:51.500
Okay.

01:57:51.500 --> 01:57:53.500
Okay.

01:57:53.500 --> 01:57:55.500
Okay.

01:57:55.500 --> 01:57:57.500
Okay.

01:57:57.500 --> 01:57:59.500
Okay.

01:57:59.500 --> 01:58:04.220
Okay.

01:58:04.220 --> 01:58:06.220
Okay.

01:58:06.220 --> 01:58:08.220
Okay.

01:58:08.220 --> 01:58:10.220
Okay.

01:58:10.220 --> 01:58:12.220
Okay.

01:58:12.220 --> 01:58:30.700
Okay.

01:58:30.700 --> 01:58:32.700
Okay.

01:58:32.700 --> 01:58:34.700
Okay.

01:58:34.700 --> 01:58:36.700
Okay.

01:58:36.700 --> 01:58:38.700
Okay.

01:58:38.700 --> 01:58:40.700
Okay.

01:58:40.700 --> 01:58:42.700
Okay.

01:58:42.700 --> 01:58:44.700
I'm trying a simple thread.

01:58:44.700 --> 01:58:46.700
Eventually.

01:58:46.700 --> 01:58:48.700
Es gibt übrigens viele Autos.

01:58:48.700 --> 01:58:56.700
Welcher Datentyp wäre deiner Meinung nach besser geeignet an der Stelle als RWLOG von den vielen Threadsafe-Datentypen?

01:58:56.700 --> 01:59:02.450
So, jetzt können wir hier sagen...

01:59:02.450 --> 01:59:06.450
Jetzt funzt es. Ja, das ist klar, aber jetzt kopiert er das auch.

01:59:06.450 --> 01:59:09.450
Das fuckt mich ultra ab, man.

01:59:09.450 --> 01:59:12.450
Ich will wissen, wie das funktioniert.

01:59:12.450 --> 01:59:24.930
Wir machen jetzt aber damit nicht weiter, sonst dreh ich echt am Rad.

01:59:25.930 --> 01:59:27.930
Okay, Moment mal.

01:59:27.930 --> 01:59:31.930
Chat, Chat, das ist genau das, was ich machen will.

01:59:31.930 --> 01:59:33.930
A, B, D...

01:59:33.930 --> 01:59:37.560
What?

01:59:37.560 --> 01:59:39.560
What the f...

01:59:39.560 --> 01:59:42.560
Ich verstehe noch nicht mal, was er fragte.

01:59:42.560 --> 01:59:50.560
You can't solve this with naming your lifetimes, as this isn't really a lifetime problem, but a problem with ownership.

01:59:50.560 --> 01:59:59.580
You can provide access to the HashMap and make the call values.

01:59:59.580 --> 02:00:08.380
Ja, sowas in der Richtung habe ich ja auch schon gebaut.

02:00:08.380 --> 02:00:16.980
Ich meine, das soll mir auch recht sein.

02:00:16.980 --> 02:00:21.290
Trivial, trivial.

02:00:21.290 --> 02:00:25.290
Because God-like FN-Trades don't exist.

02:00:26.290 --> 02:00:30.290
Jetzt weiß ich, Leute, jetzt weiß ich, warum es nicht funktioniert, man.

02:00:30.290 --> 02:00:33.290
Because God-like FN-Trades don't exist.

02:00:33.290 --> 02:00:36.290
Hätte es mal gleich einer gesagt, Mensch.

02:00:36.290 --> 02:00:40.290
Ich hoffe, euch ist jetzt auch alles klar.

02:00:40.290 --> 02:00:43.290
Jetzt, obviously, jetzt ist alles logisch.

02:00:43.290 --> 02:00:49.350
Ja, easy.

02:00:49.350 --> 02:00:51.350
So, ich war mal...

02:01:05.960 --> 02:01:08.960
Es leuchtet ein, ne? Es leuchtet komplett ein.

02:01:08.960 --> 02:01:18.050
Achso, Moment. Item ist die HashMap.

02:01:27.770 --> 02:01:32.940
Alter.

02:01:52.990 --> 02:01:58.560
Guck mal, hier, Rust weiß noch nicht, was will ich? Map, Map.

02:01:58.560 --> 02:02:01.560
It's not an iterator. Ja, ach, okay. Nice.

02:02:01.560 --> 02:02:05.560
Sehr gut, sehr gut. Excellent. Jetzt weiß ich Bescheid, ja, man.

02:02:05.560 --> 02:02:21.840
Cannot find. Moment, das gibt es überhaupt nicht?

02:02:21.840 --> 02:02:24.840
Das gibt es einfach überhaupt nicht, was die hier vorschlagen.

02:02:24.840 --> 02:02:30.500
Alter, was ist das für ein pp-iger Post, man?

02:02:30.500 --> 02:02:33.500
LW-LogGuard gibt es über... Ach, Moment, das ist von ParkingLot.

02:02:33.500 --> 02:02:36.500
Was auch immer ParkingLot ist.

02:02:36.500 --> 02:02:39.500
Das ist die ParkingLot-LW-Guard, Mensch.

02:02:39.500 --> 02:02:48.950
Ja, dann ist klar.

02:02:48.950 --> 02:02:50.950
Ich glaube, ich weiß, wo...

02:02:50.950 --> 02:02:59.960
Alles klar, scheiß drauf.

02:02:59.960 --> 02:03:01.960
Jetzt nicht, jetzt nicht, Leute.

02:03:01.960 --> 02:03:04.960
Jetzt nicht. Wir lassen es jetzt.

02:03:04.960 --> 02:03:16.530
Da drehe ich ab bei...

02:03:16.530 --> 02:03:21.670
Also, ich bin erstaunt,

02:03:21.670 --> 02:03:24.670
dass das so krass kompliziert ist.

02:03:24.670 --> 02:03:38.520
Okay, Rust Playground.

02:03:38.520 --> 02:03:51.280
Ich mache jetzt nicht weiter.

02:03:51.280 --> 02:03:54.280
Reicht dir das? Ja, Moment, Moment. Mal gucken.

02:03:54.280 --> 02:03:57.280
Moment. Excellent, excellent. ChatGym macht mit.

02:03:57.280 --> 02:04:06.900
Ich bin froh. Chat ist schlau.

02:04:06.900 --> 02:04:11.470
Wo ist der Unterschied zu mir? Ah, hier.

02:04:11.470 --> 02:04:14.470
Okay, was macht das jetzt?

02:04:14.470 --> 02:04:17.470
Anders als meins?

02:04:17.470 --> 02:04:20.470
Zwei, okay.

02:04:20.470 --> 02:04:26.830
Store. Unwrap.

02:04:26.830 --> 02:04:29.830
Okay, wirklich schön ist...

02:04:29.830 --> 02:04:32.830
Da muss ich zumindest nicht klonen.

02:04:32.830 --> 02:04:35.830
Das finde ich eigentlich ganz gut.

02:04:35.830 --> 02:04:38.830
Da muss ich zumindest nicht klonen.

02:04:38.830 --> 02:04:43.210
Und es funktioniert, oder?

02:04:43.210 --> 02:04:48.160
Das ist gut. Das reicht mir.

02:04:48.160 --> 02:04:56.060
Also, ich würde sagen, das reicht mir.

02:04:56.060 --> 02:05:03.700
Das ist im Prinzip einfach noch mal gerappt.

02:05:03.700 --> 02:05:06.700
Das ist die bisschen schönere Variante

02:05:06.700 --> 02:05:09.700
wie von meinem geklonten.

02:05:09.700 --> 02:05:12.700
Wofür ist denn hier vorne das Ding?

02:05:12.700 --> 02:05:17.200
Kann man das wegmachen?

02:05:17.200 --> 02:05:20.200
Anscheinend, okay. Ich weiß nicht, wofür das da ist.

02:05:20.200 --> 02:05:25.920
Wofür ist das Ding? Eine Lifetime.

02:05:25.920 --> 02:05:32.950
Aber Lifetime für was?

02:05:32.950 --> 02:05:35.950
Lifetime, die ich sonst nirgendswo benutze, oder?

02:05:35.950 --> 02:05:38.950
Lassen wir einfach mal weg.

02:05:38.950 --> 02:05:45.730
Ja, das finde ich gut.

02:05:45.730 --> 02:05:48.730
Alter, was ein Akt, Mann.

02:05:48.730 --> 02:05:51.730
MonkaS.

02:05:51.730 --> 02:05:59.240
MonkaS, Mann.

02:05:59.240 --> 02:06:02.240
Okay, können wir jetzt eigentlich... Moment, Moment.

02:06:02.240 --> 02:06:05.240
Ja, wir machen weiter, aber jetzt kommt ja noch was anderes,

02:06:05.240 --> 02:06:18.260
was das Ding können soll.

02:06:18.260 --> 02:06:24.230
Und zwar, es soll ja noch IDs berechnen können.

02:06:24.230 --> 02:06:27.230
Wie könnten wir das mit der ID-Berechnung machen, Chat?

02:06:27.230 --> 02:06:33.340
Habt ihr irgendeine klare Idee?

02:06:33.340 --> 02:06:36.340
Also, wir könnten einfach random was generieren.

02:06:36.340 --> 02:06:39.340
Das wäre eigentlich schön.

02:06:39.340 --> 02:06:42.340
Ich meine, die Chance, dass was doppelt generiert wird,

02:06:42.340 --> 02:06:45.340
bei meiner kleinen Anzahl.

02:06:45.340 --> 02:06:48.340
UID ist raus, weil ich UID nur etwas komplizierter

02:06:48.340 --> 02:06:51.340
hin- und herschieben kann über ein C-Interface.

02:06:51.340 --> 02:06:54.340
Aber wir könnten...

02:06:54.340 --> 02:06:59.930
Ich habe eine Idee, Leute.

02:06:59.930 --> 02:07:02.930
Ich habe eine Idee, was wir machen können.

02:07:02.930 --> 02:07:07.500
Was ist mit random oder einem Hash?

02:07:07.500 --> 02:07:10.500
Ich hätte gerne lieber irgendeinen simplen Counter.

02:07:10.500 --> 02:07:15.190
Okay, ich habe nämlich eine Idee,

02:07:15.190 --> 02:07:18.190
wie wir das ganz einfach machen können.

02:07:18.190 --> 02:07:21.190
Ich meine, unsere Keys sind U32.

02:07:21.190 --> 02:07:24.190
Also, wir haben 4 Trillionen, was auch immer, Milliarden, sonst was.

02:07:24.190 --> 02:07:27.190
Möglicher...

02:07:27.190 --> 02:07:30.190
Ich weiß nicht, was U32 Max ist. Irgendwas mit einer 4 vorne.

02:07:30.190 --> 02:07:33.190
Ah, das läuft.

02:07:33.190 --> 02:07:36.190
Mögliche, mögliche IDs.

02:07:36.190 --> 02:07:39.190
Wir machen mal so eine Funktion.

02:07:39.190 --> 02:07:46.450
Wobei, brauchen wir nicht mal für.

02:07:46.450 --> 02:07:49.450
Also, den Store.

02:07:49.450 --> 02:07:52.450
Er ist hier.

02:07:52.450 --> 02:07:55.450
Also, die ID.

02:07:55.450 --> 02:08:00.340
Wir generieren die ID folgendermaßen.

02:08:00.340 --> 02:08:05.540
Und zwar, wir checken einfach...

02:08:05.540 --> 02:08:08.540
Ich habe eine Idee.

02:08:08.540 --> 02:08:11.540
Ich muss mir nur kurz Gedanken drüber machen.

02:08:11.540 --> 02:08:14.540
Wir machen eine Schleife.

02:08:14.540 --> 02:08:17.540
Und wir lassen eine Schleife laufen.

02:08:17.540 --> 02:08:20.540
Von 0 bis U32 Max.

02:08:20.540 --> 02:08:23.540
Und die erste freie ID,

02:08:23.540 --> 02:08:32.660
die noch nicht vergeben ist, nehmen wir.

02:08:32.660 --> 02:08:35.660
Das müsste doch eigentlich gut funktionieren.

02:08:35.660 --> 02:08:38.660
Nee? Warum nicht?

02:08:38.660 --> 02:08:44.820
Warum ist das kacke?

02:08:44.820 --> 02:08:49.580
Dann kannst du auch random nehmen.

02:08:49.580 --> 02:08:52.580
Das bedeutet immer, dass ich eine Unique ID finde.

02:08:52.580 --> 02:08:55.580
Bei random habe ich im Zweifelsfall...

02:08:55.580 --> 02:08:58.580
Bei einem 32-Bit-Random habe ich im Zweifelsfall doppelte Werte.

02:08:58.580 --> 02:09:08.020
Die Chancen sind gering.

02:09:08.020 --> 02:09:11.020
Aber sie sind da.

02:09:11.020 --> 02:09:18.660
Und mit einem Counter nicht.

02:09:18.660 --> 02:09:21.660
Also, bei einem 32-Bit...

02:09:21.660 --> 02:09:24.660
Das ist nicht impossible.

02:09:24.660 --> 02:09:27.660
Bei einem 32-Bit-Int...

02:09:27.660 --> 02:09:30.660
Hast du... Moment.

02:09:30.660 --> 02:09:38.550
U32 Max.

02:09:38.550 --> 02:09:41.550
Was ist denn das?

02:09:41.550 --> 02:09:44.550
Das ist gar nicht mal so viel.

02:09:44.550 --> 02:09:47.550
Das sind nur 4 Milliarden.

02:09:47.550 --> 02:09:50.550
Wir haben nur 4 Milliarden...

02:09:50.550 --> 02:09:53.550
mögliche...

02:09:53.550 --> 02:09:56.550
IDs.

02:09:56.550 --> 02:09:59.550
4 Milliarden bei 5 gleichzeitigen Connections...

02:09:59.550 --> 02:10:02.550
ist die Chance auch sehr gering.

02:10:02.550 --> 02:10:05.550
Aber nur mal von der Idee her...

02:10:05.550 --> 02:10:08.550
Die Chancen sind gar nicht so klein.

02:10:08.550 --> 02:10:12.990
Wir haben 5 Milliarden zufällige IDs.

02:10:12.990 --> 02:10:15.990
Und ab der Hälfte...

02:10:15.990 --> 02:10:18.990
Ab 2 Milliarden IDs...

02:10:18.990 --> 02:10:21.990
ist die Chance über 50%...

02:10:21.990 --> 02:10:24.990
dass die nächste generierte Random ID schon mal vorhanden ist.

02:10:24.990 --> 02:10:27.990
Es sind einfach...

02:10:27.990 --> 02:10:30.990
Es sind einfach in einem U32 zu wenig Platz.

02:10:30.990 --> 02:10:38.310
Unix-Timestamp ist selbst in Millisekunden...

02:10:38.310 --> 02:10:41.310
nicht unbedingt so sinnvoll an der Stelle.

02:10:41.310 --> 02:10:44.310
Komm, wir machen mal das, was ich gesagt habe.

02:10:44.310 --> 02:10:47.310
Also, wir machen eine Schleife.

02:10:47.310 --> 02:10:50.310
Wir machen eine Schleife von...

02:10:50.310 --> 02:10:58.340
Kann man nicht einfach zählen hier mit einer Schleife?

02:10:58.340 --> 02:11:01.340
4i...

02:11:01.340 --> 02:11:04.340
4i in...

02:11:04.340 --> 02:11:07.340
U32 Max...

02:11:07.340 --> 02:11:11.840
So, und jetzt...

02:11:11.840 --> 02:11:19.740
Wir müssen das hier mal kurz unwrappen.

02:11:19.740 --> 02:11:22.740
Hier oben schon.

02:11:22.740 --> 02:11:25.740
If Map...

02:11:25.740 --> 02:11:28.740
Da gibt es doch immer so Contains...

02:11:28.740 --> 02:11:31.740
Contains Key i...

02:11:31.740 --> 02:11:34.740
If Not Contains Key i...

02:11:34.740 --> 02:11:39.880
Dann...

02:11:39.880 --> 02:11:42.880
Das ist alles, was wir machen müssen.

02:11:42.880 --> 02:11:48.090
Schon kriegen wir die erste freie ID.

02:11:48.090 --> 02:11:51.090
Nee, das ist doch eigentlich gar nicht schlecht.

02:11:51.090 --> 02:11:54.090
Weil das Schöne ist, die Verbindung...

02:11:54.090 --> 02:11:57.090
Das ist ja nicht nur Add, Append Only.

02:11:57.090 --> 02:12:00.090
Es können ja auch Sachen gelöscht werden.

02:12:00.090 --> 02:12:03.090
Mal angenommen, der erzeugt 5 Verbindungen.

02:12:03.090 --> 02:12:06.090
Irgendwann macht einer den Browser zu...

02:12:06.090 --> 02:12:09.090
und die ersten 5 Verbindungen werden gelöscht.

02:12:09.090 --> 02:12:12.090
0-5 wieder frei.

02:12:12.090 --> 02:12:15.090
Und wenn das nächste Mal die Schleife läuft,

02:12:15.090 --> 02:12:18.090
vergibt er IDs 0-5 neu.

02:12:18.090 --> 02:12:21.090
Das dürfte immer ziemlich schnell laufen.

02:12:21.090 --> 02:12:26.420
Übrigens Return i ist an der Stelle für Pegatime.

02:12:26.420 --> 02:12:29.420
Leute, wie würde man das jetzt Rust...

02:12:29.420 --> 02:12:32.420
Ich habe eine Idee.

02:12:32.420 --> 02:12:35.420
Wir machen jetzt Rust Idiomatic Way das Ganze.

02:12:35.420 --> 02:12:42.360
Match.

02:12:43.360 --> 02:12:47.740
Ich habe keine Ahnung.

02:12:47.740 --> 02:12:50.740
Ähm...

02:12:50.740 --> 02:12:53.740
Da müssen wir...

02:12:53.740 --> 02:13:06.300
Connectest du vielleicht dann so mit dem Sam...

02:13:06.300 --> 02:13:11.700
Ähm...

02:13:11.700 --> 02:13:14.700
Nee, weil einmal geschlossene Connections...

02:13:14.700 --> 02:13:21.580
können glaube ich nicht mal neu aufgebaut werden.

02:13:21.580 --> 02:13:24.580
Moin, für die nicht Programmierer unter uns sind.

02:13:24.580 --> 02:13:27.580
Was wird programmiert?

02:13:27.580 --> 02:13:30.580
Ein Rust WebRTC Backend.

02:13:30.580 --> 02:13:33.580
Mit dem du alle deine Webcams im Browser...

02:13:33.580 --> 02:13:36.580
in Echtzeit rein streamen kannst.

02:13:36.580 --> 02:13:41.780
Also, wenn es denn dann funktioniert.

02:13:41.780 --> 02:13:44.780
So, also.

02:13:44.780 --> 02:13:47.780
Und wir lernen Rust dabei.

02:13:47.780 --> 02:13:50.780
Also, guck mal.

02:13:50.780 --> 02:13:53.780
Kann man hier so eine Art Range draus machen?

02:13:53.780 --> 02:13:56.780
Range Rust.

02:13:56.780 --> 02:14:04.070
So was hier.

02:14:04.070 --> 02:14:07.070
Plammern.

02:14:07.070 --> 02:14:10.070
Und jetzt sagen wir Eater.

02:14:10.070 --> 02:14:13.070
Moment, das gibt es nicht.

02:14:13.070 --> 02:14:16.070
Into Eater, soll mir auch recht sein.

02:14:16.070 --> 02:14:19.070
Select.

02:14:19.070 --> 02:14:25.460
Filter.

02:14:25.460 --> 02:14:28.460
Nee, Filter will ich nicht.

02:14:28.460 --> 02:14:31.460
Rust.

02:14:31.460 --> 02:14:41.630
Position.

02:14:41.630 --> 02:14:44.630
Find.

02:14:44.630 --> 02:14:47.630
Find.

02:14:47.630 --> 02:14:53.220
Find.

02:14:53.220 --> 02:14:56.220
Find takes the...

02:14:56.220 --> 02:15:02.710
Okay.

02:15:02.710 --> 02:15:05.710
Find is short-circuiting.

02:15:05.710 --> 02:15:08.710
In other words, it will stop processing as soon as the closure returns true.

02:15:08.710 --> 02:15:11.710
Ja, das ist das, was ich haben will.

02:15:11.710 --> 02:15:14.710
Closure in Rust.

02:15:14.710 --> 02:15:17.710
Das ist so, glaube ich. Wie in Ruby ist das.

02:15:17.710 --> 02:15:23.050
Ja.

02:15:23.050 --> 02:15:27.360
Oder sagen wir mal ID.

02:15:27.360 --> 02:15:30.360
Und jetzt so?

02:15:30.360 --> 02:15:34.930
Okay, jetzt weiß ich nicht weiter.

02:15:34.930 --> 02:15:37.930
Wahrscheinlich einfach Klammer auf, Klammer zu.

02:15:37.930 --> 02:15:40.930
Moment.

02:15:40.930 --> 02:15:43.930
Oder kann man vielleicht sogar...

02:15:43.930 --> 02:15:49.140
Map contains key.

02:15:49.140 --> 02:15:52.140
ID.

02:15:52.140 --> 02:15:55.140
Oder not.

02:15:55.140 --> 02:16:03.290
Ah.

02:16:03.290 --> 02:16:06.290
Moment, da ist jetzt ein Match drauf.

02:16:06.290 --> 02:16:09.290
Dass wir eine Fehlermeldung schmeißen, wenn er keine freien IDs findet.

02:16:09.290 --> 02:16:12.290
Wie fundst du das jetzt?

02:16:12.290 --> 02:16:18.140
Match. Jawohl, die Idee hat mal was gebracht.

02:16:18.140 --> 02:16:21.140
Okay, wenn er keine freien gefunden hat,

02:16:21.140 --> 02:16:24.140
dann würde ich sagen, paniken wir.

02:16:24.140 --> 02:16:27.140
Panik.

02:16:27.140 --> 02:16:35.030
No free ID found.

02:16:35.030 --> 02:16:38.030
Und wenn er was gefunden hat,

02:16:38.030 --> 02:16:42.470
dann soll er die ID returnen.

02:16:42.470 --> 02:16:45.470
Macht das so Sinn?

02:16:45.470 --> 02:16:48.470
Du kannst auch expect machen.

02:16:48.470 --> 02:16:51.470
Mit Panik killst du den Prozess.

02:16:51.470 --> 02:16:58.540
Ja, das ist gut so.

02:16:58.540 --> 02:17:01.540
Auf der anderen Seite, ihr habt recht,

02:17:01.540 --> 02:17:04.540
das macht überhaupt keinen Sinn mit Match,

02:17:04.540 --> 02:17:07.540
sondern wir sagen einfach let ID,

02:17:07.540 --> 02:17:10.540
expect und dann machen wir eine custom Fehlermeldung.

02:17:10.540 --> 02:17:13.540
No free ID found.

02:17:13.540 --> 02:17:19.800
Zack, easy.

02:17:19.800 --> 02:17:22.800
Das finde ich schick.

02:17:22.800 --> 02:17:25.800
Kompiliert auch noch.

02:17:25.800 --> 02:17:28.800
Und jetzt haben wir jedes Mal eine frische ID.

02:17:28.800 --> 02:17:31.800
Sehr gut, nice.

02:17:31.800 --> 02:17:36.180
Jetzt können wir doch gleich mal testen, ob das funktioniert, was wir gebaut haben.

02:17:36.180 --> 02:17:44.330
Ich glaube, mehr brauchen wir in dieser Custom-Klasse nicht.

02:17:44.330 --> 02:17:47.330
So, dann lass uns doch mal gucken,

02:17:47.330 --> 02:17:50.330
ob sich die Aufregung heute gelohnt hat.

02:17:50.330 --> 02:17:53.330
Gehen wir mal in unsere Lib.

02:17:53.330 --> 02:17:56.330
So, RP State.

02:17:56.330 --> 02:17:59.330
Da gibt es jetzt ein Feld für Connections.

02:17:59.330 --> 02:18:02.330
Ich habe jetzt schon öfters gesehen,

02:18:02.330 --> 02:18:05.330
dass die Leute gerne in Rust die Sachen abkürzen.

02:18:05.330 --> 02:18:08.330
Wie würdet ihr das schreiben an der Stelle?

02:18:08.330 --> 02:18:11.330
Würdet ihr die Variable Connections nennen?

02:18:11.330 --> 02:18:14.330
Mojo, Jojo, danke schön für den Sub.

02:18:14.330 --> 02:18:17.330
Würdet ihr die Variable an der Stelle Connections nennen?

02:18:17.330 --> 02:18:20.330
Con?

02:18:20.330 --> 02:18:23.330
Cons?

02:18:23.330 --> 02:18:26.330
C?

02:18:26.330 --> 02:18:37.740
Oder WConnections?

02:18:37.740 --> 02:18:40.740
Poggen.

02:18:40.740 --> 02:18:46.020
Verbindungen, ja, genau.

02:18:46.020 --> 02:18:58.520
Prime Sub für die Krustentiere.

02:18:58.520 --> 02:19:01.520
Sehr schön, Pogu.

02:19:01.520 --> 02:19:04.520
Von Aqua, danke schön für den Sub.

02:19:04.520 --> 02:19:07.520
Und für die feinfette Unterstützung vorhin.

02:19:07.520 --> 02:19:10.520
Okay, Connections, also.

02:19:10.520 --> 02:19:15.150
Registry of T.

02:19:15.150 --> 02:19:18.150
Kann das sein, dass ich schon mal Registry irgendwie habe hier?

02:19:18.150 --> 02:19:21.150
Registry.

02:19:21.150 --> 02:19:24.150
Das habe ich schon mal importiert.

02:19:24.150 --> 02:19:27.150
Was ist das?

02:19:27.150 --> 02:19:30.150
Shit.

02:19:30.150 --> 02:19:33.150
Registry of.

02:19:33.150 --> 02:19:36.150
So, was brauchen wir jetzt?

02:19:36.150 --> 02:19:45.650
Testweise Connections, haben wir gesagt.

02:19:45.650 --> 02:20:00.490
Track local static sample.

02:20:00.490 --> 02:20:03.490
Wo ist das Problem jetzt?

02:20:03.490 --> 02:20:06.490
Ah.

02:20:06.490 --> 02:20:14.260
Exzellent.

02:20:14.260 --> 02:20:25.350
Wie will ich importieren?

02:20:25.350 --> 02:20:28.350
Moin.

02:20:28.350 --> 02:20:33.560
Pogu.

02:20:33.560 --> 02:20:38.380
Der Name kommt mir zumindest bekannt vor.

02:20:38.380 --> 02:20:43.400
Ich weiß nicht genau, woher.

02:20:43.400 --> 02:20:50.080
Aber der Name kommt mir bekannt vor.

02:20:50.080 --> 02:20:53.080
Also hier aus dem Chat auf jeden Fall.

02:20:53.080 --> 02:20:58.420
Connections, Registry, Track local static sample.

02:20:58.420 --> 02:21:01.420
Das müsste doch immer noch kompilieren, oder?

02:21:01.420 --> 02:21:04.420
Nein, natürlich nicht.

02:21:04.420 --> 02:21:10.970
Ist okay, ist okay.

02:21:10.970 --> 02:21:13.970
Registry new.

02:21:13.970 --> 02:21:16.970
Alles klar, es kompiliert.

02:21:16.970 --> 02:21:21.280
Top.

02:21:21.280 --> 02:21:24.280
Dann können wir das auch jetzt mal ausprobieren.

02:21:24.280 --> 02:21:27.280
Connections, dann schmeißen wir das hier mal weg.

02:21:27.280 --> 02:21:30.280
Check mal, ob die Funktionen alle public sind.

02:21:30.280 --> 02:21:38.690
Aber sonst alle.

02:21:38.690 --> 02:21:43.320
So.

02:21:43.320 --> 02:21:50.060
Und jetzt, wo verwenden wir denn jetzt Connections?

02:21:50.060 --> 02:21:53.060
Ich lösche das hier einfach mal.

02:21:53.060 --> 02:21:56.060
Connections, klar.

02:21:56.060 --> 02:21:59.060
Also im Prinzip brauchen wir jetzt bloß noch self.

02:21:59.060 --> 02:22:02.060
App state, get.

02:22:02.060 --> 02:22:07.910
Unwrap Connections.

02:22:08.910 --> 02:22:11.910
Cannot move.

02:22:11.910 --> 02:22:14.910
Achso, muss ich wieder und davor machen.

02:22:14.910 --> 02:22:22.070
Okay, Registry.

02:22:22.070 --> 02:22:25.070
Pair Connections.

02:22:25.070 --> 02:22:30.090
Connections, get.

02:22:30.090 --> 02:22:34.980
Moment, erstmal da unten das Ganze fixen.

02:22:34.980 --> 02:22:41.590
App state, get.

02:22:41.590 --> 02:22:47.950
Unwrap Connections.

02:22:47.950 --> 02:22:50.950
Und wieder und.

02:22:50.950 --> 02:22:53.950
So, insert. Insert gibt es nicht.

02:22:53.950 --> 02:22:56.950
Es gibt add.

02:22:56.950 --> 02:23:03.700
Und es wird einfach nur die Pair Connections hinzugefügt.

02:23:03.700 --> 02:23:21.700
Achso.

02:23:21.700 --> 02:23:24.700
Ja, wenn man es mal richtig macht, dann wird es auch funktionieren.

02:23:24.700 --> 02:23:30.300
Das hier unten brauche ich gar nicht mehr.

02:23:30.300 --> 02:23:33.300
Weil es schon initialisiert ist.

02:23:33.300 --> 02:23:44.100
Ja.

02:23:44.100 --> 02:23:47.100
Bleibt im Endeffekt nur noch das hier.

02:23:47.100 --> 02:23:50.100
Pair Connections, get ID.

02:23:50.100 --> 02:23:53.100
Das hier bleibt jetzt noch zu fixen.

02:23:53.100 --> 02:23:56.100
So, und wir getten jetzt.

02:23:56.100 --> 02:23:59.100
Okay, das ist ein U32, muss es nur noch sein.

02:23:59.100 --> 02:24:06.100
Wir sind mal hart drauf und casten mal schnell das U64 runter zu einem U32.

02:24:06.100 --> 02:24:13.360
Und get ist bei mir ein U32.

02:24:13.360 --> 02:24:21.360
Moment, kann man in Rust irgendwie casten, dass ich sage U32, ID?

02:24:21.360 --> 02:24:24.360
Äh, okay.

02:24:24.360 --> 02:24:27.360
Das ist unsafe.

02:24:27.360 --> 02:24:33.080
Ach nee, SU32.

02:24:33.080 --> 02:24:36.080
Unwrap.

02:24:36.080 --> 02:24:48.420
Jetzt brauchen wir gar nichts unwrappen.

02:24:48.420 --> 02:24:51.420
Doch, ist doch gut. Passt doch alles.

02:24:51.420 --> 02:24:54.420
Okay, ich glaube das war es schon.

02:24:54.420 --> 02:24:58.420
Das ist übrigens blöd. Wir machen das mal richtig.

02:24:58.420 --> 02:25:01.420
Das ist ein U32 hier.

02:25:01.420 --> 02:25:04.420
Und das ist ein U32 hier.

02:25:04.420 --> 02:25:10.020
Und das ist ein U32 hier.

02:25:10.020 --> 02:25:13.020
U64.

02:25:13.020 --> 02:25:16.020
Das ist ein U32 hier. Wir machen das mal richtig.

02:25:16.020 --> 02:25:19.020
Sonst habe ich nachher irgendwelche merkwürdigen random Bugs.

02:25:19.020 --> 02:25:24.020
Und in .NET ist das auch ein UINT32.

02:25:24.020 --> 02:25:27.020
Okay, so.

02:25:27.020 --> 02:25:30.020
So, und jetzt können wir mal sehen, ob der Bug gefixt ist.

02:25:30.020 --> 02:25:33.020
Das nur einmalig funktioniert.

02:25:33.020 --> 02:25:38.160
Das sollte jetzt mehrmalig mit reloaden funktionieren.

02:25:38.160 --> 02:25:43.240
Starten. Okay.

02:25:43.240 --> 02:25:51.240
Shit. Irgendwo habe ich was verkehrt gemacht.

02:25:51.240 --> 02:25:54.240
Okay. 44. Zeile 44.

02:25:54.240 --> 02:25:59.260
Okay, let's go. Zeile 44.

02:25:59.260 --> 02:26:09.010
Hast du die Lib kopiert?

02:26:09.010 --> 02:26:13.900
Ja. Zeile 44.

02:26:13.900 --> 02:26:16.900
Die ID gibt es nicht.

02:26:16.900 --> 02:26:41.500
Okay, die ID gibt es nicht. Warum gibt es die ID nicht?

02:26:41.500 --> 02:26:44.500
Weil ich irgendwo Mist mache hier.

02:26:44.500 --> 02:26:47.500
ID gleich.

02:26:47.500 --> 02:26:50.500
Okay, ID.

02:26:50.500 --> 02:26:59.220
Ach hier, ID gleich 1.

02:26:59.220 --> 02:27:14.740
ID gleich.

02:27:14.740 --> 02:27:17.740
Und jetzt gibt es die ID auch.

02:27:17.740 --> 02:27:20.740
Wenn da immer 1 drin steht.

02:27:20.740 --> 02:27:23.740
Nee, Option Return. Das ist gut, dass das gecrashed ist.

02:27:23.740 --> 02:27:31.180
Der konnte schlicht und ergreifend nicht weitermachen.

02:27:31.180 --> 02:27:39.020
Ich finde das gut. Da weiß man nichts, was kaputt ist.

02:27:39.020 --> 02:27:45.890
So, nochmal.

02:27:45.890 --> 02:27:53.050
Es geht.

02:27:53.050 --> 02:27:56.050
Der Browser war einfach nur PP gerade.

02:27:56.050 --> 02:28:11.580
Kann das sein, dass mein Javascript ein bisschen weird champ ist?

02:28:11.580 --> 02:28:14.580
Ich glaube, mein Javascript war ein bisschen weird champ gerade.

02:28:14.580 --> 02:28:17.580
Aber es funktioniert. Der Bug ist behoben.

02:28:17.580 --> 02:28:20.580
WebRTC funktioniert.

02:28:20.580 --> 02:28:23.580
Und er funktioniert mehrfach.

02:28:23.580 --> 02:28:26.580
Auch wenn man refresht.

02:28:26.580 --> 02:28:29.580
Aber wenn man zu schnell refresht, dann...

02:28:29.580 --> 02:28:35.810
Moment, wenn er irgendwas reused, dann funktioniert es nicht.

02:28:35.810 --> 02:28:38.810
Okay, das müssen wir so nochmal überprüfen.

02:28:38.810 --> 02:28:43.180
Der baut aber gar nicht die Verbindung auf.

02:28:43.180 --> 02:28:55.050
Nun ja.

02:28:55.050 --> 02:28:58.050
Der versucht irgendwas zu reusen, was er nicht reusen soll.

02:28:58.050 --> 02:29:10.680
Da stimmt irgendwas doch nicht ganz in der Logik, würde ich sagen.

02:29:10.680 --> 02:29:13.680
Wir geben nochmal kurz aus.

02:29:13.680 --> 02:29:16.680
Die Connection ID.

02:29:16.680 --> 02:29:19.680
Weil das sollte immer eine neue ID sein.

02:29:19.680 --> 02:29:24.440
Es sollte immer...

02:29:24.440 --> 02:29:27.440
Log...

02:29:27.440 --> 02:29:30.440
Es sollte immer eine neue ID sein.

02:29:30.440 --> 02:29:33.440
35, 36, 37...

02:29:33.440 --> 02:29:36.440
Es ist auch immer eine neue.

02:29:36.440 --> 02:29:39.440
38, 39...

02:29:39.440 --> 02:29:42.440
Ja, der Browser denkt nur, er kann die Sache cachen aus irgendwelchen Gründen.

02:29:42.440 --> 02:29:45.440
Und das funktioniert nicht.

02:29:45.440 --> 02:29:48.440
Manchmal cacht das und manchmal nicht.

02:29:48.440 --> 02:29:51.440
Keine Ahnung, was mein Browser da für PP-Ger-Sachen macht.

02:29:51.440 --> 02:29:54.440
Aber ich bin mir relativ sicher,

02:29:54.440 --> 02:29:57.440
weil es auch immer neu ist, dass das nicht an meinem Backend liegt.

02:29:57.440 --> 02:30:04.500
Weil, weil,

02:30:04.500 --> 02:30:07.500
wenn ich ohne Cache refreshe,

02:30:07.500 --> 02:30:10.500
guckt, wenn ich ohne Cache refreshe,

02:30:10.500 --> 02:30:16.740
dann funzt es immer.

02:30:16.740 --> 02:30:26.680
Bis es nicht funktioniert.

02:30:26.680 --> 02:30:35.220
Kommt das nicht irgendwie in die Quere?

02:30:35.220 --> 02:30:38.220
Das sieht ein bisschen nach Threat-Problemen aus, oder?

02:30:38.220 --> 02:30:41.220
Aber ihr seht, es ist immer eine neue Connection.

02:30:41.220 --> 02:30:45.780
Und daran kann es ja eigentlich nicht liegen.

02:30:45.780 --> 02:30:51.820
Und nachdem ich immer alles schön unwrappe und hier nichts abkackt,

02:30:51.820 --> 02:30:54.820
ich schiebe das wirklich aktuell auf meinen Browser.

02:30:54.820 --> 02:30:59.140
Dass der da nicht so genau...

02:30:59.140 --> 02:31:07.100
weiß, was er macht.

02:31:07.100 --> 02:31:10.100
Ich schiebe es auch auf JavaScript.

02:31:10.100 --> 02:31:15.560
Versuch mal Firefox.

02:31:15.560 --> 02:31:30.530
About WebRTC.

02:31:30.530 --> 02:31:36.760
True, lol, weh.

02:31:36.760 --> 02:31:51.380
Failed.

02:31:51.380 --> 02:31:57.190
Aber ihr seht, er bekommt die Offer hier.

02:31:57.190 --> 02:32:00.190
Hat er Probleme mit dem Multiplexen beim Port oder so?

02:32:00.190 --> 02:32:06.620
Wir machen noch mal ganz kurz den Debug rein.

02:32:06.620 --> 02:32:15.340
ATMX.

02:32:15.340 --> 02:32:22.340
Das ändert daran doch jetzt auch nichts.

02:32:22.340 --> 02:32:25.340
Wir haben in Rust nirgendwo Error-Handling.

02:32:25.340 --> 02:32:28.340
Also an Rust wird es in dem Fall echt nicht liegen.

02:32:28.340 --> 02:32:31.340
Irgendwie liegt es glaube ich an PPGaJava-Skript.

02:32:31.340 --> 02:32:43.850
Das ist meine Vermutung.

02:32:43.850 --> 02:32:46.850
Das ist übrigens auch, da waren sie lustig bei Firefox.

02:32:46.850 --> 02:32:49.850
Das steht in jeder dieser Meldungen drin.

02:32:49.850 --> 02:32:52.850
Das ist SDP.

02:32:52.850 --> 02:32:55.850
Weil das halt das Session-Description-Protokoll ist.

02:32:55.850 --> 02:32:58.850
War einer lustig, hat geschrieben.

02:32:58.850 --> 02:33:04.440
Also wenn ihr das mal seht, da war ein Mozilla-Mitarbeiter.

02:33:04.440 --> 02:33:07.440
Wollte witzig sein.

02:33:07.440 --> 02:33:10.440
Also das hat funktioniert offensichtlich.

02:33:10.440 --> 02:33:13.440
Das hätte hier ja nichts geantwortet.

02:33:13.440 --> 02:33:31.900
Wir machen noch mal hier.

02:33:31.900 --> 02:33:34.900
Keckl.

02:33:34.900 --> 02:33:37.900
Rintel.

02:33:37.900 --> 02:33:46.240
Jetzt können wir mal gucken.

02:33:46.240 --> 02:33:49.240
Also das sieht nicht so aus, als liegt das...

02:33:49.240 --> 02:33:52.240
Hä?

02:33:52.240 --> 02:34:05.830
Ich glaube eher, das liegt an meinem Java-Skript-Zeug.

02:34:05.830 --> 02:34:13.540
Okay, zweites ist kaputt gegangen.

02:34:13.540 --> 02:34:16.540
Bei mir ist alles durchgegangen.

02:34:16.540 --> 02:34:21.550
Also ich vermute, das liegt...

02:34:21.550 --> 02:34:24.550
Es ist auch immer eine neue ID am Start.

02:34:24.550 --> 02:34:29.760
ID2.

02:34:29.760 --> 02:34:34.520
Wir können mal gucken, ob es in neuen Tabs irgendwann auftritt.

02:34:34.520 --> 02:34:37.520
Wenn es nämlich nicht in neuen Tabs auftritt, dann liegt das...

02:34:37.520 --> 02:34:42.860
Okay, es tritt auch in neuen Tabs auf.

02:34:42.860 --> 02:34:45.860
Dann ist tatsächlich irgendwas kaputt.

02:34:45.860 --> 02:35:09.690
Aber das werden wir nicht jetzt fixen.

02:35:09.690 --> 02:35:12.690
Ist der Browser nicht lang genug?

02:35:12.690 --> 02:35:17.580
Nee, das glaube ich nicht so schnell, wie das immer geht.

02:35:17.580 --> 02:35:20.580
Aber auf jeden Fall, wenn es jeden zehntes Mal loaden oder so nicht funktioniert,

02:35:20.580 --> 02:35:29.620
dann ist schon pipega.

02:35:29.620 --> 02:35:32.620
Clear History.

02:35:32.620 --> 02:35:35.620
Clear History juckt dies nicht.

02:35:35.620 --> 02:35:40.320
Clear History.

02:35:40.320 --> 02:35:43.320
Ja, das geht doch in unerheblichen Teilen der Fälle...

02:35:43.320 --> 02:35:46.320
...geht es kaputt.

02:35:46.320 --> 02:35:52.040
Er bekommt aber den Handshake.

02:35:52.040 --> 02:36:05.020
Ja, er bekommt auch Candidates.

02:36:05.020 --> 02:36:10.020
Also ich tippe drauf, dass das ein Problem der Rust-Library vielleicht ist.

02:36:10.020 --> 02:36:13.020
Weil ich mache hier so Port-Multiplexing.

02:36:13.020 --> 02:36:18.680
Ich mache hier so Port-Multiplexing und...

02:36:18.680 --> 02:36:21.680
Okay, das ist meine letzte Amtshandlung heute.

02:36:21.680 --> 02:36:24.680
Ich lasse das mal weg, das Port-Multiplexing,

02:36:24.680 --> 02:36:27.680
und gucke mal, ob es dann weg ist.

02:36:27.680 --> 02:36:33.850
Aber ohne Port-Multiplexing will ich das nicht betreiben.

02:36:33.850 --> 02:36:42.510
Was bedeuten die Abkürzungen in Rust?

02:36:42.510 --> 02:36:45.510
Welche Abkürzungen?

02:36:45.510 --> 02:36:48.510
Also unspezifischer Fragen hättest du auch nicht mehr können, oder?

02:36:48.510 --> 02:36:52.950
Oder du meinst, für was Rust steht?

02:36:52.950 --> 02:36:55.950
Rust ist gar keine Abkürzung. Rust ist eine Programmiersprache.

02:36:55.950 --> 02:37:02.380
Was ist Port-Multiplexing?

02:37:02.380 --> 02:37:05.380
Der macht mehrere Connections über den gleichen Port, anstatt für jeden Port was eigenes auf.

02:37:05.380 --> 02:37:11.610
Ah!

02:37:11.610 --> 02:37:14.610
Chat-Gear?

02:37:14.610 --> 02:37:17.610
Das liegt am Port-Multiplexing, guckt mal.

02:37:17.610 --> 02:37:35.780
Seht ihr das?

02:37:35.780 --> 02:37:43.100
Jetzt kackt nichts ab.

02:37:43.100 --> 02:37:48.300
Das liegt am Port-Multiplexing von der Library.

02:37:48.300 --> 02:37:51.300
Aber ohne Port-Multiplexing werde ich das nicht betreiben.

02:37:51.300 --> 02:37:58.780
Guckt, das wäre schon längst abgekackt, normalerweise.

02:37:58.780 --> 02:38:05.660
Ich kann noch ein paar mal refreshen.

02:38:05.660 --> 02:38:11.180
Pass mal auf.

02:38:11.180 --> 02:38:14.180
Ich habe halt ein paar Ports offen jetzt, ne?

02:38:14.180 --> 02:38:17.180
Das ist wirklich nicht viel.

02:38:17.180 --> 02:38:20.180
Was ich jetzt machen würde, ist,

02:38:20.180 --> 02:38:23.180
ich würde einen Retry im JavaScript einbauen.

02:38:23.180 --> 02:38:26.180
Also, guckt mal.

02:38:26.180 --> 02:38:29.180
Das ist ja relativ offensichtlich der Bug.

02:38:29.180 --> 02:38:32.180
Der irgendwie im Port-Multiplexing liegt.

02:38:32.180 --> 02:38:35.180
Und nachdem ich hier nichts großartig einstellen kann,

02:38:35.180 --> 02:38:43.020
man kann ja auch keine großartigen Settings sonst einstellen.

02:38:43.020 --> 02:38:46.020
UDP-Multiplexing-Default.

02:38:47.020 --> 02:38:50.020
Man kann da nicht wirklich viel einstellen.

02:38:50.020 --> 02:38:55.100
Closed.

02:38:55.100 --> 02:39:01.070
Gibt keine großartigen Settings.

02:39:01.070 --> 02:39:04.070
Ich würde einen Retry im JavaScript einbauen.

02:39:04.070 --> 02:39:14.400
Da kann man nicht viel. Option.

02:39:14.400 --> 02:39:21.020
Warum nicht TCP?

02:39:21.020 --> 02:39:24.020
Würde ich gerne machen, unterstütze die Library nicht.

02:39:24.020 --> 02:39:27.020
Und ist für Echtzeit-Video jetzt auch nicht so wichtig,

02:39:27.020 --> 02:39:30.020
dass sie das kann.

02:39:31.020 --> 02:39:34.020
Und zwar,

02:39:34.020 --> 02:39:38.840
kompilieren das nochmal.

02:39:38.840 --> 02:39:41.840
Dann gehen wir in C-Sharp.

02:39:41.840 --> 02:39:44.840
Höhen das nochmal aus.

02:39:44.840 --> 02:39:47.840
Gucken, ob das Problem noch auftritt.

02:39:47.840 --> 02:39:50.840
Ja, Problem tritt immer noch auf.

02:39:50.840 --> 02:39:53.840
Es liegt echt am Port-Multiplexing.

02:39:53.840 --> 02:39:56.840
Guckt, dass das manchmal nicht geht.

02:39:56.840 --> 02:40:02.880
Kaum ist das eingeschaltet, buggt es wieder rum.

02:40:02.880 --> 02:40:05.880
Was ich jetzt machen würde,

02:40:05.880 --> 02:40:08.880
ich würde einen Retry im JavaScript einbauen.

02:40:08.880 --> 02:40:11.880
So nach dem Motto,

02:40:11.880 --> 02:40:14.880
wenn das innerhalb von nicht-connected hat,

02:40:14.880 --> 02:40:17.880
dann Retry.

02:40:17.880 --> 02:40:20.880
Das kann ich mir jetzt nicht aus dem Ärmel schütteln.

02:40:20.880 --> 02:40:23.880
Aber ich schreibe mir das mal als To-Do rein.

02:40:23.880 --> 02:40:26.880
To-Do, Retry.

02:40:26.880 --> 02:40:31.580
5 Minuten haben wir noch Zeit.

02:40:31.580 --> 02:40:34.580
Vielleicht kann man das sogar relativ einfach machen.

02:40:34.580 --> 02:40:37.580
Der legt hier die Verbindung an.

02:40:37.580 --> 02:40:43.230
Okay, ich weiß, was wir machen.

02:40:43.230 --> 02:40:46.230
Easy.

02:40:46.230 --> 02:40:49.230
Es ist JavaScript, da können wir auch eklige Sachen machen.

02:40:49.230 --> 02:40:52.230
SetInterval nach einer Sekunde.

02:40:52.230 --> 02:40:55.230
Passt mal auf, das wird jetzt richtig eklig.

02:40:55.230 --> 02:40:58.230
Das wird so eklig,

02:40:58.230 --> 02:41:01.230
da werdet ihr den Stream ausschalten wollen.

02:41:01.230 --> 02:41:04.230
Also, wenn nach einer Sekunde der Connection State

02:41:04.230 --> 02:41:09.380
ungleich

02:41:09.380 --> 02:41:12.380
ungleich

02:41:12.380 --> 02:41:15.380
ungleich

02:41:15.380 --> 02:41:18.380
connected ist,

02:41:18.380 --> 02:41:23.070
dann, pass auf, Pfeil fährt,

02:41:23.070 --> 02:41:26.070
dann Window, Location,

02:41:26.070 --> 02:41:43.600
Reload.

02:41:43.600 --> 02:41:46.600
Das ist ein bisschen schnell.

02:41:46.600 --> 02:41:49.600
Vielleicht 2 Sekunden.

02:41:49.600 --> 02:41:52.600
Okay, 2 Sekunden.

02:41:52.600 --> 02:41:58.190
Jetzt habe ich es gebroken.

02:41:58.190 --> 02:42:01.190
Jetzt ist es kaputt, Leute.

02:42:01.190 --> 02:42:07.840
Ah, geht doch. Easy.

02:42:07.840 --> 02:42:10.840
Vielleicht machen wir auch 3 Sekunden.

02:42:10.840 --> 02:42:19.220
Easy.

02:42:19.220 --> 02:42:22.220
Eventuell noch ClearInterval im Else-Case.

02:42:22.220 --> 02:42:28.380
Moment, ich will ja auch nicht SetInterval,

02:42:28.380 --> 02:42:32.950
ich will ja SetTimeout.

02:42:32.950 --> 02:42:35.950
Ich will ja gar nicht SetInterval.

02:42:35.950 --> 02:42:49.350
Ich will ja, dass es nur einmal ausgewählt wird.

02:42:49.350 --> 02:42:52.350
Guck, und es funzt.

02:42:52.350 --> 02:42:57.430
Connection-Probleme, 3 Sekunden später,

02:42:57.430 --> 02:43:00.430
Bam, Seite, Reloaded, Connection funzt.

02:43:00.430 --> 02:43:05.190
Kannst du nicht das Event Connected abfangen für den Reload?

02:43:05.190 --> 02:43:08.190
Doch.

02:43:08.190 --> 02:43:11.190
Aber ich will ja hart nach 3 Sekunden gucken,

02:43:11.190 --> 02:43:14.190
dann fange ich hier ab.

02:43:14.190 --> 02:43:17.190
Ich könnte warten, bis das auf Failed steht.

02:43:17.190 --> 02:43:20.190
Guck mal, wie lange das dauert,

02:43:20.190 --> 02:43:27.800
bis es sich auf Failed stellt.

02:43:27.800 --> 02:43:34.350
Das dauert ewig, bis es auf Failed geht.

02:43:34.350 --> 02:43:42.250
Das geht einfach gar nicht auf Failed.

02:43:42.250 --> 02:43:48.160
Das fängt auch gar nicht an erst.

02:43:48.160 --> 02:43:54.460
SetInterval, wir gucken jetzt mal kurz.

02:43:54.460 --> 02:43:57.460
Alle Sekunde,

02:43:57.460 --> 02:44:00.460
Log, PC,

02:44:00.460 --> 02:44:03.460
Connection-State und Log,

02:44:03.460 --> 02:44:06.460
PC, Ice,

02:44:06.460 --> 02:44:15.180
Connection-State.

02:44:15.180 --> 02:44:18.180
New, New, New,

02:44:18.180 --> 02:44:21.180
Das geht nie auf Failed.

02:44:21.180 --> 02:44:24.180
Das macht einfach gar nichts.

02:44:24.180 --> 02:44:38.930
Jetzt habt ihr es gerade gesehen.

02:44:38.930 --> 02:44:44.070
Ich mache das da für euch in die Mitte.

02:44:44.070 --> 02:44:47.070
Das erkennt gar nicht, dass es Failed ist.

02:44:47.070 --> 02:44:50.070
Das heißt, mein Ansatz ist einfach

02:44:50.070 --> 02:44:53.070
bester JavaScript-Fix ever.

02:44:53.070 --> 02:44:56.070
3 Sekunden warten, wenn nicht Connected,

02:44:56.070 --> 02:44:59.070
Restart. Easy.

02:44:59.070 --> 02:45:02.070
Guck, nicht Connected, 3 Sekunden später,

02:45:02.070 --> 02:45:05.070
Restart und Connected.

02:45:05.070 --> 02:45:08.070
Ich glaube, das liegt in diesem Port-Multiplexing.

02:45:08.070 --> 02:45:11.070
Was man auch gesehen hat.

02:45:11.070 --> 02:45:14.070
Wenn ich das Port-Multiplexing

02:45:14.070 --> 02:45:17.070
raus mache.

02:45:17.070 --> 02:45:20.070
Irgendwann geht das auf Failed.

02:45:20.070 --> 02:45:23.070
GitHub,

02:45:23.070 --> 02:45:26.070
WebRTCS.

02:45:26.070 --> 02:45:29.070
Wir können noch einmal kurz hier reingucken

02:45:29.070 --> 02:45:33.700
in die Examples.

02:45:33.700 --> 02:45:36.700
Single Port.

02:45:36.700 --> 02:45:39.700
Die hatten gar kein Beispiel dafür.

02:45:40.700 --> 02:45:53.780
Okay, die High-IQ-Leute setzen das so.

02:45:53.780 --> 02:46:00.080
Was ist UDP?

02:46:00.080 --> 02:46:05.480
Die verbindungslose Variante von TCP.

02:46:05.480 --> 02:46:08.480
Settings

02:46:08.480 --> 02:46:11.480
Engine.

02:46:11.480 --> 02:46:14.480
Okay, das hat jetzt wahrscheinlich nicht so viel gebracht.

02:46:14.480 --> 02:46:17.480
Settings Engine,

02:46:17.480 --> 02:46:24.740
Set UDP Network.

02:46:24.740 --> 02:46:27.740
Okay, die coolen Leute machen so.

02:46:27.740 --> 02:46:30.740
Vielleicht bin ich einfach nicht Rust-Pro genug.

02:46:30.740 --> 02:46:33.740
Ich meine mal seriously,

02:46:33.740 --> 02:46:36.740
das hier ist wahrscheinlich nicht viel anders

02:46:36.740 --> 02:46:39.740
zu dem, was ich gebaut habe.

02:46:39.740 --> 02:46:46.610
Ach so, Settings Engine sollte ich

02:46:46.610 --> 02:46:53.420
gleich noch anlegen.

02:46:53.420 --> 02:46:58.620
Das müsste die gleichen Probleme haben.

02:46:58.620 --> 02:47:01.620
Es ist kein Unterschied zu dem, was ich gemacht habe.

02:47:01.620 --> 02:47:06.380
Nur irgendwie ineinander gerappt.

02:47:06.380 --> 02:47:09.380
Placingly fast und coole Leute verwenden Rust.

02:47:09.380 --> 02:47:12.380
Ich will auch zu den coolen Leuten gehören.

02:47:12.380 --> 02:47:15.380
Nee, okay, Probleme gibt es immer noch.

02:47:15.380 --> 02:47:18.380
Jetzt geht es gar nicht mehr.

02:47:18.380 --> 02:47:24.230
Leute, jetzt ist es komplett kaputt.

02:47:24.230 --> 02:47:33.980
Jetzt ist es komplett broken.

02:47:33.980 --> 02:47:36.980
Hat ein bisschen gebraucht.

02:47:36.980 --> 02:47:39.980
Nee, aber es ist immer noch kaputt.

02:47:39.980 --> 02:47:46.860
Aber leakst du jetzt nicht eine Connection

02:47:46.860 --> 02:47:49.860
beziehungsweise eine ID?

02:47:49.860 --> 02:47:52.860
Aktuell schon.

02:47:52.860 --> 02:47:55.860
Wir probieren WebRTC zu streamen.

02:47:55.860 --> 02:47:58.860
Vom Server in den Browser.

02:47:58.860 --> 02:48:01.860
Doch aktuell leake ich.

02:48:01.860 --> 02:48:04.860
Ich brauche jetzt noch sowas wie

02:48:04.860 --> 02:48:07.860
Cleanup

02:48:07.860 --> 02:48:10.860
Old Connections.

02:48:10.860 --> 02:48:13.860
Dazu kann man,

02:48:13.860 --> 02:48:16.860
das machen wir aber heute nicht,

02:48:16.860 --> 02:48:19.860
dazu kann man beispielsweise

02:48:19.860 --> 02:48:22.860
ein Event subscriben.

02:48:22.860 --> 02:48:27.170
Da gibt es per Connection

02:48:27.170 --> 02:48:32.060
State On

02:48:32.060 --> 02:48:35.060
On State

02:48:35.060 --> 02:48:38.060
On per Connection State Changed

02:48:38.060 --> 02:48:41.060
Wie auch immer man das aufruft.

02:48:41.060 --> 02:48:47.160
Da steckt man ein Callback rein.

02:48:47.160 --> 02:48:50.160
Da ist einfach ein Syntaxfehler drin.

02:48:50.160 --> 02:48:53.160
Da kann ich warten bis der Code

02:48:53.160 --> 02:48:56.160
Closed ist und dann lösche ich den

02:48:56.160 --> 02:48:59.160
aus der Hashmap.

02:48:59.160 --> 02:49:02.160
Und dann wird nichts mehr geleakt.

02:49:02.160 --> 02:49:06.540
Okay, der Rest ist selbsterklärend.

02:49:06.540 --> 02:49:09.540
Deswegen hat es auch keine Tests oder Docs.

02:49:09.540 --> 02:49:14.550
Braucht man nicht.

02:49:14.550 --> 02:49:17.550
Git Add Minus A

02:49:17.550 --> 02:49:20.550
Diff Minus Minus

02:49:20.550 --> 02:49:27.360
Staged

02:49:27.360 --> 02:49:31.990
Ich wollte gucken ob Windows Line Endings wieder drin sind.

02:49:31.990 --> 02:49:34.990
Okay, Git Status

02:49:34.990 --> 02:49:37.990
Git Commits A Minus M

02:49:37.990 --> 02:49:42.370
Cute Chat

02:49:42.370 --> 02:49:45.370
Okay, MVP

02:49:45.370 --> 02:49:48.370
Wir küren jetzt am Abschluss jedes Streams

02:49:48.370 --> 02:49:51.370
Chatge-MVPs

02:49:51.370 --> 02:49:54.370
MVP

02:49:54.370 --> 02:49:57.370
Okay, vielleicht mehrere Leute

02:49:57.370 --> 02:50:00.370
Wer ist euch heute besonders positiv aufgefallen?

02:50:00.370 --> 02:50:03.370
Wir machen Chatge

02:50:03.370 --> 02:50:06.370
Chatge darf Chatge bewerten

02:50:06.370 --> 02:50:25.370
Communityge

02:50:25.370 --> 02:50:28.370
RonAqua

02:50:28.370 --> 02:50:38.340
RonAqua

02:50:38.340 --> 02:50:41.340
Odolmit

02:50:45.320 --> 02:50:48.320
😅

02:50:48.320 --> 02:50:51.320
ulen

02:51:10.160 --> 02:51:13.160
NㅁN

02:51:13.160 --> 02:51:32.130
NㅁN

02:51:32.130 --> 02:51:37.400
NㅁN

02:51:37.400 --> 02:51:40.400
NㅁN

02:51:40.400 --> 02:51:43.400
NㅁN

02:51:43.400 --> 02:51:46.400
NㅁN

02:51:46.400 --> 02:52:03.980
Anzeige ist raus. So mal gucken, ob alles auf ShitHub ordentlich drin ist. Ja, sieht gut aus.

02:52:03.980 --> 02:52:15.120
Okay, ChatGel, nice. Schön, dass ihr am Start gewesen seid. Ich gehe jetzt pennen. Wir sehen

02:52:15.120 --> 02:52:16.680
uns. Bis denn. Macht's gut. CEU.
