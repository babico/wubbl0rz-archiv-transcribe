1
00:02:29,230 --> 00:02:47,390
So, heute Five-Head-Time, Leute.

2
00:02:47,390 --> 00:02:51,390
Wir benchmarken heute mal ein paar Sachen.

3
00:02:51,390 --> 00:02:53,390
Und zwar...

4
00:02:53,390 --> 00:02:57,390
Ich zeige euch das, bevor ich jetzt lange erzähle.

5
00:02:57,390 --> 00:03:04,280
Wir haben ja auch im Stream schon ein bisschen mit Web...

6
00:03:04,280 --> 00:03:07,280
Ich muss mal ein bisschen leiser machen.

7
00:03:07,280 --> 00:03:10,280
Heute schon gesportet? Ja, heute moin.

8
00:03:10,280 --> 00:03:12,280
Allerdings...

9
00:03:12,280 --> 00:03:22,350
Die Lautstärke kann sich mal wieder nicht entscheiden.

10
00:03:22,350 --> 00:03:26,050
Okay.

11
00:03:26,050 --> 00:03:30,050
Aber heute nur 5,56 Kilometer.

12
00:03:30,050 --> 00:03:34,050
Nicht wieder 10 plus wie letzten Sonntag.

13
00:03:34,050 --> 00:03:37,050
Also ganz normale Runde, die ich sonst auch renne.

14
00:03:37,050 --> 00:03:39,050
Naja, wobei nicht exakt die gleiche.

15
00:03:39,050 --> 00:03:41,050
Meine normale Runde 6,2.

16
00:03:41,050 --> 00:03:45,450
Ich mach schon mal meine VM an.

17
00:03:45,450 --> 00:03:48,450
Ich muss jetzt erstmal, bevor es losgeht...

18
00:03:48,450 --> 00:03:51,450
Ich zeige euch jetzt, was wir machen.

19
00:03:51,450 --> 00:03:53,450
Und...

20
00:03:53,450 --> 00:03:58,450
Dann futtere ich nochmal zwei Plätzchen, die ich mitgebracht habe hier gerade.

21
00:03:58,450 --> 00:04:04,450
Aber in der Zwischenzeit können wir nochmal ein Package-Update auf der VM machen, falls es das in der Zwischenzeit schon gegeben hat.

22
00:04:04,450 --> 00:04:08,450
Weil ich glaube, zuletzt haben wir heute Morgen geupdatet.

23
00:04:08,450 --> 00:04:10,450
Also, ich zeige euch, was wir heute machen.

24
00:04:10,450 --> 00:04:14,450
Ich glaube, das wird recht spannend, zumindest interessieren mich die Ergebnisse auch.

25
00:04:14,450 --> 00:04:25,270
Und zwar, wir rufen heute von C-Sharp aus sowohl Rust-Funktionen auf, als auch Go-Funktionen.

26
00:04:25,270 --> 00:04:27,270
Was liegt daran?

27
00:04:27,270 --> 00:04:30,270
Ihr könnt euch vielleicht noch dran erinnern.

28
00:04:30,270 --> 00:04:35,270
Ich hab im Stream ja schon öfters mal ein bisschen mit WebRTC auf Serverseite rumgebastelt.

29
00:04:35,270 --> 00:04:41,270
Zum Beispiel, dass man sich connecten kann in den Browser und dann Webcams abspielen und solche Geschichten.

30
00:04:41,270 --> 00:04:44,270
Also ich hab ja schon öfters mal ein bisschen mit WebRTC rumgebastelt.

31
00:04:44,270 --> 00:04:50,270
Und ich hab die letzten Tage über mal so ein bisschen Just for Fun wieder ein bisschen rumgebaut mit WebRTC.

32
00:04:50,270 --> 00:04:55,270
Also WebRTC ist quasi Real-Time Video im Browser.

33
00:04:55,270 --> 00:04:58,270
Nicht Streaming, wohlgemerkt nicht Streaming.

34
00:04:58,270 --> 00:05:01,270
Also Streaming ist ja meistens HLS.

35
00:05:01,270 --> 00:05:04,270
Also HLS ist, was heißt das?

36
00:05:04,270 --> 00:05:06,270
Für was steht HLS eigentlich?

37
00:05:06,270 --> 00:05:09,900
Gute Frage.

38
00:05:09,900 --> 00:05:11,900
HTTP-Live-Streaming.

39
00:05:11,900 --> 00:05:13,900
Okay.

40
00:05:13,900 --> 00:05:15,900
Wusste ich gar nicht.

41
00:05:15,900 --> 00:05:18,900
Also die ganzen Streaming-Seiten, die funktionieren meistens über HLS.

42
00:05:18,900 --> 00:05:20,900
HLS ist relativ easy.

43
00:05:20,900 --> 00:05:24,900
HLS gibt es eine M3U8-Datei.

44
00:05:24,900 --> 00:05:27,900
Und da stehen dann URLs drin, die rotatet werden.

45
00:05:27,900 --> 00:05:31,900
Und alle paar Sekunden gibt es da einen neuen Eintrag drin.

46
00:05:31,900 --> 00:05:33,900
Und dann streamt das.

47
00:05:33,900 --> 00:05:36,900
Also es macht ab und zu mal ein Get und dann holt sich so ein 5-Sekunden-Häppchen vom Stream.

48
00:05:36,900 --> 00:05:39,900
Und dann macht es wieder ein Get neues 5-Sekunden-Häppchen.

49
00:05:39,900 --> 00:05:42,900
WebRTC ist tatsächlich Real-Time.

50
00:05:42,900 --> 00:05:44,900
On-End-Gerät zu End-Gerät.

51
00:05:44,900 --> 00:05:47,900
Das ist besonders gut, wenn man möglichst Latency-Free-Video haben will.

52
00:05:47,900 --> 00:05:51,900
Was cool ist für Audio-Calls.

53
00:05:51,900 --> 00:05:53,900
Also beispielsweise Microsoft Teams und sowas.

54
00:05:53,900 --> 00:05:55,900
Das läuft nach Möglichkeiten über WebRTC.

55
00:05:55,900 --> 00:05:59,900
Und halt auch für Videokameras.

56
00:05:59,900 --> 00:06:02,900
Wenn man zum Beispiel drauf gucken will, wer vor der Tür steht und sowas.

57
00:06:02,900 --> 00:06:05,900
Und das möglichst Latency-Free sehen will alles.

58
00:06:05,900 --> 00:06:07,900
Dann ist WebRTC gut.

59
00:06:07,900 --> 00:06:08,900
Aber das machen wir heute nicht.

60
00:06:08,900 --> 00:06:10,900
Ich sag nur, wie ich drauf gekommen bin.

61
00:06:11,900 --> 00:06:13,900
Und ich verwende für...

62
00:06:13,900 --> 00:06:15,900
Oh, ich habe irgendwas im Auge.

63
00:06:15,900 --> 00:06:19,980
Das ist ja super abartig.

64
00:06:19,980 --> 00:06:23,940
Razer, danke für den Sub.

65
00:06:23,940 --> 00:06:32,500
Und by the way, wir installieren gerade mal die neue JetBrains IDE für Rust.

66
00:06:32,500 --> 00:06:35,500
Erstmal hier updaten.

67
00:06:35,500 --> 00:06:38,500
Die Toolbox darf auch updaten.

68
00:06:38,500 --> 00:06:42,500
Genau, und normalerweise habe ich das immer mit dieser Library hier gemacht.

69
00:06:42,500 --> 00:06:45,940
Und die ist in Go.

70
00:06:46,940 --> 00:06:48,940
Die ist in Go.

71
00:06:48,940 --> 00:06:51,940
Und eine Sache, die mich in Go immer genervt hat.

72
00:06:51,940 --> 00:06:53,940
Stripes, dankeschön für den Sub.

73
00:06:53,940 --> 00:07:02,940
Eine Sache, die mich in Go immer genervt hat, ist, dass Go Interop mit anderen Sprachen so langsam ist.

74
00:07:02,940 --> 00:07:05,940
Die IDE ist absoluter Müll, echt.

75
00:07:05,940 --> 00:07:07,940
Hast du schon ausprobiert?

76
00:07:07,940 --> 00:07:09,940
Wie heißt denn das Ding überhaupt?

77
00:07:09,940 --> 00:07:11,940
Rust Rover.

78
00:07:11,940 --> 00:07:14,940
Was verwendest du, wenn das Kacke ist?

79
00:07:14,940 --> 00:07:18,940
Meistens sind die JetBrains-Dinger doch immer ganz gut.

80
00:07:18,940 --> 00:07:21,940
Aber zumindest Goland ist nice und Ryder ist nice.

81
00:07:21,940 --> 00:07:35,050
Moin.

82
00:07:35,050 --> 00:07:43,810
Was macht Visual Studio Code besser?

83
00:07:43,810 --> 00:08:01,260
Plätzchen, Stelz, Easy Light.

84
00:08:01,260 --> 00:08:31,070
Keine Ahnung, was die da treiben.

85
00:08:31,070 --> 00:08:41,170
Das denke ich persönlich auch.

86
00:08:41,170 --> 00:08:48,400
Es würde mich weniger interessieren, was Mr. Robot nicht gefallen hat.

87
00:08:48,400 --> 00:08:51,400
Beziehungsweise, was ihn wie das Code besser ist.

88
00:08:51,400 --> 00:09:01,540
Update ist raus, installieren wir das Ding.

89
00:09:01,540 --> 00:09:08,730
Das Ding buggt ja vor allem manchmal ein bisschen.

90
00:09:08,730 --> 00:09:16,140
So.

91
00:09:16,140 --> 00:09:20,140
Also, nachdem ich meine Plätzchen weggestelzt habe, kann ich weiter erzählen.

92
00:09:20,140 --> 00:09:24,140
Wie gesagt, ich sage euch gleich, wir machen heute nicht viel WebRTC.

93
00:09:24,140 --> 00:09:26,140
Wenn überhaupt, gar nicht.

94
00:09:26,140 --> 00:09:28,140
Das ist nur, wie ich auf die Idee gekommen bin.

95
00:09:28,140 --> 00:09:32,140
Und zwar, für WebRTC habe ich immer diese Library hier verwendet.

96
00:09:32,140 --> 00:09:39,140
Aber eine Sache, die mich an Go aufrufen aus anderen Sprachen immer extrem abgefuckt hat, ist,

97
00:09:40,140 --> 00:09:44,140
dass das, wenn man das öfters callt, ziemlich langsam ist.

98
00:09:44,140 --> 00:09:46,140
Es gibt zwei Varianten.

99
00:09:46,140 --> 00:09:53,140
Wenn man aus Go selber C-Funktionen aufruft, also quasi von Go andere Sprachen aufruft,

100
00:09:53,140 --> 00:09:58,140
dann ist das langsam, aber es hält sich noch halbwegs in Grenzen.

101
00:09:58,140 --> 00:10:03,140
Wenn man aus anderen Sprachen in Go rein callt, in Go-Code rein callt,

102
00:10:03,140 --> 00:10:07,140
dann ist das in der Vergangenheit zumindest extrem langsam gewesen.

103
00:10:07,140 --> 00:10:16,140
Also, wir reden hier von ein native function call von C-Sharp nach C-Sharp dauert, was weiß ich,

104
00:10:16,140 --> 00:10:21,140
keine Ahnung, eine halbe Nanosekunde oder so.

105
00:10:21,140 --> 00:10:23,140
Es ist kurz.

106
00:10:23,140 --> 00:10:29,140
Und ein call nach Go rein dauert irgendwie 300 Nanosekunden oder so.

107
00:10:29,140 --> 00:10:34,140
Also, Go ist sehr langsam, wenn es um Interop mit anderen Sprachen angeht.

108
00:10:35,140 --> 00:10:50,140
Das hat mich immer genervt, weil ich sende mehrfach, also ich sende 30 mal die Sekunde pro Kamera neue Videoframes nach Go

109
00:10:50,140 --> 00:10:53,140
und die WebRTC-Library verarbeitet die dann.

110
00:10:53,140 --> 00:10:58,140
Heißt, im Endeffekt, ich hab, sag mal, wenn du 30 FPS pro Kamera hast,

111
00:10:58,140 --> 00:11:02,140
hast du 10 Kameras, oder sagst du, du hast 100 Kameras,

112
00:11:02,140 --> 00:11:06,140
dann hast du 3000 Function Calls die Sekunde.

113
00:11:06,140 --> 00:11:10,140
Das ist nicht viel und das ist auch, ganz ehrlich,

114
00:11:10,140 --> 00:11:16,140
selbst wenn es richtig, richtig langsam ist in Go,

115
00:11:16,140 --> 00:11:19,140
nicht so wirklich das Bottleneck, aber mich nervt.

116
00:11:19,140 --> 00:11:21,140
Deswegen wollte ich das erstens mal ausprobieren.

117
00:11:21,140 --> 00:11:26,140
Naja, also es gibt noch nichts zu rewriten in Rust, aber wir probieren das mal in Rust aus.

118
00:11:26,140 --> 00:11:31,140
Also zumindest, wir machen heute kein komplettes WebRTC-Example, vielleicht nächsten Stream oder so,

119
00:11:31,140 --> 00:11:33,140
weil das geht erstmal zum Ausprobieren.

120
00:11:33,140 --> 00:11:38,140
Zumindest wollte ich erstmal ausprobieren, ob das schneller geworden ist mittlerweile.

121
00:11:38,140 --> 00:11:41,140
Also C und Go Interop.

122
00:11:41,140 --> 00:11:45,140
Ich sag C stellvertretend für alle anderen Sprachen, die es gibt,

123
00:11:45,140 --> 00:11:49,140
weil jede Sprache, oder sag mal so, mir fällt keine Sprache ein,

124
00:11:49,140 --> 00:11:53,140
die nicht Interop mit C machen kann.

125
00:11:54,140 --> 00:12:02,140
Wie C Funktionen aufruft, hat sich so ein bisschen als Standard etabliert in der Programmierwelt.

126
00:12:02,140 --> 00:12:06,140
Egal ob das jetzt Python ist, Node, C Sharp, was auch immer,

127
00:12:06,140 --> 00:12:10,140
alle können sie eigentlich dynamisch C Funktionen aufrufen.

128
00:12:10,140 --> 00:12:20,520
Also mir fällt keine Sprache ein, die nicht C Funktionen aufrufen kann.

129
00:12:20,520 --> 00:12:27,520
Sagen wir mal, kompilierte Sachen, die mit C Interface rausgefallen sind.

130
00:12:27,520 --> 00:12:33,520
Und das Ding ist, ich hab irgendwas im Auge, das ist wirklich richtig nervig.

131
00:12:33,520 --> 00:12:48,210
So, und das Ding ist, wir testen jetzt erstmal, ob das schneller geworden ist mit Go.

132
00:12:48,210 --> 00:12:51,210
Was hab ich eigentlich für eine Go-Version drauf hier?

133
00:12:51,210 --> 00:12:54,210
Go-Version, sieht man das?

134
00:12:54,210 --> 00:12:57,210
Ach nee, das ist die Minus-Version, nur so?

135
00:12:57,210 --> 00:12:59,210
Nee, das ist einfach nur Version.

136
00:12:59,210 --> 00:13:03,210
Warum macht das eigentlich jedes Command-Line-Tool irgendwie anders?

137
00:13:03,210 --> 00:13:06,210
Bei Java ist es glaube ich Minus-V oder so.

138
00:13:06,210 --> 00:13:09,210
Das kann man sich ja echt nicht merken.

139
00:13:09,210 --> 00:13:12,210
So, und Rust müssen wir auch gleich mal installieren.

140
00:13:12,210 --> 00:13:15,210
Nee, Rust ist schon installiert.

141
00:13:15,210 --> 00:13:27,540
So, und der Kompilierer für die deutsche Programmiersprache, oje.

142
00:13:27,540 --> 00:13:51,720
Ja, das mit dem einen Minus ist in der Go-Welt voll verbreitet.

143
00:13:51,720 --> 00:13:53,720
Ich verstehe es ehrlich gesagt nicht.

144
00:13:53,720 --> 00:13:56,720
Man hätte sich da ein bisschen an Lilux-Standards halten können.

145
00:13:56,720 --> 00:14:01,720
Und Lilux-Standard ist Minus Minus ausgeschrieben, einfaches Minus mit Abkürzung.

146
00:14:02,720 --> 00:14:06,720
Aber Go hat sich gedacht, scheiß drauf, wir lassen das einfach.

147
00:14:06,720 --> 00:14:16,820
Wobei, in dem Fall ist es ja sogar nicht nur einfaches Minus, sondern sogar ganz ohne Minus, also Sub-Command.

148
00:14:18,820 --> 00:14:23,820
Leute, wartet mal, ich muss mal kurz Wasser ins Auge machen, ey.

149
00:14:23,820 --> 00:15:17,160
I-Champ gefixt, hoffe ich.

150
00:15:17,160 --> 00:15:21,940
Ja, bei Git ist es auch so.

151
00:15:21,940 --> 00:15:23,940
Wobei, bei Git bin ich es gewöhnt.

152
00:15:23,940 --> 00:15:27,940
Gar nicht so schlimm, da muss ich einfach nur dran gewöhnen, dass Sub-Commands sind.

153
00:15:27,940 --> 00:15:32,940
Aber Version finde ich halt doof als Sub-Command, Minus Minus Version ist einfach viel intuitiver.

154
00:15:32,940 --> 00:15:37,830
So, also das ist das erste, was ich ausprobieren will.

155
00:15:37,830 --> 00:15:42,830
Ob Go-Interop mit anderen Sprachen immer noch so langsam ist.

156
00:15:42,830 --> 00:15:46,830
Und dann, ja, dann kam das nächste, wie ich auf Rust gekommen bin.

157
00:15:46,830 --> 00:15:54,830
Ich hab gesehen, dass es eine Rust-Reimplementation von dieser Go-Library gibt in Rust.

158
00:15:54,830 --> 00:16:00,830
Also das Ding ist ziemlich beliebt, 11.900 Sterne und das da 3.500 Sterne.

159
00:16:00,830 --> 00:16:02,830
Also fast so viel wie der Fiat-Champ.

160
00:16:02,830 --> 00:16:16,260
Hat da jemand sein Issue geschlossen, kann das sein?

161
00:16:16,260 --> 00:16:20,260
Guck mal, ich sag doch, keine Fehler, keine Fehler im Fiat-Champ.

162
00:16:20,260 --> 00:16:30,180
Einfach immer, versteht keiner, wie man es verwendet.

163
00:16:30,180 --> 00:16:36,180
So, und dann habe ich gefunden, dass es eine Reimplementierung von dieser WebRTC-Library in Rust gibt.

164
00:16:36,180 --> 00:16:40,180
Und dann habe ich mir überlegt, okay, jetzt wäre es doch mal an der Zeit,

165
00:16:40,180 --> 00:16:44,180
bevor ich irgendwie eine der beiden Libraries benutze,

166
00:16:44,180 --> 00:16:49,180
mal zu gucken, was sich prinzipiell angenehmer aus .NET aufrufen lässt.

167
00:16:49,180 --> 00:16:51,180
Rust oder Go.

168
00:16:51,180 --> 00:16:55,180
Ich persönlich tippe drauf, dass es meilenweit Rust sein wird.

169
00:16:55,180 --> 00:17:01,180
Sowohl easier zu benutzen als auch, also nicht zu schreiben, sondern anzusprechen,

170
00:17:01,180 --> 00:17:07,180
als auch deutlich höhere Performance vom Callen von C-Sharp aus.

171
00:17:07,180 --> 00:17:09,180
Aber so ganz sicher bin ich mir nicht.

172
00:17:09,180 --> 00:17:12,180
Ich gehe aber davon aus, dass Rust meilenweit vorne sein wird.

173
00:17:12,180 --> 00:17:16,180
Das Problem an Rust ist, dass Rust absolut abfuck zu schreiben ist.

174
00:17:16,180 --> 00:17:21,180
Aber der Interop mit C-Sharp sollte schneller sein.

175
00:17:21,180 --> 00:17:25,180
Deswegen probieren wir das jetzt überhaupt gar nicht, Leute.

176
00:17:25,180 --> 00:17:32,180
Ich bin ja schon seit MW1 der Meinung, dass das Kreativität komplett bankrott dort ist.

177
00:17:32,180 --> 00:17:37,180
MW2 war schon nochmal der Aufguss des Remake-Aufgusses.

178
00:17:37,180 --> 00:17:39,180
Und MW3 komplett.

179
00:17:39,180 --> 00:17:42,180
Ich habe heute bei Huskers in den Stream reingeguckt,

180
00:17:42,180 --> 00:17:46,180
habe festgestellt, die haben zwar teilweise Karten dabei,

181
00:17:46,180 --> 00:17:54,180
aber das Gameplay, was ich sehe, ist das gleiche Up-Aim-MW1-Reboot-Gameplay

182
00:17:54,180 --> 00:18:00,180
mit ultrahoher Time-to-Kill, also niedriger, niedriger, nicht hoher, niedriger Time-to-Kill.

183
00:18:00,180 --> 00:18:09,610
Also ich habe mir null davon angeguckt, das interessiert mich nicht und ich werde es mir auch nicht kaufen.

184
00:18:09,610 --> 00:18:11,610
Findest du ernsthaft? Ich finde Rust ist eklig.

185
00:18:11,610 --> 00:18:14,610
Ich meine, sowohl Go als auch Rust sind jetzt nicht gerade die schönsten Sprachen,

186
00:18:14,610 --> 00:18:16,610
aber ich finde Rust extrem umständlich.

187
00:18:16,610 --> 00:18:18,610
Deswegen werden wir das jetzt mal ausprobieren.

188
00:18:18,610 --> 00:18:20,610
So, also, was gibt es hier?

189
00:18:20,610 --> 00:18:26,610
Hey Max, kannst du eventuell berichten, wie es in dem Bankenwesen seine Ausbildung zum Anwendungsinformatiker zu machen?

190
00:18:26,610 --> 00:18:30,610
Weiß ich nicht, ich habe keine Ausbildung gemacht in der Finanzbranche,

191
00:18:30,610 --> 00:18:32,610
weder bei der Bank noch bei der Versicherung.

192
00:18:32,610 --> 00:18:36,610
Ich habe bei einem Internetprovider meine Ausbildung gemacht.

193
00:18:36,610 --> 00:18:47,700
Da hatte ich nicht direkt zumindest was damit zu tun.

194
00:18:47,700 --> 00:18:51,700
Nein, du solltest dich dort bewerben, wo die Stelle möglichst vielversprechend aussieht.

195
00:18:51,700 --> 00:18:55,700
Ich meine, der Laden, dass der dir vielleicht zusagen sollte, ist nicht verkehrt.

196
00:18:55,700 --> 00:18:58,700
Aber bewerb dich ruhig bei einer Bank oder bei einer Versicherung oder sowas.

197
00:18:58,700 --> 00:19:01,700
Finanzbranche ist gut, wenn du deinen Fuß in der Tür hast.

198
00:19:01,700 --> 00:19:06,700
Finanzbranche bezahlt mit Abstand am meisten, wenn man sich das anguckt.

199
00:19:06,700 --> 00:19:09,700
Es gibt so eine Tabelle.

200
00:19:09,700 --> 00:19:14,700
Ich glaube, das erste waren Banken, das zweite waren Versicherungen, das dritte war Pharmaindustrie in Deutschland.

201
00:19:14,700 --> 00:19:18,700
Ich glaube, das vierte Automobilindustrie oder sowas für IT-Kräfte.

202
00:19:18,700 --> 00:19:20,700
Es könnte auch umgedreht gewesen sein.

203
00:19:20,700 --> 00:19:23,700
Es könnte auch zuerst Automobil und dann Pharmaindustrie.

204
00:19:23,700 --> 00:19:26,700
Aber der erste Platz, der zweite Platz war auf jeden Fall Banken und das zweite war Versicherung.

205
00:19:26,700 --> 00:19:31,700
Das heißt, wenn du in der Finanzbranche irgendwie deinen Fuß in die Tür kriegst, ist sinnvoll.

206
00:19:31,700 --> 00:19:39,700
Und meistens sind die auch ein bisschen größer, was oftmals echt von Vorteil für die Ausbildung ist.

207
00:19:39,700 --> 00:19:42,700
Also je nachdem, was für eine kleine Klitsche das hier ist,

208
00:19:42,700 --> 00:19:47,700
da wird halt sehr viel so auf Gutmeinen gemacht.

209
00:19:47,700 --> 00:19:49,700
Ob es dann gut ist, weiß man nicht.

210
00:19:49,700 --> 00:19:56,700
Also bei den großen Läden kommt es halt weniger oft vor, dass keiner Plan hat, wie das bei einer Ausbildung laufen soll.

211
00:19:56,700 --> 00:19:59,700
Dass du keinen Ansprechpartner hast, dass sich keiner um dich kümmert und sowas.

212
00:19:59,700 --> 00:20:01,700
Das hast du bei großen Läden weniger.

213
00:20:01,700 --> 00:20:08,700
Und dann hast du in der Finanzbranche einen Fuß in der Tür, was immer gut ist, weil die bezahlen einfach gut.

214
00:20:08,700 --> 00:20:12,700
Also ganz ehrlich, wenn du die Möglichkeit hast, das zu machen, würde ich mir das angucken.

215
00:20:12,700 --> 00:20:38,760
So sieht es aus.

216
00:20:40,760 --> 00:20:42,760
Jetzt habe ich erklärt, was wir machen wollen.

217
00:20:42,760 --> 00:20:44,760
Jetzt probieren wir das Ganze mal aus.

218
00:20:44,760 --> 00:20:46,760
Also wir legen mal ein neues Projekt an.

219
00:20:46,760 --> 00:20:50,760
Also wie gesagt, wir fangen ganz simpel an.

220
00:20:50,760 --> 00:20:56,760
Wir machen ein Go-Projekt, exportieren dort eine Funktion, die nichts macht,

221
00:20:56,760 --> 00:21:04,760
rufen die FonziSharp auf und wir machen ein Rust-Projekt mit einer leeren Funktion

222
00:21:04,760 --> 00:21:10,760
und rufen die FonziSharp aus und dann benchmarken wir das erstmal und gucken, was da schneller ist.

223
00:21:10,760 --> 00:21:12,760
Beim reinen FunctionCall.

224
00:21:12,760 --> 00:21:16,760
Da wissen wir auch schon mal, dass das nicht daran liegt, dass die eine Sprache irgendwas besser kann,

225
00:21:16,760 --> 00:21:21,760
als die andere Sprache in der Implementierung, sondern einfach so der reine Funktionsaufruf.

226
00:21:21,760 --> 00:21:23,760
Mal gucken, wie schnell der ist.

227
00:21:23,760 --> 00:21:25,760
Ich würde erwarten, dass der saumäßig schnell ist.

228
00:21:25,760 --> 00:21:29,760
Vielleicht nicht so schnell wie ein Native-Aufruf, .net zu .net, aber immer noch schnell.

229
00:21:29,760 --> 00:21:37,760
Ich weiß aber aus Erfahrung, dass Go-Interop mit anderen Sprachen echt problematisch war in der Vergangenheit.

230
00:21:37,760 --> 00:21:42,760
Gerade wenn das was ist, was wirklich hunderttausendfach aufgerufen wird.

231
00:21:42,760 --> 00:22:04,750
Große Unternehmen haben Ausbildungsverantwortlichen, da passiert sowas eigentlich selten.

232
00:22:04,750 --> 00:22:09,880
Danke.

233
00:22:09,880 --> 00:22:11,880
Was ist für dich groß?

234
00:22:11,880 --> 00:22:13,880
50 Mann sind nicht groß.

235
00:22:14,880 --> 00:22:17,880
100 und 200 Mann sind auch nicht wirklich groß.

236
00:22:17,880 --> 00:22:29,930
Ich bin mir nicht sicher, ob das eine T-Bait-Frage ist oder ernst gemeint.

237
00:22:29,930 --> 00:22:33,930
Egal, ich sage dazu nichts, weil wenn ich damit anfange, dann höre ich halt nicht mehr auf.

238
00:22:33,930 --> 00:22:50,100
Das muss nicht sein.

239
00:22:50,100 --> 00:22:52,100
So, dann legen wir mal los.

240
00:22:52,100 --> 00:22:56,100
Ich lege mal ein neues BenchmarkChamp.

241
00:22:59,740 --> 00:23:02,740
Wir testen jetzt erstmal, wie schnell das Ganze ist.

242
00:23:02,740 --> 00:23:07,740
Und wenn das in Rust wirklich, und das ist ja zu erwarten, so viel schneller ist,

243
00:23:07,740 --> 00:23:11,740
dann werde ich demnächst mal etwas WebRTC in Rust programmieren.

244
00:23:11,740 --> 00:23:15,740
Wobei ich weiß jetzt schon, dass ich durchdrehen werde dabei.

245
00:23:15,740 --> 00:23:17,740
Ein gutes hat's, ein gutes hat's.

246
00:23:19,740 --> 00:23:25,740
Das ist quasi eine Rust-Reimplementation von der Go-Library hier.

247
00:23:25,740 --> 00:23:29,740
Das heißt, ich hoffe, wenn man die Go-Library ein bisschen kennt, kommt man hier auch ganz gut klar.

248
00:23:29,740 --> 00:23:37,080
Müssen wir mal schauen.

249
00:23:37,080 --> 00:23:40,520
Das ist ziemlich groß.

250
00:23:40,520 --> 00:23:45,520
Da gibt es doch eigentlich Ausbildungsbeauftragte und Leute, die dann einen Blick drauf machen.

251
00:23:45,520 --> 00:23:51,520
Also es ist selten, dass es so reingeschissen wird bei großen Unternehmen, was Ausbildung angeht.

252
00:23:51,520 --> 00:23:54,520
Das sehe ich eher gehäufter bei den kleinen.

253
00:23:54,520 --> 00:23:57,520
Okay, wir installieren mal eine neue .NET-Version.

254
00:23:57,520 --> 00:24:02,900
Wir haben mal Zeit, weil ich glaube, es gibt eine neue Preview-Version.

255
00:24:02,900 --> 00:24:04,900
Wenn ich das richtig sehe.

256
00:24:04,900 --> 00:24:11,900
Ja, es gibt 8.0.1, wobei 100 haben die glaube ich immer, RC2.

257
00:24:11,900 --> 00:24:14,900
RC2, 2.3.5.0.2.2.

258
00:24:14,900 --> 00:24:19,900
Sag mal, .NET-Team, wie viele Versionsnummern wollt ihr eigentlich noch haben?

259
00:24:19,900 --> 00:24:22,900
8.0, das lasse ich mir ja noch gefallen.

260
00:24:22,900 --> 00:24:27,900
8.0.100 ist schon ein bisschen pp-iger, aber auch noch okay.

261
00:24:27,900 --> 00:24:35,900
Aber 8.0.100-RC2.2.3.5.0.2.2.

262
00:24:35,900 --> 00:24:38,900
Also irgendwann ist auch mal gut.

263
00:24:38,900 --> 00:24:49,970
Also ich meine, bis hierhin geht es ja irgendwie noch halbwegs klar.

264
00:24:49,970 --> 00:24:52,970
Aber das dahinter ist schon komplett bescheuert.

265
00:24:52,970 --> 00:24:57,470
Das hat dann mit Semware auch nichts mehr zu tun.

266
00:24:57,470 --> 00:25:00,470
Das interessiert Microsoft eh nicht.

267
00:25:00,470 --> 00:25:03,470
Also, .NET-New-Console.

268
00:25:04,470 --> 00:25:07,470
Wir machen mal ein paar neue Ordner.

269
00:25:07,470 --> 00:25:15,100
Wir machen mkdir Rust, mkdir Go, mkdir Benchmark.

270
00:25:15,100 --> 00:25:21,100
Benchmark legen wir das .NET-Projekt an.

271
00:25:21,100 --> 00:25:23,100
Wow, der für Schmerzen.

272
00:25:23,100 --> 00:25:25,100
Blazer, wen interessiert Blazer?

273
00:25:25,100 --> 00:25:27,100
Wer auch immer das benutzt.

274
00:25:27,100 --> 00:25:31,100
Also Microsoft will das zur Zeit boosten wie sonst was.

275
00:25:32,100 --> 00:25:35,100
Aber auch wenn ich ein großer C-Sharp-Fan bin.

276
00:25:35,100 --> 00:25:38,100
Ehrlich, im Browser wie es bisher ist, brauche ich das nicht.

277
00:25:38,100 --> 00:25:41,100
So, dann haben wir hier Go und haben Rust.

278
00:25:41,100 --> 00:25:43,100
Dann kopieren wir uns mal das Verzeichnis.

279
00:25:43,100 --> 00:25:46,100
Und ich würde sagen, dann fangen wir mal ganz easy an.

280
00:25:46,100 --> 00:25:51,820
Öffnen wir das mal in Rider.

281
00:25:51,820 --> 00:25:58,060
Und tun mal so, als wüssten wir was wir machen.

282
00:25:58,060 --> 00:26:00,060
So, Repos, wie habe ich das genannt?

283
00:26:00,060 --> 00:26:02,060
Nicht Backup.

284
00:26:02,060 --> 00:26:05,060
Benchmark, Champ.

285
00:26:06,060 --> 00:26:08,060
Hier, da, öffnen.

286
00:26:08,060 --> 00:26:15,100
So, hier auf dem vierten Bildschirm machen wir Go Land auf.

287
00:26:15,100 --> 00:26:17,100
Und auf dem fünften, auf dem fünften.

288
00:26:17,100 --> 00:26:19,100
Boah, das kostet RAM, Leute.

289
00:26:19,100 --> 00:26:21,100
Das kostet RAM, Alter.

290
00:26:21,100 --> 00:26:23,100
Drei JetBrains Ideen ist offen.

291
00:26:23,100 --> 00:26:26,100
Ihr MonkaS Javer, Alter.

292
00:26:26,100 --> 00:26:29,100
Und hier machen wir das Rust-Ding auf.

293
00:26:29,100 --> 00:26:32,980
I confirm that I have Red X.

294
00:26:32,980 --> 00:26:34,980
Ja, ja, ja, ich konfirme.

295
00:26:34,980 --> 00:26:36,980
Ich konfirme alles hier.

296
00:26:36,980 --> 00:26:38,980
Wir wollen nichts senden.

297
00:26:39,980 --> 00:26:41,980
Rust-Version detected.

298
00:26:41,980 --> 00:26:43,980
173.0

299
00:26:43,980 --> 00:26:45,980
Perfekt, top.

300
00:26:45,980 --> 00:26:48,980
Wir wollen allerdings Location Repos.

301
00:26:48,980 --> 00:26:50,980
Benchmark, Champ.

302
00:26:50,980 --> 00:26:52,980
Rust.

303
00:26:52,980 --> 00:26:54,980
Da wollen wir rein.

304
00:26:54,980 --> 00:26:56,980
Binary Application.

305
00:26:56,980 --> 00:26:58,980
Standard Library.

306
00:26:58,980 --> 00:27:00,980
Egal.

307
00:27:00,980 --> 00:27:02,980
Die Standard Library von dieser Version halt.

308
00:27:02,980 --> 00:27:04,980
Ich weiß nicht, wo die ist.

309
00:27:04,980 --> 00:27:06,980
Rust.

310
00:27:07,980 --> 00:27:12,320
Let's go.

311
00:27:12,320 --> 00:27:14,320
Oh, geht ja gut los.

312
00:27:14,320 --> 00:27:16,320
Erstmal Minischrift.

313
00:27:16,320 --> 00:27:18,320
Und als nächstes irgendwelche komischen Errors.

314
00:27:18,320 --> 00:27:20,320
Nice.

315
00:27:20,320 --> 00:27:22,320
Rust am Start.

316
00:27:22,320 --> 00:27:24,320
Cargo failed.

317
00:27:24,320 --> 00:27:26,320
Sync Rust Project.

318
00:27:26,320 --> 00:27:28,320
Retrieving Rust Standard Lib.

319
00:27:28,320 --> 00:27:30,320
Hä, warum muss er die noch retrieven, bitteschön?

320
00:27:30,320 --> 00:27:32,320
Rust kommt mit der Standard Library dabei.

321
00:27:32,320 --> 00:27:34,320
Deswegen heißt es Standard Library.

322
00:27:34,320 --> 00:27:36,320
Rust up not found.

323
00:27:36,320 --> 00:27:42,930
Ja, und jetzt?

324
00:27:42,930 --> 00:27:44,930
Kann das sein, dass der Rust up braucht?

325
00:27:44,930 --> 00:27:46,930
Damit das hier funktioniert?

326
00:27:46,930 --> 00:27:48,930
Ich kann auch Rust up installieren, wenn es sein muss.

327
00:27:48,930 --> 00:27:50,930
Ja, easy.

328
00:27:50,930 --> 00:27:55,330
Rust up.

329
00:27:55,330 --> 00:27:57,330
Installieren wir Rust up, auch gut.

330
00:27:57,330 --> 00:27:59,330
Deinstallieren wir Rust, installieren wir Rust up.

331
00:27:59,330 --> 00:28:01,330
Top.

332
00:28:01,330 --> 00:28:03,330
Ist jetzt Cargo und so da?

333
00:28:03,330 --> 00:28:09,580
Was?

334
00:28:09,580 --> 00:28:11,580
Run Rust Default Stable.

335
00:28:11,580 --> 00:28:13,580
Okay, nice.

336
00:28:13,580 --> 00:28:15,580
Das mag ich.

337
00:28:15,580 --> 00:28:17,580
Das mag ich an Rust.

338
00:28:17,580 --> 00:28:19,580
Also unabhängig davon, dass die Sprache ein bisschen eklig zu schreiben ist.

339
00:28:19,580 --> 00:28:21,580
Die Command-Line-Tools

340
00:28:21,580 --> 00:28:23,580
und das wie das ausgeliefert ist,

341
00:28:23,580 --> 00:28:27,660
ist wirklich ziemlich gut gemacht.

342
00:28:27,660 --> 00:28:29,660
Das Ziel ist, sowohl Rust

343
00:28:29,660 --> 00:28:31,660
als auch Go aus die Sharp aus aufzurufen

344
00:28:31,660 --> 00:28:33,660
mit C-Interface und zu gucken, was

345
00:28:33,660 --> 00:28:35,660
schneller ist.

346
00:28:35,660 --> 00:28:37,660
Nur in diesem einen Fall.

347
00:28:37,660 --> 00:28:39,660
Also jetzt nicht die Sprache an sich,

348
00:28:39,660 --> 00:28:41,660
da dürfte Rust vorne liegen,

349
00:28:41,660 --> 00:28:43,660
sondern nur das Aufrufen aus der

350
00:28:43,660 --> 00:28:45,660
anderen Programmiersprache aus.

351
00:28:45,660 --> 00:28:47,660
Da dürfte allerdings Rust auch meilenweit vorne liegen,

352
00:28:47,660 --> 00:28:49,660
weil Go ist mega langsam.

353
00:28:49,660 --> 00:28:51,660
Interop mit anderen Sprachen.

354
00:28:51,660 --> 00:28:53,660
Zumindest war das in der Vergangenheit so.

355
00:28:53,660 --> 00:28:55,660
Es wird aufgerufen

356
00:28:55,660 --> 00:28:57,660
C-Sharp nach Go und C-Sharp nach Rust.

357
00:28:57,660 --> 00:28:59,660
Es wird nicht C-Sharp Go Rust aufgerufen.

358
00:28:59,660 --> 00:29:01,660
Es wird C-Sharp nach Go

359
00:29:01,660 --> 00:29:03,660
und dann C-Sharp nach Rust aufgerufen.

360
00:29:03,660 --> 00:29:05,660
Ich tippe einfach, dass Rust

361
00:29:05,660 --> 00:29:07,660
in allen Belangen komplett

362
00:29:07,660 --> 00:29:09,660
meilenweit ahead of Go ist,

363
00:29:09,660 --> 00:29:11,660
weil Go bekannt dafür ist, dass Go langsam ist

364
00:29:11,660 --> 00:29:13,660
als Interop mit anderen Sprachen.

365
00:29:13,660 --> 00:29:15,660
Also langsamer als ziemlich jede andere

366
00:29:15,660 --> 00:29:17,660
technisch bekannte Programmiersprache.

367
00:29:17,660 --> 00:29:19,660
Und Go ist super langsam, was das angeht.

368
00:29:19,660 --> 00:29:21,660
Also das ist langsamer

369
00:29:21,660 --> 00:29:23,660
als so ziemlich jede andere Sprache,

370
00:29:23,660 --> 00:29:25,660
die mir so einfällt.

371
00:29:25,660 --> 00:29:27,660
Das ist langsamer als

372
00:29:27,660 --> 00:29:29,660
Python, also nur in diesem

373
00:29:29,660 --> 00:29:31,660
einen Fall.

374
00:29:31,660 --> 00:29:33,660
Also Callen von und nach

375
00:29:33,660 --> 00:29:35,660
anderen Sprachen über irgendeinen

376
00:29:35,660 --> 00:29:37,660
C-Interface.

377
00:29:37,660 --> 00:29:39,660
Das ist langsamer als Python, als Java,

378
00:29:39,660 --> 00:29:41,660
als alles.

379
00:29:41,660 --> 00:29:43,660
Einfach nur Javascript.

380
00:29:43,660 --> 00:29:45,660
Das ist wirklich,

381
00:29:45,660 --> 00:29:47,660
Go ansonsten ist ja recht flott,

382
00:29:47,660 --> 00:29:49,660
aber in dem Bereich ist es wirklich

383
00:29:49,660 --> 00:29:51,660
pepega langsam.

384
00:29:51,660 --> 00:29:53,660
So, also, hat es jetzt,

385
00:29:53,660 --> 00:29:55,660
jetzt starten wir nochmal dieses Rusting,

386
00:29:55,660 --> 00:29:57,660
ob das jetzt besser funktioniert, nachdem ich

387
00:29:57,660 --> 00:30:01,810
Rustup installiert hab.

388
00:30:01,810 --> 00:30:03,810
Ja nice, scheint zu funktionieren.

389
00:30:03,810 --> 00:30:05,810
Was hat Go für Vorteile?

390
00:30:05,810 --> 00:30:07,810
Go hat

391
00:30:07,810 --> 00:30:09,810
ein paar Vorteile. Zum Beispiel

392
00:30:09,810 --> 00:30:11,810
ist Go relativ flott.

393
00:30:11,810 --> 00:30:13,810
Wie gesagt, was langsam ist,

394
00:30:13,810 --> 00:30:15,810
ist ja nur diese eine Sache, die ich gerade

395
00:30:15,810 --> 00:30:17,810
gesagt habe. Champ, schön vielen Dank für den

396
00:30:17,810 --> 00:30:19,810
Sub. Ansonsten

397
00:30:19,810 --> 00:30:21,810
ist Go relativ flott.

398
00:30:21,810 --> 00:30:23,810
Go ist richtig

399
00:30:23,810 --> 00:30:25,810
gut, wenn man self-contained

400
00:30:25,810 --> 00:30:27,810
binaries haben möchte, die rückwärtskompatibel

401
00:30:27,810 --> 00:30:29,810
einfach auf jedem Linux-System laufen.

402
00:30:29,810 --> 00:30:31,810
Da ist Go so ziemlich die beste Sprache,

403
00:30:31,810 --> 00:30:33,810
die es gibt, die existiert, die man dafür

404
00:30:33,810 --> 00:30:35,810
benutzen kann.

405
00:30:35,810 --> 00:30:37,810
Auch im Cloud-Umfeld

406
00:30:37,810 --> 00:30:39,810
ist Go

407
00:30:39,810 --> 00:30:41,810
sehr beliebt. Warum kann ich die

408
00:30:41,810 --> 00:30:43,810
Preise nicht ändern?

409
00:30:43,810 --> 00:30:55,180
Und? Ach, jetzt geht es

410
00:30:55,180 --> 00:30:58,560
auf einmal, okay.

411
00:30:58,560 --> 00:31:00,560
JetBrains Mono, meinetwegen.

412
00:31:00,560 --> 00:31:02,560
Aber

413
00:31:02,560 --> 00:31:04,560
ich glaube, die Schriftgröße ist ganz okay,

414
00:31:04,560 --> 00:31:06,560
oder? Ich glaube,

415
00:31:06,560 --> 00:31:08,560
Chatgy, ich muss mal kurz

416
00:31:08,560 --> 00:31:10,560
in meiner Vorschau gucken. Ja, die Schriftgröße ist

417
00:31:10,560 --> 00:31:12,560
gut. Ich sehe das gerade hier in der Vorschau,

418
00:31:12,560 --> 00:31:14,560
die ist okay, da kann man nichts sagen.

419
00:31:14,560 --> 00:31:16,560
Das ist eigentlich sehr

420
00:31:16,560 --> 00:31:18,560
angenehm zu lesen gerade. Ich gucke mir das gerade

421
00:31:18,560 --> 00:31:20,560
auf dem Vorschau-Monitor an.

422
00:31:20,560 --> 00:31:22,560
Auch nettes,

423
00:31:22,560 --> 00:31:24,560
recht nicht so ins Auge

424
00:31:24,560 --> 00:31:26,560
brennende Dark-Theme dabei,

425
00:31:26,560 --> 00:31:30,450
das ist okay. So,

426
00:31:30,450 --> 00:31:32,450
Main Print Hello World, ja, das kommt schon mal weg.

427
00:31:32,450 --> 00:31:34,450
Wir brauchen gar keine Main-Funktion.

428
00:31:34,450 --> 00:31:36,450
Ach so, ja, Moment.

429
00:31:36,450 --> 00:31:38,450
Ich muss das ja umstellen auf eine Library.

430
00:31:38,450 --> 00:31:40,450
Wir legen erst mal das Go-Projekt

431
00:31:40,450 --> 00:31:42,450
an. Was haben wir hier noch offen?

432
00:31:42,450 --> 00:31:44,450
New Session, New Message,

433
00:31:44,450 --> 00:31:49,040
Create Session,

434
00:31:49,040 --> 00:31:52,800
New Sender. Ach so, ah,

435
00:31:52,800 --> 00:31:54,800
ich weiß, das ist, ja, ja, ja, das

436
00:31:54,800 --> 00:31:56,800
haben wir mal gebaut. Das können wir wegmachen.

437
00:31:56,800 --> 00:31:58,800
Da müssen wir ein neues

438
00:31:58,800 --> 00:32:00,800
Projekt anlegen.

439
00:32:00,800 --> 00:32:02,800
Also legen wir ein neues Go-Projekt an.

440
00:32:02,800 --> 00:32:06,300
Wo ist das hier? Go,

441
00:32:06,300 --> 00:32:08,300
New, Project.

442
00:32:08,300 --> 00:32:10,300
Und zwar

443
00:32:10,300 --> 00:32:12,300
wollen wir nach Repos

444
00:32:12,300 --> 00:32:14,300
Benchmark

445
00:32:14,300 --> 00:32:16,300
Champ Go. Und jetzt

446
00:32:16,300 --> 00:32:18,300
wollen wir ein Go-Modules

447
00:32:18,300 --> 00:32:20,300
Projekt anlegen. Ich glaube, das macht er

448
00:32:20,300 --> 00:32:22,300
standardmäßig.

449
00:32:22,300 --> 00:32:24,300
Was ist Enable Vendoring Support?

450
00:32:24,300 --> 00:32:41,280
Äh,

451
00:32:41,280 --> 00:32:43,280
verstehe ich nicht.

452
00:32:43,280 --> 00:32:45,280
Sollte ich das an- oder ausschalten?

453
00:32:45,280 --> 00:32:47,280
Ich verstehe die Hilfe

454
00:32:47,280 --> 00:32:49,280
nicht. Kann weg.

455
00:32:49,280 --> 00:32:51,280
Ich habe keine Ahnung, was es mir überhaupt sagen

456
00:32:51,280 --> 00:32:58,300
soll, ehrlich gesagt.

457
00:32:58,300 --> 00:33:00,300
Okay, ihr habt auch keine Ahnung. Wenn der Chat

458
00:33:00,300 --> 00:33:05,150
keine Ahnung hat, dann beruhigt mich das immer.

459
00:33:05,150 --> 00:33:07,150
Okay, Create,

460
00:33:07,150 --> 00:33:12,130
this Window, Close.

461
00:33:12,130 --> 00:33:14,130
So, jetzt muss ich erst mal gucken, dass ich wieder ein bisschen

462
00:33:14,130 --> 00:33:16,130
anfange, Go zu checken.

463
00:33:16,130 --> 00:33:18,130
Go war doch so.

464
00:33:18,130 --> 00:33:20,130
So, wir gehen jetzt mal Repo,

465
00:33:20,130 --> 00:33:22,130
Benchmark Champ,

466
00:33:22,130 --> 00:33:24,130
Go. Und jetzt

467
00:33:24,130 --> 00:33:26,130
sagen wir

468
00:33:26,130 --> 00:33:28,130
Go Run. Und dann

469
00:33:28,130 --> 00:33:30,130
kackts ab. Weil,

470
00:33:30,130 --> 00:33:32,130
Missing Go Version in Modload.

471
00:33:32,130 --> 00:33:38,290
Nice.

472
00:33:38,290 --> 00:33:40,290
Achso, es fehlt ne Main, oder?

473
00:33:40,290 --> 00:33:42,290
Es fehlt einfach ne Main-Datei.

474
00:33:42,290 --> 00:33:44,290
Dann ist die Fehlermeldung, aber ppga.svg.

475
00:33:44,290 --> 00:33:46,290
Also New Go File

476
00:33:46,290 --> 00:33:48,290
Main.go

477
00:33:48,290 --> 00:33:50,290
Package.

478
00:33:50,290 --> 00:33:52,290
Moment, warum

479
00:33:52,290 --> 00:33:54,290
heißt das Projekt Go? Das ergibt doch

480
00:33:54,290 --> 00:33:56,290
gar keinen Sinn. Das Projekt

481
00:33:56,290 --> 00:33:58,290
soll heißen...

482
00:33:58,290 --> 00:34:00,290
Achso, das heißt so wie der Ordner.

483
00:34:00,290 --> 00:34:02,290
Und das hier heißt auch Rust.

484
00:34:02,290 --> 00:34:04,290
Das ist ja egal. Es sollte durchaus auch okay sein,

485
00:34:04,290 --> 00:34:06,290
dass das heißt. So, Package

486
00:34:06,290 --> 00:34:08,290
Main muss das ja sein.

487
00:34:08,290 --> 00:34:10,290
Weil wir sind ja hier in Go. Und dann brauchen wir

488
00:34:10,290 --> 00:34:12,290
Function

489
00:34:12,290 --> 00:34:14,290
Main. Und dann sagen wir so was wie

490
00:34:14,290 --> 00:34:16,290
fmt.brindln.

491
00:34:16,290 --> 00:34:18,290
kack wait.

492
00:34:18,290 --> 00:34:20,290
So, und das sollte jetzt kompilieren, oder?

493
00:34:20,290 --> 00:34:22,290
Nein. Warum nicht?

494
00:34:22,290 --> 00:34:30,140
Das darf bestimmt nicht so heißen,

495
00:34:30,140 --> 00:34:32,140
oder? Das ist bestimmt ppga.

496
00:34:32,140 --> 00:34:34,140
Weil der Ordner Go heißt. Garantiert

497
00:34:34,140 --> 00:34:36,140
kann das das nicht ab, weil der Ordner Go heißt.

498
00:34:36,140 --> 00:34:38,140
Könnte ich wetten mit euch.

499
00:34:38,140 --> 00:34:40,140
Was? Go mod init?

500
00:34:40,140 --> 00:34:42,140
Das muss man doch normalerweise nie machen.

501
00:34:42,140 --> 00:34:44,140
Äh.

502
00:34:44,140 --> 00:34:46,140
Mod?

503
00:34:46,140 --> 00:34:48,140
Already exists.

504
00:34:48,140 --> 00:34:50,140
Das ist 100 Pro. Ich wette mit euch.

505
00:34:50,140 --> 00:34:52,140
Das ist, weil der Ordner

506
00:34:52,140 --> 00:34:58,850
Go heißt.

507
00:34:58,850 --> 00:35:00,850
Go hat so komische Dinger.

508
00:35:00,850 --> 00:35:04,930
Das kann ich mir richtig gut vorstellen.

509
00:35:04,930 --> 00:35:06,930
Wir löschen das nochmal.

510
00:35:06,930 --> 00:35:14,590
Man zieht ja ins Terminal nicht.

511
00:35:14,590 --> 00:35:16,590
Ja, in dem Fall gibt es da eh nichts.

512
00:35:16,590 --> 00:35:18,590
Wir löschen das nochmal.

513
00:35:18,590 --> 00:35:20,590
Und machen mktl go app. Okay?

514
00:35:20,590 --> 00:35:22,590
So, das sollte

515
00:35:22,590 --> 00:35:24,590
nicht problematisch sein.

516
00:35:24,590 --> 00:35:31,100
Also, new project.

517
00:35:31,100 --> 00:35:33,100
Jetzt hat er das schon wieder.

518
00:35:33,100 --> 00:35:35,100
Jetzt lasse ich das mal enabled.

519
00:35:35,100 --> 00:35:39,760
Vielleicht macht es das dann richtig.

520
00:35:39,760 --> 00:35:41,760
Wir wollen nach benchmark champ

521
00:35:41,760 --> 00:35:43,760
go app

522
00:35:43,760 --> 00:35:45,760
und eigentlich da rein direkt. Genau.

523
00:35:45,760 --> 00:35:47,760
Create.

524
00:35:47,760 --> 00:35:51,970
Und jetzt sage ich

525
00:35:51,970 --> 00:35:53,970
go app

526
00:35:53,970 --> 00:35:55,970
go run Punkt.

527
00:35:55,970 --> 00:35:57,970
Jetzt funktioniert es auch.

528
00:35:57,970 --> 00:35:59,970
Ich weiß jetzt nicht, ob das an diesem automatischen

529
00:35:59,970 --> 00:36:01,970
Vendoring Support lag, was auch immer das macht.

530
00:36:01,970 --> 00:36:03,970
Oder weil das Ding...

531
00:36:03,970 --> 00:36:05,970
Ich tippe auf den Ordner Namen.

532
00:36:05,970 --> 00:36:07,970
Bei Go weißt du nie.

533
00:36:07,970 --> 00:36:09,970
Go hat so viele Magic Sachen,

534
00:36:09,970 --> 00:36:11,970
weil sie so sein müssen.

535
00:36:11,970 --> 00:36:13,970
Beispielsweise auch Klammern bei einem if oder so.

536
00:36:13,970 --> 00:36:15,970
Dass ich mir das gut vorstellen kann.

537
00:36:15,970 --> 00:36:19,280
Main Punkt Go.

538
00:36:19,280 --> 00:36:21,280
Das ist auch merkwürdig gemacht,

539
00:36:21,280 --> 00:36:23,280
dass das nicht so heißen darf wie die App.

540
00:36:23,280 --> 00:36:25,280
So, und jetzt machen wir hier

541
00:36:25,280 --> 00:36:27,280
Function main

542
00:36:27,280 --> 00:36:29,280
fmt prindeln

543
00:36:29,280 --> 00:36:31,280
check wait.

544
00:36:31,280 --> 00:36:35,490
Das sollte jetzt funktionieren.

545
00:36:35,490 --> 00:36:37,490
Okay, nice. Funktioniert.

546
00:36:37,490 --> 00:36:39,490
Mal kurz checken, ob Rust auch funktioniert.

547
00:36:39,490 --> 00:36:42,800
Seht ihr das Terminal hier,

548
00:36:42,800 --> 00:36:44,800
wenn ich da was tippe?

549
00:36:44,800 --> 00:36:46,800
Hier unten. Sieht man das?

550
00:36:46,800 --> 00:36:48,800
Da ist der Chat davor, gell?

551
00:36:48,800 --> 00:36:50,800
Dann machen wir es so.

552
00:36:50,800 --> 00:36:54,110
Dann seht ihr es auf jeden Fall.

553
00:36:54,110 --> 00:36:56,110
Jetzt ist genug Platz unter Chico

554
00:36:56,110 --> 00:36:58,110
hier rechts. Da sieht man nichts.

555
00:36:58,110 --> 00:37:00,110
Dann machen wir auch das Terminal

556
00:37:00,110 --> 00:37:02,110
hier unten drunter.

557
00:37:02,110 --> 00:37:04,110
So, ja.

558
00:37:04,110 --> 00:37:06,110
Also Repos, Benchmark,

559
00:37:06,110 --> 00:37:08,110
Champ, Rust.

560
00:37:08,110 --> 00:37:10,110
Und jetzt machen wir mal,

561
00:37:10,110 --> 00:37:12,110
ich glaube Cargo run ist es.

562
00:37:12,110 --> 00:37:14,110
Okay, Rust

563
00:37:14,110 --> 00:37:16,110
kompiliert fehlerfrei.

564
00:37:16,110 --> 00:37:18,110
Erstmal im Kalender anmarken.

565
00:37:18,110 --> 00:37:20,110
Tja,

566
00:37:20,110 --> 00:37:22,110
jetzt geht es schon los.

567
00:37:22,110 --> 00:37:24,110
Ich glaube,

568
00:37:24,110 --> 00:37:26,110
es ist prindeln, ne?

569
00:37:26,110 --> 00:37:29,680
Auch in Rust.

570
00:37:29,680 --> 00:37:31,680
Check wait.

571
00:37:31,680 --> 00:37:36,210
Okay, ja. Funktioniert. Nice.

572
00:37:36,210 --> 00:37:38,210
Okay, also.

573
00:37:38,210 --> 00:37:40,210
Jetzt kommt das nächste.

574
00:37:40,210 --> 00:37:42,210
Also das ist jetzt ja einfach nur,

575
00:37:42,210 --> 00:37:44,210
um zu gucken, ob alles richtig aufgesetzt ist.

576
00:37:44,210 --> 00:37:48,670
So, also.

577
00:37:48,670 --> 00:37:50,670
Was hat er hier für Schmerzen?

578
00:37:50,670 --> 00:37:52,670
Could not load.

579
00:37:52,670 --> 00:37:54,670
Ah, ja.

580
00:37:54,670 --> 00:37:56,670
Das liegt,

581
00:37:56,670 --> 00:38:02,290
nicht toll sein Bild.

582
00:38:02,290 --> 00:38:04,290
Das liegt daran, dass er meine .NET Version

583
00:38:04,290 --> 00:38:06,290
nicht erkannt hat. Warum auch immer.

584
00:38:06,290 --> 00:38:08,290
Reload project.

585
00:38:08,290 --> 00:38:10,290
Jetzt sollte es hoffentlich gleich gehen.

586
00:38:10,290 --> 00:38:12,290
Machen wir auch nochmal

587
00:38:12,290 --> 00:38:14,290
eine Konsole auf.

588
00:38:14,290 --> 00:38:16,290
CD, Repos, Benchmark,

589
00:38:16,290 --> 00:38:19,790
.NET,

590
00:38:19,790 --> 00:38:21,790
Run.

591
00:38:23,790 --> 00:38:25,790
Ja, Funzt. Okay.

592
00:38:25,790 --> 00:38:27,790
Alles klar.

593
00:38:27,790 --> 00:38:29,790
Also, was ich jetzt vorhabe, ist folgendes.

594
00:38:29,790 --> 00:38:31,790
Ich möchte jetzt sowas hier machen.

595
00:38:31,790 --> 00:38:33,790
Ich will jetzt, wir brauchen,

596
00:38:33,790 --> 00:38:35,790
wir machen mal

597
00:38:35,790 --> 00:38:37,790
den .NET Teil.

598
00:38:37,790 --> 00:38:39,790
Als erstes und dann den anderen.

599
00:38:39,790 --> 00:38:41,790
Wir machen jetzt mal eine Datei interop.cs

600
00:38:41,790 --> 00:38:43,790
Die kriegt

601
00:38:43,790 --> 00:38:45,790
eine public,

602
00:38:45,790 --> 00:38:47,790
eine uns,

603
00:38:47,790 --> 00:38:49,790
eine unsafe public

604
00:38:49,790 --> 00:38:51,790
static class.

605
00:38:51,790 --> 00:38:53,790
Warum unsafe?

606
00:38:53,790 --> 00:38:55,790
Naja, weil ich

607
00:38:55,790 --> 00:38:57,790
zähe Sachen mit Pointern und so in anderen Sprachen

608
00:38:57,790 --> 00:38:59,790
aufrufen will. Also das muss unsafe sein.

609
00:38:59,790 --> 00:39:01,790
Und damit das funktioniert,

610
00:39:01,790 --> 00:39:03,790
muss ich unsafe

611
00:39:03,790 --> 00:39:05,790
erlauben.

612
00:39:05,790 --> 00:39:07,790
Ich weiß eh nicht, warum das nicht standardmäßig

613
00:39:07,790 --> 00:39:09,790
an ist. Ich meine, wenn man es nicht verwendet, verwendet man es

614
00:39:09,790 --> 00:39:13,550
halt nicht. So.

615
00:39:13,550 --> 00:39:15,550
Und jetzt

616
00:39:15,550 --> 00:39:17,550
will ich beispielsweise sowas hier

617
00:39:17,550 --> 00:39:19,550
aufrufen.

618
00:39:19,550 --> 00:39:21,550
DLL-Import

619
00:39:21,550 --> 00:39:23,550
von, ja,

620
00:39:23,550 --> 00:39:25,550
RustLib

621
00:39:25,550 --> 00:39:27,550
will ich aufrufen.

622
00:39:27,550 --> 00:39:29,550
Eine Funktion, die

623
00:39:29,550 --> 00:39:31,550
boah, DLL-Import-Syntax

624
00:39:31,550 --> 00:39:33,550
Moment. Muss ich mir abgucken.

625
00:39:33,550 --> 00:39:35,550
Ich glaube, static-extern

626
00:39:35,550 --> 00:39:37,550
oder irgendwie so muss das aussehen.

627
00:39:37,550 --> 00:39:39,550
Public

628
00:39:39,550 --> 00:39:41,550
static-extern, genau.

629
00:39:41,550 --> 00:39:46,270
So, public static-extern.

630
00:39:46,270 --> 00:39:48,270
Das heißt ja hier irgendwie

631
00:39:48,270 --> 00:39:50,270
call me, so.

632
00:39:50,270 --> 00:39:52,270
Einfach nur call heißt das Ding.

633
00:39:52,270 --> 00:39:54,270
Also, was das macht,

634
00:39:54,270 --> 00:39:56,270
was noch nicht geht, weil es ist noch nicht da.

635
00:39:56,270 --> 00:39:58,270
Damit kann ich jetzt aus C-Sharp

636
00:39:58,270 --> 00:40:00,270
eine Funktion aufrufen,

637
00:40:00,270 --> 00:40:02,270
die in Rust, in einer

638
00:40:02,270 --> 00:40:05,780
Library, in einer

639
00:40:05,780 --> 00:40:07,780
Rust-Library, die mit C-Interface

640
00:40:07,780 --> 00:40:09,780
kompiliert wurde, existiert.

641
00:40:09,780 --> 00:40:11,780
Aufrufen.

642
00:40:11,780 --> 00:40:13,780
Void fehlt noch.

643
00:40:13,780 --> 00:40:15,780
Und hiermit

644
00:40:15,780 --> 00:40:17,780
kann ich, achso, die sollte ich vielleicht

645
00:40:17,780 --> 00:40:19,780
ein bisschen anders nennen.

646
00:40:19,780 --> 00:40:21,780
Call me Rust

647
00:40:21,780 --> 00:40:23,780
Call, oder einfach nur

648
00:40:23,780 --> 00:40:27,220
Call Go.

649
00:40:27,220 --> 00:40:29,220
Ich muss nur gucken, dass die Libraries

650
00:40:29,220 --> 00:40:31,220
am Ende dann richtig heißen. Also, das

651
00:40:31,220 --> 00:40:33,220
sucht jetzt nach einer Library, die

652
00:40:33,220 --> 00:40:35,220
RustLib heißt, irgendwo hier im Verzeichnis.

653
00:40:35,220 --> 00:40:37,220
Oder GoLib, die gibt es noch nicht.

654
00:40:37,220 --> 00:40:39,220
Die müssen wir anlegen.

655
00:40:39,220 --> 00:40:41,220
Und dort drin ruft es dann eine

656
00:40:41,220 --> 00:40:43,220
Funktion auf, die heißt Call Go

657
00:40:43,220 --> 00:40:45,220
und Call Rust. Das wird erstmal eine

658
00:40:45,220 --> 00:40:47,220
leere Funktion sein.

659
00:40:47,220 --> 00:40:49,220
Man kann mit C-Sharp DLLs

660
00:40:49,220 --> 00:40:51,220
erstellen, nein, man kann aber

661
00:40:51,220 --> 00:40:53,220
native Funktionen

662
00:40:53,220 --> 00:40:55,220
importieren, beziehungsweise aufrufen, die

663
00:40:55,220 --> 00:40:57,220
in DLLs

664
00:40:57,220 --> 00:40:59,220
oder in unter linux.so

665
00:40:59,220 --> 00:41:01,220
Dateien vorhanden sind.

666
00:41:01,220 --> 00:41:03,220
Also, dynamic

667
00:41:03,220 --> 00:41:07,680
loading. So, und mein

668
00:41:07,680 --> 00:41:09,680
Ziel ist dann sowas zu machen hier.

669
00:41:09,680 --> 00:41:11,680
Interop

670
00:41:11,680 --> 00:41:13,680
Punkt, Call

671
00:41:13,680 --> 00:41:15,680
Interop

672
00:41:15,680 --> 00:41:17,680
Call Rust.

673
00:41:17,680 --> 00:41:19,680
Wenn ich das jetzt aufrufe, wird Folgendes passieren.

674
00:41:19,680 --> 00:41:21,680
Bam!

675
00:41:21,680 --> 00:41:23,680
Er findet nämlich GoLib

676
00:41:23,680 --> 00:41:25,680
und

677
00:41:25,680 --> 00:41:27,680
RustLib nicht.

678
00:41:27,680 --> 00:41:29,680
Ist aber auch klar, die haben wir noch nicht angelegt.

679
00:41:29,680 --> 00:41:31,680
Die gibt es schlicht und ergreifend noch gar nicht.

680
00:41:31,680 --> 00:41:33,680
Ich würde sagen, wir fangen mal mit dem

681
00:41:33,680 --> 00:41:35,680
Go-Teil an. Da weiß ich noch

682
00:41:35,680 --> 00:41:37,680
ungefähr, so ganz grob,

683
00:41:37,680 --> 00:41:39,680
wie es aussehen muss,

684
00:41:39,680 --> 00:41:41,680
dass das funktioniert. Und zwar,

685
00:41:41,680 --> 00:41:43,680
wenn ich das richtig in Erinnerung habe,

686
00:41:43,680 --> 00:41:45,680
muss man jetzt Folgendes machen.

687
00:41:45,680 --> 00:41:47,680
Wir legen jetzt mal in Go was an.

688
00:41:47,680 --> 00:41:49,680
Die Main-Funktion brauchen wir nicht.

689
00:41:49,680 --> 00:41:51,680
Weil wir rufen, wir starten

690
00:41:51,680 --> 00:41:53,680
ja kein Binary, sondern wir

691
00:41:53,680 --> 00:41:55,680
callen FonziSharp in was rein,

692
00:41:55,680 --> 00:41:57,680
was in Go definiert ist. Also, das

693
00:41:57,680 --> 00:41:59,680
ist natürlich auch der Einstiegspunkt.

694
00:41:59,680 --> 00:42:01,680
Nicht Main, sondern der Einstiegspunkt in dem Fall ist

695
00:42:01,680 --> 00:42:03,680
Call Go, weil das ist, was wir aufrufen.

696
00:42:03,680 --> 00:42:05,680
So, wenn ich das noch richtig im Kopf habe,

697
00:42:05,680 --> 00:42:07,680
wie das funktioniert in Go, dann sagt man

698
00:42:07,680 --> 00:42:09,680
hier Function, die

699
00:42:09,680 --> 00:42:11,680
muss heißen Call Go, so wie

700
00:42:11,680 --> 00:42:13,680
hier. Also, so wie da.

701
00:42:13,680 --> 00:42:15,680
Und dann muss man, glaube ich,

702
00:42:15,680 --> 00:42:17,680
drüber schreiben

703
00:42:17,680 --> 00:42:19,680
Export

704
00:42:19,680 --> 00:42:21,680
Call Go. Entweder

705
00:42:21,680 --> 00:42:23,680
mit Leerzeichen, ne, ohne Leerzeichen.

706
00:42:23,680 --> 00:42:25,680
Und ich glaube, so muss man

707
00:42:25,680 --> 00:42:27,680
das machen, dass Go

708
00:42:27,680 --> 00:42:29,680
das als C-Interface exportiert.

709
00:42:29,680 --> 00:42:31,680
Aber das war noch

710
00:42:31,680 --> 00:42:35,180
nicht alles.

711
00:42:35,180 --> 00:42:37,180
Go run, ne, das geht natürlich nicht.

712
00:42:37,180 --> 00:42:41,520
Ähm, oh

713
00:42:41,520 --> 00:42:43,520
Shit. Go kompilieren

714
00:42:43,520 --> 00:42:45,520
als C-Library,

715
00:42:45,520 --> 00:42:47,520
beziehungsweise mit C-Interface. Wie ging das jetzt nochmal?

716
00:42:47,520 --> 00:42:49,520
Oh,

717
00:42:49,520 --> 00:42:51,520
meine Güte. Ähm, muss ich nachgucken.

718
00:42:51,520 --> 00:42:53,520
C Go Compile.

719
00:42:53,520 --> 00:42:58,750
Ach, Import C musste man

720
00:42:58,750 --> 00:43:00,750
auch noch machen. Ja, ja, okay.

721
00:43:00,750 --> 00:43:02,750
Genau, genau. Gut, dass wir in die

722
00:43:02,750 --> 00:43:04,750
Hilfe gucken. Das musste man auch

723
00:43:04,750 --> 00:43:06,750
noch machen am Anfang. Also,

724
00:43:06,750 --> 00:43:08,750
das braucht man,

725
00:43:08,750 --> 00:43:10,750
das braucht man in Go, damit man

726
00:43:10,750 --> 00:43:12,750
aus Go C-Libraries aufrufen kann.

727
00:43:12,750 --> 00:43:14,750
Und das hier braucht man,

728
00:43:14,750 --> 00:43:16,750
damit man aus anderen Sprachen Go

729
00:43:16,750 --> 00:43:18,750
Sachen aufrufen kann, über

730
00:43:18,750 --> 00:43:20,750
ein C-Interface, was generiert wird.

731
00:43:20,750 --> 00:43:22,750
Ich glaube,

732
00:43:22,750 --> 00:43:24,750
man braucht beides, oder?

733
00:43:24,750 --> 00:43:26,750
Egal, schadet auf jeden Fall nix.

734
00:43:26,750 --> 00:43:31,860
Was auch immer

735
00:43:31,860 --> 00:43:33,860
das da jetzt ist,

736
00:43:33,860 --> 00:43:46,960
keine Ahnung.

737
00:43:46,960 --> 00:43:48,960
Äh, what the...

738
00:43:48,960 --> 00:43:50,960
Ich suche

739
00:43:50,960 --> 00:43:52,960
den Go Build Aufruf dafür.

740
00:43:52,960 --> 00:43:57,940
Go Build, man muss irgendwie

741
00:43:57,940 --> 00:43:59,940
C Go Enable oder sowas machen.

742
00:43:59,940 --> 00:44:07,660
Ich hab das noch

743
00:44:07,660 --> 00:44:09,660
im Hinterkopf irgendwie.

744
00:44:09,660 --> 00:44:11,660
Go Build,

745
00:44:11,660 --> 00:44:13,660
ich weiß aber nur nicht mehr, hab ich das vielleicht

746
00:44:13,660 --> 00:44:15,660
hier irgendwo... Ne.

747
00:44:15,660 --> 00:44:17,660
Hab ich das vielleicht in der anderen

748
00:44:17,660 --> 00:44:19,660
VM noch

749
00:44:19,660 --> 00:44:21,660
als History?

750
00:44:21,660 --> 00:44:23,660
Kann GCC auch Go

751
00:44:23,660 --> 00:44:25,660
kompilieren? Ja,

752
00:44:25,660 --> 00:44:27,660
es gibt ein GCC

753
00:44:27,660 --> 00:44:29,660
Plugin für Go, aber das verwendet glaube ich

754
00:44:29,660 --> 00:44:31,660
meines Wissens nach so gut wie niemand.

755
00:44:31,660 --> 00:44:33,660
C Go?

756
00:44:33,660 --> 00:44:35,660
Gleich?

757
00:44:35,660 --> 00:44:37,660
Ah, shit,

758
00:44:37,660 --> 00:44:39,660
haben wir es auch nicht in der History mal drin.

759
00:44:39,660 --> 00:44:43,300
Wie war das denn

760
00:44:43,300 --> 00:44:45,300
jetzt nochmal?

761
00:44:45,300 --> 00:44:47,300
Hier, C Go Enable, genau.

762
00:44:47,300 --> 00:44:51,060
Ganz ehrlich, ich verstehe auch gar nicht,

763
00:44:51,060 --> 00:44:53,060
wozu das gut sein soll. Ja, C Go Enable,

764
00:44:53,060 --> 00:44:55,060
genau, das suche ich. C Go

765
00:44:55,060 --> 00:44:57,060
Enable. Aber

766
00:44:57,060 --> 00:44:59,060
die Frage ist, wie man es jetzt nochmal aufruft.

767
00:44:59,060 --> 00:45:01,060
Env

768
00:45:01,060 --> 00:45:04,370
Go OS Linux?

769
00:45:04,370 --> 00:45:07,740
C Go Enable.

770
00:45:07,740 --> 00:45:12,020
Okay, das

771
00:45:12,020 --> 00:45:14,020
ging irgendwie so. C...

772
00:45:14,020 --> 00:45:16,020
Es ist auf jeden Fall Env.

773
00:45:16,020 --> 00:45:18,020
C Go

774
00:45:18,020 --> 00:45:20,020
Enable

775
00:45:20,020 --> 00:45:22,020
gleich 1

776
00:45:22,020 --> 00:45:24,020
und dann sagt man glaube ich einfach Go Build?

777
00:45:24,020 --> 00:45:27,970
Ne.

778
00:45:27,970 --> 00:45:29,970
Aber ich bin ja auch falsch hier.

779
00:45:29,970 --> 00:45:31,970
Ich muss ja auch in mein Go Projekt.

780
00:45:31,970 --> 00:45:33,970
Ja, das wird jetzt ein bisschen abartig,

781
00:45:33,970 --> 00:45:38,880
bis das funktioniert.

782
00:45:38,880 --> 00:45:40,880
Im Moment halt einfach funktioniert gerade.

783
00:45:40,880 --> 00:45:45,980
Nein,

784
00:45:45,980 --> 00:45:47,980
das ist falsch.

785
00:45:47,980 --> 00:45:49,980
Der soll das als Library kompilieren.

786
00:45:49,980 --> 00:45:51,980
Äh,

787
00:45:51,980 --> 00:45:53,980
Build Mode, oh meine Güte, wie geht das?

788
00:45:53,980 --> 00:45:55,980
Go Shared

789
00:45:55,980 --> 00:45:57,980
Shared

790
00:45:57,980 --> 00:45:59,980
Library

791
00:45:59,980 --> 00:46:05,280
Shared Libraries in Go,

792
00:46:05,280 --> 00:46:07,280
how to use? Go Shared Libraries

793
00:46:07,280 --> 00:46:09,280
Ne, ne, ne, ne.

794
00:46:09,280 --> 00:46:11,280
Building

795
00:46:11,280 --> 00:46:13,280
Shared Libraries in Go.

796
00:46:13,280 --> 00:46:17,550
Genau, wie ging das nochmal?

797
00:46:17,550 --> 00:46:19,550
Ich hab das, das ist ja manchmal

798
00:46:19,550 --> 00:46:21,550
in der History gar nicht so gut.

799
00:46:21,550 --> 00:46:23,550
Weil,

800
00:46:23,550 --> 00:46:25,550
wenn man dann seine History nicht hat,

801
00:46:25,550 --> 00:46:27,550
hier,

802
00:46:27,550 --> 00:46:29,550
Build Mode gleich C Shared

803
00:46:29,550 --> 00:46:31,550
minus O Preload, ich hab keine Ahnung,

804
00:46:31,550 --> 00:46:33,550
was das bedeuten soll. Ich lass das einfach mal weg.

805
00:46:33,550 --> 00:46:35,550
Was?

806
00:46:35,550 --> 00:46:44,430
Okay, was auch immer.

807
00:46:44,430 --> 00:46:46,430
Also wahrscheinlich brauchen wir

808
00:46:46,430 --> 00:46:48,430
jetzt noch das hier dabei.

809
00:46:48,430 --> 00:46:50,430
Ach ne, das muss hier bei

810
00:46:50,430 --> 00:46:57,460
Go Build hin.

811
00:46:57,460 --> 00:46:59,460
Ja, schon besser, schon besser.

812
00:46:59,460 --> 00:47:03,090
Aber wo ist meine Library?

813
00:47:03,090 --> 00:47:07,170
Ach, Go App ist die Library.

814
00:47:07,170 --> 00:47:09,170
Okay, das Ding soll heißen,

815
00:47:09,170 --> 00:47:11,170
ach dem ist ja,

816
00:47:11,170 --> 00:47:13,170
ach, okay, also,

817
00:47:13,170 --> 00:47:20,030
äh,

818
00:47:20,030 --> 00:47:25,010
wenn ich,

819
00:47:25,010 --> 00:47:27,010
Moment, warum ist der Aufruf nicht in meiner History drin?

820
00:47:27,010 --> 00:47:29,010
What the?

821
00:47:31,010 --> 00:47:33,010
Ach so, weil ein Leerzeichen davor war.

822
00:47:33,010 --> 00:47:35,010
Lul.

823
00:47:35,010 --> 00:47:37,010
Ja, na, dann ist klar,

824
00:47:37,010 --> 00:47:39,010
dass das nicht drin steht.

825
00:47:39,010 --> 00:47:41,010
Minus O,

826
00:47:41,010 --> 00:47:43,010
der Output soll sein,

827
00:47:43,010 --> 00:47:45,010
wie hab ich das genannt in .NET?

828
00:47:45,010 --> 00:47:51,460
Golib.

829
00:47:51,460 --> 00:47:53,460
Golib.so

830
00:47:53,460 --> 00:47:57,920
Ja,

831
00:47:57,920 --> 00:47:59,920
sehr schön, genau, genau, genau, genau.

832
00:47:59,920 --> 00:48:01,920
So will ich das haben.

833
00:48:01,920 --> 00:48:03,920
Okay, Golib.so

834
00:48:03,920 --> 00:48:05,920
soll er bauen und dann

835
00:48:05,920 --> 00:48:07,920
soll er das Ganze moven,

836
00:48:07,920 --> 00:48:09,920
Golib.so

837
00:48:09,920 --> 00:48:11,920
moven hoch in das C Sharp

838
00:48:11,920 --> 00:48:16,770
Projekt.

839
00:48:16,770 --> 00:48:18,770
Golib.so, okay, nice.

840
00:48:18,770 --> 00:48:20,770
So, wenn ich Glück hab,

841
00:48:20,770 --> 00:48:22,770
klappt das jetzt schon.

842
00:48:22,770 --> 00:48:24,770
Fuck.

843
00:48:24,770 --> 00:48:26,770
Cannot open.

844
00:48:26,770 --> 00:48:30,660
Ah, ich weiß warum.

845
00:48:30,660 --> 00:48:32,660
Weil ich pp-ger bin.

846
00:48:32,660 --> 00:48:34,660
Ich muss die

847
00:48:34,660 --> 00:48:36,660
Build Action noch umstellen, dass der das

848
00:48:36,660 --> 00:48:38,660
ins Output Directory kopiert.

849
00:48:38,660 --> 00:48:40,660
Und jetzt scrollt's, präge Leute, präge.

850
00:48:40,660 --> 00:48:42,660
Ey,

851
00:48:42,660 --> 00:48:44,660
es funzt, es funzt.

852
00:48:44,660 --> 00:48:46,660
Ich kann euch auch beweisen, dass es funzt.

853
00:48:46,660 --> 00:48:48,660
Guckt mal, wir schreiben jetzt hier was

854
00:48:48,660 --> 00:48:50,660
in Go rein, okay?

855
00:48:50,660 --> 00:48:52,660
fmt, prindeln, lul,

856
00:48:52,660 --> 00:48:54,660
kompilieren das,

857
00:48:54,660 --> 00:48:56,660
und jetzt ruf ich's aus C Sharp

858
00:48:56,660 --> 00:48:58,660
auf,

859
00:48:58,660 --> 00:49:00,660
lul.

860
00:49:00,660 --> 00:49:02,660
Und ihr seht hier nirgends wo in C Sharp ist lul definiert,

861
00:49:02,660 --> 00:49:04,660
oder lul, die Ausgabe, die kommt aus Go.

862
00:49:04,660 --> 00:49:06,660
Also jetzt callt, jetzt callt

863
00:49:06,660 --> 00:49:12,400
C Sharp nach Go rein.

864
00:49:12,400 --> 00:49:16,540
Das ist nice.

865
00:49:16,540 --> 00:49:18,540
Wie mach ich in

866
00:49:18,540 --> 00:49:20,540
Chat, wie mach ich denn in Go

867
00:49:20,540 --> 00:49:22,540
ein Release Build?

868
00:49:22,540 --> 00:49:24,540
Ist das standardmäßig ein Release Build?

869
00:49:24,540 --> 00:49:35,340
Nee, nee, C Go

870
00:49:35,340 --> 00:49:37,340
brauch ich, auf jeden Fall.

871
00:49:37,340 --> 00:49:39,340
Weil ich will gleich noch versuchen,

872
00:49:39,340 --> 00:49:41,340
wie das ist, ob man auch in Struct returnen kann

873
00:49:41,340 --> 00:49:46,380
und sowas.

874
00:49:46,380 --> 00:49:49,760
Ähm, äh, was hab ich grade gesagt?

875
00:49:49,760 --> 00:49:51,760
Was wollt ich grade machen?

876
00:49:51,760 --> 00:49:53,760
Jetzt hab ich grad an was anderes gedacht, lul.

877
00:49:53,760 --> 00:49:55,760
Jetzt weiß ich, was ich grad machen wollt. Ähm,

878
00:49:55,760 --> 00:50:00,160
Chat, was hab ich vor zwei Sekunden gesagt?

879
00:50:00,160 --> 00:50:02,160
Oh, du aller Boomer hier, Mann.

880
00:50:02,160 --> 00:50:04,160
Achso, Release Build, ja.

881
00:50:04,160 --> 00:50:06,160
Achso, Release Build. Go, Build,

882
00:50:06,160 --> 00:50:08,160
Release.

883
00:50:08,160 --> 00:50:10,160
Auto Build.

884
00:50:10,160 --> 00:50:23,360
Achso.

885
00:50:23,360 --> 00:50:25,360
Strip Debug Symbols. Nö, nö, nö, nö.

886
00:50:25,360 --> 00:50:28,990
Ach, okay, es gibt gar kein

887
00:50:28,990 --> 00:50:30,990
Debug und Release Build bei Go. Gibt es nur,

888
00:50:30,990 --> 00:50:32,990
gibt es nur Release Builds, quasi.

889
00:50:32,990 --> 00:50:38,610
Was für eine Linungsliste

890
00:50:38,610 --> 00:50:40,610
ist drüber zugenommen? Das ist Arch, by the way.

891
00:50:40,610 --> 00:50:42,610
Wenn du es genau wissen willst,

892
00:50:42,610 --> 00:50:44,610
dafür hab ich natürlich schon mal mein Neo

893
00:50:44,610 --> 00:50:46,610
Fetch vorbereitet, damit ich euch regelmäßig

894
00:50:46,610 --> 00:50:48,610
sagen kann, dass ich Arch Linungs verwende.

895
00:50:48,610 --> 00:50:50,610
Das ist Arch Linungs, allerdings in der

896
00:50:50,610 --> 00:50:52,610
VM. Und

897
00:50:52,610 --> 00:50:54,610
das Terminal ist West Term.

898
00:50:54,610 --> 00:50:56,610
Das ist die 3 als

899
00:50:56,610 --> 00:50:58,610
Window Manager und ZSH

900
00:50:58,610 --> 00:51:00,610
als Shell.

901
00:51:00,610 --> 00:51:02,610
Wenn's dich

902
00:51:02,610 --> 00:51:04,610
genau interessiert, wie das alles konfiguriert

903
00:51:04,610 --> 00:51:06,610
ist und funktioniert, kannst du auf

904
00:51:06,610 --> 00:51:08,610
GitHub gucken, hier ist meine ganze

905
00:51:08,610 --> 00:51:12,110
Konfig. Und wenn du grad dabei

906
00:51:12,110 --> 00:51:14,110
bist, kann ich dir empfehlen,

907
00:51:14,110 --> 00:51:16,110
schnapp dir auch noch gleich die passenden Desktop

908
00:51:16,110 --> 00:51:18,110
Hintergründe,

909
00:51:18,110 --> 00:51:20,110
dass du auch

910
00:51:20,110 --> 00:51:22,110
White Paper Happy hast,

911
00:51:22,110 --> 00:51:34,900
im Hintergrund, so wie ich.

912
00:51:34,900 --> 00:51:36,900
Was ist One Fetch?

913
00:51:36,900 --> 00:51:38,900
Is One Fetch die coolere Neo

914
00:51:38,900 --> 00:51:40,900
Fetch Variante

915
00:51:40,900 --> 00:51:42,900
oder was?

916
00:51:42,900 --> 00:51:44,900
Command Line Git Information Tool.

917
00:51:44,900 --> 00:51:53,360
Was ist das?

918
00:51:53,360 --> 00:51:55,360
Written in Rust, natürlich!

919
00:51:55,360 --> 00:51:57,360
Die Krustentiere sind wieder am Start.

920
00:51:57,360 --> 00:52:03,490
Ach, da kriegt man

921
00:52:03,490 --> 00:52:05,490
Infos über das Repo angezeigt.

922
00:52:05,490 --> 00:52:07,490
Ja, das ist doch eigentlich auch ganz cool.

923
00:52:07,490 --> 00:52:13,550
So.

924
00:52:13,550 --> 00:52:15,550
Also das Call nach

925
00:52:15,550 --> 00:52:17,550
Go Code funktioniert schon einmal.

926
00:52:17,550 --> 00:52:19,550
So,

927
00:52:19,550 --> 00:52:21,550
wir können jetzt natürlich noch sagen, .NET

928
00:52:21,550 --> 00:52:23,550
Run minus

929
00:52:23,550 --> 00:52:25,550
C Release, dass es auch im Release Mode

930
00:52:25,550 --> 00:52:27,550
läuft, aber funzt.

931
00:52:27,550 --> 00:52:29,550
Gut, also erster Part

932
00:52:29,550 --> 00:52:31,550
ist geschafft.

933
00:52:31,550 --> 00:52:33,550
Jetzt könnt ihr euch aussuchen,

934
00:52:33,550 --> 00:52:35,550
Chat, ob wir als erstes

935
00:52:35,550 --> 00:52:37,550
den Go Part

936
00:52:37,550 --> 00:52:39,550
vollständig bauen, also vollständig

937
00:52:39,550 --> 00:52:41,550
bauen bedeutet zwei Sachen.

938
00:52:41,550 --> 00:52:43,550
Leider nicht aus Go die nächste

939
00:52:43,550 --> 00:52:45,550
Programmiersprache callen, aus C Sharp die nächste

940
00:52:45,550 --> 00:52:47,550
Programmiersprache callen.

941
00:52:47,550 --> 00:52:49,550
Also, was ich

942
00:52:49,550 --> 00:52:51,550
in den Sprachen machen will,

943
00:52:51,550 --> 00:52:53,550
ich will zwei Sachen jeweils in den Sprachen einbauen.

944
00:52:53,550 --> 00:52:55,550
Und zwar, das erste ist,

945
00:52:55,550 --> 00:52:57,550
eine leere Funktion, die wir aufrufen können.

946
00:52:57,550 --> 00:52:59,550
In dem Fall kommt das mit dem 0 wieder raus,

947
00:52:59,550 --> 00:53:01,550
weil ich will nicht 500 mal 0 ausgeben.

948
00:53:01,550 --> 00:53:03,550
Und

949
00:53:03,550 --> 00:53:05,550
das zweite ist eine Funktion, die

950
00:53:05,550 --> 00:53:07,550
nennen wir einfach hier irgendwie Call Go 2

951
00:53:07,550 --> 00:53:09,550
und die soll ein Struct

952
00:53:09,550 --> 00:53:11,550
returnen.

953
00:53:11,550 --> 00:53:13,550
Und da bin ich mal gespannt, wie ich das

954
00:53:13,550 --> 00:53:15,550
mache, ein Struct

955
00:53:15,550 --> 00:53:17,550
von Go zu returnen in C Sharp,

956
00:53:17,550 --> 00:53:19,550
was man dann dort

957
00:53:19,550 --> 00:53:21,550
auch als Struct quasi

958
00:53:21,550 --> 00:53:23,550
deserialisieren kann und benutzen kann.

959
00:53:23,550 --> 00:53:25,550
Das einfachste wäre natürlich alle seine Daten

960
00:53:25,550 --> 00:53:27,550
irgendwie als JSON String zu returnen

961
00:53:27,550 --> 00:53:29,550
und dann parsen, aber das ist ja langweilig.

962
00:53:29,550 --> 00:53:31,550
Wir wollen das ja richtig auf C eben

963
00:53:31,550 --> 00:53:33,550
Memory Bytes

964
00:53:33,550 --> 00:53:36,860
dann

965
00:53:36,860 --> 00:53:38,860
Casten zu irgendeinem Struct.

966
00:53:38,860 --> 00:53:40,860
Da bin ich mal gespannt, wie das geht, ich hab keinen Plan.

967
00:53:40,860 --> 00:53:42,860
Ne, auch nicht gRPC,

968
00:53:42,860 --> 00:53:44,860
das ist wirklich richtig, richtig Low Level Memory

969
00:53:44,860 --> 00:53:46,860
hin und her schieben soll das sein.

970
00:53:46,860 --> 00:53:48,860
So.

971
00:53:48,860 --> 00:53:50,860
Also ihr könnt euch jetzt aussuchen, wollen wir jetzt den

972
00:53:50,860 --> 00:53:52,860
Go Part noch implementieren, also sprich

973
00:53:52,860 --> 00:53:54,860
die Funktion in Go, die

974
00:53:54,860 --> 00:53:56,860
den Struct zurückliefert an C Sharp

975
00:53:56,860 --> 00:53:58,860
oder wollen wir jetzt erstmal gucken,

976
00:53:58,860 --> 00:54:00,860
wie man Rust

977
00:54:00,860 --> 00:54:02,860
callen kann von C Sharp aus.

978
00:54:02,860 --> 00:54:04,860
Könnt ihr euch aussuchen.

979
00:54:04,860 --> 00:54:12,850
War was? Rust,

980
00:54:12,850 --> 00:54:16,800
erstmal Go fertig.

981
00:54:16,800 --> 00:54:18,800
Go fertig. Go.

982
00:54:18,800 --> 00:54:20,800
Okay.

983
00:54:20,800 --> 00:54:22,800
Also, Tommy,

984
00:54:22,800 --> 00:54:24,800
die meisten Leute wollen Go haben.

985
00:54:24,800 --> 00:54:26,800
Ich denke nicht, dass das so lang

986
00:54:26,800 --> 00:54:28,800
dauert, wobei ich das noch nicht gemacht hab.

987
00:54:28,800 --> 00:54:30,800
Structs returnen

988
00:54:30,800 --> 00:54:32,800
von Go nach C Sharp.

989
00:54:32,800 --> 00:54:34,800
Ich würde sagen, wir fangen mal easy

990
00:54:34,800 --> 00:54:36,800
an, okay? Wir fangen mal easy

991
00:54:36,800 --> 00:54:38,800
an. Easy heißt,

992
00:54:38,800 --> 00:54:40,800
wir returnen hier jetzt ein

993
00:54:40,800 --> 00:54:42,800
Moment.

994
00:54:42,800 --> 00:54:44,800
Wie ging das nochmal?

995
00:54:44,800 --> 00:54:46,800
Ich glaube einfach

996
00:54:46,800 --> 00:54:48,800
sagen wir mal

997
00:54:48,800 --> 00:54:50,800
in den UN64

998
00:54:50,800 --> 00:54:55,970
returnen wir jetzt hier mal.

999
00:54:55,970 --> 00:54:57,970
So. Und jetzt sagen wir hier

1000
00:54:57,970 --> 00:54:59,970
return 1.

1001
00:54:59,970 --> 00:55:01,970
Mein einfacher geht's nicht mehr, okay?

1002
00:55:01,970 --> 00:55:03,970
Return 1, kompiliert auch ohne

1003
00:55:03,970 --> 00:55:05,970
Fehler. Und jetzt ist die Frage,

1004
00:55:05,970 --> 00:55:07,970
das dürfte ziemlich easy

1005
00:55:07,970 --> 00:55:09,970
sein. Jetzt gehe ich hier einfach hin,

1006
00:55:09,970 --> 00:55:11,970
ich kommentiere mal das Rusting aus.

1007
00:55:11,970 --> 00:55:13,970
Jetzt ist der return-Typ nicht

1008
00:55:13,970 --> 00:55:15,970
void, sondern der return-Typ ist UN64.

1009
00:55:15,970 --> 00:55:17,970
Das Ding ist nur, ich

1010
00:55:17,970 --> 00:55:19,970
hab keine Ahnung, ob die

1011
00:55:19,970 --> 00:55:21,970
Repräsentation im Speicher

1012
00:55:21,970 --> 00:55:23,970
von einem C Sharp UN und einem

1013
00:55:23,970 --> 00:55:25,970
C

1014
00:55:25,970 --> 00:55:27,970
aus Go exportierten

1015
00:55:27,970 --> 00:55:29,970
C UN die gleiche

1016
00:55:29,970 --> 00:55:31,970
ist. Moment, geht das überhaupt so?

1017
00:55:31,970 --> 00:55:33,970
Das geht doch

1018
00:55:33,970 --> 00:55:35,970
eigentlich gar nicht. Ich will ja kein

1019
00:55:35,970 --> 00:55:37,970
Rust UN exportieren,

1020
00:55:37,970 --> 00:55:39,970
sondern ein C

1021
00:55:39,970 --> 00:55:41,970
UN 64.

1022
00:55:41,970 --> 00:55:43,970
Also es könnte sein, dass

1023
00:55:43,970 --> 00:55:45,970
das funktioniert, wenn die

1024
00:55:45,970 --> 00:55:47,970
Implementierungen einfach überall gleich sind.

1025
00:55:47,970 --> 00:55:49,970
Probieren wir das mal

1026
00:55:49,970 --> 00:55:51,970
aus, aber ich glaube nicht, dass das

1027
00:55:51,970 --> 00:55:53,970
funktioniert. Machen wir mal I.

1028
00:55:53,970 --> 00:55:55,970
Ups. Hä?

1029
00:55:55,970 --> 00:55:59,540
Da sollte jetzt

1030
00:55:59,540 --> 00:56:01,540
1 rauskommen. 1. Okay.

1031
00:56:01,540 --> 00:56:03,540
Das funktioniert, aber ich glaube ganz

1032
00:56:03,540 --> 00:56:05,540
korrekt ist das nicht.

1033
00:56:05,540 --> 00:56:07,540
Das funktioniert wirklich nur,

1034
00:56:07,540 --> 00:56:09,540
weil das Memory-Layout von einem

1035
00:56:09,540 --> 00:56:11,540
UN 64 einfach in C Sharp

1036
00:56:11,540 --> 00:56:13,540
und Go gleich ist.

1037
00:56:13,540 --> 00:56:15,540
Ich glaube korrekt wäre

1038
00:56:15,540 --> 00:56:17,540
hier gewesen zu returnen ein

1039
00:56:17,540 --> 00:56:19,540
C Punkt UN 64

1040
00:56:19,540 --> 00:56:21,540
oder sowas.

1041
00:56:21,540 --> 00:56:23,540
Gibt es nicht. Ne, wie

1042
00:56:23,540 --> 00:56:25,540
heißt das? T oder so, gell?

1043
00:56:25,540 --> 00:56:27,540
Heißt das so? Ne, ah man.

1044
00:56:27,540 --> 00:56:29,540
UN 64

1045
00:56:29,540 --> 00:56:31,540
C. Wie heißt der Kram?

1046
00:56:31,540 --> 00:56:36,190
UN

1047
00:56:36,190 --> 00:56:38,190
64 T.

1048
00:56:38,190 --> 00:56:44,640
Hab ich doch.

1049
00:56:44,640 --> 00:56:46,640
Gibt es nicht.

1050
00:56:46,640 --> 00:56:48,640
Was muss ich denn da inkluden dafür?

1051
00:56:48,640 --> 00:56:53,620
Standard

1052
00:56:53,620 --> 00:56:55,620
Int, Moment, was?

1053
00:56:55,620 --> 00:57:00,340
std

1054
00:57:00,340 --> 00:57:02,340
int.h, okay.

1055
00:57:02,340 --> 00:57:04,340
Hey, Funst! Nice!

1056
00:57:04,340 --> 00:57:06,340
Stack Overflow Triff and Copy Pasting.

1057
00:57:06,340 --> 00:57:10,030
Okay, also einzelne

1058
00:57:10,030 --> 00:57:12,030
Ints returnen von Go nach C.

1059
00:57:12,030 --> 00:57:14,030
Vor allem nach, von

1060
00:57:14,030 --> 00:57:16,030
Go

1061
00:57:16,030 --> 00:57:18,030
über C nach C Sharp. Funst?

1062
00:57:18,030 --> 00:57:22,820
Jetzt ist die Frage,

1063
00:57:22,820 --> 00:57:24,820
wie machen wir das mit einem Struct?

1064
00:57:24,820 --> 00:57:26,820
Das wird bestimmt etwas

1065
00:57:26,820 --> 00:57:28,820
komplizierter.

1066
00:57:28,820 --> 00:57:30,820
Könnte ich mir vorstellen, weil

1067
00:57:30,820 --> 00:57:32,820
wir brauchen ja einen

1068
00:57:32,820 --> 00:57:34,820
C Struct, kein Go Struct.

1069
00:57:34,820 --> 00:57:36,820
Okay,

1070
00:57:36,820 --> 00:57:38,820
Go Struct to C

1071
00:57:38,820 --> 00:57:40,820
Struct.

1072
00:57:40,820 --> 00:57:45,410
Layouts sind in C Sharp

1073
00:57:45,410 --> 00:57:47,410
recht easy.

1074
00:57:47,410 --> 00:57:49,410
Wenn du dem sagst, dass er

1075
00:57:51,410 --> 00:57:53,410
wie heißt das?

1076
00:57:53,410 --> 00:57:55,410
Serialisieren soll,

1077
00:57:55,410 --> 00:57:57,410
dann ist es das gleiche Layout wie von C.

1078
00:57:57,410 --> 00:57:59,410
Dann ist das eigentlich kein Ding.

1079
00:57:59,410 --> 00:58:05,660
Hoff ich mal.

1080
00:58:05,660 --> 00:58:07,660
Genau, genau, das meine ich.

1081
00:58:07,660 --> 00:58:09,660
Damit ist das

1082
00:58:09,660 --> 00:58:11,660
meistens nicht so ein großes Problem.

1083
00:58:11,660 --> 00:58:13,660
Go Lang Struct

1084
00:58:13,660 --> 00:58:15,660
with C Struct in C.

1085
00:58:15,660 --> 00:58:30,880
Okay, okay, okay.

1086
00:58:30,880 --> 00:58:32,880
Nee, der hat einen

1087
00:58:32,880 --> 00:58:34,880
Go Struct

1088
00:58:34,880 --> 00:58:36,880
mit C Types drinnen.

1089
00:58:36,880 --> 00:58:38,880
Das will ich nicht.

1090
00:58:38,880 --> 00:58:40,880
Okay, C Go

1091
00:58:40,880 --> 00:58:45,920
Return Struct.

1092
00:58:45,920 --> 00:58:47,920
How to return Struct

1093
00:58:47,920 --> 00:58:49,920
from C Go?

1094
00:58:49,920 --> 00:58:51,920
Ja, genau, das will ich haben.

1095
00:58:51,920 --> 00:58:56,130
I have found a solution

1096
00:58:56,130 --> 00:59:02,060
in C.

1097
00:59:02,060 --> 00:59:07,040
Okay, der definiert ein Struct in C.

1098
00:59:07,040 --> 00:59:09,040
Gibt es nicht C Pack Unpack?

1099
00:59:09,040 --> 00:59:11,040
Ich hab keine Ahnung.

1100
00:59:11,040 --> 00:59:26,960
Go C Pack?

1101
00:59:26,960 --> 00:59:28,960
How to return a C Struct from a Go Function?

1102
00:59:28,960 --> 00:59:30,960
Genau das will ich wissen.

1103
00:59:30,960 --> 00:59:32,960
Okay, Struct Point.

1104
00:59:32,960 --> 00:59:34,960
Ich muss das in C definieren

1105
00:59:34,960 --> 00:59:41,020
auf jeden Fall.

1106
00:59:41,020 --> 00:59:43,020
To access a Struct Type

1107
00:59:43,020 --> 00:59:45,020
directly.

1108
00:59:45,020 --> 00:59:47,020
Prefix it with Struct Underscore.

1109
00:59:47,020 --> 00:59:49,020
Okay.

1110
00:59:49,020 --> 00:59:51,020
C Punkt Struct Underscore.

1111
00:59:51,020 --> 00:59:53,020
Oh meine Güte.

1112
00:59:53,020 --> 00:59:57,100
Jetzt wird es aber Pepega Style.

1113
00:59:57,100 --> 00:59:59,100
Also ich glaube, das wird in Rust

1114
00:59:59,100 --> 01:00:01,100
deutlich angenehmer sein.

1115
01:00:01,100 --> 01:00:03,100
Als in Go.

1116
01:00:03,100 --> 01:00:05,100
Also sprich, wir brauchen jetzt...

1117
01:00:05,100 --> 01:00:07,100
Nee, Moment.

1118
01:00:07,100 --> 01:00:09,100
So.

1119
01:00:09,100 --> 01:00:11,100
Und das muss, soweit ich weiß,

1120
01:00:11,100 --> 01:00:13,100
dann auch direkt über Import C stehen.

1121
01:00:13,100 --> 01:00:15,100
Sonst mag er nicht.

1122
01:00:15,100 --> 01:00:20,270
Die Includes können wir dann hier rein machen.

1123
01:00:20,270 --> 01:00:28,190
Massive Pepega.

1124
01:00:28,190 --> 01:00:30,190
So, jetzt haben wir einen Struct Point.

1125
01:00:30,190 --> 01:00:32,190
Wir wollen allerdings nicht Point Return.

1126
01:00:32,190 --> 01:00:34,190
Wir wollen ein Struct...

1127
01:00:34,190 --> 01:00:36,190
Okay, machen wir einfach mal sowas hier.

1128
01:00:36,190 --> 01:00:38,190
Struct Session

1129
01:00:38,190 --> 01:00:40,190
hat eine...

1130
01:00:40,190 --> 01:00:42,190
Wir machen mal was, was von später

1131
01:00:42,190 --> 01:00:44,190
auch sinnvoll irgendwie...

1132
01:00:44,190 --> 01:00:46,190
Das einmal gibt es hier ein

1133
01:00:46,190 --> 01:00:49,630
Int.

1134
01:00:49,630 --> 01:00:51,630
Oder ein

1135
01:00:51,630 --> 01:00:53,630
U

1136
01:00:53,630 --> 01:00:55,630
Int. Machen wir es mal so.

1137
01:00:55,630 --> 01:00:57,630
Ein U Int 64 T.

1138
01:00:57,630 --> 01:01:01,200
Client ID.

1139
01:01:01,200 --> 01:01:04,900
Und dann

1140
01:01:04,900 --> 01:01:06,900
gibt es... Oh, jetzt wird es interessant.

1141
01:01:06,900 --> 01:01:08,900
Jetzt gibt es einen String.

1142
01:01:08,900 --> 01:01:10,900
Den nennen wir...

1143
01:01:10,900 --> 01:01:12,900
Keine Ahnung. Name. Oder so.

1144
01:01:12,900 --> 01:01:14,900
Ja. Client Name.

1145
01:01:14,900 --> 01:01:16,900
Jetzt bin ich mal

1146
01:01:16,900 --> 01:01:18,900
gespannt, wie ich

1147
01:01:18,900 --> 01:01:20,900
einen Struct mit einem

1148
01:01:20,900 --> 01:01:22,900
Char Pointer

1149
01:01:22,900 --> 01:01:24,900
irgendwie rüberkriege in C Sharp.

1150
01:01:24,900 --> 01:01:26,900
Ohne,

1151
01:01:26,900 --> 01:01:28,900
wohlgemerkt, ohne

1152
01:01:28,900 --> 01:01:33,230
Memory Leaks zu verursachen.

1153
01:01:33,230 --> 01:01:35,230
Das wird...

1154
01:01:35,230 --> 01:01:37,230
Ohje.

1155
01:01:37,230 --> 01:01:39,230
Ich weiß leider mal,

1156
01:01:39,230 --> 01:01:41,230
wie ich das über... Okay. Return.

1157
01:01:41,230 --> 01:01:43,230
Also wie ging das jetzt? C Punkt

1158
01:01:43,230 --> 01:01:45,230
Struct Underscore

1159
01:01:45,230 --> 01:01:47,230
und dann Session

1160
01:01:47,230 --> 01:01:49,230
Und jetzt durfte ich

1161
01:01:49,230 --> 01:01:51,230
das so benennen mit

1162
01:01:51,230 --> 01:01:53,230
ähm...

1163
01:01:53,230 --> 01:01:55,230
Client Name

1164
01:01:55,230 --> 01:01:57,230
Ich weiß überhaupt nicht, wie ist die Syntax?

1165
01:01:57,230 --> 01:02:01,180
X. Ah, die Variable

1166
01:02:01,180 --> 01:02:03,180
Variable zuerst. Okay.

1167
01:02:03,180 --> 01:02:07,140
Ja. Ja, Tommy.

1168
01:02:07,140 --> 01:02:09,140
Also Client ID. So.

1169
01:02:09,140 --> 01:02:11,140
Das ist jetzt ein C Char

1170
01:02:11,140 --> 01:02:13,140
Array oder so.

1171
01:02:13,140 --> 01:02:15,140
Ich hoffe,

1172
01:02:15,140 --> 01:02:17,140
dass... Nee.

1173
01:02:17,140 --> 01:02:19,140
Nee, nee. Das fand ich schon mal nett.

1174
01:02:19,140 --> 01:02:21,140
Ohje.

1175
01:02:21,140 --> 01:02:23,140
Wie ist das Syntaktisch denn richtig?

1176
01:02:23,140 --> 01:02:25,140
Nee, das ist eigentlich okay so.

1177
01:02:25,140 --> 01:02:29,340
Und dann haben wir noch was.

1178
01:02:29,340 --> 01:02:31,340
Ich weiß das... Moment. Client ID.

1179
01:02:31,340 --> 01:02:33,340
Client ID ist 123.

1180
01:02:33,340 --> 01:02:35,340
Und dann haben wir noch Client Name.

1181
01:02:35,340 --> 01:02:37,340
Client Name ist dann...

1182
01:02:37,340 --> 01:02:39,340
Das wird so definitiv nicht

1183
01:02:39,340 --> 01:02:41,340
funktionieren, Leute. Das kann ich euch... Das kann ich euch sagen.

1184
01:02:41,340 --> 01:02:43,340
Das wird nicht funktionieren.

1185
01:02:43,340 --> 01:02:50,560
Okay. Das funktioniert schon mal nett.

1186
01:02:50,560 --> 01:02:52,560
Also.

1187
01:02:52,560 --> 01:02:54,560
Das ist falsch, weil das ist ja auch

1188
01:02:54,560 --> 01:02:56,560
ein U Int.

1189
01:02:56,560 --> 01:02:58,560
Also das hier muss ja auch

1190
01:02:58,560 --> 01:03:00,560
ein sowas hier sein.

1191
01:03:00,560 --> 01:03:02,560
Moment. Meine

1192
01:03:02,560 --> 01:03:04,560
Go Skills verlassen mich. Ich glaube, das geht so,

1193
01:03:04,560 --> 01:03:06,560
dass das

1194
01:03:06,560 --> 01:03:08,560
funktioniert.

1195
01:03:08,560 --> 01:03:10,560
Ja. Nee.

1196
01:03:10,560 --> 01:03:12,560
Achso.

1197
01:03:12,560 --> 01:03:14,560
Moment. Ich return ja gar kein Struct.

1198
01:03:14,560 --> 01:03:16,560
Ich will das hier returnen.

1199
01:03:16,560 --> 01:03:21,790
Okay. Schon besser.

1200
01:03:21,790 --> 01:03:23,790
Schon besser. Hätte ich es auch einfach

1201
01:03:23,790 --> 01:03:25,790
so returnen können, ohne dass der rummeckert?

1202
01:03:25,790 --> 01:03:27,790
Anscheinend.

1203
01:03:27,790 --> 01:03:29,790
So. Also das funktioniert nicht.

1204
01:03:29,790 --> 01:03:31,790
Ich muss jetzt einen...

1205
01:03:31,790 --> 01:03:33,790
Charakter Array

1206
01:03:33,790 --> 01:03:35,790
in Go machen. Okay.

1207
01:03:35,790 --> 01:03:37,790
Äh.

1208
01:03:37,790 --> 01:03:39,790
C String

1209
01:03:39,790 --> 01:03:41,790
C Go Return. Wie funzt das?

1210
01:03:41,790 --> 01:03:43,790
Return Strings

1211
01:03:43,790 --> 01:03:45,790
C Function in Go legen.

1212
01:03:45,790 --> 01:03:47,790
C Punkt

1213
01:03:47,790 --> 01:03:49,790
C String.

1214
01:03:49,790 --> 01:03:51,790
Was ich mache?

1215
01:03:51,790 --> 01:03:53,790
Ich rufe aus C Sharp Go

1216
01:03:53,790 --> 01:03:55,790
auf über ein C Interface.

1217
01:03:55,790 --> 01:03:57,790
Also machen wir es

1218
01:03:57,790 --> 01:03:59,790
irgendwie sowas wie

1219
01:03:59,790 --> 01:04:01,790
Let String

1220
01:04:01,790 --> 01:04:03,790
C String

1221
01:04:03,790 --> 01:04:05,790
Moment. Let. Wir sind...

1222
01:04:05,790 --> 01:04:07,790
Achso.

1223
01:04:07,790 --> 01:04:09,790
Nee. Go.

1224
01:04:09,790 --> 01:04:11,790
Nee. Moment.

1225
01:04:11,790 --> 01:04:13,790
Zu viele Programmiersprachen auf einmal.

1226
01:04:13,790 --> 01:04:15,790
So, oder?

1227
01:04:23,650 --> 01:04:25,650
Okay.

1228
01:04:25,650 --> 01:04:27,650
Leute. Es kompiliert.

1229
01:04:27,650 --> 01:04:29,650
Okay.

1230
01:04:29,650 --> 01:04:31,650
Client Name ist Omega Lul

1231
01:04:31,650 --> 01:04:33,650
Keckel HD

1232
01:04:33,650 --> 01:04:35,650
XYZ 123.

1233
01:04:35,650 --> 01:04:37,650
Könnte ein geiles Passwort sein. Das ist es aber nicht.

1234
01:04:37,650 --> 01:04:41,660
Okay. Jetzt returne

1235
01:04:41,660 --> 01:04:43,660
ich ein Struct aus Go.

1236
01:04:43,660 --> 01:04:45,660
Heißt im Endeffekt, wenn ich

1237
01:04:45,660 --> 01:04:47,660
das hier aufrufe, das sollte noch funktionieren.

1238
01:04:47,660 --> 01:04:49,660
Weil das erst... Okay.

1239
01:04:49,660 --> 01:04:51,660
Das ist schon mal gut.

1240
01:04:51,660 --> 01:04:53,660
123 ist die Client ID, die ich hier gesetzt habe.

1241
01:04:53,660 --> 01:04:55,660
Das funzt, weil in meinem Struct

1242
01:04:55,660 --> 01:04:57,660
vorne immer noch

1243
01:04:57,660 --> 01:04:59,660
die Client ID ist. Jetzt ist die große Preisfrage.

1244
01:04:59,660 --> 01:05:01,660
Wie kriege ich hier raus

1245
01:05:01,660 --> 01:05:03,660
ein Struct?

1246
01:05:03,660 --> 01:05:05,660
Also machen wir mal.

1247
01:05:05,660 --> 01:05:07,660
Das nennen wir auch Session.

1248
01:05:07,660 --> 01:05:09,660
Public

1249
01:05:09,660 --> 01:05:11,660
Uint64

1250
01:05:11,660 --> 01:05:13,660
Tja.

1251
01:05:13,660 --> 01:05:15,660
Client ID. Wir nennen das mal genauso.

1252
01:05:15,660 --> 01:05:17,660
Public

1253
01:05:17,660 --> 01:05:19,660
String

1254
01:05:19,660 --> 01:05:21,660
Das kann ich mir so nicht

1255
01:05:21,660 --> 01:05:23,660
vorstellen, dass das funktioniert.

1256
01:05:23,660 --> 01:05:25,660
Und selbst wenn es funktioniert,

1257
01:05:25,660 --> 01:05:27,660
passiert Memory Leaks.

1258
01:05:27,660 --> 01:05:29,660
Das werden wir jetzt mal ausprobieren.

1259
01:05:29,660 --> 01:05:31,660
Mal gucken, ob das

1260
01:05:31,660 --> 01:05:33,660
C Sharp Interop

1261
01:05:33,660 --> 01:05:35,660
Zeug so schlau ist

1262
01:05:35,660 --> 01:05:37,660
und erkennt, dass man ja aus einem

1263
01:05:37,660 --> 01:05:39,660
C String

1264
01:05:39,660 --> 01:05:43,360
ein C Sharp String machen kann.

1265
01:05:43,360 --> 01:05:45,360
Automatisch. Da bin ich mal gespannt.

1266
01:05:45,360 --> 01:05:47,360
So und das Ding soll heißen

1267
01:05:47,360 --> 01:05:49,360
Client Name. Übrigens, die Namen hier

1268
01:05:49,360 --> 01:05:51,360
sind vollkommen egal.

1269
01:05:51,360 --> 01:05:53,360
Die Namen sind vollkommen wurscht.

1270
01:05:53,360 --> 01:05:55,360
Die müssen nicht die gleichen sein wie hier.

1271
01:05:55,360 --> 01:05:57,360
Wichtig ist, die Byte Anzahl.

1272
01:05:57,360 --> 01:05:59,360
Also dass das hier

1273
01:05:59,360 --> 01:06:01,360
quasi so lang ist

1274
01:06:01,360 --> 01:06:03,360
und das hier so lang ist und

1275
01:06:03,360 --> 01:06:05,360
dass es dann passt im Endeffekt.

1276
01:06:05,360 --> 01:06:07,360
Wie das hier heißt, ist vollkommen egal.

1277
01:06:07,360 --> 01:06:09,360
Also das Layout im Speicher muss das gleiche sein.

1278
01:06:09,360 --> 01:06:11,360
So und jetzt returnen

1279
01:06:11,360 --> 01:06:13,360
wir hiervon kein Uint, sondern

1280
01:06:13,360 --> 01:06:15,360
eine Session.

1281
01:06:15,360 --> 01:06:17,360
Das funktioniert nicht, weil es nicht public ist.

1282
01:06:17,360 --> 01:06:22,400
Okay. Session.

1283
01:06:22,400 --> 01:06:26,350
Jetzt bin ich mal gespannt.

1284
01:06:26,350 --> 01:06:28,350
Jetzt bin ich mal gespannt.

1285
01:06:28,350 --> 01:06:30,350
Client ID. Ich hoffe,

1286
01:06:30,350 --> 01:06:32,350
das geht noch. Okay, das funzt.

1287
01:06:32,350 --> 01:06:34,350
Okay, das funzt.

1288
01:06:34,350 --> 01:06:36,350
Was ist hier? Warum kann ich

1289
01:06:36,350 --> 01:06:38,350
kein Konsole

1290
01:06:38,350 --> 01:06:40,350
PPGA IDE gerade

1291
01:06:40,350 --> 01:06:44,690
Client Name.

1292
01:06:44,690 --> 01:06:50,110
Funzt einfach. Es funktioniert einfach.

1293
01:06:50,110 --> 01:06:52,110
Moment.

1294
01:06:52,110 --> 01:06:54,110
Der erkennt automatisch.

1295
01:06:54,110 --> 01:06:56,110
Der weiß automatisch, wie man

1296
01:06:56,110 --> 01:06:58,110
einen C String in einen C Sharp String

1297
01:06:58,110 --> 01:07:00,110
Aber das hat 100

1298
01:07:00,110 --> 01:07:02,110
pro Memory Leaks. Das hat

1299
01:07:02,110 --> 01:07:04,110
sowas von Memory Leaks, Leute. Ich sag's euch.

1300
01:07:04,110 --> 01:07:06,110
100 pro hat es

1301
01:07:06,110 --> 01:07:08,110
Memory Leaks. Moment. Moment.

1302
01:07:08,110 --> 01:07:10,110
Watch 3 minus

1303
01:07:10,110 --> 01:07:12,110
H. Wir machen jetzt die simpelste

1304
01:07:12,110 --> 01:07:14,110
Variante Memory Leaks zu erkennen.

1305
01:07:14,110 --> 01:07:16,110
Passt mal auf. Wir machen jetzt folgendes.

1306
01:07:16,110 --> 01:07:18,110
Wir gucken jetzt

1307
01:07:18,110 --> 01:07:20,110
mal, ob es Memory Leaks hat.

1308
01:07:20,110 --> 01:07:22,110
While true.

1309
01:07:22,110 --> 01:07:24,110
While lulw.

1310
01:07:24,110 --> 01:07:27,490
Okay. So.

1311
01:07:27,490 --> 01:07:29,490
Wir gucken, ob es Memory

1312
01:07:29,490 --> 01:07:31,490
Leaks hat. Wir rufen es einfach in der Schleife

1313
01:07:31,490 --> 01:07:33,490
auf und gucken, ob

1314
01:07:33,490 --> 01:07:37,630
Free runtergeht.

1315
01:07:37,630 --> 01:07:41,460
Run. Oh, shit.

1316
01:07:41,460 --> 01:07:43,460
Ich glaube, es hat

1317
01:07:43,460 --> 01:07:45,460
Naja, nö.

1318
01:07:45,460 --> 01:07:49,090
Oder doch. Doch.

1319
01:07:49,090 --> 01:07:51,090
Ah. Das ist jetzt

1320
01:07:51,090 --> 01:08:03,100
aktuell so gar nicht mal zu

1321
01:08:03,100 --> 01:08:05,100
Das ist jetzt, das ist echt schwer.

1322
01:08:05,100 --> 01:08:07,100
Der GC

1323
01:08:07,100 --> 01:08:09,100
kann es nicht freen, weil der GC

1324
01:08:09,100 --> 01:08:17,090
wahrscheinlich kein free...

1325
01:08:17,090 --> 01:08:19,090
Nee, nee. Das hat Memory Leaks.

1326
01:08:19,090 --> 01:08:27,620
Oder? Oder nicht?

1327
01:08:27,620 --> 01:08:29,620
Das hat 100 pro Memory.

1328
01:08:29,620 --> 01:08:31,620
Also, wenn das kein Memory Leak hat, dann wundert

1329
01:08:31,620 --> 01:08:49,780
es mich extrem. Warum

1330
01:08:49,780 --> 01:08:51,780
verursacht das nicht mehr CPU Last?

1331
01:08:51,780 --> 01:08:55,410
Nee, macht es doch. Ja.

1332
01:08:55,410 --> 01:08:59,680
Memory.

1333
01:08:59,680 --> 01:09:01,680
Wir könnten doch einfach mal mit einem Debugger starten.

1334
01:09:01,680 --> 01:09:21,820
Schwer zu sagen.

1335
01:09:21,820 --> 01:09:23,820
Also, das könnte auch einfach

1336
01:09:23,820 --> 01:09:25,820
kein Memory Leak. Aber das wundert

1337
01:09:25,820 --> 01:09:29,580
mich. Woher will es

1338
01:09:29,580 --> 01:09:31,580
sie scharf festen, wie man das

1339
01:09:31,580 --> 01:09:33,580
Ei gibt?

1340
01:09:33,580 --> 01:09:39,840
Moment. Moment.

1341
01:09:39,840 --> 01:09:41,840
Moment. Moment. Moment. Moment. Hab ich das überhaupt

1342
01:09:41,840 --> 01:09:43,840
schon kompiliert jetzt und dahin geschoben?

1343
01:09:43,840 --> 01:10:05,390
Wie kann das sein, dass das kein

1344
01:10:05,390 --> 01:10:16,260
Memory Leak gibt?

1345
01:10:16,260 --> 01:10:18,260
Warum das .NET nicht freeen können soll?

1346
01:10:18,260 --> 01:10:20,260
Weil .NET nicht zuständig ist dafür, das zu

1347
01:10:20,260 --> 01:10:22,260
freen.

1348
01:10:22,260 --> 01:10:24,260
Woher möchte .NET wissen

1349
01:10:24,260 --> 01:10:26,260
an der Stelle, dass ich den eigentlichen

1350
01:10:26,260 --> 01:10:28,260
Pointer, auf dem das basiert, das im Ursprungsprogramm

1351
01:10:28,260 --> 01:10:30,260
nicht mehr verwende?

1352
01:10:30,260 --> 01:10:32,260
Wenn ich das selbst

1353
01:10:32,260 --> 01:10:34,260
aufrufen würde, dann ist okay.

1354
01:10:34,260 --> 01:10:36,260
Aber, dass das

1355
01:10:36,260 --> 01:10:43,110
Automatisch Fried wird er gibt Eigentlich Keinen sinn Aber anscheinend

1356
01:10:44,870 --> 01:10:46,870
anscheinend funktioniert das

1357
01:10:53,570 --> 01:10:58,000
Zappt!Con Danke Für. Den Stab also das ist das

1358
01:10:58,860 --> 01:11:00,860
Irgendwas Falsch

1359
01:11:01,060 --> 01:11:03,060
Interop Call

1360
01:11:16,250 --> 01:11:18,890
Wir MüsSen Mal Kurz was Checken steht Da üBerhaupt was Drinne

1361
01:11:20,090 --> 01:11:21,730
Session

1362
01:11:21,730 --> 01:11:24,850
Name steht Da üBerhaupt was sinnvolles Drinne Jetzt Ja

1363
01:11:25,570 --> 01:11:34,580
Ich bin leute ich bin hochgradig verwirrt dass das kein

1364
01:11:34,940 --> 01:11:53,740
Kann das Sein dass es Einfach raus optimiert wird ich bin ich bin echt jetzt begeistert

1365
01:11:54,260 --> 01:11:57,700
verwirrt und begeistert gleichzeitig dass es wohl anscheinend Kein

1366
01:11:58,580 --> 01:12:00,580
Memory leak

1367
01:12:00,580 --> 01:12:01,620
Ergibt

1368
01:12:01,620 --> 01:12:06,540
Wir Können das hier nicht mit dem debugger starten und sehen an die ram auslastung also in Visual Studio gibt es

1369
01:12:06,700 --> 01:12:10,860
In Visual Studio gibt es ein debugger mit ram auslastung ich weiß nicht wie das hier in

1370
01:12:11,820 --> 01:12:17,500
den rider aussieht

1371
01:12:25,820 --> 01:12:46,740
Was was Genau MöcHte rider von mir wo ist das wo ist das problem ach hier

1372
01:12:54,650 --> 01:13:05,700
rider was willst du von mir

1373
01:13:06,220 --> 01:13:10,060
Was hat er Für. Schmerzen mit war der weißt du wo mein dotnet zeug liegt

1374
01:13:27,420 --> 01:13:29,420
Also ich würde gerne das kann man

1375
01:13:30,500 --> 01:13:32,780
das muss doch hier irgendwie funktionieren benchmark

1376
01:13:34,100 --> 01:13:38,940
Wo ist das hier ja richtig runtime korrekt

1377
01:13:41,280 --> 01:13:43,280
exec pass korrekt

1378
01:13:43,440 --> 01:13:49,890
der

1379
01:13:49,890 --> 01:13:52,250
Ja Aber das hier ist doch dort nicht acht stimmt eigentlich

1380
01:13:53,050 --> 01:14:02,300
Ja Ja der ruft das nicht der ruft das nicht mit mit dem richtigen mit dem richtigen

1381
01:14:03,100 --> 01:14:07,940
mit der richtigen installation auf was aber äußerst pepega ist weil

1382
01:14:08,780 --> 01:14:16,050
Hier checkt das hier checkt das ja

1383
01:14:16,650 --> 01:14:20,860
Da ist IrGendwas Falsch Falsch

1384
01:14:27,540 --> 01:14:32,420
Der benutzt meines ist meine meine system runtime was aber keinen sinn ergibt weil ich überall hier

1385
01:14:33,540 --> 01:14:43,780
Überall hier das richtige eingestellt ist auch hier acht guck ich glaube irgendwie das packt rum

1386
01:14:44,900 --> 01:14:48,940
Okay, wir probieren jetzt mal was anderes nur um sicherzustellen dass das irgendwie an mir liegt

1387
01:14:49,660 --> 01:14:50,900
und zwar

1388
01:14:50,900 --> 01:14:56,500
Guck mal was wir jetzt machen wir sind jetzt einfach mal das hier ist jetzt einfach kein string sondern in pointer

1389
01:14:57,220 --> 01:14:59,700
Und spätestens jetzt sollte er es ja nicht aufräumen

1390
01:15:00,220 --> 01:15:16,520
So mal gucken ob es jetzt memory leaks gibt also ich würde sagen es gibt memory leaks

1391
01:15:17,000 --> 01:15:36,620
Ja, ja ja

1392
01:15:36,620 --> 01:15:38,380
guck das geht

1393
01:15:38,380 --> 01:15:39,980
das geht steil

1394
01:15:39,980 --> 01:15:45,820
Ja, also im pointer gibt es memory leaks

1395
01:15:48,520 --> 01:15:55,280
Aber wenn es ein string ist dann gibt das woher weiß der dass er das automatisch freigeben kann das ergibt für mich eigentlich überhaupt

1396
01:15:56,040 --> 01:16:08,040
Nee guck im string checkt er das ich habe keine ahnung wie warum die runtime so 6 header ist

1397
01:16:09,200 --> 01:16:12,360
Aber wenn man ihm sagt ist ein string dann freeter das automatisch

1398
01:16:13,680 --> 01:16:18,960
Ich bin begeistert ich hätte nicht damit gerechnet dass das dort netto das dort netto schlauer ist und das kapiert

1399
01:16:23,250 --> 01:16:25,930
Macht er da unter der haube irgendwie einen free drauf

1400
01:16:26,490 --> 01:16:31,050
Aber woher weiß er überhaupt dass ein free drauf machen darf also das finde ich äußerst

1401
01:16:31,090 --> 01:16:33,090
Spannend dass das funktioniert

1402
01:16:33,610 --> 01:16:41,750
Der checkt das hätte ich nicht gedacht ich hätte gedacht ich muss das von hand machen also das ist das ist schlau

1403
01:16:42,270 --> 01:16:49,380
Also dass das ist von der runtime wirklich schlau dass der den den string ja automatisch freien kann

1404
01:16:50,500 --> 01:16:53,300
Das das ding ist nur das ding ist nur

1405
01:16:53,940 --> 01:16:57,700
dass eigentlich er das eher nicht machen sollte weil

1406
01:16:58,220 --> 01:17:02,460
Er hat keine ahnung ob ich das hier noch irgendwie verwende zum beispiel

1407
01:17:02,460 --> 01:17:04,460
Machen wir doch mal was machen wir mal folgendes

1408
01:17:05,100 --> 01:17:08,340
Machen wir mal hier das muss man jetzt mit wahr machen glaube ich

1409
01:17:09,220 --> 01:17:11,220
Irgendwie so wahr

1410
01:17:13,470 --> 01:17:15,470
Und der wird jetzt gefreed

1411
01:17:16,070 --> 01:17:21,880
Wobei ne dann ist er wahrscheinlich so schlau

1412
01:17:24,790 --> 01:17:26,790
Gute frage

1413
01:17:27,790 --> 01:17:35,580
Entdeckt entdeckt

1414
01:17:36,860 --> 01:17:38,860
Exposed

1415
01:17:39,380 --> 01:17:43,460
Ja die runtime ist so schlau und ruft wirklich free unter der haube

1416
01:17:43,820 --> 01:17:51,420
Das hätte ich nicht gedacht aber da sieht man auch schon das kann echt zu problemen führen wenn ich den string noch weiterverwende in dem

1417
01:17:51,420 --> 01:17:59,700
Drunter liegenden go programm ich bin mir nicht so sicher ob das ein sinnvolles default verhalten ist dass das immer automatisch einen pointer freed

1418
01:18:01,700 --> 01:18:03,700
Da bin ich mir nicht so sicher

1419
01:18:03,700 --> 01:18:06,100
Aber ich glaube das ist ein sinnvolles default verhalten

1420
01:18:06,100 --> 01:18:08,100
Ich glaube das ist ein sinnvolles default verhalten

1421
01:18:08,100 --> 01:18:10,100
Ich glaube das ist ein sinnvolles default verhalten

1422
01:18:10,220 --> 01:18:12,220
Da bin ich mir nicht so sicher

1423
01:18:12,220 --> 01:18:14,220
Wie hast du das rausgefunden?

1424
01:18:14,220 --> 01:18:16,220
Indem ich das einfach einmal global angelegt habe

1425
01:18:16,220 --> 01:18:18,220
den string und immer den gleichen returne

1426
01:18:18,220 --> 01:18:20,220
Und jetzt versucht ihr ihn zum zweiten mal zu freeen

1427
01:18:20,220 --> 01:18:22,220
Und das geht natürlich nicht

1428
01:18:22,220 --> 01:18:24,220
Also ihr habt . net versucht

1429
01:18:24,220 --> 01:18:26,220
Also ich mein ok

1430
01:18:26,220 --> 01:18:28,220
In gewisser logik hat das

1431
01:18:28,220 --> 01:18:30,220
. net erkennt wir bekommen einen charakter pointer

1432
01:18:30,220 --> 01:18:32,220
Und am Ende

1433
01:18:32,220 --> 01:18:34,220
Erkennt wir wir bekommen einen character pointer

1434
01:18:34,220 --> 01:18:36,220
Und am Ende

1435
01:18:36,220 --> 01:18:38,220
Erkennt wir wir bekommen einen charakter pointer

1436
01:18:38,220 --> 01:18:46,340
Charakterpointer und am wandelnden Charakterpointer um, kopieren quasi den Inhalt in einen .NET-String und dann fremen wir den ursprünglichen Pointer.

1437
01:18:46,440 --> 01:18:49,080
Das ist aber eigentlich gar nicht so ungefährlich, weil

1438
01:18:49,800 --> 01:18:55,400
.NET, weil es das automatisch macht, weiß doch überhaupt nicht, ob ich den darunter liegenden Characters,

1439
01:18:55,840 --> 01:18:57,520
Charakter

1440
01:18:57,520 --> 01:19:00,920
Pointer noch weiter verwende, hier beispielsweise.

1441
01:19:02,320 --> 01:19:04,320
Also, weiß nicht.

1442
01:19:04,520 --> 01:19:07,360
Da bin ich, da gehe ich nicht so d'accord mit,

1443
01:19:07,760 --> 01:19:12,290
was das da macht, aber

1444
01:19:12,690 --> 01:19:14,250
soll mir recht sein,

1445
01:19:14,250 --> 01:19:19,640
in dem Fall funzt einfach ohne mein Zutun.

1446
01:19:20,200 --> 01:19:26,130
Ja, wenn man es nicht direkt als String macht, geht das, kann man garantiert unterbinden.

1447
01:19:26,690 --> 01:19:30,690
Wir haben es ja gesehen, man kann es schon unterbinden, indem ich hier einfach einen In-Pointer draus mache.

1448
01:19:31,330 --> 01:19:36,290
Sobald ich hier einen In-Pointer draus mache, dann, dann wird Memory geleaked as fuck, guck.

1449
01:19:37,770 --> 01:19:41,120
Ja,

1450
01:19:41,120 --> 01:19:42,840
700 MB,

1451
01:19:42,840 --> 01:19:47,920
160 MB, 1,2 Gig, 1,4 Gig, 1,7 Gig.

1452
01:19:49,780 --> 01:19:55,540
Also da, also eigentlich hätte ich damit gerechnet, dass ich das eh so machen muss. Charakter-Pointer,

1453
01:19:56,580 --> 01:20:02,400
selbst deserialisieren und dann fremen. Also eigentlich dachte ich, ich muss sowas hier machen, sinngemäß.

1454
01:20:03,500 --> 01:20:06,200
Session,

1455
01:20:06,200 --> 01:20:11,440
In-Pointer, das ist ja im Prinzip nur ein Pointer an die Stelle, wo das Charakter-Array steht,

1456
01:20:11,600 --> 01:20:15,200
sondern ich dachte mir, ich muss, ich muss da jetzt sowas hier machen, zum Beispiel.

1457
01:20:16,120 --> 01:20:17,080
Ähm,

1458
01:20:17,080 --> 01:20:23,960
UTF-8, hier Pointer to String, UTF-8, Client Name. So, wenn ich das mache, sollte es auch Memory Leaks geben, hä?

1459
01:20:24,480 --> 01:20:34,000
Das machen soll es auch Memory Leaks.

1460
01:20:34,920 --> 01:20:36,920
Achso, Semi-Kolon.

1461
01:20:37,720 --> 01:20:45,160
Das sollte auch Memory Leaks geben. Ja, ja, ja, ja, fette, fette Memory Leaks.

1462
01:20:45,920 --> 01:20:47,920
250 MB Memory Leaks pro Sekunde.

1463
01:20:48,600 --> 01:20:51,480
Ja, so und jetzt dachte ich eigentlich, ich, ich

1464
01:20:52,480 --> 01:20:56,640
kopiere mir das hier im .NET String und danach, danach sage ich

1465
01:20:57,120 --> 01:20:59,120
Native Memory Free.

1466
01:20:59,120 --> 01:21:02,360
Das ist, das ist was Neues, das gibt es noch nicht so lange in C-Sharp, das ist, um

1467
01:21:02,600 --> 01:21:10,960
die, den, die Standard, ja, C-Free-Funktion aufzurufen, in der Hoffnung, dass der Code, von dem ich den Pointer bekomme, das mit der Standard C-Free

1468
01:21:12,160 --> 01:21:17,600
Geschichte, mit der Standard, Standard C Alloc-Geschichte allockiert hat, den Speicher. Also

1469
01:21:18,040 --> 01:21:23,600
hoffen wir einfach mal und jetzt sagen wir hier Session Client Name und jetzt sollte ich,

1470
01:21:24,560 --> 01:21:26,080
warum nicht?

1471
01:21:26,080 --> 01:21:32,200
Ach, Unsave, ja, ja. Geht nicht, weil

1472
01:21:33,640 --> 01:21:35,640
muss ein Void Pointer sein.

1473
01:21:36,800 --> 01:21:40,320
Okay, so und jetzt sollte ich auch keine Memory Leaks mehr haben,

1474
01:21:41,120 --> 01:21:45,800
weil jetzt mache ich das von Hand. Ich schnappe mir den Pointer, kopiere den in .NET String und

1475
01:21:46,080 --> 01:21:49,160
dann free ich den Pointer. So müsste das eigentlich sein.

1476
01:21:51,560 --> 01:21:54,280
Und siehe da, es gibt auch keine Memory Leaks mehr.

1477
01:21:54,840 --> 01:22:05,120
Also das macht anscheinend, ernsthaft .NET unter der Haube. Das finde ich ehrlich gesagt ein bisschen

1478
01:22:08,640 --> 01:22:13,420
merkwürdig,

1479
01:22:13,420 --> 01:22:15,020
dass es das macht.

1480
01:22:15,020 --> 01:22:31,310
Sehr komisch, sehr, sehr komisch auf jeden Fall, dass das macht. Wir probieren noch mal was, wir machen jetzt hier noch mal einen String

1481
01:22:31,310 --> 01:22:34,470
draus und dann machen wir das, was der Chat sagt, das interessiert mich nämlich echt.

1482
01:22:35,670 --> 01:22:40,450
S

1483
01:22:40,490 --> 01:22:42,490
Unmanaged

1484
01:22:42,730 --> 01:22:44,730
Unmanaged Type, nicht Bool.

1485
01:22:46,650 --> 01:22:48,810
Char, ne Moment, was gibt es denn da überhaupt?

1486
01:22:50,170 --> 01:22:51,370
Str

1487
01:22:51,370 --> 01:22:53,370
Was haben wir? Oh, das ist Windows Shit.

1488
01:22:53,890 --> 01:23:01,360
LP String, a single byte, null terminated on the character single. Dann haben wir

1489
01:23:02,880 --> 01:23:05,880
LPT String, Unicode Character String.

1490
01:23:11,770 --> 01:23:15,930
LPW String, zwei Byte, alles klar.

1491
01:23:24,740 --> 01:23:37,090
B String, B-Wall-T String. Alter, Microsoft, es ist ja gut, man, übertreibt es halt nicht.

1492
01:23:39,210 --> 01:23:46,690
LPUTF8 String, a pointer to UTF8, Unicode String. Okay, das klingt, das klingt schon mal ganz gut.

1493
01:23:48,010 --> 01:23:50,010
Way too dank.

1494
01:23:52,420 --> 01:23:55,860
Auch keine Memory Leaks. Okay, okay, das muss man wissen.

1495
01:23:57,020 --> 01:23:59,300
Das muss man echt wissen, dass

1496
01:24:06,410 --> 01:24:13,160
es ein automatisches Free macht. Ich weiß nicht, nach was ich suchen muss.

1497
01:24:16,660 --> 01:24:18,660
Das ist Interessantes, also

1498
01:24:20,460 --> 01:24:22,460
Damit hätte ich nicht gerechnet.

1499
01:24:22,540 --> 01:24:24,540
Guck, kein Memory Leak.

1500
01:24:26,920 --> 01:24:33,560
Das muss man in dem Fall wirklich wissen, weil damit rechnet man eigentlich nicht. Gut, also hätten wir den Part, ich muss sagen, das ging

1501
01:24:34,440 --> 01:24:36,120
einfacher als gedacht.

1502
01:24:36,120 --> 01:24:39,080
Jetzt benchmarken wir das Ganze mal, so auf die Schnelle.

1503
01:24:39,440 --> 01:24:45,480
Wir können danach noch ein ordentliches Benchmark.net Projekt drumherum machen, um es beides zu vergleichen, aber

1504
01:24:46,600 --> 01:24:48,600
probieren wir das mal aus.

1505
01:24:48,960 --> 01:24:50,960
Übrigens, das da

1506
01:24:51,120 --> 01:24:55,560
ist auch PPGA, das hier soll eigentlich die Funktion sein, die nichts returnt und

1507
01:24:56,160 --> 01:25:04,590
GoCall2 soll die Funktion sein, die was returnt, sonst wird das nix.

1508
01:25:05,790 --> 01:25:07,790
Jetzt müssen wir das hier anlegen, interop.

1509
01:25:07,790 --> 01:25:14,270
Ja, kopieren wir das mal, GoCall2 und GoCall2 ist einfach nur Void.

1510
01:25:14,870 --> 01:25:20,910
Okay, jetzt benchmarken wir das Ganze mal ganz kurz, auf die Schnelle, also

1511
01:25:21,750 --> 01:25:23,750
Stopwatch

1512
01:25:24,430 --> 01:25:27,720
Start.

1513
01:25:27,720 --> 01:25:31,160
Okay, aus irgendwelchen Gründen funzt mein

1514
01:25:32,000 --> 01:25:34,000
Console-Rightline-Makro nicht.

1515
01:25:34,680 --> 01:25:36,520
Elapsed

1516
01:25:36,520 --> 01:25:38,320
Total

1517
01:25:38,360 --> 01:25:40,360
Seconds

1518
01:25:40,720 --> 01:25:45,280
Stopwatch Stop und hier dazwischen rufen wir mal auf interop.

1519
01:25:45,280 --> 01:25:50,560
So, das hier sollte so gering sein, ein einfacher Function Call, dass das gar nicht auffällt im Endeffekt, ja.

1520
01:25:51,640 --> 01:25:56,000
Das ist jetzt, weil er zum ersten Mal aufgerufen wird, da wird ja nix drauf geben, wir machen da mal eine Schleife drum.

1521
01:25:56,720 --> 01:25:58,720
So, machen wir mal

1522
01:25:59,480 --> 01:26:02,040
100 Aufrufe davon und gucken, wie schnell das ist.

1523
01:26:02,960 --> 01:26:07,240
Und einmal rufen wir es vor der Stopwatch auf, damit es nicht mitgezählt wird.

1524
01:26:07,720 --> 01:26:12,570
Wo bist du überrascht, dass es Pointer gibt?

1525
01:26:14,730 --> 01:26:16,730
Okay, ja, das ist sehr schnell jetzt.

1526
01:26:20,560 --> 01:26:23,280
Gibt es in C-Sharp auch einen Typ für String-Pointer?

1527
01:26:26,000 --> 01:26:30,600
In C-Sharp sind Strings immer Pointer. String ist ein Ref-Type.

1528
01:26:35,210 --> 01:26:37,930
In C-Sharp ist ein String unter der Haube immer ein Pointer.

1529
01:26:39,130 --> 01:26:45,450
Ohne, dass du explizit was hinschreibst. In C-Sharp ist eigentlich 90 Prozent der Sachen, die du verwendest, Pointer.

1530
01:26:46,450 --> 01:26:48,250
Ohne Pointer-Syntax.

1531
01:26:48,250 --> 01:27:00,200
Ich glaube, er meint aber über der, was, wie jetzt?

1532
01:27:13,480 --> 01:27:21,080
Ach so, nee, das ist jetzt in dem Falle von Interop mit wirklich Raw-C-Pointern zu Managed-String-Objekten.

1533
01:27:21,800 --> 01:27:24,240
Damit geht er echt nicht so um, wie erwartet.

1534
01:27:24,680 --> 01:27:33,500
Ja, als dumm gibt es das nur, wenn ich es anscheinend nicht explizit sage. Also,

1535
01:27:33,700 --> 01:27:37,460
was ich vermute, was hier passiert, sobald ich hier hinschreibe,

1536
01:27:38,020 --> 01:27:40,260
sobald ich hier hinschreibe String,

1537
01:27:40,820 --> 01:27:43,220
dann checkt er, wenn das ein

1538
01:27:45,140 --> 01:27:48,220
oder, dann erwartet er einen Character-Pointer,

1539
01:27:49,580 --> 01:27:56,740
kopiert sich den bis zu einem Null-Terminator in einen .NET-String und macht dann einen Free auf den ursprünglichen Pointer.

1540
01:27:56,860 --> 01:28:00,180
Das ist Ultra-Magic unter der Haube, was da passiert.

1541
01:28:00,620 --> 01:28:06,830
Und wenn du das nicht haben willst, dann musst du einfach sagen, mach keinen String draus,

1542
01:28:07,030 --> 01:28:11,390
sondern nimm den, nimm den Raw-Pointer und dann kannst du ihn selbst auslesen und freen.

1543
01:28:11,510 --> 01:28:14,710
Das, das muss ich echt sagen, das ist richtig krasse Magic unter der Haube.

1544
01:28:16,580 --> 01:28:18,940
Also, ja, wenn du das in dumm haben willst,

1545
01:28:19,380 --> 01:28:25,100
okay, dann was du machen kannst ist, ach, das war, meinst du, du kannst auch sowas machen, ja, das funktioniert auch.

1546
01:28:25,700 --> 01:28:31,460
Muss sagen, Unsave-Character-Pointer. Das funktioniert auch, das ist dann, Moment, Moment, das, ha ha,

1547
01:28:31,940 --> 01:28:35,500
Debated, nein, das ist nicht das Gleiche. Du musst einen Byte-Pointer,

1548
01:28:36,140 --> 01:28:40,460
Pointer auf Start von einem Byte-Array setzen, weil, weil,

1549
01:28:42,340 --> 01:28:44,100
das ist auch ein bisschen

1550
01:28:44,100 --> 01:28:51,180
eine Verarschung, da müssten wir aufpassen, wenn man einen Character-Pointer macht, in C-Sharp ist das nicht das Gleiche wie ein Character-Pointer in C.

1551
01:28:51,740 --> 01:28:59,740
Character und ein Byte ist in C das Gleiche. In C-Sharp ist ein Character zwei Byte, weil C-Sharp-Strings intern als UTF-16 speichert.

1552
01:29:00,340 --> 01:29:02,820
Deswegen ist quasi in C,

1553
01:29:03,340 --> 01:29:05,340
in C ist das da

1554
01:29:05,820 --> 01:29:10,740
quasi mehr oder weniger das Gleiche wie das da und das da auch in C-Sharp, aber in C-Sharp ist

1555
01:29:11,500 --> 01:29:18,860
Character-Pointer was anderes. Also das könntest du auch machen, das geht allerdings nur mit Unsave davor, weil sobald du Pointer-Matching machst,

1556
01:29:19,140 --> 01:29:22,220
sagt C-Sharp, ah ja, das ist aber, könnt auch in die Hose gehen.

1557
01:29:23,300 --> 01:29:28,140
Aber muss man in dem Fall gar nicht, weil tatsächlich die Managed-Implementierung von diesem,

1558
01:29:28,540 --> 01:29:34,220
unter der, also unter der Haube machen, machen die schon das Richtige in dem, in dem einen Fall, ja.

1559
01:29:34,940 --> 01:29:41,620
Umwandeln, kopieren einen .NET-String und da unten drunter Free-Callen, das ist schon sehr Magic-mäßig.

1560
01:29:42,100 --> 01:29:48,290
Nee, nee, das ist egal, unter der Haube ist das alles das Gleiche.

1561
01:29:48,890 --> 01:29:54,210
Die, die Interpretation der Daten ist da ein bisschen anders, zum Beispiel, dass du bei einem

1562
01:29:57,510 --> 01:29:58,870
Byte

1563
01:29:58,870 --> 01:30:04,950
kein Minus drin stehen haben kannst, aber bei einem S-Byte, bei einem Signed-Byte, könntest du theoretisch minus 180, aber das reine

1564
01:30:05,270 --> 01:30:09,670
Interpretierungs-, reine Interpretationsfrage, es ist alles in C ein Byte.

1565
01:30:10,110 --> 01:30:16,030
Egal, ob es ein Charakter, ein Byte oder, nee, ein Short ist 16, glaube ich, oder? Ist ein Short nicht in C

1566
01:30:16,630 --> 01:30:21,550
nicht 2-Byte? Also 1 bis 16.000 noch etwas?

1567
01:30:23,390 --> 01:30:28,960
Da bin ich mir jetzt aus dem Kopf nicht sicher. So, aber jetzt haben wir uns,

1568
01:30:29,800 --> 01:30:32,600
jetzt haben wir uns etwas sidetracken lassen.

1569
01:30:33,160 --> 01:30:35,160
Anscheinend ist .NET mittlerweile so

1570
01:30:35,560 --> 01:30:43,000
Five-Head-schlau, dass es, wenn man so komische Dinger macht, wie ich, von denen ich nicht geahnt hätte, dass sie funktionieren,

1571
01:30:43,560 --> 01:30:45,560
tatsächlich funktioniert

1572
01:30:45,800 --> 01:30:50,800
ohne Memory-Leaks zu verursachen. Das hätte ich wirklich nicht gedacht.

1573
01:30:51,640 --> 01:30:56,120
Okay, jetzt wollte ich das mal ganz kurz benchmarken. Wie schnell ist denn das Ganze?

1574
01:31:03,600 --> 01:31:06,440
Okay, ein paar Nanosekunden, aber 100 ist ja auch nix.

1575
01:31:07,240 --> 01:31:09,240
Machen wir mal 1000

1576
01:31:09,640 --> 01:31:15,560
und dann machen wir mal eine Million. Es gibt übrigens ein nices Feature schon seit ein paar C-Sharp-Versionen. Kennt ihr das hier?

1577
01:31:18,020 --> 01:31:19,620
Dass man

1578
01:31:19,620 --> 01:31:23,260
Underscores in die Zahlen machen kann, die eigentlich nix ändern da dran,

1579
01:31:23,980 --> 01:31:28,500
aber viel viel besser lesbar sind. Jetzt erkennt jeder, dass das hier,

1580
01:31:28,940 --> 01:31:33,740
das ist eine Million, also dass das quasi zehn Millionen sind. Machen wir das mal weg. Dass das eine Million ist.

1581
01:31:34,260 --> 01:31:38,860
Das kann man viel besser, viel besser lesen. Man darf übrigens nicht auf die Idee kommen, so zu versuchen,

1582
01:31:39,780 --> 01:31:44,740
weil dann ist das ein Float beziehungsweise ein Double und also mit zwei Punkten geht es dann auch gar nicht.

1583
01:31:46,490 --> 01:31:49,930
Aber das hier, aber das hier ist nice. Ja, das andere sind zehn Millionen gewesen.

1584
01:31:50,570 --> 01:31:56,770
Es ist kein Unterschied. Also, ob ich so schreibe oder so, unter der Haube kommt genau das Gleiche raus, aber es ist besser lesbar.

1585
01:31:56,770 --> 01:32:02,810
Man kann es auch so schreiben, das ist ein bisschen pp-iger, aber es würde auch funktionieren. Oder so, oder so, aber das macht eigentlich keiner.

1586
01:32:02,970 --> 01:32:08,250
Also, das finde ich ganz nice, dass einfach Anderscores in Zahlen ignoriert werden. So eine Million Aufrufe.

1587
01:32:08,650 --> 01:32:11,330
Oh, das ist schon recht langsam.

1588
01:32:13,450 --> 01:32:16,730
90 Millisekunden für eine Million Function Aufrufe.

1589
01:32:17,250 --> 01:32:25,990
Ist das ein Callback Function zu einer Go-Funktion?

1590
01:32:26,510 --> 01:32:32,430
Das ist kein Callback, das ist ein direkter Call von einer Funktion in Go und zwar der hier.

1591
01:32:33,150 --> 01:32:35,150
Guck.

1592
01:32:35,150 --> 01:32:39,030
Wir haben eine leere Funktion in Go, die einfach nur Call Go heißt,

1593
01:32:40,030 --> 01:32:45,190
die in eine Library reinkompiliert wird. Die Library wird in .NET geladen,

1594
01:32:46,830 --> 01:32:50,590
definiert, dass es darin eine Funktion Call Go gibt und dann wird die aufgerufen.

1595
01:32:55,030 --> 01:33:01,990
Unter welchen Umständen merkt man das? Naja, ganz ehrlich, eine Million Function Calls sind schon ganz schön viel.

1596
01:33:02,310 --> 01:33:04,310
Das wird man normalerweise

1597
01:33:05,390 --> 01:33:09,550
nicht wirklich merken. Es sei denn, es sei denn, man hat wirklich irgendwie so eine

1598
01:33:09,870 --> 01:33:16,870
irgendein Parser oder so oder irgendwas, wo das millionenfach aufgerufen wird pro Durchgang, dann macht es schon

1599
01:33:17,430 --> 01:33:22,270
performantechnisch einiges aus. Ich zeige euch jetzt mal den Unterschied. Wir machen jetzt mal eine

1600
01:33:23,230 --> 01:33:28,030
eine Static Public, nennen wir es mal Call

1601
01:33:30,190 --> 01:33:32,590
.NET, nennen wir das jetzt mal, okay.

1602
01:33:33,830 --> 01:33:37,270
Static Public Void. Also, das ist jetzt eine .NET Funktion.

1603
01:33:37,750 --> 01:33:43,270
Nichts irgendwie über Libraries, eine ganz normale .NET Funktion ist das. Und wenn ich die jetzt mal aufrufe hier,

1604
01:33:44,750 --> 01:33:49,030
Call .NET, dann werden wir sehen, Bäm, 1,2 Millisekunden.

1605
01:33:50,470 --> 01:33:54,310
Und mit Release-Modus wahrscheinlich sogar noch ein bisschen weniger, ja.

1606
01:33:55,830 --> 01:33:58,790
Also 500, 500 Nanosekunden

1607
01:34:00,790 --> 01:34:02,790
Versus, versus

1608
01:34:05,130 --> 01:34:07,130
500 Nanosekunden versus

1609
01:34:07,850 --> 01:34:09,850
80 Millisekunden.

1610
01:34:10,690 --> 01:34:12,290
Okay, also

1611
01:34:12,290 --> 01:34:21,910
C-Interop ist immer noch nicht das Allerschnellste, was man machen kann. Das ist, das ist echt lahm. Das ist wirklich lahm.

1612
01:34:22,430 --> 01:34:29,750
80 Millisekunden für eine Million Funktionsaufrufe. Also von .NET nach .NET braucht das Ganze, braucht das Ganze

1613
01:34:29,990 --> 01:34:34,710
500 Nanosekunden. Also hier 0,5 Millisekunden und

1614
01:34:35,670 --> 01:34:44,670
von .NET nach Go braucht es 80 Millisekunden. In normalen Anwendungen, wo das nicht oft aufgerufen wird, ist es überhaupt gar kein Problem, ja.

1615
01:34:46,470 --> 01:34:50,830
Aber so ist schon ordentlich Overhead.

1616
01:34:52,150 --> 01:34:59,630
Ich meine, selbst bei meiner WebRTC-Anwendung, wenn man 30 FPS hat pro Kamera und 100 Kameras drin, dann sind das

1617
01:35:00,150 --> 01:35:01,510
3000,

1618
01:35:01,510 --> 01:35:03,670
3000 Function Calls pro

1619
01:35:04,670 --> 01:35:08,470
Sekunde. Das ist halt nix im Endeffekt, nix.

1620
01:35:09,470 --> 01:35:14,150
Das ist egal, ob ich Function, ob ich hier C-Go Overhead habe, das juckt einfach nicht.

1621
01:35:14,750 --> 01:35:22,450
Für jeden Function Call einen neuen Thread starten,

1622
01:35:23,570 --> 01:35:25,570
ist vielleicht ein bisschen Overkill, aber das würde,

1623
01:35:26,130 --> 01:35:29,890
würde, würde zumindest teilweise die ganze Sache schneller machen, ja.

1624
01:35:33,130 --> 01:35:35,930
Also besser parallel, aber also es ist schon,

1625
01:35:36,570 --> 01:35:41,230
ja,

1626
01:35:41,470 --> 01:35:43,550
schon ein bisschen, schon ein bisschen langsamer.

1627
01:35:46,180 --> 01:35:53,900
Ich glaube, in dem Fall macht .NET gar nicht so viel Magie, sondern es ist eher Go, was die Magie macht. .NET macht in dem Fall ein relativ straight

1628
01:35:54,580 --> 01:35:57,300
Call, wie man halt eine C-Funktion callt.

1629
01:35:57,700 --> 01:36:04,500
Bisschen Magic bestimmt, aber Go macht halt extrem viel Magic für ihren Threads und, und Runtime-Scheduler,

1630
01:36:04,940 --> 01:36:08,180
dass sich das nicht in die Quere kommt. Also C-Go ist

1631
01:36:08,740 --> 01:36:13,740
berüchtigt, oder Go ist berüchtigt dafür, dass der Interop mit anderen Sprachen echt langsam ist.

1632
01:36:14,220 --> 01:36:34,390
Du hast recht, du hast recht, wer auch immer das gesagt hat, du hast recht, deswegen, deswegen machen wir das jetzt mal im Debug-Modus, du hast recht,

1633
01:36:34,910 --> 01:36:38,190
du hast recht. Also im Debug-Modus brauchen wir ungefähr

1634
01:36:39,070 --> 01:36:42,910
82 Millisekunden, 85 Millisekunden Go und Call-NET

1635
01:36:43,550 --> 01:36:45,470
brauchen wir

1636
01:36:45,470 --> 01:36:47,270
eine Millisekunde, okay.

1637
01:36:47,270 --> 01:36:54,150
Ja, du hast recht, das könnte durchaus sein, dass sie scharp schlau genug ist und die Funktion rausschmeißt im Release-Modus, weil es feststellt, okay,

1638
01:36:54,670 --> 01:36:59,430
das ist eine, das ist eine Schleife mit nichts drinnen, also scheiß drauf, mach weg. Ja.

1639
01:37:03,580 --> 01:37:06,780
Test mit einem Print. Print ist immer ganz schlecht für sowas.

1640
01:37:08,060 --> 01:37:10,260
Print ist immer ganz, ganz mies.

1641
01:37:12,060 --> 01:37:18,620
Print ist auf die Konsole und Single Output und so. Nee, der überspringt, ich hab's jetzt im Debug-Modus, da wird nix, da wird nix geskippt.

1642
01:37:19,300 --> 01:37:23,000
Da wird nix geskippt.

1643
01:37:23,400 --> 01:37:25,200
Der ruft die wirklich auf.

1644
01:37:25,200 --> 01:37:31,600
Aber ganz ehrlich, das ist auch zu erwarten,

1645
01:37:32,200 --> 01:37:38,600
dass ein Function Call von .NET nach .NET nahezu kein Overhead hat. Wäre ja auch, wäre ja auch schlimm, wenn nicht.

1646
01:37:38,960 --> 01:37:42,600
Okay, also, dann haben wir das jetzt ausprobiert für Go.

1647
01:37:43,480 --> 01:37:46,360
Wollen wir mal gucken, wie schnell das mit dem Struct ist.

1648
01:37:49,310 --> 01:37:51,790
Oh, das ist natürlich noch mal eine ganze Ecke langsamer.

1649
01:37:52,430 --> 01:37:58,490
Hoho.

1650
01:37:58,770 --> 01:38:00,770
Ja, es schwankt ein bisschen.

1651
01:38:01,210 --> 01:38:05,370
Wir machen gleich mal eine, wir machen gleich mal einen Benchmark. Komm, wir machen jetzt schon einen Benchmark draus.

1652
01:38:06,330 --> 01:38:09,650
Wir machen jetzt schon einen Benchmark draus, bevor wir die Rust-Sache basteln.

1653
01:38:10,650 --> 01:38:12,650
Nougat.

1654
01:38:13,370 --> 01:38:15,370
Benchmark.net

1655
01:38:16,850 --> 01:38:24,360
Bam. Mir gefällt C-Sharp auch enorm gut und ich bin wirklich kein Microsoft-Fan.

1656
01:38:24,920 --> 01:38:31,120
Ich weiß, ich weiß. Wobei das, das ein uralter Artikel ist, das meinte ich ja, und das ist auch das, was ich am Anfang des Streams gesagt habe.

1657
01:38:31,440 --> 01:38:36,320
Dass ich auch mal heute gucken will, wie sehr sich das, wie sehr sich das verbesserte, wie, wie sehr sich das

1658
01:38:39,060 --> 01:38:45,020
verbessert hat. C, Go, Interop. Ich denke schon, dass es schneller geworden ist. Wir machen mal kurz eine Benchmark-Klasse.

1659
01:38:45,500 --> 01:38:47,500
Public Class, Bench,

1660
01:38:49,300 --> 01:38:51,300
Benchmark.

1661
01:38:53,300 --> 01:39:00,220
Wie geht, Moment, Moment, wie ging das jetzt noch mal, Moment, Moment, irgendwie Benchmark, Runner, nee, nee, nee, Bench, Benchmark, Runner?

1662
01:39:01,220 --> 01:39:03,220
Runner? Benchmark, Runner?

1663
01:39:04,780 --> 01:39:09,660
Run, Benchmark, okay.

1664
01:39:11,500 --> 01:39:14,660
Das hier oben kommt weg, das,

1665
01:39:15,940 --> 01:39:20,060
ein Aufruf hier oben ist okay, das kommt da rein.

1666
01:39:20,940 --> 01:39:24,380
Public, Void, das nennen wir jetzt einfach mal irgendwie Run,

1667
01:39:25,100 --> 01:39:27,100
Run, Go oder so.

1668
01:39:27,420 --> 01:39:33,330
Dann kommt das hier rein. Machen wir, machen wir aber mal nur, nur,

1669
01:39:35,560 --> 01:39:43,310
ja doch, na komm, 1000, 1000 Aufrufe ist vielleicht besser, da kann das mehrfach, mehrfach die Funktion aufrufen.

1670
01:39:43,830 --> 01:39:45,830
Okay, Go, Run.

1671
01:39:46,430 --> 01:39:47,910
Und jetzt,

1672
01:39:47,910 --> 01:39:52,560
ich glaube, jetzt muss man hier noch Benchmark drüber schreiben, ne?

1673
01:39:55,580 --> 01:40:00,660
Okay, so und jetzt sollte er eine ordentliche Ausgabe haben, wie schnell der ist.

1674
01:40:03,410 --> 01:40:04,890
Zack.

1675
01:40:04,890 --> 01:40:06,890
Wow, wat?

1676
01:40:06,930 --> 01:40:09,610
There are not any result runs, warum?

1677
01:40:10,410 --> 01:40:18,860
Failed. Der erkennt wieder mein .NET nicht. Mann, was ist das für ein Upfuck? Okay, Export, hier, Path,

1678
01:40:20,660 --> 01:40:38,500
Export, .NET, kann man hier drinnen, kann man hier drinnen relative Farbe verwenden?

1679
01:40:39,100 --> 01:40:43,760
Gar nicht sicher. .NET,

1680
01:40:46,080 --> 01:40:49,010
Version,

1681
01:40:49,010 --> 01:40:51,610
Minus, Minus, Version, 7, nee.

1682
01:40:52,610 --> 01:40:54,610
Also, Home,

1683
01:40:56,250 --> 01:40:58,250
Max,

1684
01:40:58,370 --> 01:41:00,370
Jetzt ist es 8, okay.

1685
01:41:00,690 --> 01:41:05,330
Mach doch in die Bash-RC. Eigentlich will ich meine System.NET Version nicht überschreiben.

1686
01:41:06,730 --> 01:41:08,010
So.

1687
01:41:08,010 --> 01:41:10,530
Und jetzt sagen wir Run, Release, jetzt soll es hoffentlich gehen.

1688
01:41:15,240 --> 01:41:21,880
Jetzt wird ordentlich gebenchmarkt, fast wie in einem Nick Chapsas Video hier. Der Benchmarkt auch immer.

1689
01:41:22,080 --> 01:41:24,080
50 Mal.

1690
01:41:25,360 --> 01:41:27,360
Falls dir jemand guckt.

1691
01:41:28,120 --> 01:41:30,120
Da wird auch immer bis zum Umkippen gebenchmarkt.

1692
01:41:31,120 --> 01:41:42,840
Wenn du Variable für die Anzahl machst, kannst du die Anzahl der Durchläufe testen.

1693
01:41:43,760 --> 01:41:48,120
So, also, Go hat im Durchschnitt

1694
01:41:50,120 --> 01:41:52,120
182

1695
01:41:52,640 --> 01:41:57,160
Mikrosekunden.

1696
01:41:58,200 --> 01:42:00,200
Also für

1697
01:42:00,960 --> 01:42:02,960
1000 Aufrufe.

1698
01:42:09,900 --> 01:42:12,220
Das ist jetzt halt nicht, nicht so schnell.

1699
01:42:20,760 --> 01:42:22,760
Warum? Warum?

1700
01:42:23,360 --> 01:42:25,360
Ich brauche ja keine Parameter, oder?

1701
01:42:28,300 --> 01:42:33,980
Hast du dir mal das Video angeguckt? Da muss ich nicht das Video angucken, das habe ich oft genug erzählt, dass die .NET Versionierung

1702
01:42:34,460 --> 01:42:43,530
beschissen ist. Da habe ich ja schon, da habe ich ja schon selbst oft genug gesagt, also, ach komm.

1703
01:42:44,770 --> 01:42:50,480
Machen wir einfach, machen wir nur 100.

1704
01:42:54,250 --> 01:42:58,850
Und wir callen jetzt das ohne Overhead, also das, was nix macht.

1705
01:42:59,730 --> 01:43:05,310
So, und jetzt das Ganze noch einmal für Rust. Auf geht's.

1706
01:43:06,750 --> 01:43:35,840
Krustentiere versammeln. Ah ja, ja, danke schön für den Sub.

1707
01:43:37,840 --> 01:43:39,840
Bolgi19.

1708
01:43:40,880 --> 01:43:42,880
Huge Subscription.

1709
01:43:44,240 --> 01:43:48,120
Sorry, falls ich irgendjemanden übersehen habe, ich gucke mal kurz rein.

1710
01:43:49,160 --> 01:43:51,160
Creator Dashboard.

1711
01:43:51,240 --> 01:44:00,010
Der Karlzon, danke für den Sub, haben wir hier den ZeppCon.

1712
01:44:01,010 --> 01:44:08,410
Shapeshifter und Stripes. Der Razer hat auch Subscribed vorhin noch, der Alfred auch.

1713
01:44:09,010 --> 01:44:11,010
Gar nicht richtig gesehen, alles hier.

1714
01:44:13,420 --> 01:44:20,930
Vomax heute morgen.

1715
01:44:20,930 --> 01:44:24,210
So, also, es wird Zeit für Go.

1716
01:44:28,520 --> 01:44:31,160
Wir kommentieren das hier gerade mal aus.

1717
01:44:32,640 --> 01:44:34,640
Und ich sage jetzt mal,

1718
01:44:35,320 --> 01:44:37,240
Call.

1719
01:44:37,240 --> 01:44:40,640
Wir brauchen jetzt, wir brauchen jetzt Call

1720
01:44:42,120 --> 01:44:44,120
Call Rust.

1721
01:44:44,120 --> 01:44:46,120
Das wird nicht funktionieren, weil es das auch nicht gibt.

1722
01:44:49,010 --> 01:44:55,130
Ja, bam, Crash, gibt es nicht. So, also, ich muss jetzt in Rust eine Library erzeugen, die RustLib heißt.

1723
01:44:55,370 --> 01:45:00,610
Jetzt geht es los. Ich habe keine Ahnung, wirklich absolut keinen blassen Schimmer, wie ich das jetzt machen soll.

1724
01:45:00,610 --> 01:45:03,410
Okay, also, müssen wir mal suchen. Rust

1725
01:45:05,530 --> 01:45:07,530
FFI

1726
01:45:07,770 --> 01:45:12,370
The Rustonomicon. Okay, jetzt kriegen wir es erklärt.

1727
01:45:13,210 --> 01:45:16,210
Also, Calling Foreign Functions.

1728
01:45:21,240 --> 01:45:24,960
Rust ist so eklig. Alter, wenn ich das hier schon sehe. Ich dreh aber.

1729
01:45:26,840 --> 01:45:30,790
Create Type.

1730
01:45:35,040 --> 01:45:41,540
Wie macht man das überhaupt? Da gab es doch mal irgendein GitHub.

1731
01:45:42,580 --> 01:45:44,580
Rust FFI Examples.

1732
01:45:45,100 --> 01:45:48,760
Gucken wir mal.

1733
01:45:48,760 --> 01:45:52,320
Hat er denn? C Sharp to Rust, das ist doch schon mal ein gutes Beispiel.

1734
01:45:53,080 --> 01:45:55,080
Ja, Cargo Tommel.

1735
01:45:56,240 --> 01:45:58,520
Also, das braucht man. Lib.

1736
01:45:59,600 --> 01:46:03,960
Okay, also, let's go. Wir müssen in unsere Cargo Tommel gehen.

1737
01:46:04,720 --> 01:46:07,080
Und da jetzt ein Lib hinzufügen. Lib.

1738
01:46:08,120 --> 01:46:10,120
Name ist einfach

1739
01:46:11,040 --> 01:46:15,480
RustLib. RustLib, so wahrscheinlich, wie der Output heißen soll.

1740
01:46:16,480 --> 01:46:18,480
CD Lib klingt gut.

1741
01:46:21,830 --> 01:46:26,110
Und jetzt ist die Frage, wie funzt das? Source, Lib S.

1742
01:46:26,830 --> 01:46:35,790
Ja, copy-pasten wir uns mal hier rein und nennen es Call Rust, aber wir haben kein Input und wir haben kein Output erst mal.

1743
01:46:37,150 --> 01:46:41,150
No Mängel extern FN Call Rust.

1744
01:46:44,880 --> 01:46:51,400
Das hier bedeutet, glaube ich, dass er die Namen genauso lässt, wie die Funktion heißt, sodass sie später aufgerufen werden kann.

1745
01:46:52,360 --> 01:46:57,360
Und Main können wir eigentlich raus machen. No Main Function Found. Ja, ist doch klar, will ich auch nicht mehr.

1746
01:46:58,440 --> 01:47:01,640
Cannot Find Library RustLib. Rename File zu...

1747
01:47:02,440 --> 01:47:06,960
Okay. Source Main in Lib. S.

1748
01:47:08,680 --> 01:47:14,640
Achso, Cargo Run geht natürlich. Cargo Build. Ohne Fehler hat es gebildet. Ich fass es nicht.

1749
01:47:17,240 --> 01:47:21,120
Und jetzt, wo ist das Ganze? Target. Debug.

1750
01:47:22,520 --> 01:47:25,160
Lib. Lib. Rust. Lib.

1751
01:47:26,160 --> 01:47:29,240
Hört sich ein bisschen kacke vielleicht an, oder?

1752
01:47:30,080 --> 01:47:35,160
Wie habe ich es genannt? Ich habe es einfach nur RustLib genannt. Also, dann heißt es hier einfach nur Rust.

1753
01:47:37,300 --> 01:47:40,280
Build.

1754
01:47:40,280 --> 01:47:47,280
Lib Rust Punkt S. Ja, meinetwegen, dann heißt es halt nicht RustLib, sondern Lib Rust.

1755
01:47:47,880 --> 01:47:50,080
Auch gut, kann ich auch mit leben, okay?

1756
01:47:51,800 --> 01:47:54,280
Und jetzt Build. Okay, Minus Minus Release.

1757
01:47:54,760 --> 01:48:03,030
Wobei eigentlich wurscht es, wie ich das nenne. Wir können auch sagen Build Release. Dann sagen wir CP oder MV.

1758
01:48:05,710 --> 01:48:14,340
Target. Build. Release. Lib Rust Punkt S. O. Hoch zu...

1759
01:48:15,940 --> 01:48:17,540
Benchmark.

1760
01:48:17,540 --> 01:48:19,540
Und dann soll das einfach heißen

1761
01:48:19,740 --> 01:48:21,900
RustLib Punkt S. O. Ich benenne es einfach um.

1762
01:48:25,450 --> 01:48:30,690
Doch, doch. Das ist eigentlich schon richtig. Ich habe es nur falschrum benannt. Ich habe es falschrum benannt. Lib, das ist auf jeden Fall

1763
01:48:30,810 --> 01:48:34,050
so, so ist richtiger als meins. Mit Lib zuerst.

1764
01:48:36,840 --> 01:48:43,280
Okay, so jetzt haben wir in unserem .NET Projekt noch eine RustLib. Die fügen wir hinzu in den Output.

1765
01:48:44,120 --> 01:48:49,240
Dass er die auch findet, wenn er dann später, später läuft. Ja, so, also Build Action.

1766
01:48:51,040 --> 01:48:57,160
Copy hier. Zack. So, und wenn wir Glück haben, funktioniert das jetzt schon.

1767
01:48:57,160 --> 01:49:05,400
Hey, es läuft. Rust Aufruf. Funzt. So, Beweis. Moment. Beweis, dass es funktioniert.

1768
01:49:06,400 --> 01:49:08,400
Source.

1769
01:49:08,440 --> 01:49:09,640
Print.

1770
01:49:09,640 --> 01:49:14,080
Was ist das? Module. Declaration. Reload. Immer. Restart. Hilft immer.

1771
01:49:14,800 --> 01:49:17,360
Okay, nice. So, jetzt bin ich mal hier. Das Brindeln.

1772
01:49:18,000 --> 01:49:20,000
Cack W.

1773
01:49:20,800 --> 01:49:27,120
Build. Und jetzt aufrufen von .NET aus. Moment. Oh, zu viele Fenster. Aufrufen von .NET auf. Cack W.

1774
01:49:27,960 --> 01:49:29,960
Funzt. Sehr gut.

1775
01:49:30,000 --> 01:49:37,240
Exzellent. Okay, jetzt können wir mal testen, wie schnell das ist, in Go das, in Rust das Ganze zu machen.

1776
01:49:37,240 --> 01:49:41,160
Und danach bauen wir das noch mit Rust und Struct zurückgeben.

1777
01:49:42,280 --> 01:49:46,000
Also, wir sagen jetzt Interop. Call. Go.

1778
01:49:49,070 --> 01:49:51,070
Und zwar mein Benchmark.

1779
01:49:52,760 --> 01:49:56,160
Interop. Call. Net. Wir machen jetzt alle drei Sachen.

1780
01:49:58,320 --> 01:50:00,720
So, also wir kopieren uns den Benchmark.

1781
01:50:02,240 --> 01:50:09,240
Und den Benchmark. Sagen wir Run. Go. Run. Rust. Und Run. .NET. Das sollte ja eigentlich das Schnellste sein.

1782
01:50:10,040 --> 01:50:11,680
Call. Net.

1783
01:50:11,680 --> 01:50:17,520
Und hier Rust. Jetzt bin ich mal auf die Ergebnisse gespannt, was da rauskommt.

1784
01:50:19,520 --> 01:50:22,240
C. Release. Wir machen es auch so schnell, wie geht. Zack.

1785
01:50:23,440 --> 01:50:30,640
Lassen wir das mal kurz laufen und ich gucke in den Chat. Moin, bin aktuell auf Windows. Man würde gerne auf Linux rüber wechseln.

1786
01:50:30,960 --> 01:50:37,360
OS gefällt mir sehr. Jedoch zweifle ich noch, da ich gerne zocke und ich weiß, wie gut das unter Linux funktioniert. Ganz ehrlich,

1787
01:50:38,200 --> 01:50:44,080
wenn du viel spielst und je nachdem, was du spielst, wenn du Spiele beispielsweise mit Anti-Cheat spielst, also

1788
01:50:44,160 --> 01:50:47,760
wobei CS ja wohl mittlerweile ganz gut funktioniert, aber wenn du sowas wie, sagen wir mal,

1789
01:50:48,000 --> 01:50:52,920
Rainbow Six, Fortnite oder sowas spielst, dann hast du eigentlich verloren unter Linux.

1790
01:50:54,780 --> 01:50:59,220
Ich würde dir empfehlen, mach das so wie ich erstmal. Benutz Windows als Host

1791
01:50:59,820 --> 01:51:07,060
und auf dem zweiten Windows-Desktop eine Linux-VM mit Fullscreen, wo du zwischendrin hin- und herschalten kannst. Du machst in der Linux-VM alles, was du

1792
01:51:07,060 --> 01:51:11,660
machen willst, was gut unter Linux ist und für Sachen wie

1793
01:51:12,620 --> 01:51:14,580
Videos gucken,

1794
01:51:14,580 --> 01:51:16,580
streamen, Videobearbeitung,

1795
01:51:17,580 --> 01:51:19,420
irgendwelche

1796
01:51:19,420 --> 01:51:25,140
Games, dann machst du es unter Windows. Da hast du, finde ich, das Beste aus beiden Welten und das Gute ist,

1797
01:51:25,420 --> 01:51:31,620
du kannst dich ein bisschen an Linux gewöhnen, ohne dass du irgendwie Dualboot machen musst oder direkt ins kalte Wasser geworfen wirst.

1798
01:51:32,020 --> 01:51:34,020
Also zum Anfang

1799
01:51:35,260 --> 01:51:43,880
einfach nur eine VM und gut ist. So, aber was sagt der meine Benchmarks hier?

1800
01:51:51,740 --> 01:51:53,740
Meine Benchmarks, Benchmarken noch.

1801
01:51:54,020 --> 01:52:05,510
Ich bin mal gespannt, was rauskommt. Also ich meine, eigentlich kann ich es mir schon denken. .NET am schnellsten, gefolgt von Rust

1802
01:52:05,870 --> 01:52:07,870
und dann Go hintendran.

1803
01:52:07,910 --> 01:52:16,240
Also in diesem einen speziellen Fall jetzt. Was macht der da eigentlich so lange?

1804
01:52:17,960 --> 01:52:23,640
So, ja, guck mal. Boah, alter, was ein Unterschied, man!

1805
01:52:26,200 --> 01:52:34,160
Guckt euch das mal an. Okay, also unser Benchmark ist 100 Funktionsaufrufe, die nichts machen, ja. Also

1806
01:52:35,480 --> 01:52:39,280
von einem Funktionsaufruf 100, nicht einer.

1807
01:52:40,280 --> 01:52:45,200
100 Funktionsaufrufe von .NET nach .NET sind natürlich abfuck schnell.

1808
01:52:46,680 --> 01:52:50,440
28,8 für Nanosekunden. Das ist mega schnell, ja.

1809
01:52:51,400 --> 01:52:53,160
Das ist aber auch klar.

1810
01:52:53,160 --> 01:53:00,960
Gefolgt von Rust. Call in Rust, also die haben ein super, super C-Interface, was einfach funktioniert, ohne viel Overhead.

1811
01:53:01,720 --> 01:53:03,040
Nur

1812
01:53:03,040 --> 01:53:06,120
125 Nanosekunden für 100 Aufrufe. Das ist auch im Prinzip

1813
01:53:06,840 --> 01:53:14,360
Mix, eigentlich. Und jetzt kommt Go. Go braucht einfach mal, sehe ich das richtig, 8 Millisekunden.

1814
01:53:14,800 --> 01:53:16,480
Also

1815
01:53:16,480 --> 01:53:21,590
8114 Nanosekunden.

1816
01:53:21,590 --> 01:53:24,590
Jetzt muss ich ein Video machen auf YouTube, dass Go stirbt, ja.

1817
01:53:27,090 --> 01:53:30,210
Blazingly fast. Rust is destroying Go.

1818
01:53:33,330 --> 01:53:38,410
Go will be dead soon. Oder irgendwas in der Regel. Wir brauchen noch ein bisschen mehr, mehr Klick.

1819
01:53:38,530 --> 01:53:43,810
Wir brauchen, wir brauchen Klickbait. Go is dead. Here is why.

1820
01:53:54,460 --> 01:53:57,980
Mikrosekunden. Ja, ja, Mikrosekunden. Wir sind hier in Bananosekunden.

1821
01:53:59,900 --> 01:54:03,260
How Golang is destroying your performance. Genau.

1822
01:54:04,900 --> 01:54:08,820
Mikrosekunden, nicht Millisekunden. Ja, ich hab mich vertan. Kann man auch mal durcheinander kommen. Also

1823
01:54:09,540 --> 01:54:13,780
.NET, logischerweise in dem Fall das schnellste. 28 Nanosekunden. Rust

1824
01:54:14,020 --> 01:54:20,540
125 Nanosekunden. Würde ich sagen, das ist so wirklich, da kannst du ohne Problem nach Rust callen. Und hier 8 Mikrosekunden.

1825
01:54:20,940 --> 01:54:24,020
Nicht, dass 8 Mikrosekunden schnell wäre, aber es ist um Größenordnungen

1826
01:54:25,260 --> 01:54:35,620
langsamer als Rust. .NET steht ja eigentlich gar nicht zur Auswahl, weil die WebRTC-Libraries für .NET,

1827
01:54:36,220 --> 01:54:39,300
da gibt, es gibt SipSorcery für .NET, das ist auch nicht schlecht.

1828
01:54:39,980 --> 01:54:44,540
Aber ich finde, dem fehlen noch ein paar Features, dass man sie komplett

1829
01:54:45,100 --> 01:54:50,780
so gut benutzen kann, wie die Go-Library zum Beispiel. Und die Rust-Library weiß ich noch nicht.

1830
01:54:50,860 --> 01:54:56,300
Das ist ein Nachbau von der Go-Library, die ich verwenden will, aber ich weiß nicht, wie feature-complete die schon ist.

1831
01:55:09,960 --> 01:55:12,800
Mach die Übung mal anders, mit Rust als Base und import C-Sharp.

1832
01:55:17,710 --> 01:55:21,710
Also, von Rust nach Go wird mehr oder weniger genauso sein.

1833
01:55:23,470 --> 01:55:27,510
Aber von Rust nach C-Sharp ist gar nicht so einfach möglich,

1834
01:55:27,990 --> 01:55:32,630
weil C-Sharp braucht eine .NET-Runtime, die läuft.

1835
01:55:33,230 --> 01:55:37,350
Das heißt, ich müsste quasi eine .NET-Runtime in Rust hosten, was sicherlich geht.

1836
01:55:38,030 --> 01:55:41,710
Ja, du kannst AOT machen, aber ich erzähle euch, wie es die ganze Zeit gewesen ist.

1837
01:55:42,150 --> 01:55:46,590
Du bräuchst quasi, du musst quasi eine .NET-Runtime in Rust hosten. Ich glaube, das will man nicht machen.

1838
01:55:47,230 --> 01:55:49,230
Seit den letzten,

1839
01:55:49,710 --> 01:55:56,630
seit .NET 6, aber eher seit .NET 7 und noch spannender wird es mit .NET 8. .NET 8 kommt ja demnächst,

1840
01:55:56,910 --> 01:55:58,790
quasi raus.

1841
01:55:58,790 --> 01:56:03,190
Da unterstützen die ja auch Ahead-of-Time-Compilation, also im Prinzip das, was

1842
01:56:03,790 --> 01:56:05,790
so ein Compiler macht.

1843
01:56:06,230 --> 01:56:10,670
Normalerweise halt irgendwas native ausführbares rauswerfen. Dann kann man

1844
01:56:11,510 --> 01:56:17,310
auch, Moment, da gibt es wirklich was, da kann man dann auch direkt Funktionen daraus aufrufen.

1845
01:56:20,150 --> 01:56:25,310
Nee, das ist was anderes. Das ist was anderes. Das ist Rust zu

1846
01:56:26,150 --> 01:56:31,510
IR-Kompilieren, was dann in .NET laufen kann. Das ist auch Six-Head, dass es sowas gibt,

1847
01:56:32,830 --> 01:56:36,110
aber das ist andersrum.

1848
01:56:36,110 --> 01:56:40,550
Das ist Rust in .NET. Wir wollen ja .NET von echtem Rust aufrufen.

1849
01:56:41,430 --> 01:56:43,430
So, jetzt müssen wir aber nochmal,

1850
01:56:43,870 --> 01:56:47,190
was ist IR-Intermediate? Also das ist quasi IL.

1851
01:56:49,910 --> 01:56:54,270
IL und IR ist das, ist das, ist das gleiche quasi.

1852
01:56:54,790 --> 01:56:56,790
Bin ich jetzt blöd?

1853
01:56:59,150 --> 01:57:03,630
Ja, also IR und IL ist das gleiche im Endeffekt. Das ist nicht direkt

1854
01:57:04,150 --> 01:57:10,790
ausführbar von deinem Rechner, aber ausführbar von der .NET-Runtime. Also C-Sharp kompiliert ja auch nicht direkt in

1855
01:57:11,550 --> 01:57:16,230
ein Binary, was du ausführen kannst, sondern C-Sharp kompiliert in Bytecode,

1856
01:57:16,750 --> 01:57:23,790
den .NET ausführen kann. Und wenn du in den C-Sharp-Binary startest, dann ist es in Wirklichkeit sehr, sehr, sehr, sehr, sehr, sehr, sehr, sehr, sehr

1857
01:57:24,670 --> 01:57:28,040
so, dass erst mal

1858
01:57:28,040 --> 01:57:31,080
.NET gestartet wird und .NET startet dann ein C-Sharp,

1859
01:57:32,000 --> 01:57:34,000
liest dann das

1860
01:57:34,400 --> 01:57:39,400
CLR, IR oder IL ein, je nachdem wie man es nennt und führt das aus.

1861
01:57:40,320 --> 01:57:42,920
Und dort ist es so, dass quasi

1862
01:57:43,760 --> 01:57:49,360
Rust zu IL umgewandelt wird und IL kann dann von der .NET-Runtime ausgeführt werden.

1863
01:57:49,600 --> 01:57:54,000
Das ist halt echt schon richtig sick, Seth. Ich wüsste nicht genau, wozu das...

1864
01:57:54,360 --> 01:58:04,920
Ich meine, ja, um Rust-Libraries in C-Sharp zu verwenden, aber es funktioniert noch nicht alles.

1865
01:58:05,920 --> 01:58:07,920
Aber cool, dass das funktioniert.

1866
01:58:08,760 --> 01:58:15,040
So, jetzt haben wir unser Benchmark-Zeug hier am Start. Das werde ich jetzt gerade einfach mal wieder auskommentieren.

1867
01:58:16,760 --> 01:58:24,560
Und wir gucken uns mal an, wie man in Rust ein Struct baut und das Struct zurückgibt

1868
01:58:24,960 --> 01:58:28,880
an C-Sharp. Also, Call Rust 2 brauchen wir jetzt noch.

1869
01:58:31,700 --> 01:58:33,700
Das legen wir jetzt hier auch mal an.

1870
01:58:36,150 --> 01:58:43,550
Ich prophezeie, dass es etwas einfacher wird als in Go, weil Rust-C-Interop ist ziemlich gut in der Regel.

1871
01:58:54,500 --> 01:59:00,820
Aber Rust hat schon .NET-Libraries, oder nicht? Nee, Rust ist Rust und Rust ist nicht .NET normalerweise.

1872
01:59:07,170 --> 01:59:11,490
Hast du einen coolen, vielleicht auch leichten Weg mit Rust? Ich habe keine Ahnung.

1873
01:59:12,490 --> 01:59:18,890
Aber ich glaube, man muss ganz schön masochistisch sein, veranlagt sein, mit Rust Windows-UI-Anwendungen bauen zu wollen.

1874
01:59:20,330 --> 01:59:22,330
Das ist einfach nur so mein Bauchgefühl dazu.

1875
01:59:30,980 --> 01:59:36,260
Blazingly fast written in Rust. Musst du jetzt aber auch bei allen deinen Projekten dabeischreiben.

1876
01:59:40,110 --> 01:59:46,790
Also, okay, wie macht man... Es geht ja schon mal los, Leute. Wie man überhaupt einen Struct in Rust macht.

1877
01:59:47,150 --> 01:59:49,150
Struct. Okay, so...

1878
01:59:49,830 --> 01:59:51,830
Nice, Max, super.

1879
01:59:52,750 --> 01:59:56,750
Ich glaube, so weit wärt ihr wahrscheinlich auch schon gekommen, oder?

1880
01:59:57,550 --> 01:59:59,110
Okay, aber...

1881
01:59:59,110 --> 02:00:01,470
Wie geht es weiter? Rust, Struct.

1882
02:00:02,350 --> 02:00:04,350
FFI, suchen wir mal danach.

1883
02:00:04,830 --> 02:00:08,310
Ja, Complex Data Tabs and Rust FFI, genau.

1884
02:00:09,430 --> 02:00:15,030
Okay, also, Inamstruct, hier, RepR, RepR, RepR, C.

1885
02:00:15,790 --> 02:00:19,990
Okay, das ist so ein typisches Rust-Ding. Das können wir copy-pasten.

1886
02:00:20,510 --> 02:00:23,510
Das ist eines der Gründe, warum Rust echt nicht schön zu lesen ist.

1887
02:00:24,270 --> 02:00:28,280
Pupp, Pupp

1888
02:00:28,840 --> 02:00:34,880
ist quasi was wie Public. Public Ausschreiben ist outdated, overrated. Also machen wir hier mal das gleiche. Session,

1889
02:00:35,480 --> 02:00:38,880
Name. Okay, wir fangen einfach an. Wir machen wieder das gleiche.

1890
02:00:40,320 --> 02:00:42,320
Hier, Client ID.

1891
02:00:42,720 --> 02:00:44,520
Und...

1892
02:00:44,520 --> 02:00:51,480
Nee, komm, wir sind A, B, heißt es jetzt. So, UINT, nee, Moment.

1893
02:00:53,000 --> 02:00:56,920
Int. Moment, es ist Rust. Da ist es U64 einfach nur, gell?

1894
02:00:57,760 --> 02:01:03,400
Ja, es ist Rust. Und hier noch mal, eh noch ein Bool oder so. Ja, okay, Build.

1895
02:01:04,280 --> 02:01:06,800
Es bildet noch. Und jetzt, Return.

1896
02:01:07,560 --> 02:01:09,560
Tja, das ist eine gute Frage. Ich weiß gar nicht, wie ich das

1897
02:01:12,960 --> 02:01:17,160
So? A, 1, 2, 3.

1898
02:01:24,760 --> 02:01:26,760
B, Moment.

1899
02:01:27,760 --> 02:01:29,760
B, Schuhe.

1900
02:01:29,760 --> 02:01:31,760
Ne? Ein Semikolon vielleicht?

1901
02:01:33,760 --> 02:01:37,460
Ja.

1902
02:01:39,460 --> 02:01:41,460
So? Hm.

1903
02:01:44,800 --> 02:01:46,800
Was hat er denn für Schmerzen?

1904
02:01:50,710 --> 02:01:52,710
Ah, ja, ja.

1905
02:01:52,710 --> 02:01:54,710
Was hat er denn für Schmerzen?

1906
02:01:54,790 --> 02:01:57,390
Ach so, weil ich kein Return-Type angegeben habe.

1907
02:01:58,310 --> 02:02:03,430
Rust-Return-Type ist so, gell? Ja, okay, ist schon besser, schon besser.

1908
02:02:03,670 --> 02:02:06,950
Übrigens, ich hab's verkackt. Ich hab's in der falschen Funktion gemacht. Das muss hier unten rein.

1909
02:02:12,170 --> 02:02:13,530
Format.

1910
02:02:13,530 --> 02:02:17,990
Okay, und das funktioniert jetzt. Moment, das funzt.

1911
02:02:19,070 --> 02:02:24,590
Okay, jetzt bin ich mal gespannt, wie das, wie das zurückkommt in, in .NET.

1912
02:02:27,380 --> 02:02:29,900
Wir brauchen, wir müssen das mal kurz ein bisschen ändern.

1913
02:02:30,780 --> 02:02:38,960
Hier, Session, Rename, Rename, Session, äh, Go.

1914
02:02:42,030 --> 02:02:46,390
Session, Rust. So, U, Int, und dann haben wir hier einen Bool.

1915
02:02:47,670 --> 02:02:49,670
Und ja, A, B, wie's heißt, ist egal.

1916
02:02:49,990 --> 02:02:55,230
Jetzt bin ich, jetzt bin ich mal gespannt, ob das, das ist ja die Basics. Das sind einfach nur Values zurückgeben.

1917
02:02:55,910 --> 02:03:01,030
Und unser Ziel ist ja hier auch noch einen String zurückzugeben und sowas. Das wird dann schon ein bisschen komplizierter.

1918
02:03:01,950 --> 02:03:05,950
Call Rust 2 zurück, bekommen wir eine Session.

1919
02:03:06,910 --> 02:03:08,910
Okay, Call Rust 2.

1920
02:03:09,710 --> 02:03:13,400
Session gleich.

1921
02:03:13,760 --> 02:03:15,760
Session A

1922
02:03:16,280 --> 02:03:18,280
und

1923
02:03:18,520 --> 02:03:26,480
Session B. Und jetzt gucken wir mal, ob das funzt, was da rauskommt. 1, 2, 3 und True.

1924
02:03:28,440 --> 02:03:31,400
True, Lulw. Ja, das funzt. Okay, das,

1925
02:03:32,240 --> 02:03:35,640
das war schon ein bisschen einfacher als in Go an der Stelle.

1926
02:03:36,600 --> 02:03:42,000
Weil Rust ist deutlich besser, also wir brauchen kein C, Go und C, Struct definieren und sowas.

1927
02:03:43,680 --> 02:03:48,280
Das ist einfacher. So, und jetzt kommt ein String. Jetzt bin ich mal gespannt, wie das funzt.

1928
02:03:49,800 --> 02:03:55,880
Kann ich, kann ich einfach sagen, String, das geht doch im Leben nicht, oder? Wenn ich hier einfach sage, ich returne ein String.

1929
02:03:57,160 --> 02:03:59,160
Keck weh.

1930
02:03:59,720 --> 02:04:02,240
Okay, jetzt kommt Rust-Gedöns.

1931
02:04:02,240 --> 02:04:05,360
Warum kann ich einem Struct String kein String zuweisen?

1932
02:04:05,920 --> 02:04:10,400
Weil man irgendwie sagen muss, Pass as String oder sowas. Ich erinnere mich dunkel.

1933
02:04:11,200 --> 02:04:15,520
From String, from to String. Wo ist der Unterschied dazwischen?

1934
02:04:17,000 --> 02:04:19,560
Aber das habe ich schon mal, das habe ich schon mal gesehen in Rust, ja.

1935
02:04:20,440 --> 02:04:34,000
Das kompiliert zwar, aber das wird nicht funktionieren.

1936
02:04:35,200 --> 02:04:40,960
Das wird, das wird so nicht funktionieren, weil die Rust-String-Repräsentation ganz anders ist.

1937
02:04:40,960 --> 02:04:43,520
Als das, was sich C-Sharp vorstellt.

1938
02:04:45,040 --> 02:04:51,120
Aber wir können es mal ausprobieren. Wir stellen uns einfach mal wieder doof und sagen, das ist ein String, okay.

1939
02:04:51,680 --> 02:04:53,680
So, das wird nicht funzen.

1940
02:04:54,240 --> 02:04:56,240
Es crasht sogar.

1941
02:04:56,640 --> 02:04:58,640
Crasht es? Crasht es wirklich?

1942
02:05:01,990 --> 02:05:03,990
Ja, es crasht.

1943
02:05:04,070 --> 02:05:06,070
Okay, es crasht, es crasht komplett.

1944
02:05:06,870 --> 02:05:08,870
Macht einfach gar nichts.

1945
02:05:08,950 --> 02:05:14,500
Also das funzt so definitiv nicht.

1946
02:05:14,500 --> 02:05:17,780
Aber das habe ich auch schon gedacht.

1947
02:05:18,900 --> 02:05:26,340
Ich brauche, ich brauche ein c-string oder sowas. Oder einen, oder einen character array oder sowas.

1948
02:05:27,780 --> 02:05:32,200
Wir gucken mal in die Hilfe von Rust. Ach hier guck mal.

1949
02:05:33,240 --> 02:05:37,000
Const c, Const c char.

1950
02:05:37,960 --> 02:05:43,960
Hat er importiert?

1951
02:05:43,960 --> 02:05:48,230
hat er importiert?

1952
02:05:48,230 --> 02:05:50,230
konsti

1953
02:05:50,230 --> 02:05:52,230
das geht natürlich nicht

1954
02:05:52,230 --> 02:05:54,230
kann man sowas machen wie pointer?

1955
02:05:54,230 --> 02:05:56,230
es pointer

1956
02:05:56,230 --> 02:06:00,820
aber das ist kein null

1957
02:06:00,820 --> 02:06:02,820
terminierter string

1958
02:06:02,820 --> 02:06:04,820
das

1959
02:06:04,820 --> 02:06:06,820
das kann man sagen wie into pointer

1960
02:06:06,820 --> 02:06:08,820
oder so

1961
02:06:08,820 --> 02:06:10,820
rust magic

1962
02:06:12,820 --> 02:06:14,820
das funzt nicht

1963
02:06:14,820 --> 02:06:16,820
was ist konst

1964
02:06:16,820 --> 02:06:18,820
konst u8

1965
02:06:18,820 --> 02:06:20,820
das ist jetzt quasi ein byte array

1966
02:06:20,820 --> 02:06:22,820
kompiliert

1967
02:06:22,820 --> 02:06:24,820
ich bin mal gespannt was jetzt

1968
02:06:24,820 --> 02:06:26,820
in C sharp rauskommt

1969
02:06:26,820 --> 02:06:28,820
es crasht einfach wieder

1970
02:06:28,820 --> 02:06:30,820
ok

1971
02:06:30,820 --> 02:06:38,680
es crasht

1972
02:06:38,680 --> 02:06:40,680
ok dann probieren wir was anderes

1973
02:06:40,680 --> 02:06:42,680
dann probieren wir was anderes

1974
02:06:42,680 --> 02:06:44,680
int pointer

1975
02:06:44,680 --> 02:06:46,680
das sollte jetzt nicht mal crashen

1976
02:06:46,680 --> 02:06:48,680
es crasht immer noch

1977
02:06:48,680 --> 02:07:07,000
ich habe die

1978
02:07:07,000 --> 02:07:09,000
go session bearbeitet

1979
02:07:09,000 --> 02:07:11,000
ah

1980
02:07:11,000 --> 02:07:19,940
ich bin ein kack noob

1981
02:07:19,940 --> 02:07:21,940
ok das funzt

1982
02:07:21,940 --> 02:07:25,570
also

1983
02:07:25,570 --> 02:07:27,570
hier gibt es den int pointer

1984
02:07:27,570 --> 02:07:33,000
hier kriege ich den int pointer

1985
02:07:33,000 --> 02:07:35,000
zurück

1986
02:07:35,000 --> 02:07:39,970
und was kann ich mit dem int pointer jetzt machen

1987
02:07:39,970 --> 02:07:41,970
sicherlich nicht als string parsen

1988
02:07:41,970 --> 02:07:43,970
oder

1989
02:07:43,970 --> 02:07:45,970
marshall

1990
02:07:45,970 --> 02:07:47,970
pointer to string

1991
02:07:47,970 --> 02:07:51,480
bam geht nicht

1992
02:07:51,480 --> 02:07:53,480
pointer

1993
02:07:53,480 --> 02:07:59,860
to

1994
02:07:59,860 --> 02:08:01,860
ey das funzt nicht

1995
02:08:01,860 --> 02:08:03,860
das ergibt aber auch sinn dass das nicht funktioniert

1996
02:08:03,860 --> 02:08:05,860
weil rust strings sind ja nicht null terminated

1997
02:08:05,860 --> 02:08:07,860
und sonst wie das

1998
02:08:07,860 --> 02:08:09,860
das klappt nicht

1999
02:08:09,860 --> 02:08:14,200
mut u8 haben wir auch noch

2000
02:08:14,200 --> 02:08:16,200
nicht dass das was ändert oder so

2001
02:08:16,200 --> 02:08:20,210
ne ne das funzt nicht

2002
02:08:20,210 --> 02:08:22,210
ok also ich muss da irgendwie mit

2003
02:08:22,210 --> 02:08:26,550
c string hantieren

2004
02:08:26,550 --> 02:08:28,550
c string new

2005
02:08:28,550 --> 02:08:30,550
c unwrap

2006
02:08:30,550 --> 02:08:32,550
das klingt sehr rust style

2007
02:08:32,550 --> 02:08:34,550
machen wir es mal sowas hier

2008
02:08:34,550 --> 02:08:36,550
let str gleich

2009
02:08:36,550 --> 02:08:38,550
c string

2010
02:08:38,550 --> 02:08:40,550
was

2011
02:08:40,550 --> 02:08:45,140
new

2012
02:08:45,140 --> 02:08:47,140
und jetzt hier sowas wie

2013
02:08:47,140 --> 02:08:51,540
kack w oder so

2014
02:08:51,540 --> 02:08:53,540
und an der stelle dann

2015
02:08:53,540 --> 02:08:55,540
hier machen wir auch wieder char

2016
02:08:55,540 --> 02:08:57,540
c char

2017
02:08:57,540 --> 02:08:59,540
und an der stelle dann str

2018
02:08:59,540 --> 02:09:01,540
ok ne funzt nicht

2019
02:09:01,540 --> 02:09:03,540
warum

2020
02:09:03,540 --> 02:09:05,540
expected const

2021
02:09:05,540 --> 02:09:07,540
found

2022
02:09:07,540 --> 02:09:09,540
ah nochmal unwrap

2023
02:09:09,540 --> 02:09:11,540
unwrap

2024
02:09:11,540 --> 02:09:13,540
unwrap muss da oben hin

2025
02:09:13,540 --> 02:09:15,540
unwrap

2026
02:09:15,540 --> 02:09:17,540
unwrap

2027
02:09:17,540 --> 02:09:24,820
into raw

2028
02:09:24,820 --> 02:09:26,820
into raw

2029
02:09:26,820 --> 02:09:28,820
klingt doch sinnvoll oder

2030
02:09:28,820 --> 02:09:30,820
s pointer

2031
02:09:30,820 --> 02:09:32,820
zack kompiliert

2032
02:09:32,820 --> 02:09:34,820
run

2033
02:09:34,820 --> 02:09:43,760
oh

2034
02:09:43,760 --> 02:09:45,760
das lookt nicht korrekt

2035
02:09:45,760 --> 02:09:53,170
das lookt gar nicht korrekt

2036
02:09:53,170 --> 02:09:55,170
das sieht nach

2037
02:09:55,170 --> 02:09:57,170
wurde gefreed aus

2038
02:09:57,170 --> 02:09:59,170
das ergibt

2039
02:09:59,170 --> 02:10:01,170
auch sinn dass es nicht funktioniert

2040
02:10:01,170 --> 02:10:03,170
weil rust

2041
02:10:03,170 --> 02:10:05,170
wird das hier wahrscheinlich verwerfen

2042
02:10:05,170 --> 02:10:07,170
sobald die funktion zu ende ist

2043
02:10:07,170 --> 02:10:09,170
jetzt ist die große preisfrage

2044
02:10:09,170 --> 02:10:16,200
wie kriege ich rust dazu

2045
02:10:16,200 --> 02:10:18,200
dass es das

2046
02:10:18,200 --> 02:10:20,200
überlebt

2047
02:10:20,200 --> 02:10:22,200
wir gucken uns mal die hilfe von c

2048
02:10:22,200 --> 02:10:27,560
string in rust an

2049
02:10:27,560 --> 02:10:29,560
global definieren

2050
02:10:29,560 --> 02:10:31,560
ne ne ne

2051
02:10:31,560 --> 02:10:33,560
extracting a raw pointer

2052
02:10:35,560 --> 02:10:42,390
s pointer

2053
02:10:42,390 --> 02:10:44,390
also eins kann man rust ja meistens nicht vorwerfen

2054
02:10:44,390 --> 02:10:46,390
dass uns zu wenig docs haben

2055
02:10:46,390 --> 02:10:48,390
aber dass ich nicht durchblicke

2056
02:10:48,390 --> 02:10:52,470
ist schon wieder

2057
02:10:52,470 --> 02:10:54,470
s pointer

2058
02:10:54,470 --> 02:10:56,470
ja so schlau bin ich auch

2059
02:10:56,470 --> 02:11:16,800
safety

2060
02:11:16,800 --> 02:11:18,800
ich muss

2061
02:11:18,800 --> 02:11:20,800
ich muss dem ding jetzt

2062
02:11:20,800 --> 02:11:22,800
bei rust ist es so

2063
02:11:22,800 --> 02:11:24,800
rust ist super pingelig

2064
02:11:24,800 --> 02:11:26,800
was lifetime von objekten angeht

2065
02:11:26,800 --> 02:11:28,800
und rust ist schlau genug und weiß

2066
02:11:28,800 --> 02:11:30,800
am ende dieses dings

2067
02:11:30,800 --> 02:11:32,800
normalerweise müsste ich jetzt sowas machen

2068
02:11:32,800 --> 02:11:34,800
ja irgendwie und also rust

2069
02:11:34,800 --> 02:11:36,800
logisch da muss man dann und mut oder so

2070
02:11:36,800 --> 02:11:40,240
komisches zeug da vormachen

2071
02:11:40,240 --> 02:11:42,240
aber das also

2072
02:11:42,240 --> 02:11:44,240
dass ich rust sage

2073
02:11:44,240 --> 02:11:46,240
ich möchte

2074
02:11:46,240 --> 02:11:48,240
quasi das ownership

2075
02:11:48,240 --> 02:11:50,240
heißt das bei rust übertragen an den der aufruft

2076
02:11:50,240 --> 02:11:52,240
aber ich weiß nicht wie das funktioniert

2077
02:11:52,240 --> 02:11:55,750
geht mit nem apostrophe

2078
02:11:55,750 --> 02:11:57,750
mit was

2079
02:11:57,750 --> 02:11:59,750
so

2080
02:11:59,750 --> 02:12:01,750
alter rust macht mich fertig

2081
02:12:01,750 --> 02:12:11,840
ne ne das kanns nicht sein oder

2082
02:12:11,840 --> 02:12:15,280
examples

2083
02:12:15,280 --> 02:12:21,250
den hat man schon

2084
02:12:21,250 --> 02:12:27,960
weg

2085
02:12:27,960 --> 02:12:29,960
wenn du willst übergibst du einfach noch den c string noch mal als

2086
02:12:29,960 --> 02:12:33,520
feldinstruct

2087
02:12:33,520 --> 02:12:35,520
ich übergebe doch das

2088
02:12:35,520 --> 02:12:37,520
feldinstruct

2089
02:12:37,520 --> 02:12:41,160
hier

2090
02:12:41,160 --> 02:12:43,160
oder du meinst hier c string

2091
02:12:43,160 --> 02:12:45,160
ja aber das wird doch

2092
02:12:45,160 --> 02:12:47,160
da nicht so funktionieren wie ich mir das gedacht

2093
02:12:47,160 --> 02:12:53,860
hab oder

2094
02:12:53,860 --> 02:12:55,860
so

2095
02:12:55,860 --> 02:12:57,860
nee its not ffe safe

2096
02:12:57,860 --> 02:12:59,860
das wird nicht funktionieren so

2097
02:12:59,860 --> 02:13:09,480
siehste

2098
02:13:09,480 --> 02:13:11,480
crasht einfach direkt ne ne ne ne

2099
02:13:11,480 --> 02:13:13,480
so funzt das nicht

2100
02:13:13,480 --> 02:13:15,480
ähm

2101
02:13:15,480 --> 02:13:17,480
wir sind glaube ich

2102
02:13:17,480 --> 02:13:19,480
im richtigen weg

2103
02:13:19,480 --> 02:13:21,480
das ist glaube ich garnicht so verkehrt

2104
02:13:21,480 --> 02:13:23,480
vielleicht muss ich auch einfach sagen

2105
02:13:23,480 --> 02:13:25,480
mut

2106
02:13:25,480 --> 02:13:33,910
hier oben anstatt konst

2107
02:13:33,910 --> 02:13:35,910
in c sharp muss das in den session daten

2108
02:13:35,910 --> 02:13:37,910
zu string geändert werden nee muss es nicht

2109
02:13:37,910 --> 02:13:39,910
ich bekomme nen in pointer

2110
02:13:39,910 --> 02:13:41,910
und den wandle ich dann selbst

2111
02:13:41,910 --> 02:13:43,910
in den string um das muss auch funktionieren

2112
02:13:43,910 --> 02:13:51,380
ok das geht nicht warum

2113
02:13:51,380 --> 02:13:53,380
weil

2114
02:13:53,380 --> 02:13:55,380
type differs in

2115
02:13:55,380 --> 02:13:57,380
expected raw pointer

2116
02:13:57,380 --> 02:13:59,380
und found raw pointer

2117
02:13:59,380 --> 02:14:05,440
konst

2118
02:14:05,440 --> 02:14:07,440
jetzt kommt richtig krasses

2119
02:14:07,440 --> 02:14:09,440
nice backseating hier an start

2120
02:14:09,440 --> 02:14:11,440
und das soll jetzt funktionieren

2121
02:14:11,440 --> 02:14:13,440
da hab ich so meine zweifel

2122
02:14:13,440 --> 02:14:15,440
dass das funzt

2123
02:14:15,440 --> 02:14:17,440
und

2124
02:14:17,440 --> 02:14:29,010
funzt nicht

2125
02:14:29,010 --> 02:14:31,010
ich will dem sagen dass er hier

2126
02:14:31,010 --> 02:14:33,010
ownership übertragen soll

2127
02:14:33,010 --> 02:14:35,010
ok wie geht das

2128
02:14:35,010 --> 02:14:37,010
was haben wir denn sonst noch hier

2129
02:14:37,010 --> 02:14:39,010
from raw

2130
02:14:39,010 --> 02:14:41,010
into raw

2131
02:14:41,010 --> 02:14:43,010
consumes

2132
02:14:43,010 --> 02:14:45,010
the c string and transfer

2133
02:14:45,010 --> 02:14:47,010
ownership of the string to the c

2134
02:14:47,010 --> 02:14:49,010
caller das ist das

2135
02:14:49,010 --> 02:14:54,310
was ich wahrscheinlich will

2136
02:14:54,310 --> 02:15:04,020
into

2137
02:15:04,020 --> 02:15:06,020
into raw

2138
02:15:06,020 --> 02:15:08,020
das gibt ein mut

2139
02:15:08,020 --> 02:15:10,020
c char

2140
02:15:10,020 --> 02:15:12,020
was ja auch durchaus ok ist ich kann ja da drin rum

2141
02:15:12,020 --> 02:15:14,020
sauen wie ich will mach ich aber nicht aber könnte ich

2142
02:15:14,020 --> 02:15:16,020
ok lässt sich

2143
02:15:16,020 --> 02:15:18,020
kombinieren und jetzt und jetzt

2144
02:15:18,020 --> 02:15:23,320
post champ

2145
02:15:23,320 --> 02:15:28,870
post champ ich finde meine

2146
02:15:28,870 --> 02:15:30,870
emotes grad nicht

2147
02:15:30,870 --> 02:15:32,870
post champ time

2148
02:15:32,870 --> 02:15:34,870
funzt easy

2149
02:15:34,870 --> 02:15:36,870
kaum macht man es richtig

2150
02:15:36,870 --> 02:15:38,870
easy as fuck

2151
02:15:38,870 --> 02:15:40,870
easy

2152
02:15:40,870 --> 02:15:42,870
easy

2153
02:15:42,870 --> 02:15:48,360
easy as fuck

2154
02:15:48,360 --> 02:15:50,360
hat funktioniert

2155
02:15:50,360 --> 02:15:52,360
also so funzt das in rust

2156
02:15:52,360 --> 02:15:56,240
c string

2157
02:15:56,240 --> 02:15:58,240
moment

2158
02:15:58,240 --> 02:16:00,240
und dann sagt man

2159
02:16:00,240 --> 02:16:02,240
moment

2160
02:16:02,240 --> 02:16:04,240
das ist go

2161
02:16:04,240 --> 02:16:07,560
und dann sagt man

2162
02:16:07,560 --> 02:16:19,510
into raw

2163
02:16:19,510 --> 02:16:21,510
so was haben wir denn sonst noch

2164
02:16:21,510 --> 02:16:23,510
the pointer

2165
02:16:23,510 --> 02:16:25,510
which this function returns

2166
02:16:25,510 --> 02:16:27,510
must be returned to rust

2167
02:16:27,510 --> 02:16:29,510
and

2168
02:16:29,510 --> 02:16:31,510
reconstituted using

2169
02:16:31,510 --> 02:16:33,510
c string from

2170
02:16:33,510 --> 02:16:35,510
raw

2171
02:16:35,510 --> 02:16:37,510
so

2172
02:16:37,510 --> 02:16:39,510
so

2173
02:16:39,510 --> 02:16:41,510
so

2174
02:16:41,510 --> 02:16:43,510
so

2175
02:16:43,510 --> 02:16:45,510
so

2176
02:16:45,510 --> 02:16:47,510
so

2177
02:16:47,510 --> 02:16:51,650
so

2178
02:16:51,650 --> 02:16:53,650
so

2179
02:16:53,650 --> 02:16:55,650
so

2180
02:16:55,650 --> 02:16:57,650
so

2181
02:16:57,650 --> 02:17:11,430
so

2182
02:17:11,430 --> 02:17:13,430
so

2183
02:17:13,430 --> 02:17:15,430
so

2184
02:17:15,430 --> 02:17:18,870
so

2185
02:17:18,870 --> 02:17:22,560
so

2186
02:17:22,560 --> 02:17:24,560
so

2187
02:17:24,560 --> 02:17:26,560
so

2188
02:17:26,560 --> 02:17:28,560
so

2189
02:17:28,560 --> 02:17:30,560
so

2190
02:17:30,560 --> 02:17:32,560
so

2191
02:17:32,560 --> 02:17:34,560
so

2192
02:17:34,560 --> 02:17:36,560
so

2193
02:17:36,560 --> 02:17:38,560
so

2194
02:17:38,560 --> 02:17:40,560
so

2195
02:17:40,560 --> 02:17:42,560
so

2196
02:17:42,560 --> 02:17:44,560
so

2197
02:17:44,560 --> 02:17:46,560
so

2198
02:17:46,560 --> 02:17:48,560
so

2199
02:17:48,560 --> 02:17:51,280
Das ist schon ein See, quasi. Ohne was dazwischen.

2200
02:17:52,080 --> 02:17:54,580
Zwei Sekunden, vier Gigabyte RAM, Alter.

2201
02:17:55,840 --> 02:18:00,280
Mich würde nicht wundern, wenn irgendeine IDE abgekackt ist, jetzt, weil er zu viel RAM sich geschnappt hat.

2202
02:18:02,000 --> 02:18:05,280
Halbe Forkbomb ist das schon, ohne sich zu forken. Gut.

2203
02:18:06,520 --> 02:18:08,320
Also, was müssen wir machen?

2204
02:18:10,930 --> 02:18:19,530
The pointer which is found must be returned to Rust and re-configured using C-String from raw to be properly deallocated.

2205
02:18:20,050 --> 02:18:23,130
Da bin ich mal gespannt, ob das stimmt, was die da sagen.

2206
02:18:23,530 --> 02:18:29,410
Wir machen jetzt da einfach mal ein String draus, weil dann wissen wir ja, dass der automatisch freet.

2207
02:18:33,660 --> 02:18:35,860
Und jetzt sollten wir kein Memory Leak mehr haben.

2208
02:18:41,160 --> 02:18:42,440
Wir haben kein Memory Leak mehr.

2209
02:18:46,430 --> 02:18:48,550
Alles perfectly fine.

2210
02:18:49,590 --> 02:18:52,510
Na, oder vielleicht doch so ein kleines Memory Leak vielleicht.

2211
02:18:53,710 --> 02:18:55,030
Ne, wir haben kein Memory Leak.

2212
02:18:57,600 --> 02:18:59,600
Aber, aber vielleicht doch ein kleines.

2213
02:19:00,360 --> 02:19:02,240
Genau, C-Sharp macht wieder free.

2214
02:19:03,720 --> 02:19:07,800
Profile ist doch... Ich weiß ehrlich gesagt gerade nicht, wie gescheit, weil...

2215
02:19:08,880 --> 02:19:11,960
...mein Rider ist irgendwie der Meinung, Debugger funktioniert nicht.

2216
02:19:13,040 --> 02:19:14,680
Warum auch immer, vielleicht geht er jetzt.

2217
02:19:16,160 --> 02:19:16,680
Nö.

2218
02:19:17,840 --> 02:19:19,760
Obwohl ich's mit... er versucht mein...

2219
02:19:20,400 --> 02:19:25,920
...ihr .NET Location, ergibt überhaupt keinen Sinn, der soll mein .NET verwenden und nicht das falsche .NET.

2220
02:19:27,950 --> 02:19:28,750
Ja, ist es nicht!

2221
02:19:32,120 --> 02:19:33,120
Ist es eben nicht!

2222
02:19:33,560 --> 02:19:37,520
Das Ganze ist ein .NET 8 Projekt und er zeigt's auch hier an, dass es .NET 8 ist.

2223
02:19:38,120 --> 02:19:39,920
Aber Rider ist der Meinung, ne...

2224
02:19:40,680 --> 02:19:43,760
...ist es nicht. Guck hier, .NET 8, .NET Version 8.

2225
02:19:46,670 --> 02:19:49,350
Ich weiß nicht, keine Ahnung, ergibt keinen Sinn, ich glaub...

2226
02:19:49,790 --> 02:19:52,790
...ich glaube fast, das ist ein Bug in Rider, was wir hier haben.

2227
02:19:59,860 --> 02:20:00,660
.Memory.

2228
02:20:03,180 --> 02:20:05,860
So, und jetzt lesen wir mal weiter, was hier steht.

2229
02:20:07,380 --> 02:20:08,900
Ja, okay, hier.

2230
02:20:09,900 --> 02:20:18,420
Specifically, one should not use the standard C3 function to deallocate the string.

2231
02:20:18,420 --> 02:20:21,100
Das ist schon mal falsch, was wir da gerade machen.

2232
02:20:21,980 --> 02:20:27,220
Failure to call CString from raw will lead to a memory leak.

2233
02:20:29,060 --> 02:20:31,860
The C-Site must not modify the length of the string?

2234
02:20:31,860 --> 02:20:32,620
Ja, okay.

2235
02:20:43,340 --> 02:20:45,220
Also müssen wir noch das hier machen.

2236
02:20:45,780 --> 02:20:52,180
Bedeutet im Endeffekt auch, so dass wir kein Memory leaken, brauche ich noch eine Funktion, die nennen...

2237
02:20:52,180 --> 02:20:52,700
Ups.

2238
02:20:54,020 --> 02:20:57,740
...brauche ich noch eine Funktion, die nennen wir jetzt einfach mal hier, ähm...

2239
02:20:58,740 --> 02:21:00,100
...pre-stril oder so.

2240
02:21:01,580 --> 02:21:03,340
Und da rufen wir jetzt auf...

2241
02:21:04,780 --> 02:21:07,980
...CString from raw, okay, hier Pointer rein.

2242
02:21:09,060 --> 02:21:13,900
Und dann wahrscheinlich, wahrscheinlich, äh, okay, Rust.

2243
02:21:13,900 --> 02:21:15,100
Rust, geht das so?

2244
02:21:22,240 --> 02:21:24,240
Achso, das muss in den Unsave-Block.

2245
02:21:24,840 --> 02:21:26,160
Ist ja fast wie in .NET hier.

2246
02:21:37,040 --> 02:21:40,500
Öh, das ist nicht einfach.

2247
02:21:45,000 --> 02:21:45,840
Ich will das so haben.

2248
02:21:48,770 --> 02:21:55,360
Warum, warum sieht der Unsave-Block hier so kacke aus?

2249
02:21:55,360 --> 02:21:56,400
Ah, dann machen wir es so.

2250
02:21:59,120 --> 02:22:01,360
Okay, und jetzt ist das, jetzt ist das safe.

2251
02:22:02,400 --> 02:22:06,080
Da muss ich das aber noch dazu aufrufen, und zwar...

2252
02:22:07,800 --> 02:22:09,280
...würde ich sagen...

2253
02:22:10,920 --> 02:22:12,440
...muss ich dann hier noch...

2254
02:22:13,400 --> 02:22:15,520
...was reinpacken, und zwar...

2255
02:22:16,120 --> 02:22:17,840
...nicht call Rust, sondern...

2256
02:22:18,520 --> 02:22:19,920
...pre-stril...

2257
02:22:21,280 --> 02:22:22,280
...int Pointer...

2258
02:22:25,200 --> 02:22:25,720
...äh...

2259
02:22:26,320 --> 02:22:29,480
...so, und wenn ich jetzt das Memory-Leak vermeiden will...

2260
02:22:30,080 --> 02:22:34,900
...sage ich interop pre-stril...

2261
02:22:35,940 --> 02:22:38,620
...und gebe da Session meinen...

2262
02:22:40,220 --> 02:22:42,660
...nee, nein, ich mein String, das funktioniert ja so jetzt nicht.

2263
02:22:42,980 --> 02:22:46,260
Ja, okay, jetzt ergibt das Sinn, jetzt müssen wir es nämlich wirklich selbst machen.

2264
02:22:46,740 --> 02:22:47,740
int Pointer...

2265
02:22:51,080 --> 02:22:53,080
Ich hab schon wieder das Falsche editiert, man.

2266
02:22:55,060 --> 02:22:57,060
Ich hab schon wieder die Go-Session editiert.

2267
02:22:59,560 --> 02:23:03,880
int Pointer, wir benennen das übrigens mal gescheit, sonst kann ich es gar nicht mehr nicht merken.

2268
02:23:05,600 --> 02:23:06,640
Client Name, so.

2269
02:23:07,000 --> 02:23:10,600
Und jetzt sollte das Memory-Leak auch wieder weg sein.

2270
02:23:13,800 --> 02:23:15,400
Ja, ja, ja, ja.

2271
02:23:16,320 --> 02:23:17,320
Da liegt nix mehr.

2272
02:23:18,880 --> 02:23:24,840
Ich mein, es ist offensichtlich, vorher hatten wir 4 Gigabyte pro 2 Sekunden und jetzt haben wir nix.

2273
02:23:25,840 --> 02:23:26,440
Okay.

2274
02:23:26,760 --> 02:23:32,080
.memory hab ich noch nie ausprobiert, kann man .memory vielleicht installieren über die Toolbox?

2275
02:23:35,680 --> 02:23:37,680
.trace haben wir.

2276
02:23:38,080 --> 02:23:42,240
.net performance profiler.

2277
02:23:43,240 --> 02:23:44,240
Geht das damit auch?

2278
02:23:45,280 --> 02:23:47,520
Hab ich noch nie, hab ich noch nie verwendet.

2279
02:23:49,280 --> 02:23:51,760
Zeigt der mir auch die Memory-Usage?

2280
02:23:53,910 --> 02:23:55,710
Eigentlich, ohne Scheiß...

2281
02:23:55,910 --> 02:23:59,510
Eigentlich fucks mich übelst ab, dass der Ryder-Debugger nicht geht.

2282
02:24:01,930 --> 02:24:04,330
Warum geht da Ryder? Okay, ich hab ne Idee, woran das liegt.

2283
02:24:04,530 --> 02:24:07,530
Wir gehen jetzt mal hier auf Build & Tool Sets.

2284
02:24:08,730 --> 02:24:12,330
Es ist eindeutig richtig eingestellt.

2285
02:24:21,480 --> 02:24:24,280
Kann ich das systemweit speichern, einfach?

2286
02:24:30,600 --> 02:24:31,600
Jetzt funzt's.

2287
02:24:33,200 --> 02:24:36,200
Shit, warum benutzt der? Alter, was ist das für ein Kack?

2288
02:24:36,400 --> 02:24:40,200
Warum benutzt der so ein alles outdatedes .net?

2289
02:24:41,800 --> 02:24:42,800
Versteh ich nicht.

2290
02:24:46,440 --> 02:24:47,640
Es ist irgendein Bug.

2291
02:24:48,040 --> 02:24:49,840
Hier ist alles richtig eingestellt.

2292
02:24:50,440 --> 02:24:55,440
Nee, der Ryder benutzt die Runtime, die ich ja ausgewählt hab normalerweise,

2293
02:24:55,440 --> 02:24:59,440
aber anscheinend macht's das in dem Fall nicht, weil's irgendwie verbuggt ist.

2294
02:25:00,440 --> 02:25:01,840
Was ziemlich suckt.

2295
02:25:18,340 --> 02:25:19,340
Ich weiß es nicht.

2296
02:25:23,870 --> 02:25:25,870
Das sind doch die richtigen Settings, oder was?

2297
02:25:31,040 --> 02:25:32,440
Ich wüsste nicht, was hier dran...

2298
02:25:33,440 --> 02:25:35,040
Weil die Runtime auch stimmt.

2299
02:25:39,180 --> 02:25:41,180
Wir können hier nochmal die Runtime hinzufügen.

2300
02:25:41,580 --> 02:25:43,780
maxhome.net

2301
02:25:47,540 --> 02:25:48,340
.net

2302
02:25:49,340 --> 02:25:50,740
Custom. So, Apply.

2303
02:25:55,210 --> 02:25:56,210
Ah, jetzt geht's!

2304
02:26:00,810 --> 02:26:01,810
Jetzt geht's.

2305
02:26:05,960 --> 02:26:06,960
Glaub ich zumindest.

2306
02:26:07,160 --> 02:26:07,760
Oder?

2307
02:26:08,160 --> 02:26:08,560
Ja.

2308
02:26:09,160 --> 02:26:09,960
Memory.

2309
02:26:13,600 --> 02:26:14,800
Haben die nicht sowas?

2310
02:26:15,000 --> 02:26:15,600
Chat Gil.

2311
02:26:15,800 --> 02:26:18,200
Ich benutze den Debugger in Ryder sehr selten.

2312
02:26:19,400 --> 02:26:21,600
Haben die nicht so eine Anzeige wie in Visual Studio Code,

2313
02:26:21,600 --> 02:26:25,000
wo man einfach sehen kann live, was das für Memory verwendet?

2314
02:26:31,830 --> 02:26:33,030
Anscheinend nicht, oder?

2315
02:26:39,160 --> 02:26:40,360
Ja, stimmt auch wieder.

2316
02:26:44,760 --> 02:26:46,760
Aber ist doch blöd, dass das nicht eingebaut ist, oder?

2317
02:26:47,160 --> 02:26:49,760
Das ist dann tatsächlich eine Sache, wo ich sagen würde,

2318
02:26:51,680 --> 02:26:54,080
da ist Visual Studio Code angenehmer.

2319
02:26:54,080 --> 02:26:56,680
Äh, nicht Visual Studio Code, äh, Visual Studio angenehmer.

2320
02:27:02,560 --> 02:27:04,360
Auf die drei Dots bei Debuggen.

2321
02:27:08,570 --> 02:27:09,770
Du meinst hier, oder wo?

2322
02:27:09,970 --> 02:27:10,570
Oder da?

2323
02:27:13,640 --> 02:27:15,440
Profile with Sampling.

2324
02:27:21,370 --> 02:27:25,620
Ah.

2325
02:27:25,820 --> 02:27:26,820
Excellent.

2326
02:27:27,820 --> 02:27:30,020
So, und wo seh ich jetzt den, den RAM-Verbrauch?

2327
02:27:30,420 --> 02:27:32,420
Erst wenn ich's wieder geschlossen hab, oder...

2328
02:27:33,220 --> 02:27:34,420
...seh ich das live?

2329
02:27:44,720 --> 02:27:46,120
Da gibt's doch eins für Memory.

2330
02:27:46,320 --> 02:27:46,920
Echt?

2331
02:27:56,630 --> 02:27:57,230
Snapshot?

2332
02:28:01,060 --> 02:28:03,060
Ey, das ist aber nicht die Memory-Size, oder?

2333
02:28:10,080 --> 02:28:12,880
Äh, boah, da blinke ich nicht durch, das mit zu high IQ jetzt.

2334
02:28:15,250 --> 02:28:18,450
Das mir, das ist mir massified zu high IQ, äh.

2335
02:28:21,770 --> 02:28:23,770
Was ist jetzt CPU? Ja, ich hätte gerne Memory.

2336
02:28:28,820 --> 02:28:31,020
Das massify IQ Zeug hier.

2337
02:28:33,320 --> 02:28:34,320
Okay, stoppen wir mal.

2338
02:28:37,760 --> 02:28:40,360
Profile with? Profile running process? Profile...

2339
02:28:41,560 --> 02:28:42,960
Sampling? Memory!

2340
02:28:54,480 --> 02:28:56,880
Ja, sowas such ich!

2341
02:28:57,080 --> 02:28:58,080
Genau.

2342
02:28:58,880 --> 02:28:59,880
Excellent.

2343
02:29:00,280 --> 02:29:02,280
Genau das hab ich gesucht.

2344
02:29:05,210 --> 02:29:07,210
Dass man sieht, wie viel Speicher das Ding verbraucht.

2345
02:29:07,410 --> 02:29:11,810
Man sieht, wir haben absolut null Memory-Leaks.

2346
02:29:12,010 --> 02:29:12,810
Gar nix.

2347
02:29:17,220 --> 02:29:18,020
Null Memory-Leaks.

2348
02:29:18,220 --> 02:29:19,820
Es ist einfach die ganze Zeit...

2349
02:29:20,620 --> 02:29:23,020
...immer auf 43,59.

2350
02:29:24,020 --> 02:29:26,620
So, wir können das, wir können das Ganze, Ganze nochmal...

2351
02:29:28,530 --> 02:29:30,530
...checken, indem wir sagen...

2352
02:29:31,130 --> 02:29:33,330
...wir lassen das, wir lassen das Free mal weg, aber...

2353
02:29:33,730 --> 02:29:34,330
...wir machen...

2354
02:29:36,130 --> 02:29:37,730
...wenn man in Sleep kurz rein...

2355
02:29:38,330 --> 02:29:38,930
...von...

2356
02:29:40,130 --> 02:29:41,330
...einer Millisekunde...

2357
02:29:41,730 --> 02:29:42,330
...das ist...

2358
02:29:44,130 --> 02:29:47,130
...jetzt hatten wir es mehrfach drauf, dass es nicht sich komplett in die...

2359
02:29:49,770 --> 02:29:51,370
...in die, in die Quere kommt, ja.

2360
02:29:51,970 --> 02:29:52,970
So, und jetzt sagen wir...

2361
02:29:53,370 --> 02:29:55,370
...Profile with Memory.

2362
02:30:06,300 --> 02:30:07,900
Ich hätte jetzt eigentlich erwartet...

2363
02:30:14,930 --> 02:30:16,530
...ich hätte jetzt eigentlich erwartet, dass das...

2364
02:30:20,640 --> 02:30:21,240
...irgendwie...

2365
02:30:24,490 --> 02:30:26,490
Es geht hoch, ja es geht hoch, guckt Leute.

2366
02:30:27,090 --> 02:30:27,890
Es geht hoch.

2367
02:30:28,690 --> 02:30:30,890
Langsam, weil eine Millisekunde Sleep dazwischen...

2368
02:30:31,090 --> 02:30:33,090
...und eine Millisekunde ist verdammt viel...

2369
02:30:33,290 --> 02:30:36,090
...wenn der Millionen Aufrufe pro Sekunde macht normalerweise.

2370
02:30:36,690 --> 02:30:37,090
Ja.

2371
02:30:37,490 --> 02:30:39,290
Jetzt sieht man, dass ein Memory-Leak drin ist.

2372
02:30:39,290 --> 02:30:40,890
Guckt, es geht immer ein bisschen weiter hoch.

2373
02:30:46,640 --> 02:30:47,440
Nice, nice.

2374
02:30:47,640 --> 02:30:50,240
Okay, heute, das ist wirklich nice...

2375
02:30:50,640 --> 02:30:53,040
...dass ihr wusstet, wo das ist, weil...

2376
02:30:54,040 --> 02:30:54,640
...ähm...

2377
02:30:54,840 --> 02:30:56,640
...wir können aber sagen, Timespan...

2378
02:30:57,640 --> 02:30:58,640
...Brom...

2379
02:30:59,240 --> 02:31:00,440
...Microseconds...

2380
02:31:01,840 --> 02:31:03,040
...jede Mikrosekunde...

2381
02:31:03,240 --> 02:31:04,040
...einfach, bam.

2382
02:31:07,620 --> 02:31:08,820
Profile Memory.

2383
02:31:13,560 --> 02:31:14,560
Oh ja, guckt Leute.

2384
02:31:15,360 --> 02:31:16,360
Jetzt geht's steil.

2385
02:31:16,560 --> 02:31:17,760
Jetzt geht's steil.

2386
02:31:18,760 --> 02:31:20,160
Die Speicher aus Gigabyte.

2387
02:31:20,760 --> 02:31:24,160
1,2 Gigabyte, 1,4, 1,6, 1,7.

2388
02:31:24,560 --> 02:31:26,360
Ja, jetzt wird Memory-Leaked as fuck.

2389
02:31:31,220 --> 02:31:33,020
Jetzt hat man's, jetzt hat man's wirklich gut gesehen.

2390
02:31:33,420 --> 02:31:34,820
So, und jetzt machen wir das Free rein.

2391
02:31:35,820 --> 02:31:36,820
Jetzt machen wir das Free rein.

2392
02:31:37,420 --> 02:31:39,620
Aber Chat, da habt ihr mal was Gutes gezeigt.

2393
02:31:40,420 --> 02:31:42,020
Das wusste ich gar nicht, dass es das gibt.

2394
02:31:42,420 --> 02:31:44,220
Das ist mega praktisch dafür.

2395
02:31:46,590 --> 02:31:47,990
Rider ist einfach echt beste.

2396
02:31:52,850 --> 02:31:54,650
So, guckt, und jetzt kein Memory-Leak mehr.

2397
02:31:54,650 --> 02:31:57,450
Es bleibt einfach bei 44 MB Memory total used.

2398
02:32:03,340 --> 02:32:04,340
Excellent, Leute.

2399
02:32:04,940 --> 02:32:06,540
Excellent, excellent.

2400
02:32:08,340 --> 02:32:08,740
Okay.

2401
02:32:08,940 --> 02:32:10,540
So, und was lernen wir daraus?

2402
02:32:10,540 --> 02:32:12,140
Okay, wir machen jetzt nochmal einen abschließenden...

2403
02:32:12,140 --> 02:32:13,340
...wie krieg ich denn das hier minimiert, so?

2404
02:32:13,740 --> 02:32:15,340
Jetzt machen wir nochmal einen abschließenden Vergleich...

2405
02:32:15,340 --> 02:32:16,340
...zu diesem ganzen Campbell.

2406
02:32:19,480 --> 02:32:20,480
Wir schmeißen das hier raus.

2407
02:32:20,480 --> 02:32:22,480
Wir sagen...

2408
02:32:27,730 --> 02:32:29,330
...Duster wird einmal aufgerufen.

2409
02:32:32,020 --> 02:32:33,620
Dann wird Interop...

2410
02:32:35,620 --> 02:32:38,820
...Call Rust einmal aufgerufen.

2411
02:32:39,620 --> 02:32:44,920
Interop Call Rust 2.

2412
02:32:48,050 --> 02:32:50,250
Und Interop Call Go.

2413
02:32:50,250 --> 02:32:52,650
So, jetzt lassen wir uns einmal noch Benchmark-Ergebnisse...

2414
02:32:52,650 --> 02:32:53,650
...generaten.

2415
02:32:55,250 --> 02:32:56,850
Zum Vergleich...

2416
02:32:59,400 --> 02:33:00,000
Das kommt weg.

2417
02:33:00,000 --> 02:33:03,000
Also, den .NET-Vergleich, den machen wir mal wieder raus.

2418
02:33:03,000 --> 02:33:04,600
Den braucht eigentlich niemand an der Stelle.

2419
02:33:04,600 --> 02:33:06,200
Wir wissen, dass .NET schnell ist.

2420
02:33:06,800 --> 02:33:08,000
Von .NET zu .NET.

2421
02:33:08,400 --> 02:33:09,400
Ja, also hier Run.

2422
02:33:10,200 --> 02:33:11,600
Gucken wir uns das nochmal abschließend an.

2423
02:33:12,400 --> 02:33:13,200
Go 2.

2424
02:33:14,600 --> 02:33:15,200
Und...

2425
02:33:18,280 --> 02:33:20,480
...Run Rust 2.

2426
02:33:21,280 --> 02:33:22,080
Wobei wir da...

2427
02:33:23,280 --> 02:33:25,280
...tatsächlich noch einen Free machen müssen.

2428
02:33:25,680 --> 02:33:27,680
Der in Go unter der Haube passiert.

2429
02:33:29,080 --> 02:33:29,880
Aber das ist ja nicht schlimm.

2430
02:33:33,320 --> 02:33:33,720
So.

2431
02:33:34,720 --> 02:33:36,920
Und jetzt können wir nochmal den Benchmark laufen lassen.

2432
02:33:37,920 --> 02:33:38,920
Und uns freuen...

2433
02:33:39,520 --> 02:33:41,520
...dass wir eine tolle Benchmark-Ausgabe kriegen.

2434
02:33:54,700 --> 02:33:57,700
Glaube ich zumindest, dass ich nichts falsch gemacht habe.

2435
02:34:01,920 --> 02:34:02,520
Oh, doch.

2436
02:34:03,520 --> 02:34:05,120
Run, Run Rust.

2437
02:34:06,520 --> 02:34:07,720
Fehlt noch das normale...

2438
02:34:09,120 --> 02:34:10,520
...Call Rust.

2439
02:34:11,120 --> 02:34:15,420
So, okay.

2440
02:34:15,620 --> 02:34:17,820
Wenn man jetzt noch richtig schreiben könnte, wäre perfekt.

2441
02:34:24,470 --> 02:34:25,870
Gibt es überhaupt Go 2, ja?

2442
02:34:25,870 --> 02:34:26,470
Gibt es?

2443
02:34:27,070 --> 02:34:28,670
Go 2 macht das mit dem Struct.

2444
02:34:29,870 --> 02:34:31,270
So, ich bin mal gespannt.

2445
02:34:32,070 --> 02:34:33,670
Habst du da High IQ Stream heute?

2446
02:34:33,670 --> 02:34:34,470
Ja, stimmt schon.

2447
02:34:35,070 --> 02:34:37,070
Übrigens schön, dass so viele Leute wieder am Start sind.

2448
02:34:37,270 --> 02:34:39,070
Ich meine, das ist ja nicht selbstverständlich...

2449
02:34:39,470 --> 02:34:42,670
...dass quasi die ganze Zeit über 200 Leute zugucken...

2450
02:34:42,670 --> 02:34:44,470
...bei so einem Kram hier, ja?

2451
02:34:49,710 --> 02:34:53,310
Muss man beim Struct in Rust nicht auch die Namen anpassen...

2452
02:34:53,310 --> 02:34:54,910
...oder hattest du das schon gemacht?

2453
02:34:56,710 --> 02:34:58,310
Ne, warum brauche ich die Namen anpassen?

2454
02:34:58,510 --> 02:34:59,110
Was meinst du?

2455
02:34:59,310 --> 02:35:01,310
Du meinst, weil das in C Sharp...

2456
02:35:01,910 --> 02:35:02,510
...heißt...

2457
02:35:02,910 --> 02:35:04,510
...Session Rust und Session Go?

2458
02:35:05,510 --> 02:35:06,310
Das ist Wurscht.

2459
02:35:07,710 --> 02:35:09,110
Wichtig ist einfach nur, dass die...

2460
02:35:09,310 --> 02:35:11,110
...das Speicher-Layout das gleiche ist.

2461
02:35:11,110 --> 02:35:11,910
Ich könnte es auch ein...

2462
02:35:11,910 --> 02:35:12,710
...ich könnte es auch...

2463
02:35:13,310 --> 02:35:15,510
...Cacquait, QChat, Ajaja nennen.

2464
02:35:15,710 --> 02:35:16,310
Das Struct.

2465
02:35:16,310 --> 02:35:17,310
Vollkommen egal, wie das...

2466
02:35:17,310 --> 02:35:18,510
...wie das in C Sharp heißt.

2467
02:35:18,910 --> 02:35:21,110
A Client ID ist der Name auch egal.

2468
02:35:21,110 --> 02:35:22,310
Der Typ ist das Wichtige.

2469
02:35:23,310 --> 02:35:24,910
Also hauptsache, dass das Struct...

2470
02:35:24,910 --> 02:35:26,310
...denn das ist das richtige Memory-Layout.

2471
02:35:26,510 --> 02:35:29,310
Also dass es in Rust A und B heißt, ist vollkommen egal.

2472
02:35:30,310 --> 02:35:31,910
Wichtig ist, dass es ein Struct ist...

2473
02:35:32,310 --> 02:35:33,910
...dass als erstes ein Bool kommt...

2474
02:35:33,910 --> 02:35:34,910
...als zweites ein Int...

2475
02:35:34,910 --> 02:35:36,510
...als drittes ein String oder sowas.

2476
02:35:37,110 --> 02:35:38,510
Das muss stimmen in beiden Sprachen.

2477
02:35:38,510 --> 02:35:40,310
Wie das heißt, ist vollkommen egal.

2478
02:35:41,910 --> 02:35:42,510
Weil die...

2479
02:35:42,510 --> 02:35:44,310
...denn die Namen stehen dann irgendwo drinne.

2480
02:35:44,710 --> 02:35:46,110
Was der sich einfach merkt, ist...

2481
02:35:46,910 --> 02:35:48,310
...die Size von dem Struct...

2482
02:35:49,110 --> 02:35:50,510
...und wie er das dann quasi...

2483
02:35:50,710 --> 02:35:52,910
...casten muss in den eigentlichen Managed-Typ...

2484
02:35:54,110 --> 02:35:55,110
...vom...

2485
02:35:55,110 --> 02:35:56,510
...von der Speicher-Aufteilung her.

2486
02:36:02,650 --> 02:36:04,050
Ja, ich mag die Streams auch.

2487
02:36:04,250 --> 02:36:05,650
Ich meine, ich kann natürlich eben nicht immer...

2488
02:36:05,650 --> 02:36:07,450
...so Sachen aus dem Ärmel schütteln, ja.

2489
02:36:08,250 --> 02:36:09,450
Immer nur, wenn was ansteht.

2490
02:36:11,450 --> 02:36:13,650
So, ich bin mal gespannt, was bei den Benchmarks rauskommt.

2491
02:36:13,650 --> 02:36:15,250
Wobei, eigentlich bin ich nicht gespannt.

2492
02:36:15,250 --> 02:36:16,650
Wir wissen alle, was rauskommt.

2493
02:36:17,050 --> 02:36:18,250
Rust schneller.

2494
02:36:18,850 --> 02:36:19,250
Ja.

2495
02:36:20,050 --> 02:36:21,450
Um Längen schneller.

2496
02:36:21,450 --> 02:36:22,050
Guckt mal.

2497
02:36:22,850 --> 02:36:23,450
Also...

2498
02:36:23,650 --> 02:36:24,250
...die Funktion...

2499
02:36:24,250 --> 02:36:24,650
...hier...

2500
02:36:25,050 --> 02:36:27,450
...die pure Rust-Funktion aufrufen...

2501
02:36:29,050 --> 02:36:33,650
...ist einfach 124 Nanosekunden zu 8,5 Mikrosekunden.

2502
02:36:34,450 --> 02:36:35,650
Und hier ist...

2503
02:36:35,850 --> 02:36:38,250
Go braucht für die Geschichte mit dem Struct...

2504
02:36:39,250 --> 02:36:40,050
...18...

2505
02:36:40,250 --> 02:36:41,250
...Nanosekunden...

2506
02:36:41,650 --> 02:36:43,050
...18.000 Nanosekunden...

2507
02:36:43,050 --> 02:36:43,850
...ne, Moment.

2508
02:36:44,650 --> 02:36:46,050
18.000 Nanosekunden...

2509
02:36:46,050 --> 02:36:48,450
...also 18 Millisekunden, sehe ich das richtig?

2510
02:36:48,850 --> 02:36:49,450
Chat?

2511
02:36:49,850 --> 02:36:50,850
Ne, Mikrosekunden.

2512
02:36:51,050 --> 02:36:52,050
Mikrosekunden, nicht Millisekunden.

2513
02:36:52,250 --> 02:36:53,050
Meine Güte!

2514
02:36:53,250 --> 02:36:53,850
Boah!

2515
02:36:55,250 --> 02:36:56,050
Einheiten!

2516
02:36:56,050 --> 02:36:56,850
Keck, wait!

2517
02:36:57,250 --> 02:36:58,450
18 Mikrosekunden...

2518
02:36:58,450 --> 02:37:01,050
...und Rust braucht einfach nur 2.

2519
02:37:01,050 --> 02:37:05,200
Ist schon eine ganze Ecke schneller.

2520
02:37:05,800 --> 02:37:06,800
Und hier haben wir...

2521
02:37:06,800 --> 02:37:15,900
...und das dürfen wir nicht vergessen...

2522
02:37:16,300 --> 02:37:18,300
...hier haben wir 2 Calls...

2523
02:37:18,900 --> 02:37:19,500
...drinne.

2524
02:37:20,300 --> 02:37:20,900
Wir haben...

2525
02:37:21,300 --> 02:37:21,700
...in der...

2526
02:37:21,700 --> 02:37:24,140
...und es sind trotzdem schneller.

2527
02:37:24,140 --> 02:37:25,340
Wir haben 2 Calls.

2528
02:37:25,740 --> 02:37:26,740
Wir haben den...

2529
02:37:27,740 --> 02:37:28,540
...eigentlichen...

2530
02:37:28,740 --> 02:37:30,540
...Call zum Struct erzeugen...

2531
02:37:31,340 --> 02:37:33,940
...und wir haben den Call zum Free noch drinne.

2532
02:37:34,740 --> 02:37:41,700
Nimm mal String als Type und nicht Pointer.

2533
02:37:41,700 --> 02:37:42,900
Lass ihn Free callen.

2534
02:37:42,900 --> 02:37:43,900
Sollte schneller sein.

2535
02:37:44,100 --> 02:37:44,500
Ne.

2536
02:37:45,300 --> 02:37:45,900
Also, ja.

2537
02:37:45,900 --> 02:37:46,300
Ne.

2538
02:37:47,100 --> 02:37:47,700
Also, ja.

2539
02:37:47,700 --> 02:37:48,700
Vielleicht ist das...

2540
02:37:48,700 --> 02:37:49,700
...ein Ticken schneller.

2541
02:37:50,300 --> 02:37:51,900
Weil .NET das Free macht...

2542
02:37:51,900 --> 02:37:53,300
...und nicht Rust gecallt wird.

2543
02:37:53,300 --> 02:37:53,900
Aber...

2544
02:37:54,500 --> 02:37:56,900
...die Rust-Docs sagen explizit...

2545
02:37:56,900 --> 02:37:59,300
...man soll nicht Free callen, sondern...

2546
02:37:59,500 --> 02:38:01,300
...soll das zurück an Rust geben...

2547
02:38:01,300 --> 02:38:02,500
...und Rust soll es freeen.

2548
02:38:04,100 --> 02:38:05,300
Sonst Memory Leak.

2549
02:38:06,300 --> 02:38:06,900
Es ist...

2550
02:38:06,900 --> 02:38:07,900
...also du hast Recht, das ist schneller.

2551
02:38:07,900 --> 02:38:09,100
Aber wir können das ausprobieren.

2552
02:38:09,700 --> 02:38:10,100
Schade nix.

2553
02:38:10,100 --> 02:38:11,100
Wir können das ausprobieren.

2554
02:38:11,300 --> 02:38:11,900
Ich lass das...

2555
02:38:11,900 --> 02:38:12,700
...ich lass das mal weg.

2556
02:38:13,900 --> 02:38:15,700
Und wir ändern den hier zu String.

2557
02:38:16,100 --> 02:38:16,700
Wir haben ja gesehen...

2558
02:38:16,700 --> 02:38:18,300
...wir haben auch nahezu kein Memory Leak...

2559
02:38:18,300 --> 02:38:19,300
...und führen das Ganze nochmal...

2560
02:38:19,900 --> 02:38:20,700
...ööö...

2561
02:38:25,180 --> 02:38:25,580
...ja.

2562
02:38:25,780 --> 02:38:27,180
Jetzt sollte er schneller sein...

2563
02:38:27,180 --> 02:38:29,180
...aber wir haben potenziell ein Memory Leak.

2564
02:38:29,180 --> 02:38:29,780
Zumindest...

2565
02:38:29,980 --> 02:38:31,580
...sagen die Rust...

2566
02:38:31,580 --> 02:38:33,180
...sagt die Rust-Doku das...

2567
02:38:33,580 --> 02:38:35,380
...dass wir dann einen Memory Leak haben.

2568
02:38:36,980 --> 02:38:38,180
Wenn wir das nicht so machen.

2569
02:38:44,520 --> 02:38:46,120
Also Arduino plus Rust...

2570
02:38:46,120 --> 02:38:47,120
...hab ich noch nie gemacht.

2571
02:38:48,320 --> 02:38:51,320
Ich bin eher der ESP32-Enjoyer.

2572
02:38:51,920 --> 02:38:53,720
Und da ist Rust ja auch nur...

2573
02:38:53,720 --> 02:38:54,320
...sagen wir mal so...

2574
02:38:54,320 --> 02:38:55,120
...sehr rudimentär.

2575
02:38:55,120 --> 02:38:56,320
Vieles geht ja in Rust noch nicht.

2576
02:38:56,320 --> 02:38:57,720
Ich glaube, Rust und WiFi...

2577
02:38:58,120 --> 02:38:59,320
...geht glaube ich auch noch nicht...

2578
02:38:59,320 --> 02:38:59,720
...auf dem...

2579
02:38:59,720 --> 02:39:01,320
...auf dem ESP32.

2580
02:39:09,390 --> 02:39:10,190
Ja, genau.

2581
02:39:10,190 --> 02:39:10,390
Das...

2582
02:39:10,390 --> 02:39:10,790
...das...

2583
02:39:10,790 --> 02:39:11,990
...genau deshalb denke ich auch.

2584
02:39:12,390 --> 02:39:13,990
Es kann ja auch möglich sein...

2585
02:39:14,390 --> 02:39:15,990
...dass Rust nicht einfach...

2586
02:39:17,390 --> 02:39:17,590
...den...

2587
02:39:17,590 --> 02:39:17,990
...den...

2588
02:39:17,990 --> 02:39:18,990
...das Memory...

2589
02:39:18,990 --> 02:39:19,990
...allocated...

2590
02:39:19,990 --> 02:39:20,990
...über die...

2591
02:39:20,990 --> 02:39:22,390
...das normale C-Malloc...

2592
02:39:22,390 --> 02:39:23,990
...sondern irgendwas eigenes macht.

2593
02:39:24,390 --> 02:39:25,990
Und dann bringt ja normales C-Free...

2594
02:39:25,990 --> 02:39:27,390
...an der Stelle ja auch wenig.

2595
02:39:27,790 --> 02:39:28,990
Wenn da noch Sachen nestet...

2596
02:39:28,990 --> 02:39:30,590
...irgendwie anderweitig allokiert sind...

2597
02:39:30,590 --> 02:39:31,990
...von denen nur Rust was weiß.

2598
02:39:33,390 --> 02:39:34,590
Also das ergibt schon Sinn.

2599
02:39:34,990 --> 02:39:36,590
Und dass das auch ein Memory-Leak hat...

2600
02:39:36,990 --> 02:39:37,990
...gehe ich auch von aus...

2601
02:39:37,990 --> 02:39:38,990
...aber es dürften wahrscheinlich...

2602
02:39:38,990 --> 02:39:39,990
...nur ein paar Bytes sein.

2603
02:40:00,520 --> 02:40:02,520
Über Unsafe sollte WLAN gehen.

2604
02:40:03,320 --> 02:40:04,720
Sofern man die...

2605
02:40:05,320 --> 02:40:06,320
...eingebauten...

2606
02:40:06,320 --> 02:40:09,120
...ESP-C-Sachen aufrufen kann aus Rust...

2607
02:40:09,120 --> 02:40:10,320
...dann vielleicht, ja.

2608
02:40:15,560 --> 02:40:16,560
Aber ehrlich gesagt...

2609
02:40:16,560 --> 02:40:16,960
...muss ich...

2610
02:40:16,960 --> 02:40:17,560
...muss ich sagen...

2611
02:40:17,960 --> 02:40:18,960
...Plattform-IO...

2612
02:40:19,760 --> 02:40:20,960
...und auch wenn da unter der Haube...

2613
02:40:20,960 --> 02:40:22,960
...C++ für den ESP32 ist...

2614
02:40:22,960 --> 02:40:24,160
...ist recht angenehm.

2615
02:40:32,150 --> 02:40:33,350
Ich glaube ehrlich gesagt...

2616
02:40:33,350 --> 02:40:34,550
...dass in dem Fall C++...

2617
02:40:34,550 --> 02:40:35,750
...und ich sag's nur ungern, ja...

2618
02:40:36,350 --> 02:40:37,750
...aber C++ für solche Sachen...

2619
02:40:37,750 --> 02:40:38,550
...angenehmer ist.

2620
02:40:38,750 --> 02:40:39,550
Rust plus...

2621
02:40:39,550 --> 02:40:40,350
...plus Arduino...

2622
02:40:40,350 --> 02:40:42,150
...gibt's da denn ein gutes Projekt für?

2623
02:40:42,150 --> 02:40:42,750
Wir hatten das...

2624
02:40:42,750 --> 02:40:43,750
...wir hatten das geschrieben.

2625
02:40:44,950 --> 02:40:46,350
Gibt's da ein gutes Projekt für?

2626
02:40:46,550 --> 02:40:47,350
Kannst mal schicken...

2627
02:40:47,350 --> 02:40:48,750
...vielleicht können wir uns das wirklich angucken.

2628
02:40:48,750 --> 02:40:49,150
So.

2629
02:40:54,080 --> 02:40:55,280
Leute, ich weiß nicht warum...

2630
02:40:55,280 --> 02:40:57,280
...aber das Ganze ist jetzt langsamer geworden...

2631
02:41:03,550 --> 02:41:05,350
...wenn wir C-Sharp freen lassen.

2632
02:41:08,210 --> 02:41:08,810
Okay?

2633
02:41:12,840 --> 02:41:13,840
Also es ist schneller...

2634
02:41:14,840 --> 02:41:17,040
...es ist schneller Rust freen zu lassen als...

2635
02:41:18,040 --> 02:41:20,640
...als C-Sharp freen zu lassen.

2636
02:41:25,490 --> 02:41:25,890
Okay?

2637
02:41:27,090 --> 02:41:27,690
Ah ja.

2638
02:41:29,600 --> 02:41:30,600
Meinetwegen...

2639
02:41:31,200 --> 02:41:32,600
...soll mir recht sein, okay.

2640
02:41:38,160 --> 02:41:39,360
Der Benchmark hier unten...

2641
02:41:39,360 --> 02:41:40,960
...ist aber für meine Sachen...

2642
02:41:40,960 --> 02:41:42,360
...eh nicht sonderlich relevant...

2643
02:41:42,760 --> 02:41:43,960
...weil die Funktion...

2644
02:41:43,960 --> 02:41:46,160
...die ich wirklich schnell in der Schleife aufrufe...

2645
02:41:46,560 --> 02:41:48,760
...ist nichts was Strings oder so returnt...

2646
02:41:49,160 --> 02:41:50,560
...sondern das returnt gar nichts.

2647
02:41:50,760 --> 02:41:51,760
Bekommt einfach nur nen...

2648
02:41:52,760 --> 02:41:54,960
...nen Pointer als Parameter übergeben...

2649
02:41:57,320 --> 02:41:59,120
...den es auch nicht selbst freen muss.

2650
02:41:59,520 --> 02:42:01,720
Also insofern ist das hier eigentlich für mich...

2651
02:42:01,720 --> 02:42:03,720
...die, die, der relevantere Benchmark...

2652
02:42:03,920 --> 02:42:05,920
...und da ist Rust meilenweit schneller.

2653
02:42:06,120 --> 02:42:07,720
.NET ist noch einen Ticken schneller...

2654
02:42:08,120 --> 02:42:10,120
...also .NET zu .NET ist logischerweise...

2655
02:42:10,120 --> 02:42:11,520
...schneller als .NET zu Rust...

2656
02:42:12,120 --> 02:42:14,320
...aber Rust ist um Welten schneller als Go.

2657
02:42:16,320 --> 02:42:17,520
Überrascht mich aber auch nicht...

2658
02:42:17,520 --> 02:42:19,320
...weil ich wusste dass C-Go langsam ist...

2659
02:42:19,320 --> 02:42:20,720
...und ich wollte einfach mal gucken...

2660
02:42:21,520 --> 02:42:23,520
...ob es mittlerweile besser geworden ist.

2661
02:42:23,920 --> 02:42:25,520
Ich würde sagen es ist besser geworden...

2662
02:42:25,520 --> 02:42:26,720
...aber es ist immer noch ziemlich...

2663
02:42:26,720 --> 02:42:27,720
...ziemlich lahm...

2664
02:42:27,920 --> 02:42:29,720
...wenn man Millionenfach das aufruft.

2665
02:42:29,920 --> 02:42:31,120
Wenn man das jetzt einfach nur...

2666
02:42:31,120 --> 02:42:32,920
...ein paar tausend mal aufruft oder so...

2667
02:42:33,320 --> 02:42:34,120
...drauf geschissen...

2668
02:42:34,120 --> 02:42:36,120
...da macht es ein bisschen Overhead auch nicht aus.

2669
02:42:37,720 --> 02:42:38,720
Aber wenn man das Millionenfach...

2670
02:42:38,720 --> 02:42:39,720
...pro Sekunde aufruft...

2671
02:42:39,720 --> 02:42:41,120
...dann macht es schon einiges aus.

2672
02:42:41,920 --> 02:42:43,520
Was ich übrigens auch nicht machen werde.

2673
02:42:44,520 --> 02:42:44,920
Also...

2674
02:42:45,520 --> 02:42:46,320
...also für meine Verhältnisse...

2675
02:42:46,320 --> 02:42:47,320
...könnte ich auch einfach...

2676
02:42:48,520 --> 02:42:49,920
...die Go Library verwenden...

2677
02:42:49,920 --> 02:42:50,720
...aber warum?

2678
02:42:50,720 --> 02:42:51,320
Ich meine...

2679
02:42:51,720 --> 02:42:52,520
...wir können...

2680
02:42:52,520 --> 02:42:53,120
...das machen wir dann...

2681
02:42:53,120 --> 02:42:54,120
...einmal nächsten Streams...

2682
02:42:54,120 --> 02:42:54,920
...da machen wir dann...

2683
02:42:55,320 --> 02:42:57,920
...WebRTC in Rust.

2684
02:42:58,720 --> 02:43:03,900
Sind auch Aufrufe von Go nach C langsam?

2685
02:43:04,500 --> 02:43:05,500
Ja, ja, auch...

2686
02:43:06,300 --> 02:43:09,680
Theoretisch sind die ein Ticken schneller...

2687
02:43:09,880 --> 02:43:10,880
...also früher war es so...

2688
02:43:11,280 --> 02:43:13,080
...Aufrufe von Go nach C...

2689
02:43:13,480 --> 02:43:14,480
...waren langsam...

2690
02:43:15,480 --> 02:43:17,680
...also auch langsamer als von anderen Sprachen...

2691
02:43:18,480 --> 02:43:20,280
...von anderer Sprache nach C...

2692
02:43:20,880 --> 02:43:21,480
...aber...

2693
02:43:21,480 --> 02:43:23,680
...in Go reinkollen von C aus...

2694
02:43:23,680 --> 02:43:25,480
...war nochmal eine Ecke langsamer.

2695
02:43:26,480 --> 02:43:27,280
Mittlerweile...

2696
02:43:27,680 --> 02:43:28,680
...mittlerweile ist es glaube ich...

2697
02:43:28,680 --> 02:43:30,480
...ungefähr gleich langsam.

2698
02:43:31,480 --> 02:43:32,680
Aber das ist auch langsam, ja...

2699
02:43:32,680 --> 02:43:34,080
...es ist vielleicht nicht ganz so langsam...

2700
02:43:34,080 --> 02:43:35,680
...wie von anderer Sprache zu Go...

2701
02:43:37,280 --> 02:43:38,280
...aber auch langsam.

2702
02:43:38,880 --> 02:43:39,880
Go hat mit...

2703
02:43:40,280 --> 02:43:40,880
...mit...

2704
02:43:41,280 --> 02:43:42,680
...den langsamsten Interop...

2705
02:43:43,080 --> 02:43:44,280
...mit anderen Sprachen...

2706
02:43:44,280 --> 02:43:45,680
...von allen Programmiersprachen...

2707
02:43:45,680 --> 02:43:46,280
...die es gibt.

2708
02:43:46,680 --> 02:43:48,080
Go an sich ist relativ flott...

2709
02:43:48,480 --> 02:43:49,080
...aber...

2710
02:43:49,280 --> 02:43:51,880
...was hier alles immer über irgendeinen C-Interface geht...

2711
02:43:52,280 --> 02:43:53,680
...da ist Go richtig langsam...

2712
02:43:53,880 --> 02:43:54,880
...was auch ein Problem ist...

2713
02:43:55,280 --> 02:43:55,880
...weil...

2714
02:43:56,080 --> 02:43:56,880
...die ganzen...

2715
02:43:57,280 --> 02:43:59,880
...Wrapper-Libraries für SQLite...

2716
02:44:00,280 --> 02:44:02,680
...oder für irgendwelche anderen Low-Level-Sachen...

2717
02:44:03,080 --> 02:44:06,080
...die sind potenziell in Go einfach arschlangsam...

2718
02:44:06,680 --> 02:44:07,480
...weil...

2719
02:44:07,880 --> 02:44:09,080
...C-Go langsam ist.

2720
02:44:10,080 --> 02:44:11,680
Also wenn man ordentlich Load drauf hat...

2721
02:44:12,080 --> 02:44:12,680
...und...

2722
02:44:13,080 --> 02:44:13,680
...und...

2723
02:44:14,080 --> 02:44:14,680
...und...

2724
02:44:15,080 --> 02:44:15,680
...und...

2725
02:44:16,080 --> 02:44:16,680
...und...

2726
02:44:17,080 --> 02:44:17,680
...und...

2727
02:44:17,680 --> 02:44:19,480
...also wenn man ordentlich Load drauf hat, ja...

2728
02:44:22,280 --> 02:44:24,680
...deswegen gibt es beispielsweise für SQLite...

2729
02:44:25,480 --> 02:44:26,280
...ein Projekt...

2730
02:44:27,080 --> 02:44:28,280
...das SQLite...

2731
02:44:28,880 --> 02:44:31,080
...transpiled nach Go...

2732
02:44:31,880 --> 02:44:34,680
...damit es native Go kompiliert werden kann...

2733
02:44:34,680 --> 02:44:37,280
...und nicht mit C-Function-Calls...

2734
02:44:37,880 --> 02:44:40,880
...weil SQLite unter ordentlich Last wohl...

2735
02:44:42,080 --> 02:44:44,080
...eine nicht zu unterschätzende Overhead hat...

2736
02:44:44,080 --> 02:44:47,280
...weil es sehr viele C-Calls macht in Go...

2737
02:44:47,280 --> 02:44:49,480
...weil SQLite halt eine C-Library ist.

2738
02:44:50,680 --> 02:44:51,080
Ja.

2739
02:44:51,880 --> 02:44:52,880
Also macht Probleme...

2740
02:44:52,880 --> 02:44:55,280
...Go ist schnell, solange man sich innerhalb von Go bewegt.

2741
02:45:04,360 --> 02:45:06,360
Und gibt es noch ein paar Examples?

2742
02:45:07,560 --> 02:45:08,960
Examples?

2743
02:45:17,400 --> 02:45:18,400
Plattform-IO.

2744
02:45:18,400 --> 02:45:19,000
Nice.

2745
02:45:20,910 --> 02:45:23,510
Ach, haben die das jetzt offiziell in Plattform-IO drin, ne?

2746
02:45:24,110 --> 02:45:25,710
Ne, das ist das ganz normale...

2747
02:45:26,310 --> 02:45:27,710
...ESP-IDF...

2748
02:45:32,430 --> 02:45:33,430
...Source...

2749
02:45:35,590 --> 02:45:36,590
...Main-AS.

2750
02:45:38,880 --> 02:45:41,080
Okay, ja, da haben sie Rapper um Sachen gebaut, okay.

2751
02:45:41,480 --> 02:45:42,680
Ja, also anscheinend kann man...

2752
02:45:46,640 --> 02:45:48,040
...in den Makro-Zeug...

2753
02:45:48,040 --> 02:45:49,440
...also anscheinend kann man auch...

2754
02:45:49,440 --> 02:45:52,240
...ESP mit Rust programmieren, aber ganz im Ernst, das...

2755
02:45:52,440 --> 02:45:53,440
...tue ich mir nicht an.

2756
02:46:04,890 --> 02:46:05,290
Jo.

2757
02:46:05,290 --> 02:46:06,290
Nice, Chat.

2758
02:46:07,290 --> 02:46:08,290
Fast drei Stunden...

2759
02:46:08,290 --> 02:46:11,290
...heute ganz schön lang gestreamt, heute Morgen drei Stunden, jetzt drei Stunden...

2760
02:46:26,070 --> 02:46:27,470
...das Maurice-Video.

2761
02:46:32,640 --> 02:46:33,040
Jo.

2762
02:46:33,240 --> 02:46:33,840
Chat.

2763
02:46:34,840 --> 02:46:36,040
Wir sind fertig für heute.

2764
02:46:37,040 --> 02:46:38,840
Schön, dass ihr am Start wart.

2765
02:46:40,040 --> 02:46:43,040
Guckt mal kurz, ob wir irgendjemand hosten können.

2766
02:46:46,880 --> 02:46:48,680
Ich hoffe, euch hat der Stream heute gefallen.

2767
02:47:11,900 --> 02:47:12,300
Wir haben...

2768
02:47:12,300 --> 02:47:13,100
...okay.

2769
02:47:16,290 --> 02:47:17,490
Hier haben wir...

2770
02:47:17,490 --> 02:47:20,090
...hier haben wir einen am Start, vielleicht hoste ich den, zeigt mal.

2771
02:47:22,450 --> 02:47:23,250
Der macht...

2772
02:47:25,050 --> 02:47:26,250
...ja, ja, Fake-Email.

2773
02:47:26,450 --> 02:47:27,250
Der macht...

2774
02:47:27,450 --> 02:47:29,250
...Devops plus Kubernetes.

2775
02:47:34,250 --> 02:47:34,650
Oh.

2776
02:47:35,250 --> 02:47:35,650
Der...

2777
02:47:36,250 --> 02:47:39,650
Ich glaube, der macht auch gerade seinen Stream aus, weil er Stream-Manager ist.

2778
02:47:40,050 --> 02:47:40,650
Na gut.

2779
02:47:41,250 --> 02:47:41,850
Dann nicht.

2780
02:47:43,050 --> 02:47:43,850
Okay, Chat.

2781
02:47:44,050 --> 02:47:44,850
Dann gehe ich auf.

2782
02:47:45,050 --> 02:47:46,050
Bis denn, macht's gut.

2783
02:47:46,250 --> 02:47:46,650
See you.

2784
02:47:49,360 --> 02:47:50,160
Winke-Winke.
