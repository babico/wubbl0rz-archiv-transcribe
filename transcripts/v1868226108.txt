So, da bin ich wieder.
Was heißt wieder? Heute war ich ja noch gar nicht da.
Wahrscheinlich die meisten auf dem Weg heim von der Arbeit gerade.
Oder kurz
bevor die Arbeit fertig ist. Ich weiß es nicht.
Placing the fast ist ja eigentlich nur Rust. Oder, oder Craplang.
Ich habe gehört, die coolen Leute verwenden ja heute lieber Craplang anstatt... Alter, wie stellt man das nochmal ein?
Ey, Lautstärke ist richtig.
Ja, wie gesagt, die coolen Leute benutzen ja heute Craplang und nicht
und nicht Rust.
Wegen irgendeinem Drama,
wo ich keinen Plan habe, was da eigentlich genau los war.
Ich habe das nicht so ganz verfolgt, aber Rust wurde ja geforkt,
weil, boah fragt mich nicht, weil Mozilla, Mozilla hat irgendwelches komisches Zeug gemacht. Kein Plastenschimmer.
Kein Plastenschimmer, was da los ist. Es gibt überall Drama, ihr müsst euch das mal vorstellen. Sogar bei
Programmiersprachen gibt es Drama, wo dann geforkt wird und sowas.
Irgendwer war unhappy über GPL. Ja, okay, wenn du das sagst. Ich habe keine Ahnung. Ich starte mal kurz meine 4M
und mache gerade mal Update, weil ich habe schon eine Weile nicht mehr geupdatet. Das heißt, es läuft jetzt mal kurz. Ah, Bester!
White Paper Fett, Leute, am Start.
V3, warum ist GPL V3 böse? Ist Linux nicht auch unter GPL V3?
Man weiß es nicht. Man versteht es nicht so ganz, was da los ist.
Macht das wie ich, macht eure Software einfach unter gar keine Lizenz, da kann niemand was mit anfangen.
Pech gehabt. Wie? Keine Updates? Für aure Packages.
Was ist da los? Ah ja, ich habe den Screenshot zurückgerollt. Exzellent!
So, wo wir gerade dabei sind beim Thema Snapshots.
Gerade mal die Snapshots deleten.
Easy, das ist eine gute Idee. Oder einfach die Software vergammeln lassen
und nicht mehr updaten seit einem halben Jahr.
Und auch keine Issues mehr bearbeiten.
Aber V2, 4-Champ-V2 wird es geben.
Was willst du denn mit SICK bauen?
Also, ich habe mir tatsächlich heute mal Gedanken gemacht, wo man eine gute Demo-Anwendung machen kann.
Das wird eine CLI-Anwendung werden. Ich gehe nicht davon aus, dass ich heute in SICK-UI diven werde.
Aber wir bauen eine UI-Anwendung, die einfach das Format von einem Video ausgeben kann.
Das heißt, wir brauchen Interop mit C bzw. C++ mit FFmpeg.
Wir müssen gucken, wie man CLI-Parsing macht.
Und wir müssen gucken, wie man Packages installiert und sowas.
Keine Ahnung, ich habe das noch nie benutzt.
Ich muss auch sagen, die Syntax hat mich jetzt ein bisschen abgeschreckt, als ich mir das angeguckt habe.
Aber ich wollte es schon lange mal ausprobieren.
Das hat ja irgendjemand letztens sogar im Stream hier vorgeschlagen, dass wir das mal machen können.
Ich wollte es schon lange mal ausprobieren.
Also, ich wollte es eigentlich schon ausprobieren, seit es diese komische neue Javascript-Engine gibt in SICK.
Oder in SICK.
Ich habe vergessen, wie die heißt.
Äh, BUN? Kann das sein? Heißt die BUN?
BUN?
Ja. Ja.
Und das ist doch in SICK.
Warum heißt das eigentlich SICK?
Warum heißt SICK wie SICK?
So richtig SICK-Programming-Language-Pro oder wie?
Oder warum heißt das so?
Base64? Moment, Moment, Moment.
Base64 ist nicht in der Standard-Library drin.
Ich ahne Schlemmes.
Oh, die Syntax.
MonkaW-Extreme, Alter.
Das ist so eine Mischung aus Rust-Style-Schleife und C-Style-Schleife.
Oh Gott, das wird was, Leute. Ich sag's euch.
MonkaS.
MonkaGiga.
Also, wir machen mal alle Tabs zu.
Oh, das war vielleicht ein bisschen viel.
Und dann rebooten wir nochmal die VM.
Also mit C++ hat es nicht allzu viel zu tun, wenn ich mir das jetzt angeguckt habe.
Ich meine, die C++-Syntax an sich ist gar nicht so schlimm.
Was die halt daraus gebaut haben, ist schlimm.
Mit 580 Milliarden Zusatzdingern.
Irgendwie höre ich mich auf dem einen Ohr nicht richtig.
Also entweder...
Ja, genau, das ist halt so das Problem.
Von den grundsätzlichen Sachen ist das nicht so schlimm.
Ich höre mich nur auf einem Ohr.
Es gibt zwei Möglichkeiten.
Entweder ich habe gerade einen Schlaganfall oder sowas.
Wovon ich mal nicht ausgehe.
Oder mein Headset spinnt.
Ich muss mal kurz mein Headset abstöpseln.
Zack.
Gleich wieder am Start.
Oder noch bessere Kombi.
Warte mal, ja.
So.
Ich hoffe, jetzt höre ich mich wieder halbwegs auf beiden Ohren.
Ja, ja, okay, nice.
Also, wer sich fragt, warum ich mich hören muss.
Ganz klar, ich habe ein geschlossenes Headset auf.
Und ich spiele ja das, was ins Mikrofon reingeht, immer so ein bisschen bei mir wieder auf die Ohren drauf.
Also ich höre mich quasi so...
Ich höre mich quasi ein bisschen selbst.
Was wichtig ist, dass ich höre, ob das Mikrofon irgendwelche Probleme hat.
Und, dass ich nicht so rumschreie.
Und das ist wichtig, dass das ohne...
Ja.
Und das ist übrigens wichtig, dass man das wirklich an ein gescheites Audiointerface anschließt.
Und halt irgendwas ohne Delay.
Weil sobald man Delay hat, kann man sich nicht monitoren.
Also selbst wenn es nur 2, 3 Millisekunden Verzögerung ist, dann wirst du verrückt im Kopf.
Das muss instant, so wie du sprichst, muss es auf deinem Ohr landen.
Und...
Naja gut.
Lichtgeschwindigkeit sollte reichen.
Natürlich ist es nicht ganz Lichtgeschwindigkeit.
Die Signalübertragung ist nahe zu Lichtgeschwindigkeit.
Aber natürlich muss das Ganze noch umgewandelt werden.
Also sprich, es muss erstmal vom Mikrofon in das Audiointerface.
Und dann muss das irgendwie durch das Audiointerface geroutet werden.
Und dann wieder am Output raus.
Aber das ist alles sehr schnell.
Heh.
Du verwirrst...
Ja, das ist sobald du Delay hast.
Wenn du ein Delay hast, beim selbst wieder einspielen des Mikrofons, dann drehst du durch.
Im Kopf.
Wenn es aber quasi instant ist, so wie wenn du sprechen würdest, stört es nicht weiter.
Außerdem darf man es nicht so laut machen.
Welches Interface hast du?
Ich habe ein...
Ich habe das schon eine ganze Weile.
Ich weiß gar nicht, ob es das überhaupt noch zu kaufen gibt.
Ein Moto Track 16.
Products.
Track.
Das gibt es gar nicht mehr.
Guck, aber so sieht es aus.
Das ist echt nice.
Mittlerweile findest du wahrscheinlich...
Noch bessere.
Beziehungsweise mit mehr Anschlüssen.
Oder mit noch günstiger oder was auch immer.
Ja, hast du richtig gehört.
Und so sieht das aus.
Es hat übrigens noch ein Firewire-Anschluss.
Und das da ist für so ein IO-Breakout-Kabel.
Also das Interface hat sich jetzt...
Also wie gesagt, ich habe das seit...
Frag mich nicht.
2012 oder so.
Das habe ich schon wirklich lange.
2012 kann nicht sein.
Ja doch.
2010 habe ich mit YouTube angefangen.
Ich habe das schon über 10 Jahre.
Seitdem habe ich da auch alles drüber laufen.
Also wenn ich über die Konsolen habe,
habe ich den Sound drüber laufen.
Verschiedene Mikrofon-Inputs habe ich drüber laufen.
Du kannst ja da auch mit diesem Breakout-Kabel
jede Menge Sachen dran anschließen.
Und so hast du theoretisch noch
einen digitalen Input.
Bis zu 8 Kanäle auf einem digitalen Input.
Und du kannst es durchschleifen.
Oder den Sound auch optisch ausgeben.
Per SPDiv oder per USB.
Oder per Firewire.
Kein Mensch braucht heute noch Firewire.
Aber könnt ihr euch überlegen.
Das ist halt schon ein bisschen her.
Das Interface ist schon ein bisschen älter.
Aber das hat sich wirklich bewährt.
Den Knopf da oben verwende ich übrigens
so gut wie gar nicht.
Manchmal gucke ich auf meinen Main-Output
beziehungsweise auf den Mikrofon-Input
hier oben drauf.
Aber im Prinzip drücke ich die Knöpfe
eigentlich so gut wie gar nicht.
Und auch die Lautstärke.
Drehdings benutze ich nicht.
Drehdings benutze ich hier nicht.
Ja, das war damals relativ teuer.
Und ist wahrscheinlich auch immer noch
relativ teuer.
Was kostet das aktuell?
Geht, geht, geht.
Es ist günstiger.
Ich glaube, das hat irgendwas um 500-600 Euro
tatsächlich gekostet.
Aber mittlerweile gibt es das billiger.
Und wahrscheinlich wird man auch
besser geeignete Interfaces heute
für Streaming und Aufnahme
und Gaming-Sachen finden als das.
Aber vor 10 Jahren war das gut.
Ich muss sagen, ich war technisch eh
ziemlich gut dabei. Damals bei YouTube.
Ich hatte ja eine der besten
Capture-Cards
Pre-Elgato. Heute hat jeder eine
Elgato-Capture-Card und die sind fein.
Die machen einfach alles, was man braucht.
Damals gab es auch keine Elgato-Capture-Karte.
Damals hatte ich eine
Blackmagic
Intensity Pro.
720p, 60fps.
Das war einfach richtig
Pog
für Xbox 360-Aufnahmen.
Da konntest du auch die Playstation 3
noch anschließen und sowas.
Mittlerweile ist es deutlich einfacher geworden.
Irgendeine
Easy-Interface von Toma
ankaufen oder
ein USB-Streaming-Mikrofon
und
irgendeine günstige Elgato-Capture-Karte
und du bist mit 200-300 Euro
bei einem ganz guten Streaming-Setup
dabei. Das war
tatsächlich
2010 noch ein bisschen komplizierter.
Heute
gucken wir uns folgendes an.
Sick Lang. Richtig Sick Bro.
So sieht das Ganze aus.
Es ist syntaktisch
eine Mischung aus
ich würde sagen
C
Ruby und ein bisschen
Rust.
Oh, ist auch ein bisschen mit dabei.
Wilde Mischung aus
allem.
Ich frage mich auch
was ist eigentlich aus Machinima Respawn
geworden. Machinima Respawn
war so ein riesen Ding und den Channel
gibt es mittlerweile gar nicht mehr.
Soll ich das sagen?
Machinima Respawn
einfach 2,4 Millionen Abos noch
einfach alles weg.
Keine Ahnung. Das habe ich nicht mitbekommen.
Ich frage mich
wo die hin sind.
Das wäre natürlich auch ein Grund, warum es die nicht mehr gibt.
Ich weiß, viele der Leute,
die damals bei Machinima waren, die gibt es
heute noch. Wobei, also
CNNers gibt es noch.
Der hat eine Zeit lang
diese funny Garry's Mod
Videos und sowas gemacht. Weiß gar nicht, ob der noch am
Start ist. Hatscha, wie lange nicht mehr.
Tapes gibt es glaube ich nicht mehr.
Viele von denen machen ja
heute auf anderen YouTube Channels
was, aber dass sowas einfach verschwindet
weil Machinima Respawn
war halt riesig groß.
Ach, der ist auf Twitch. Okay.
The many scams and downfall
of Machinima.
Das gucken wir uns vielleicht irgendwann mal
demnächst an.
Vielleicht habe ich das nämlich auch schon mal geguckt.
Kann sein, weil ich wieder alles vergessen habe.
Würde mich doch mal interessieren, wo die eigentlich hin sind.
Und was mich noch viel mehr interessieren würde
ist, warum hat meine
JetBrains
Toolbox seit
neuestem kein Icon mehr.
Was ist denn das da?
Wobei es hat einen Icon, aber
es sieht kacke aus. Es ist auf einmal ein schwarz-weiß
Icon anstatt dieses schöne bunte
Toolbox JetBrains
Icon. Warum sieht denn das so kacke aus?
Der Rest ist
gleich geblieben.
Gibt es das bald als Microtransaction oder
was ist da los?
Deswegen wundert es mich auch, warum
bekomme ich keine Package-Updates
für meine Icons?
Ich kann die direkt anzeigen.
Farbe gibt es nur gegen
Aufpreis. Und an wen
soll ich das überweisen unter Arch Linux?
Wer ist da der
Empfänger, dass ich
mein DLC freigeschaltet
bekomme?
Wer ist Head of Arch
Linux Store?
Achso, im Abo ist das
auch noch. Ja gut, man muss ja
mit der Zeit gehen.
Nee, der kann das nicht sein.
Dann wäre
das ja GNU Arch.
Wenn er das wäre, wäre das
auf jeden Fall GNU Arch.
Der lebt noch, ja?
Arch plus GNU plus
Linux. Nee, Moment.
GNU muss
natürlich
vorne stehen.
Das muss GNU plus Arch plus Linux sein.
Habe ich schon
rebooted?
Ich glaube schon.
Okay, also
das gucken wir uns heute an. Mal schauen
wie viele Sterne die
auf ShitHub haben.
Oh, krass,
Alter. 34, äh
24.
24k. Fast so
viel wie der Fiat Champ.
Wahnsinn.
Nicht schlecht.
Ich meine, das ist jetzt kein
Top Ten Projekt.
Aber
34, wie komme ich auf 34?
24k ist schon
sehr
respektabel.
Wenn man sich
gewählt ausdrücken möchte. Ist schon nicht
schlecht. Ist schon
relativ Pog.
So, wie installiert
man das? Also Leute, ich habe keine Ahnung.
Der Grund, warum ich drauf komme
jetzt, das zu machen. Also ich habe es ja schon ein bisschen
länger im Hinterkopf mir das anzugucken.
Seitdem es mal diese Vorstellung gab von der
neuen JavaScript Runtime, die ja gar nicht so
neu ist.
Also die erfinden das Rad ja auch nicht neu.
Der Kern ist ja immer noch
top auch
V8, oder? Plus noch einiges drum
herum gebaut.
2,3k Issues. Da gucken wir mal.
Wie viele Issues open zu Issues
closed?
Da bin ich besser.
Da ist der
Fiat Champ noch vorne. Guck, 16
offen und 29 geschlossen. Naja, okay.
Ja.
Die sind doch
besser als ich.
Was das angeht.
Ja, also, wie gesagt.
Ich bin drauf gekommen, zum ersten Mal
dass es das gibt, als
der Bann als JavaScript Runtime
so gehyped war.
Letztens hat es jemand im Stream vorgeschlagen
und ich habe letztens irgendeinen Blogpost
oder was bei Hacker News irgendwie was gesehen
das SICK ganz toll ist.
Weil SICK
super Interop angeblich
mit irgendwie C, C++
und sonst was.
Wenn ich das richtig gelesen habe.
Und blazingly fast
aber nicht Rust.
So.
Und ich habe mir gedacht, wir probieren das Ganze
mal aus. Wir machen eine kleine
Demo-Anwendung.
Wie gesagt, ich weiß nicht wie weit wir kommen.
Dazu brauche ich FFmpeg.
Aber ich habe FFmpeg schon installiert.
So, was ich bauen will
ist folgendes.
Ich zeige euch ganz einfach, was wir
für eine Anwendung bauen.
Wie gesagt, es ist eine Demo-Anwendung.
Also,
mein Terminal kann übrigens GIFs.
Also,
kennt jemand FFProbe?
Wisst ihr, was FFProbe
macht?
Wer ist Fifan und weiß, was FFProbe macht?
Welches Betriebssystem benutzt du?
ArchLinux, by the way.
Die einzig wahre Linux-Distribution.
Nur
wahre Kenner und Genießer
benutzen ArchLinux.
Und müssen selbstverständlich auch allen
erzählen, weil wir uns ja einig sind,
dass ArchLinux einfach komplett superior
ist.
Ja, genau.
Genau.
Ja, das stimmt.
Metadatenstuff. Ja, genau.
Nicht GIF-Abspielen.
GIF-Abspielen wäre
FFplay, weil ich gar nicht weiß,
ob FFplay gescheiten GIF-Support hat.
Doch, hat es.
Kann man FFplay-Loop-GIF?
Geht das?
Wie Loop-Infinite? Macht's doch gar nicht.
Lüg halt nicht.
Ach nee, Moment.
Null muss man machen.
Okay, best is off.
FFplay ist
Abspielen von GIFs.
Nein, was FFProbe
macht, ist folgendes.
FFProbe
das zeigt dir, guck
so Metadaten an
zu Videos. Zum Beispiel
dass es
70
700 Millisekunden glaube ich
Duration hat ein
Loop,
Bitrate,
Videoformat und sowas
in der Richtung. Also wir probieren
im Prinzip ein Command-Line-Tool zu kreieren,
was diesen Output hier hat.
Nicht das da oben. Das da oben ist ja nur
Zeug von FFmpeg. Also
irgendwie sowas.
Command-Line-Tool ist ungefähr sowas.
Im Prinzip reicht mir auch, wenn es sagt
Videoformat-GIF. Das juckt
mich jetzt nicht weiter. Wichtig ist,
dass wir das mit SIG machen
und
das ist gar nicht so einfach, weil
wir müssen Command-Line-Parsen dazu. Also ich
mach dann sowas wie, keine Ahnung hier,
SIG-Champ.
So.
So soll das dann ausgeführt werden.
Und das heißt, ich muss
Command-Line-Argumente parsen.
Gut, muss ich überhaupt Command-Line-Argumente
parsen? Ja, okay.
Sagen wir mal, Minus-Minus-Info gibt es noch.
Irgendwie so.
Oder Minus-Minus-Debug oder was auch immer.
Dann müssen wir lernen, wie man Command-Line-Argumente
parsen. Und wir
müssen lernen, wie man Interop
mit FFmpeg macht.
Ich kenne mich mit
FFmpeg ganz brauchbar aus.
Ist ja schon eine Weile her, wo ich zuletzt was mit gemacht habe.
Wir können zur Not auch bei mir auf GitHub nachgucken,
wie man Videofiles
mit der FFmpeg-Library einliest.
Das ist an sich relativ
simpel, so eine Art
FF-Probe zu bauen.
Aber wir brauchen Interop mit
RC-Library. Das ist nicht
C++, das ist ein C-Library, FFmpeg.
Und wir
müssen gucken, wie man irgendwelche Packages installiert.
Ich hab da wirklich überhaupt gar keine
Ahnung von. Das Problem probieren wir das jetzt aus.
So, let's go.
Machen wir mal ein Repo.
Mkdir
TheSigChamp
Als erstes brauche ich mal ein Getting Started
Tutorial, dass ich weiß, wie es
losgeht. Beziehungsweise wie
ich es installiere und sowas.
Getting Started. Installing
Zig. Na, gucken wir mal.
Zig. Bam.
General Purpose Programming Language
and Toolchain for Maintaining
Robust, Optimal and
Reusable
Software
Es ist nicht Blazingly Fast, Leute.
Warum ist es nicht Blazingly Fast?
Was sollen die ganzen
Krustashians dazu denn sagen?
Brauchst du es für die Arbeit?
Nein, ich brauche es nicht für die Arbeit.
Ich kenne niemand, der im professionellen Umfeld
Zig benutzt. Einfach nur just for fun.
Benutzt du Archilix oder
hast du Dual Boot mit Windows
oder als VM?
Als VM. Guck da.
Also folgendermaßen.
Man kann ja mehrere Desktops unter Windows machen.
Und ich habe drei Desktops.
Erster Desktop. Hier, ChatGill.
Zweiter Desktop.
Forever Workstation und dritter Desktop.
Ja.
Für alles mögliche.
Zum Anzeigen von Sachen.
Falls man mal einen dritten Desktop braucht.
Ich schalte immer um mit
Ctrl-Windows-Taste.
Pfeiltaste rechts.
Pfeiltaste links.
Pfeiltaste doppelt rechts.
So, ich schalte immer um.
Man erkennt das leider nicht so gut, dass umgeschaltet wird.
Weil Microsoft hat sich gedacht.
Man braucht keine Animationen mehr.
Unter Windows 10 gab es noch
so eine sanfte Scroll-Animation
von einem Desktop
auf den anderen.
Aber das wurde bei Windows 11
komplett wegrationalisiert.
Da hat sich Microsoft gedacht.
Nope. Animationen overrated.
Outdated. Cheapated.
Warum auch immer.
Das war nicht snappy genug.
Also.
General Purpose Programming Language
and Toolchain.
Warum heißt das Ding eigentlich so?
Woher kommt
Siglang Name?
Woher kommt das her?
Wikipedia mal befragen.
Gibt es hier eine Erklärung zu dem Namen?
Man weiß es nicht so genau.
Du hast nicht viel verpasst.
Okay.
Installiert.
Haben wir es jetzt?
Aha.
Das Ganze basiert wohl auf LVM.
Ja.
Auf geht's.
Okay. Jetzt brauchen wir echt ein Getting Started Tutorial.
Back to the Learning Section.
Jawohl.
Introduction.
In-Depth Overview.
Ich brauche eigentlich nur so ein
Hello World Example, wie das funktioniert.
Okay.
Installing haben wir gemacht.
Jetzt geht es schon los.
Okay.
Alles klar.
Run Hello World.
Mkdir SIGCHAMP haben wir schon.
SIG?
Was? Init? EXE?
Sicher, dass ich das unter Linux auch machen muss?
Äh.
Okay.
Anscheinend.
Okay. Source.
Was ist die beste IDE für SIG?
Oder der beste Editor?
Oder das beste Visual Studio Code Plugin?
Jetzt kommt mir
please keiner an mit NeoVim.
NeoVim Plugin.
Wir setupen kurz noch mal NeoVim.
Mit allen Plugins, damit
wir SIG programmieren können.
Emacs. Was kommt als Notepad++?
Best
SIG IDE.
Gibt es vielleicht... Ach hier Tools.
Tools.
Language Servers.
Text.
VS Code. Ah. Es gibt
eine offizielle Visual Studio
Code Extension.
Dann.
Okay.
Und wie runne
ich das jetzt?
SIG
SIG Build.
Oh.
Das macht ja tatsächlich was.
Und dann run.
Okay. Nice.
Wir haben ein Hello World am Start.
Der SIG Champ läuft.
Yes. Wir trusten alles.
Alles getrusted.
Main SIG.
S
Extension. Yes. Search.
Das soll man nicht
installieren. Man soll
das installieren. Hoodie.
Man kann auch Hoodie
installieren. Aber ich glaube wir bleiben
lieber mal bei dem offiziellen.
Ja. Wir benutzen die offizielle
Extension.
SIG Path
hasn't been set. Do you want to specify the
path or install?
Hä?
Use SIG in Path.
Be
recommend enabling
for a better... Would you like to enable
it? Yes.
Was? Wie ich soll
SIG updaten? Moment.
Die letzte Stable Version ist zu alt
um das zu benutzen.
Okay. Wie
sehen denn da die Releases
aus?
We're bleeding edge. Wir machen klein.
Ja. Okay. Das ist noch
vom Januar. Nee. Guck mal hier.
Das ist ja outdated, overrated, debated.
Nee.
Das wird noch mal
uninstalled. Bam.
Weg damit. Zack.
Uninstall. Alles weg.
Weg damit.
Outdated shit. Das kommt mir
gar nicht erst in die Tüte.
Outdated.
Wollen wir nicht.
Yes.
So. Wunderbar. Jetzt ist es wieder leer.
SIG.
Wir löschen das jetzt wieder.
Und jetzt installieren wir bleeding edge SIG.
SIG.
Bam. Git.
SIG. Defbin.
Perfekt. Viel
besser. Nee. Wir installieren
binary. Ich weiß nicht. Wollen wir mal gucken,
wie lange das kompiliert?
Lass uns mal
wishlist studio code. Ich meine wishlist studio
code wird es uns doch
wahrscheinlich vorschlagen.
Extensions. SIG.
Dann installieren wir das hier.
SIG language install.
Sollte das jetzt nicht eigentlich irgendwas
fragen nochmal? Oder
muss ich eine SIG Datei
öffnen? Install
ZLS. Jawohl. Hä?
Moment. Settings.
Ähm.
Wie kann man? Ach guck mal
da. Debated.
Wie kriege ich jetzt diesen
komischen Assistent hier nochmal getriggert?
Uninstall. Okay.
Reload. Alles nochmal.
Das fragt mich nicht mehr.
SIG pass.
Do you want to specify the password? Install.
Nightly.
Oder? Leute. Bleeding edge.
Komplett. Nix hier.
Nightly wird installiert.
Jawohl.
Easy.
Wohin wurde es installiert?
What?
Das kann ich mir doch im Leben nicht merken.
Wohin wurde es installiert?
Schau ich das mal an.
Ganz unauffällig.
Unauffälliger Pfad.
Wir installieren das
über wishlist studio code anstatt über den
Package Manager. Vielleicht wäre es sinnvoller gewesen
es direkt über. Aber ist doch eigentlich egal.
Dann hängen wir
das ganze doch mal an.
Also.
Export.
Pass. Gleich.
Und jetzt den
Shit da. Doppelpunkt.
Pass. Vielleicht sollte man
das lieber quoten.
Um auf Nummer sicher zu gehen.
SIG.
Warum geht das nicht?
Ah. Ich kacke.
Okay.
Gut.
Sehr schön. Dann können wir doch jetzt anfangen.
Wie war das? SIG new?
SIG. Wie ging das?
Init Exit.
Das können wir wieder weg machen. Move to trash.
Ja.
Main SIG. Da sind wir. Und jetzt kommt als nächstes
Run.
Die kennen uns schlecht hier im Stream
Leute. Die wollen uns gleich
erzählen wir sollen irgendwelche Tests bauen.
Ich glaube es geht los.
Tests brauchen nur
die Zeug programmieren was nicht funktioniert.
Also. Was
haben wir denn hier?
Public Function Main.
Es returned Ausrufezeichen
void. Okay.
Haben wir hier ordentliches Autocomplete drin.
STD.
Debug. Haben wir. Print.
Gibt da sowas wie Brindl?
Nee. Gibt es nicht.
Jetzt bin ich ja mal gespannt.
So.
Erstmal das
Versuchen in mich aufzunehmen.
So. Also das kommt schon mal weg.
Testen. Machen wir hier nicht.
Hier wird nicht getestet.
Standard Debug Print.
Okay. Da machen wir Standard.
Was gibt es da so? Gibt es da noch Print?
Nee. Ist immer unter Debug.
Print.
Print Source Add
Add.
What? Print.
Comptime.
Was?
Comptime.
Format.
Ach. Compiletime.
Das ist sowas wie
Constexpr in C++ oder was?
Okay.
Comptime.
Also.
Haben wir keine gescheite String Interpolation?
Das
nervt mich schon wieder ein bisschen wenn ich das sehe.
Zig
String Interpolation.
Interpolated
Interpolated Strings.
Gibt es das nicht?
Ja. Sowas da zum Beispiel.
Geht das nicht?
Das ist aber Kacke.
Oh Gott. Alter Reddit.
Ihr geht mir so auf den Sack mit dem Kram.
Okay. Es gibt
Es gibt
keine String Interpolation.
Es gibt nur so den
Klassiker String Format.
Das finde ich schon irgendwie doof.
Also können wir zum Beispiel
Chat.
Und dann muss man hier wahrscheinlich noch
eingeben es.
Für was es ist. Und dann
Punkt.
Codebase.
Okay. Jetzt bin ich
irritiert. Warum kann ich da nicht einfach
Lul reinschreiben? Ist das Run?
Oh. Error.
Oh. Kaputt.
It's wrong.
Okay. So einfach ist das anscheinend nicht.
Irgendwas zu printen.
Warum muss da
ein Punkt davor sein?
Und warum muss das in
geschweifte
Klammer.
Das ist ein Struct.
Ah. Ich weiß ja nicht.
Documentation. Gucken wir mal rein.
String.
Also. Was haben wir
da? Print.
C? D?
Und was ist S?
S gibt es gar nicht.
Alter. Das ist.
Also allein schon Textausgabe
ist extremly six head.
Jetzt seht ihr ernst?
Type of bytes.
Ach. Kann man
auch tatsächlich alles ohne machen?
Geht das auch?
Ne.
Darf ich jetzt einfach so?
Ne.
Okay. Funktioniert nicht.
Warum nicht?
Machen sie doch hier auch.
Was hat er denn für Schmerzen jetzt?
Cannot format array
ref without the specified.
Da muss ich jetzt.
Aber man kann auch Sternchen hin machen.
Was ist denn Sternchen jetzt?
Ist so eine Art Debugausgabe oder sowas.
Es ist ein Stringarray
mit vier Charakter oder sowas.
Ja.
Okay. Naja gut.
Okay. Da muss man sich dran
gewöhnen, dass das erstmal ein bisschen
auf jeden Fall
gewöhnungsbedürftig das ganze.
So. Was haben wir denn sonst
noch hier schönes?
Standout
is for the actual output.
Was?
Ich will nicht gzip implementieren.
Standout
get standout
Wie? Ich kann nicht
einfach was printen auf der Commandline
ohne das von Hand zu flaschen oder wie?
Oder?
Oder?
Wir probieren das jetzt einfach aus.
Geht doch.
Ach, standout print.
Das ist, weil ich Debugprint mache.
Alles gut. Wunderbar.
Das kann ich mir merken.
Alles weg hier. Brauchen wir nicht.
Für was gibt es try?
Beziehungsweise was passiert,
wenn es hier einen Fehler schmeißt?
So.
Beste Ausgabe.
Jetzt wissen wir Bescheid.
Nehmen wir uns mal dem
ersten Problem.
Wie macht man CLI-Argumente parsing
in SICK?
Das einfachste dürfte wahrscheinlich sein.
Kann man hier sowas wie args
machen?
Okay, das muss ich mal lesen.
SICK
CLI-Parsing
Da gibt es extra
Libraries. Ist in der Standardlibrary keiner dabei?
API
Guides
Opt
Opt
Options
Schaut gut an.
Ne, das ist irgendwas anderes.
Log Level
Moment, da ist
Log
Da ist eine
Da braucht man gar kein Debugprint.
Log
Info
Noch besser.
Log Info wollen wir haben.
Nicht Standard Debugprint.
Hier, da.
Logging
Ja, guck mal hier. Gleich viel nicer.
Warning loggen.
Okay.
Ich dachte, da kommt jetzt eine andere
Farbe oder so.
Okay, wir
loggen Info. Wunderbar.
Excellent, excellent.
Also anscheinend ist kein
Commandline-Parser standardmäßig mit dabei.
SICK
Argument
Parsing
So, wir haben zur Auswahl SICK
CLAP oder SICK ARCS.
Was ist besser?
128 Sterne versus
467 Sterne. Okay.
Gucken wir das.
What the f...
Ich fühle mich erschlagen.
Okay, lass mal das andere angucken.
Ja, okay.
Das verstehe ich besser.
Jetzt leuchtet
mir besser.
Wahrscheinlich ist es
KW.
Ich sehe,
es ist zumindest in der Standard Library nichts eingebaut.
Das heißt, wir müssen jetzt
diesen Kram installieren.
Wie installiert
man mit dem Package Manager
Sachen? Das stand doch irgendwo
hier im Getting Started, oder?
It's planned to have a SICK Package Manager.
Gibt es keinen?
Wie jetzt?
Kein Package Manager?
Oh, das ist ja doof.
Hat nicht irgendjemand noch eben im Chat geschrieben,
dass würde angeblich Old Reddit
würde das angeblich umgehen?
Do it the Builder. Old School Forum.
Nice.
Is POG?
What's the proper way to install?
Ja. Cached.
I was trying to use SICK.
Nicht nur er, ich auch.
On my project, but I don't see any
install instructions on README,
how can I use it?
Seems like they are using GYRO.
Unofficial Package.
Boah, nee, das gefällt mir nicht.
Warum ist sowas nicht offiziell?
Ich dachte, wir sind...
Wir haben aus C++ gelernt,
dass neue Programmiersprachen ohne Package Manager
sucken. Not yet.
Currently.
Ja, aber Moment.
Mal angenommen, ich habe keinen Package Manager.
Wie benutze ich den Kram denn dann?
Das Git-Repo-Klon
in mein Source-Verzeichnis?
Oder wie?
Ich mein... Ja, aber das ist doch abfuck.
Das ist doch eklig.
Das läuft ja raus
wie in C++, dass ich irgendwie
so einen Include-Ordner brauche oder sowas.
SICK ist noch in der frühen Phase.
Also Rust hat davor eine allererste Version
ab mit einem Package Manager.
Was haben wir denn hier sonst noch zu bieten?
GYRO.
SICK Package Manager with an Index
Builder
and Builder.
Kann man das aufmachen?
Nice. Ein Package Manager ohne Suche.
Pogu.
Und es gibt zwei
Dinger mit dem gleichen Namen.
Was?
SICK Mod.
A Package Manager
for SICK Lang.
Okay, nice.
Ja, dann probieren wir das doch mal aus.
Wie funktioniert das?
Download.
Gibt es das vielleicht?
Ah.
Guck mal da.
Aber das fragt mich schon ab, dass es keinen offiziellen
Package Manager gibt.
Das ist schon ein bisschen fail.
Aber machen wir es mal ohne
Package Manager. Wie würde ich das
Ding jetzt benutzen,
wenn ich eine Library brauche?
SICK Use Library.
Also ich mein,
wenn es C++ wäre,
was es glücklicherweise nicht ist,
bräuchte man irgendwie so einen Include Ordner.
Und in dem Include Ordner würde ich
die Sache dann klonen.
Was?
Nein. What the?
Alter.
In den Lib Folder klonen.
Wir machen das jetzt mal, was die
5Head SICK Leute im Chat sagen.
Lib.
Okay, nice.
Und jetzt SICK Build anpassen.
Ähm. Wow.
Obviously.
Be at executable.
Install artifact.
Run set. Depends on.
Ich hab nicht die leiste
Ahnung.
What's the proper way to install?
Use. Here. Not yet.
Currently I'd also recommend using
clone libraries. Okay, Lib
and add them to like
exe add package.
Okay, glücklicherweise ist es das gleiche
Package, was ich auch haben will.
Okay, exe
add. Also, ne.
Hier unten drunter.
Bin ich mal gespannt, ob das funktioniert.
Run.
Es ist no field or member
add package.
Add
package.
Add library path.
Okay, das ist ja schon mal geil, Alter.
Rust libraries.
Gar nicht.
Was? Standard
Build. Äh.
Okay, also, ich mein,
so schwer kann es doch nicht sein, eine fucking library
zu inkluden. Okay, Build
SICK Clap. Da muss es
doch irgendein
irgendein Exempel für geben.
What the fuck,
Alter.
Add module. Aha.
Name?
Ne.
Da bin ich scheitert schon an den einfachsten
Sachen, Alter. Wie bildet
man eine Library ein?
So in etwa. Keine Ahnung.
Ich weiß nicht, ob man das so
in etwa macht.
Okay, da muss es doch eine ordentliche Erklärung
für geben.
How to use library.
How can I use
Rust libraries? Ich will keine Rust libraries.
Ich will SICK libraries verwenden.
Ja, ich hab die allerneueste Version.
Breaking Build Changes.
Oh, jawoll. Geht gut los.
Die haben vor kurzem das
Build System geändert. Gut, dass
wir das jetzt merken gleich.
Boah, Leute.
Ich weiß ja nicht, Alter.
SICK Learn. Okay, auf geht's.
Modules. SICK
Build System.
Which are other source files written in it?
Okay, let's make use of
a module.
Okay, das haben wir. Lips.
Lips, ja, alles klar.
Okay, so.
Your
newly made build
at the following lines.
Es soll ja nicht Table Helper
sein. Es ist kein Clap.
Moment, wir hatten doch hier den Kram eben.
Wir hatten doch hier irgendwie so
Lip. Okay.
Es heißt auch nicht
Table Helper, sondern
Clap. Moment.
Warum mach ich das jetzt doppelt?
Was ist vor allem B?
B ist
das Bild.
Und das soll jetzt funktionieren?
Oh.
Oh. Ne.
Äh.
Der Path stimmt nicht?
Ach, es ist SICK Clap.
Aha.
Oh, es hat funktioniert.
Der Build Champ war erfolgreich.
Okay, jetzt machen wir wahrscheinlich so was wie
Const Clap gleich
at import
Path.
Kann man einfach so jetzt machen?
Checkt er das dann?
Okay, okay, nice.
Nice, nice, nice.
Und jetzt so was wie Clap?
Aha, guck mal da.
Schon haben wir
die Library am Start. Aber das ist nicht schön.
Ganz ehrlich, das ist wirklich
nicht schön. Also ich dachte
eigentlich aus Zeiten, wo wir Source-Dateien
klonen und von Hand
managen und so, die sind vorbei.
Also ohne Package Manager
weiß ich nicht.
So, also wie benutzt man das denn jetzt?
Die eigentliche Frage.
1.0 kommt noch?
Ja, aber da kommt bestimmt auch kein Package Manager
wenn sie es bis jetzt noch nicht hingekriegt haben.
So was muss von Anfang
an dabei sein oder es wird nie richtig.
Ich lass mich gerne eines besseren
belehren. Okay, das
haben wir gemacht.
Const Params.
Wie machen die das hier? Ne, hier gibt es nichts.
Clap, Pass, Params,
Compile Time.
Minus, Minus, Help, reicht mir.
Und keine Ahnung.
Minus, Number brauchen
wir auch nicht. Minus,
Minus, was machen
wir denn? Keine Ahnung.
E
und das ist dann irgendwie Spezial
Info. Achso, wie macht man
einen Bool? Das müssen wir uns
gleich angucken, wie das funktioniert.
Okay.
So. Was? Underscore?
Underscore gleich
Params? Was zum Teufel ist
Underscore?
Ist das irgendwie Diskard Parameter
oder?
Warum ist hier einfach random ein Underscore?
Hä? Wo
kommt denn das her?
Wo kommt das überhaupt her?
Hä? Was ist
denn jetzt?
Unused Local. Oh nein.
Das schlimmste Feature
aus Go erstmal mit übernommen.
So, mal gucken, ob der Kram noch kompiliert.
Also, okay, okay.
Gibt es jetzt sowas wie Minus, Minus, Help
schon? Nee, noch nicht.
So.
Initialize our
Diagnostics, which can be used to report useful
errors. This is optional.
Okay.
Ich weiß zwar nicht
warum, aber
alles klar.
Okay, Diagnostics
Zeug.
What the fuck?
Okay, was
passiert hier?
Was bin ich da sehend gerade?
Clap Paths.
Params, also
das da.
Default Paths as Opt.
Das kann man doch
bestimmt weglassen, oder?
Kann ich diese ganzen
Catch...
Wir brauchen keine
Errors.
Wer will schon Errors catchen?
Keck.
Wait.
RestDinit.
Funktioniert so glaube ich nicht, oder?
Kurz auskommentieren und gucken, ob das noch
funktioniert.
Nee.
Du musst ein Trainer vorsetzen.
Aha.
Aber so funktioniert das auch nicht.
Wir machen das mal rückgängig.
Ja.
Ich will keine Errors reporten.
Gehen wir mal nicht auf den Keks
hier weg damit.
Okay, funktioniert.
So, und was
genau habe ich da jetzt gemacht?
Also Diagnostics Zeug kommt schon mal
weg, den braucht eh keiner.
Massive Error Handling, ja.
Wenn schon, dann klar richtig.
Okay, aber
wo wurde es denn jetzt gepasst?
Achso, hier.
Also Log.
Nee, Info.
Jetzt
will ich
SRES
ARCS
Punkt.
Gibt kein Autocomplete für.
Moment, sind das
irgendwelche Dynamics Sachen jetzt?
Info.
Okay, Info ist nicht gesetzt.
Info,
Keckl. Okay, funktioniert.
Also das ist
der Parameter. Nice.
Jetzt wissen wir Bescheid.
Also, dass es hier jetzt auch noch Dynamics
Sachen gibt, jetzt wird es richtig abgedreht.
Ich hab den
Eindruck, seit Rust so
beliebt ist, versuchen die alle
ihre Programmiersprachen
einfach nur noch extrem
5Head zu machen.
Sodass du eigentlich beim Angucken gar nicht mehr
verstehst, was überhaupt passiert.
Schon alle Zugänge beim neuen Job bekommen.
Ja, ich bin jetzt 3 Monate schon da.
So, also jetzt
haben wir gepasst, ob es Info...
So, Info ist ja im Prinzip
auch nur ein Bool.
Das heißt, das machen wir so.
Okay.
Warum ist das jetzt Brocken?
Achso, weil es ein Bool ist.
What the...
Fuck.
Okay.
Das ist ja fast C++ Error, Leute.
Schaut euch das mal an.
Stellt euch mal vor, ihr führt ein
Kommandozeilentool aus und es kommt erst mal das hier.
Dann würdet ihr euch auch denken.
Obviously, alles klar.
Jetzt weiß ich sofort, was ich falsch gemacht habe.
Ich hab hier einen String zu viel eingegeben.
Gibt es bei euch viele Meetings?
Ja.
Useless Meetings gibt es auch einige.
So, das heißt, wir können jetzt gucken.
Ich will kein else.
Ich will einfach nur ein probliches if haben.
if resArgsInfo
Tja, ungleich 0.
Dann ist es gesetzt.
Vermutlich.
Es ist gesetzt.
Und jetzt ist es nicht gesetzt.
Funktioniert.
Was denet macht, check ich nicht.
Weil aus irgendwelchen Gründen
gibt es kein Autocomplete dafür.
denet
Weiß man nicht, was es macht.
Scheint auch keine nähere Erklärung
zu bedarf
bedürfen.
Weil der eingefleischte SICK-User
sicherlich sofort weiß, was denet
bedeuten soll.
Also ich hab keine Ahnung, was diese Zeile
macht. Also defer kann ich mir noch
zusammenreiben.
Das ist quasi, wenn alles andere
durch ist, bevor die Funktion exitet,
automatisch noch gerannt,
noch ausgeführt wird.
Aber res.denet, es gibt ja
kein Autocomplete, keine Hilfe und sonst was.
Ich hab absolut keinen Plastenschimmer,
was das macht.
Ist das sowas wie free?
Ah ja, okay.
Dachte ich mir auch gerade.
Aber das sollte doch automatisch aufräumen,
weil es hier innerhalb von der Funktion
angelegt wird.
Zumindest mit der C-Denkweise.
Das erscheint mir
sehr anstrengend in SICK
zu programmieren.
So, jetzt haben wir schon mal unser erstes
Argument geparst.
Kann doch nicht sein, dass
das sind doch die abartigsten
Fehlermeldungen aller Zeiten.
Warum gibt das Ding nicht einfach jetzt eine Hilfe
aus? So nach dem Motto
Ey, guck mal, du hast da Mist
eingegeben. Guck mal hier.
Das checkt doch niemand.
Das liegt wahrscheinlich
an mir. Da gehe ich auch von aus.
Aber das macht es einem auch
schwer. Da muss man bestimmt
irgendwie... Vielleicht...
Vielleicht ist
die Errorhandling,
was ich rausgeschmissen habe, genau dafür
zuständig.
Moment, das müssen wir jetzt mal ausprobieren.
Ich hab doch das komplette
Errorhandling rausgeschmissen.
Was ist IO?
Standard
IO.
So, jetzt haben wir...
Ne.
Ne.
Macht keinen Unterschied. Die Fehlermeldungen sind immer noch so
eklig. Wobei, da steht doch was
da. Invalid Argument.
Ist doch eigentlich ganz gut. Stand das vorher auch
schon da? Invalid Argument?
Leute, was ist denn jetzt los?
Was ist denn jetzt?
Ich... Ich konnte
grad nicht mehr scrollen in meinem Terminal.
War broken.
Stand vorher auch schon da?
Gut, dann können wir uns das auch sparen.
Bestes Errorhandling.
Kein Errorhandling.
Invalid Argument.
Okay, das steht... Vielleicht steht das nur drinnen,
weil das ein
Debug-Bild ist. Gibt es da sowas wie
Release oder sowas?
Ne.
Das muss doch eigentlich gar nicht angezeigt werden.
Invalid Argument. Ja, okay.
Das ist was damit...
Damit komme ich irgendwie
noch halbwegs hin.
Okay. Was macht das?
Wenn jetzt minus minus
halb drin ist, dann gibt das einfach nur
halb aus, oder? Kann ich mir schenken, ja.
So, also, zumindest
wisst ihr schon mal, wie man so
Command-Line-Parsing-Light macht
damit. Zickt der Compiler
rum. Ne. Beim Ausführen,
wenn ich Sachen
eingebe, die nicht erlaubt sind im Command-Line-
Parameter, kackt er ab.
Aber vorher sagt er wenigstens Invalid
Argument. Okay, nice.
Wenn es aber auch super verwirrend ist.
Ich mein, wenn du ein Invalid Argument hast,
gib halt gefälligst die Hilfe aus und nicht
sowas. Ja, gut.
Ist aber auch wurscht. Ich glaube,
zum Testen ist das erstmal okay.
Jetzt kommt der viel interessantere Teil.
Wie kann ich auf FF...
Wie kann ich auf die FFmpeg-Library
zugreifen?
Äh, Zig, wir suchen mal nach
explizitem Beispiel FFmpeg.
Was? FFmpeg-Build-System
replaced by Zig. What?
Äh.
What?
Ach, es ist FFmpeg als
Zig-Package oder sowas in der Richtung.
But why?
Okay.
Zig, use
C-Library.
How do I link
and use a C-Library?
Jetzt wird's
advanced. Jetzt wird's
advanced langsam.
C-Import.
What the fuck?
Was machen die da überhaupt?
Import from C-Header-File.
C-Import.
Way too dank.
So, also.
FFmpeg
C-Example.
Excellent. So.
Libav-Codec.
Ich brauch...
Ich brauch eigentlich
nur...
Wir gucken uns jetzt mal ein simples
FFmpeg-Example an.
Hier.
Die Code. Nein, nein, nein.
Info. Das ist relativ
easy in FFmpeg zu machen.
Ah, hier ist auch okay.
So, also was? Include.
Libav-Format.
Schauen wir mal, ob das nicht schon gleich
die ganze Sache
kaputt macht.
Ach so, nee.
Wahrscheinlich ist das Format
so zum
zum Includen. Schauen wir mal.
Run. Nein.
Das wäre jetzt auch zu einfach gewesen.
Ah nee, Moment.
Okay, das hat funktioniert.
Include.
Hat das jetzt getan? Okay, ich mach jetzt mal was.
Ey, das interessiert den nicht.
C-Punkt.
Ich seh schon,
das wird schlimm.
Ich dachte, das hat ganz guten
Interop mit.
Hier. C-Punkt.
Ah ja, okay.
Und da mach ich jetzt C-Punkt.
Ach, guck mal. Boah.
Nice.
Der hat den ganzen C-Heterogramm
schon gepasst. Guck mal.
Massive
5-Hit.
Guckt euch das mal an.
High IQ.
Würde ich sagen.
Ich muss mal kurz zu mir auf GitHub.
Irgendwo
hab ich doch ein Exampel in meinen
Repos, wo wir
FFmpeg gemacht haben.
Ich glaub das da.
Genau, mit dem allerbesten Logo überhaupt.
Das war's
im Ding, hab ich aber nie gepusht.
FFmpeg.
Ja, FFmpeg
AV-Guess-Format und
sowas. Ja, genau.
So, in welcher Datei
ist das drinne?
Das ist in AV-Format, würde ich
sagen drinne. Haben wir doch.
Das heißt, ich kann jetzt sowas
machen wie
Okay,
dann nennen wir das doch mal FFmpeg.
AV-Format.
AV-Format.
AV-Guess-Format.
AV-Guess-Format.
AV-Guess-Format.
AV-Guess-Format.
Okay, so.
Und da können wir jetzt eine
Shortname, Filename. Okay, 0.
Okay, jetzt gibt's in Zick auch
Filename.
keckel.mp4
MIME-Type 0.
So, die Datei gibt's nicht. Das sollte
jetzt ein Fehler geben. Mal gucken, ob das
überhaupt kompiliert. Ne.
C-Import failed.
Lib
C-Header is not available.
Okay, da hab ich irgendwas verkehrt
gemacht. Minus
LC?
Bild? Ne.
What?
Build has no
member named
main. Ne, ich will da gar
kein... Ich will mein Projekt bauen.
Das ist eigentlich alles, was ich
will. Link.
Okay, ähm, nice.
Hier.
Ne.
Was hat der eben für einen Fehler geschmissen?
Lib C-Header is not available.
Wir copy-pasten das
jetzt einfach mal.
Need help. Jawoll.
Ich neede auch
help. You have to add
the configuration to main tab.
Ach hier. Link, Lib, C
muss man machen. Alter,
das ist ja... Boah,
ist das eklig. Ich dachte, das hat
guten Hinterhaupt mit C.
Können wir einfach in das Bild gehen?
Sagen, Echse.
Add. Wie heißt das Ding?
Link.
Link. Link,
Lib, C.
Easy.
Ups.
Oh shit.
Was? Error.
Der Return-Wert ist
ignoriert. Stört ihn das?
Also muss ich sowas
hier machen? Ne.
Undefined Symbol?
Wie? Sogar mein Autocomplete
hat jetzt erkannt, dass es das gibt.
Jetzt habe ich keine Ahnung
mehr, was das Problem ist.
Wir fragen Google.
Du musst noch die andere Lib linken.
Link, System, Library,
C. Meinst du?
Oh. Oh.
Nein.
Undefined.
Muss ich jetzt
FFmpeg noch?
Aber das include ich doch
explizit hier.
Ne.
Install.
Was macht das?
Ich würde jetzt erwarten, dass der in den Standard-Include-Verzeichnissen
einfach nachguckt.
Das macht er hier auch nicht.
Doch, das macht er.
Add-Source-File. Ne, das
will ich nicht. Alter, das ist
ja extrem. Extremly six
header time.
Ich sehe schon, das wird nichts.
Link, Library. Meinst du
wirklich? Ich meine, da gibt es
natürlich auch kein gescheites
Beispiel für.
C-Import.
C-Include.
Linking-Lib-C. Linking-Lib
can be done with a command.
Ja, habe ich gemacht.
Ne, das ist die Standard-C-Library.
Die alleine reicht
ja nicht. Wir suchen
da jetzt einfach mal explizit nach FFmpeg.
Das haben bestimmt schon ein paar andere gemacht.
C-Library.
How do I link and use C-Library?
Ja, zeig her.
Reddit. Aha.
Link-System-Library.
AV-Format.
H? Oder
wie? Ne, einfach nur AV-Format
vielleicht?
Hä? Hä? Hä?
Pause-Jam? Pause-Jam? Oh!
Aber es ist gleich gecrashed,
oder? Ne, es geht.
Es geht. Okay, nice.
Boah, das war aber echt durch die Brust
ins Auge.
Was gibt es denn hier für einen Return-Wert
von? Ein Return-Wert von?
Was ist das hier?
War? Ne.
Was ist denn das jetzt?
Woher sehe ich denn jetzt, was das für
ein Typ ist?
Lass mal überlegen, was gibt denn
FFmpeg überhaupt zurück?
Oder was gibt das denn überhaupt
zurück als Return-Wert? Das Format, oder?
Ah, hier.
AV-Output-Format.
Oh, ne! Shit!
Das sind ja 30 Milliarden
Struck-Dinger, die man hier
zurückbekommt. Das, oh ne,
das kann ich nicht nachbauen.
Aber das kann er doch.
Kann er das nicht einfach hier raus?
Direkt? Kann ich das jetzt
printen? Standard.
Standard. Print. Ne.
Debug.
Print.
Wie geht das? Log.
Ne, S. S
muss man machen. Was?
Okay, da ist auf jeden Fall irgendwas.
Return and Pointer.
Ja, die große Preisfrage ist,
wie die
referenziere ich denn jetzt den
Pointer?
Okay.
Zick. Pointer.
Kann ich jetzt sowas sagen
wie Name zum Beispiel?
Einfach, also probieren wir mal.
Log. Oh man, das hat er
doch gecheckt! Hä?
Ich glaub, das braucht einfach nur ne ganze
Weile.
Der muss das irgendwie im Hintergrund erst
modellieren oder so. Was auch immer.
Ach, shit.
Was ist denn jetzt schon wieder das Problem?
Mensch. Language
ist aber fast abgeschafft.
Was hat er denn jetzt für Probleme?
Does not support field access.
Heißt was?
Ich muss das in ne extra Variable packen?
Oder wie?
0w? Gleich.
Das ist nervig hier.
Does not support field access.
Was sagt mir das?
Muss man da sowas machen?
Weil das ist ja ein
Pointer eigentlich.
Also muss ich vielleicht...
Nee. Kann man das
dereferenzen oder so?
Ich seh schon.
Das soll... Ja, okay.
Zeig mal her.
Translate this incorrectly.
Was muss ich machen?
Punkt Sternchen.
Punkt was?
Punkt Sternchen.
Punkt Sternchen.
Punkt...
What the fuck ist das für ne
Sonntagsalter?
Das funktioniert. Guck mal. Das ist ein MP4.
Geil.
Punkt Sternchen Punkt Name.
Alter. Wer hat sich
das denn ausgedacht?
Aber wir wissen schon mal,
dass es ein MP4 ist.
Ich mein, die Datei existiert nicht wirklich.
Aber...
I guess
das Format right.
I guess.
Richtig high IQ.
Guck mal.
C++.
Alter.
Okay. Wir brauchen
ein Testvideo.
Sonst funktioniert das nicht.
Ähm.
Which?
Wir brauchen irgendein...
Nehmen einfach irgendein 30 Sekunden
Clip von gestern oder so. Wollen wir das damit ausprobieren.
Videos.
Clips.
Von 24 Stunden.
Ja gut. Da war ich nicht on.
Ähm.
C-Sharp.
Ja. Perfekt. Den Clip brauchen wir jetzt.
Genau. Den brauchen wir jetzt.
YouTube. DLP.
Minus F.
Ja.
Was bedeutet das hier?
Minus F.
1080.
Ja.
FFProbe.
Wie heißt denn die Datei, die ich da gerade runtergeladen habe?
Ja. Ist klar.
Äh.
Vid.mp4 heißt das Ding jetzt einfach.
FFPlay.
FFProbe. Vid.
Vid.mp4.
Okay. Das...
Okay. Die Sachen bekommen wir da drüber raus.
Ja. Video H264 und so. Alles klar.
Was hier gebaut wird.
Also. Wir versuchen sowas wie
FFProbe mit SICK zu bauen.
Nicht weil es sinnvoll ist, sondern einfach um zu gucken, wie man das
machen würde. Und ich habe festgestellt,
dass Interop mit C-Libraries
aus SICK schon alles andere
als SICK ist.
Run.
Okay. Er sagt, er sagt, es ist eine
MP4. Jetzt muss ich den
Kram natürlich einlesen, dass es wirklich
funktioniert. Und da muss ich
selbst mal wieder abgucken bei mir.
Wie man das, wie man das macht.
Guest Format. Allog. Output.
Kontext.
Ne. Zu kompliziert.
Das ist, wenn ich was in das... Moment. Das ist was, wenn ich
in die Datei was reinschreiben will. Das will
ich doch überhaupt nicht. Kamerastream.
Es ist eigentlich total
simpel mit FFmpeg, aber
ich habe es schon eine Weile
nicht mehr gemacht.
Hier. AV Packet.
Hier. Genau. Da ist das Zeug.
Das ist so kompliziert, was
ich hier gebaut habe.
AV Packet. Allog.
Close. Input. Open. Das brauchen wir.
Wir brauchen AV Format. Open.
Hier. AV Format.
Find. Stream Info.
Irgendwie sowas. Genau.
AV Format. Open. Input.
Da kommen wir doch zur Sache.
Genau. So hat das...
So funktioniert der Kram. Das funktioniert mit Dateien genauso.
Hier.
Genau.
Okay. Das brauchen wir jetzt. FFmpeg Format.
Also. Das...
Das wird jetzt was.
Okay. War.
Gleich. AV Format.
Wie ist das?
AV Format.
Allog. Context.
So. Da kommt irgendein komisches...
Irgendein komischer Pointerkrempel
zurück.
Per CLI Arc File Name holen.
Ja. Das können wir dann machen.
Wie man Argumente passt, habe ich ja schon rausgekriegt.
So.
Ach guck mal. Der schlägt einem diese hässliche
Syntax sogar vor hier.
So. Jetzt geht es
weiter mit...
AV Format. Open.
Input.
Das copy paste ich mir jetzt einfach mal.
Weil ich kann mir das eh nicht merken.
Also. AV Format.
AV Format. Open.
Input.
So.
Da müssen wir jetzt
einen Pointer
auf den Kontext übergeben.
So.
Die URL ist relativ einfach.
Vid.mp4
Äh.
Das ist 0.
Und das Dictionary ist auch 0.
So.
Das wird jetzt so wahrscheinlich nicht funktionieren.
Weil...
CTX. Genau.
Also ist die Frage, wie man einen Pointer da drauf übergibt.
Auch mit einem und davor.
Value of type C.
Okay. Wir haben den Return Type
ignored.
Result.
Log.
Result.
Minus 2.
Ist es jetzt gut oder schlecht?
Ach so.
Es wird...
Deswegen ist es minus 2.
Ach guck mal. Jetzt ist es auch 0.
Es funktioniert.
Wait a minute.
Das funktioniert so überhaupt nicht.
Was ich da mache.
So. So. Das ist schon besser.
So.
Das können wir hier oben machen.
Das muss ich bisschen halbwegs
gescheit formatieren. Sonst blicke ich gleich nochmal durch.
So. Also.
Hier ist jetzt unser geöffnetes Video drin.
Den ganzen anderen Krempel
ignorieren wir mal.
Und jetzt will ich FFmpeg
stream info.
Find
stream info.
Da muss ich jetzt mal in die
Docs gucken von FFmpeg.
Was da zurückkommt.
Read packets of media file
to get stream info.
Okay.
Ja. Let's go.
Muss wie
aufgerufen werden?
Warum kann man hier eigentlich nicht Tab drücken?
Options brauchen wir nicht.
0.
Kann man einfach so machen, dass er nicht nervt?
Ja. Okay.
Das funktioniert auch.
Jetzt haben wir erstmal ein paar Sachen
eingelesen. So. Und jetzt kann ich raus.
Genau. Jetzt kann ich gucken wie viele
Streams sind dann
überhaupt. Wir vergleichen das jetzt
mal. Guckt mal. Also.
Wir geben jetzt mal aus. Davor und
danach wo wir das gemacht haben.
Also. Das hier sind
Streams.
Anzahl von Streams.
Das sollte nämlich hier drinnen stehen.
CTX N
N Streams.
Was will er jetzt wieder?
Does not support field access. Ah.
Jetzt muss ich wieder Punkt Sternchen Punkt machen.
Okay.
Der hat auch schon erkannt, dass es 2 Streams sind.
Ohne dass ich den Kram eingelesen habe.
Das hat er direkt gecheckt.
Weil es sind 2 Streams. Guck.
FFprobe. Es ist ein
Video Stream und es ist ein Audio Stream.
Also. Das heißt eigentlich kann ich mir das schenken.
Aber wir machen das trotzdem mal.
So. 2 Streams hat er.
Format ist MP4.
Result. Brauche ich das irgendwie?
Ne. Brauche ich nicht.
Das ist ein abartiges Feature hier.
Das muss immer irgendwie zugewiesen sein.
Da haben sie das nervigste von Go
mit übernommen. So.
Und jetzt will ich natürlich noch wissen was das für ein Format
ist. Und das gibt es
Codec Parameter. Codec Type.
Für den jeweiligen Stream.
Das heißt wir brauchen jetzt
eine Schleife über alle
Streams drüber.
Ja gut. Das ist ja irgendwie
logisch.
Eine Schleife über alle Streams.
For?
Ne.
Doch.
What?
I?
Ne.
Zig For. Ups.
Zig For Loop.
Ich bin überfordert eine Schleife zu machen.
For Loop.
For Items.
Ne.
Ich möchte
so eine Zähl
For Loop haben.
Ah ja.
So was will ich haben.
Nicht so was hier.
So was will ich haben.
Okay.
Von 0 bis
CTX
Streams.
Oh es ist eklig.
NB Streams.
Geile
Geile Syntax Alter.
Aber immerhin.
Soweit verständlich, dass ich nicht
Instant irgendwelche Fehler produziere.
Ey das schaut aus oder?
0 Punkt Punkt CTX Punkt
Sternchen Punkt NB Streams.
Alright.
Alles klar. So jetzt haben wir den Kram.
Stream gleich.
So und jetzt Streams.
Jeweils
vom aktuellen Index.
Geht das immer noch?
Nein. Fuck. Warum?
Das Soziopath Field Access.
So jetzt aber.
Nice. So und jetzt haben wir
unseren Stream.
Unseren FFmpeg Stream.
Oh ne. Da ist es.
Jetzt haben wir unseren Stream.
Und da kann ich mir jetzt den
Codec Parameter und den Codec Type
rausholen. Let's go.
Stream.
Language Server klüht.
Es ist unknown. Muss ich vielleicht noch
irgendwas
AV Stream?
Wo kommt das her?
Muss ich da vielleicht noch irgendwas inkluden?
AV Format?
Es ist alles in AV Format.
Das ist schon mal gut.
Stream.
Kann es sein, dass mein Language Server
einfach jetzt komplett broken ist und er keinen Bock hat?
Versuche mal den
Typ zu annotieren.
Hier hin? Oder wo?
So?
Oder anstelle von war?
Ja? Okay.
Ne.
C?
AV Stream?
Ne.
Was hat er jetzt für Schmerzen?
Struct AV Stream.
Er hat es doch erkannt.
Er hat es doch erkannt.
Oder nicht?
Ne, er hat es doch erkannt, was es ist.
Boah, ich habe keine Ahnung,
was ich hier treibe, Alter.
Ne, so funktioniert es schon mal nicht.
Wir können mal ausprobieren,
was passiert, wenn wir einfach so tun, als wüssten
wir, was es macht. Aber warum denn nicht?
Ich meine, er erkennt doch, was es ist. Guck.
Er sagt ja auch explizit go to.
Meint er,
der Language Server ist gecrashed?
Ne, der ist nicht gecrashed.
Guck hier, hier geht das ja.
Ne, der ist nicht gecrashed.
Aber wir können trotzdem
mal neu starten. Man weiß ja nie.
Ne.
Was jetzt?
Also das kann das Ding schon mal
nicht richtig. Wir tun einfach
mal so, als wissen wir, was wir machen.
Wir wissen es ja prinzipiell
auch. Wir wollen sagen
Stream
Index einfach mal. Okay?
Log Stream
Index. Da sollte jetzt ein Int rauskommen.
Das sollte er checken. Guck, funktioniert.
Überhaupt kein Problem.
Aber aus irgendwelchen Gründen
ist das nicht...
Ja, aber das ist ziemlich ein Sack, wenn das
das Ding nicht checkt.
Ich meine, er weiß, dass da ein
AV
Stream zurückkommt.
Aber er checkt
es irgendwie nicht.
Type annotation
Tja, aber die Frage
ist halt auch, wie gebe ich das richtig an?
Bei einem Int ist es ja
offensichtlich nicht.
Wie
gebe ich denn das jetzt überhaupt richtig
an?
Wie gibt man sowas richtig an?
Ich hab keine Ahnung. Das ist so
eine Art Inam oder sowas in der Richtung.
Hier!
Struct AV Stream
Jetzt hat er es kapiert.
Aber jetzt ist broken.
Vorher ging es...
Moment, Moment. Ich hab jetzt die Auswahl
zwischen mein Autocomplete geht
oder nicht.
Expected type
found
What?
Was willst du von mir?
Was will der mir sagen?
Vielleicht das da.
Ah, muss ja sowas draus machen.
Ah.
Pointerstelz. Okay.
Ist natürlich ein bisschen blöd,
dass er das nicht selbst checkt mit dem Typ.
Aber man kriegt es
ihm ja beigebracht.
Okay, im Stream haben wir jetzt so Sachen wie
Codec Parameter
Da checkt er es jetzt
wieder, komischerweise.
Okay. Oh gut.
Stream
Soll was sein? Punkt? Ne.
Punkt, Sternchen, Punkt, Codec
Parameter. Das wird wahrscheinlich nicht funktionieren.
Punkt, Stern, Punkt
Codec
Codec
ID
Oh, das ist irgendeine...
Ja.
Das ist es.
Punkt, Sternchen, Punkt, wie kommt man...
Frag die SIG-Entwickler. Ich hab auch keinen Plan.
Wie man auf die...
Guckt euch das mal an, wie das ausschaut, Alter.
Das ist doch nicht normal.
Okay, das ist die Codec ID.
Das heißt, mit der ID kann ich
mir jetzt ausgeben lassen
Ja. Da kann ich mir ausgeben lassen,
was das ist. So, normalerweise
in C wäre das jetzt relativ easy.
Da könnte ich das...
Warum SIG?
Gibt es einen spezifischen Grund, dass du das nutzt?
Nö. Einfach nur angucken.
Das hat keinen tieferen Sinn.
Ich plane auch nicht, das in Zukunft für
größere Sachen zu benutzen. Einfach
gucken, sonst nix.
Also die Codec ID kriege ich
schon mal raus.
So, und jetzt würde ich gerne
den Namen mir
ausgeben lassen.
Jetzt stehe ich grad...
Also in C-Sharp
weiß ich, wie ich's machen würde.
Da kann man sich nämlich einfach,
wenn man...
Da kann man einfach das Int
zu nem
Inamt casten und man kann
den Namen sich
anzeigen lassen. Die Frage ist, also
was ich jetzt haben will, ist folgendes.
Das ist ja eigentlich
Codec ID. Ach Moment, das ist schon ein Inamt?
Der checkt das schon? Wait a minute.
Kapiert er das schon?
Wartet mal.
Ah nee, das ist ein Int. Okay.
Weil eigentlich ist das, was
da zurückkommt...
So, Codec ID.
So, und das kann man
normalerweise jetzt casten
zu einem...
Wir gucken mal in die FFmpeg-Docs.
AV Codec
Parameters. Codec ID.
Codec ID. So. Und da steht der
ganze Mist drin, was es ist.
Also, ich will es casten
zu einer AV...
Kann ich nicht einfach hier
sowas machen?
AV Format
Inamt.
Moment, das ist... Nee, das funktioniert nicht.
Das hat er nicht richtig
importiert, oder?
Oder wie
funktioniert das jetzt?
Oh shit. Oh nee.
Wie kriege ich jetzt den passenden Namen
dazu raus? Der hat das
nicht... Das ist eigentlich ein
Inamt. Wobei,
ist es das?
Ja. Wie kriege ich...
Oder wie würde ich denn das in C
machen? Wie kriege ich den Namen
von einem Inamt
raus? Okay.
FFmpeg... Vielleicht,
vielleicht brauche ich den Namen gar nicht.
Vielleicht gibt es ja auch noch
irgendwas anderes.
Codec
Type.
Da gibt es bestimmt so wie Codec Name
oder sowas. Gibt es doch bestimmt
schon eingebaut.
AV Format
Codec
Name.
Hier. AV Codec
Get Name.
Easy. Jawoll.
Dachte ich mir
doch, dass es da schon was gibt.
Log. Also das
Login-Ergebnis, das nervt mich.
Äh.
What? Undefined Symbol.
AV Codec.
Hä? Wer ist es doch?
Moment, Moment.
Was sind die Parameter?
Was?
Ah, da kommt ein Character Array zurück.
Was hat er jetzt für Schmerzen?
Undefined Symbol.
Wahrscheinlich muss ich... Moment. Ich muss bestimmt
noch andere Sachen importieren.
Examples.
Was
inkluden die da alles?
Include?
Hä?
Wo ist denn der FFmpeg
Source Code? Utils oder so?
Muss ich da vielleicht
was anderes inkluden?
Nee, oder?
Lib AV Codec?
Muss ich das noch
inkluden?
Bam!
Easy.
So, guck mal. Wir wissen es jetzt schon.
Das ist H264 und AAC.
Genau das, was wir haben wollen.
Zwei Streams.
Pogu vor allem, ja.
Zwei Streams, ein Videostream.
Ja, cool.
Das ist nice. Okay.
So, und dann können wir jetzt noch den Typ checken.
Wie findest du Sigg bis jetzt?
Ehrlich gesagt finde ich die Syntax
umständlich.
Und
es ist Gewöhnungssache, aber
es hat mich jetzt nicht
direkt gecharmt, irgendwie.
Toller Satz.
Also, weiß nicht.
Bisschen umständlich
ist es schon.
Wir brauchen noch ein If.
If.
Stream?
Nee.
Codec.
Ich will Codec Type haben.
Codec Type. Wie mach ich das denn hier?
Codec Type ist
hier AV Media Type Video.
Ich will wissen, ob es Video oder Audio ist,
wenn es viel komfortabler
als C und C++.
Ich mein,
C++ ist ja so die
Ausgeburt des Bösen.
Aber hat irgendwie, wenn man diesen ganzen
Templateshit und sowas links liegen lässt,
nee, das kann man so nicht sagen.
C++ hat
richtig Abfucks Syntax.
Spätestens wenn du mal Zeiten konvertieren musst
oder sowas. Und dann
Chrono, Doppelpunkt, Doppelpunkt, System,
Wall, Clock,
2 Milliseconds, Convert.
Das ist eklig.
So, was brauch ich jetzt?
AV Media
Codec
Nee.
AV Media Type
AV Media Type Video
AV Media Type Video
AV Media Type Video
Dann das.
Muss man hier wirklich diese hässliche
Golang-Formatierung machen?
So, das
und das
Format
So, Video
äh
Audio. Nicht, nicht wirklich.
Es kann auch Untertitel sein und sowas.
Okay.
Es ist Video, ist der Stream, Audio ist der Stream.
Frage.
Eher Fritzbox als MiniNAS verwenden
oder Raspberry Pi? Also das sind
beides ziemlich schlechte Nasses.
Die Fritzbox hat den Vorteil,
die ist lahm als fuck, aber die hast du halt.
Ein Raspberry Pi,
wenn du keinen hast, ist
eigentlich zu teuer, um sich einen gerade zu
kaufen. Für jeden
in einem Value ein String. Ja klar, ich
definier mal 140 Dinger.
Ähm, aber der Raspberry, also
der Raspberry Pi ist schneller als
die Fritzbox. Fritzbox nass ist lahm als fuck.
Aber der Raspberry Pi ist
aktuell auch kein gutes nass.
Ich mein, wenn du
einen Raspberry Pi 4 hast und den dafür opfern
willst und deine SSD
an den USB hängst und
dir irgendwie so
Gigabit, sag mal so, irgendwas
in Richtung Gigabit ausreicht, okay.
Aber ansonsten,
du kannst das, du kannst das machen,
aber schnell wird's nicht sein, das kann ich
dir gleich sagen. Es wird mein schneller
als bei der Fritzbox.
Welches Anfänger nass kann ich dir, weiß ich nicht, kann ich dir
keins empfehlen. Also du kriegst
beim Raspberry Pi 3 nass,
also wenn du das mit
einer SSD dran machst, kann ja auch eine
Billig-SSD sein, kriegst du so
was, was kriegt man da so
50, 60 MB oder so
was drüber.
Also Gigabit voll wird man wahrscheinlich nicht ganz
bekommen. Gerade wenn, also
schon mal auf gar keinen Fall, wenn du die Platte, wenn du
die SSD verschlüsselst, was ich
prinzipiell bei einem nass immer machen würde.
Da kannst du die nämlich einfach in Müll
schmeißen, wenn sie kaputt ist.
So, guck mal, wir haben doch unsere FFmpeg schon
ganz gut am Laufen.
Wir müssen jetzt noch den Dateinamen
hier einlesen können.
Also vid.mp4
Was crasht?
Weil?
Wie geht denn das?
Wie lese ich ganz normale
Argumente ein?
Achso, hier, so.
So.
Guck hier, schon funktioniert's.
Str wird eingelesen.
Und
Positionals
Args, String
Positionals, Pos
Ähm, okay.
Vid.mp4
Okay, nice.
Ja, dann würde ich sagen
Kann man das
irgendwie ordentlich klammern?
Ja, ne? So.
Dann machen wir das nämlich so.
Hier kriegen wir die Dateien.
Dann schnappen wir uns das hier einfach.
Wie macht man denn Functions?
Einfach wahrscheinlich fn
String
Äh, was weiß ich hier? Print
Info
Keine Ahnung. So.
Dann wollen wir einen Parameter haben, der eigentlich
nur der Videotitel ist. Also der
Dateiname. String
Nee. Äh.
File, String
Hm. Tja.
Sig Functions
Fn
Parameter
Gibt's denn?
Ach so, ach das
muss man machen.
Aber wie
schreibt man das hin? Doppelpunkt hier und dann
Nee.
Hier als erstes
wahrscheinlich.
Const
U8
Und dann, und dann
File
Oder umgedreht?
File
Okay. Ja. So rum.
Alles klar.
Dann hauen wir, dann eliminieren wir das mal hier rein.
Wie man so schön sagt heute.
File
So. Wit
Okay. Und jetzt
Ja. Pogu können wir uns
mal sparen.
Und jetzt rufen wir das auf mit
Print
Print Info
Pos
Hoffe ich mal.
Ja natürlich
wieder nett. Ja war schon klar.
Expected type
Sternchen. Okay.
Sternchen
Sternchen
Const
Ne.
Muss ich das jetzt als Pointer
übergeben, dass das funktioniert?
Ne. Oh fucking
Keine Ahnung.
Was ist das Problem?
Was?
Expected type
Const U8
Found
Was?
Was will er von
Gott alter. Ich dreh am Rad.
Was will er denn von mir?
Was willst du von mir?
Ich verstehe
die Fehlermeldung noch nicht mal.
Sind Pointer nicht immer?
Const
Const
Muss ich jetzt hier angeben.
Const
Was willst du denn?
Was ist denn das Problem?
Okay.
Also.
Das ist an der Stelle
ja okay.
Soweit.
Soweit so gut.
Das funktioniert doch ohne alles.
Nein das funktioniert auch schon nicht.
Warum?
Warum geht die einfachste Sache mit Position
nicht? Weil?
Weil?
Error is ignored.
Was ist
das Problem jetzt?
Kannst du mir mal
kann mir das Ding mal irgendwie sagen
was hier an das Problem ist?
Achso.
Ne.
Okay das Ausrufezeichen ist
anscheinend wahnsinnig entscheidend an der Stelle
gewesen jetzt.
Hahaha.
Alles klar.
Okay.
Ausrufezeichen
Volt ist
verboten. Volt ist okay.
Nun gut.
Soll mir recht sein.
Gehen wir mal langsam vor.
Gehen wir mal langsam vor.
Pfeil nehmen.
Okay. So.
Jetzt meckert er. Jetzt meckert er mich an.
Er sagt, dass er
gerne
einen Pointer haben möchte
und er bekommt
keinen Pointer sondern direkt
per Value.
Das heißt da machen wir jetzt einfach ein und
da vorne es geht. Nein.
Weil cannot cast into pointer
type. Child U8.
Was
ist denn jetzt? Was ist überhaupt das Problem?
Hier.
Expected type.
Const found.
Moment.
Hier sind irgendwelche
Pointer in dem Array und das ist
ein Pointer.
Was soll mir das überhaupt sagen?
Er will keinen Pointer
auf den Array sondern einen Pointer auf den Array
oder was will er?
Ne. Er will keinen Array.
Wenn ich ihm einfach einen Array gebe.
Wobei du hast
recht. Der will einen Array.
Aber dann mag er ja auch nicht.
Er will was haben?
Ich check das
nicht. Was ist Sternchen C?
Okay.
Zig String to C
String.
How to pass a C String?
Umgedreht. Ich will umgedreht.
Umgedreht will ich das haben.
Alter.
Reddit. Ich raste aus.
C String.
Das sind immer so die easy
Dinger sind.
Erklär mir wie es geht.
Hier.
How can I pass a 6 String
literally to C?
Das will ich machen.
Was?
Es ist nämlich verwirrend. So geht das.
Aber wahrscheinlich weil der Compile Time Magic
macht. Aha. PTR.
Geht es jetzt?
Easy.
Einfach nur
gut Glück
auf gut Glück.
Okay. Nice. PTR.
Obviously PTR.
PTR.
Funktioniert einfach.
PTR.
Das gibt es angeblich nicht mal.
Richtig cringe wer das nicht sofort checkt.
Sehe ich auch so.
Okay. Nice.
Jetzt haben wir den Kram für mehrere Videos.
Guck mal. Jetzt kann man das Video mehrfach
angeben.
Er macht das mehrfach.
Für jedes Argument.
Kriegen wir jetzt die Infos von dem Video.
Output. Okay. Nice.
Standard
Out.
Debug.
Print.
Aha.
Wir ersetzen das. Wir loggen das nicht.
Wir machen das einfach mit Print.
Sonst haben wir diesen Logging Output davor.
Was ist jetzt?
Achso. Weil ich keine Newlines
habe. Okay. Dann lassen wir es doch so.
Ey. Wenn das automatisch
Newlines macht, sollen wir das
Recht sein. Okay. Nice.
Standard
Standard
Standard
Ich kann es mir immer nicht merken. Debug.
Print.
Kann ich einfach irgendwie leer
auch was printen?
Nein.
Leer ist nicht erlaubt.
Kann ich jetzt irgendwas irgendwie
Also das ist komfortmäßig echt
nicht so nice. Okay. Jetzt
kriegen wir angezeigt, was es für eine Videodatei
ist. Das ist das. Das ist das. Das ist die Info.
Das ist ein MP4. Das ist, dass es zwei
Streams enthält. Ja.
Das ist doch eigentlich genau das, was ich haben wollte.
Guck mal. Wir haben ein Kommandozeilentool.
Was macht
ein FF-Probe sonst
noch so?
Was ist SIG? Eine Programmiersprache.
Gibt es in SIG
eine
Console
Color Library oder sowas?
Progress? Also gibt es
gibt es sowas? Okay.
Sowas suche ich. Genau.
Also ich
suche im Prinzip sowas wie
Specter Console
für SIG.
Also Specter Console kannst du halt so coole Dinge
auf der Commandline machen.
Sowas wie Specter Console nur für
SIG.
Beziehungsweise wie heißt das
Gegenstück nochmal?
Ähm. Recht bekannt.
Rich.
Rich. Genau.
Rich. Sowas wie Rich
für SIG. Was ist das?
Oh man.
Nur, dass ich das richtig sehe.
Die haben ein Progressbar Formatting
in der Standardlibrary.
Aber
Commandline Parsing haben sie
nicht in der Standardlibrary.
Ich würde mal sagen, Commandline Parsing brauchst du öfter
als Progressbar.
Okay. Standard Progress.
Ich wüsste gerne, wie ich das benutze.
Standard Progress.
Standard Progress.
Ne, das muss ich wahrscheinlich
importieren, oder?
Ne, wie geht das?
Standard Progress.
Okay, ich hab keinen Schimmer, wie das funktioniert.
SIG Standard Progress.
Ey, mal ganz davon abgesehen.
Ich brauch das überhaupt nicht.
Ich brauch überhaupt keine
Progressbar.
Ich brauch
Color Terminal brauch ich.
Und Table und sowas.
Äh, das gibt's da wahrscheinlich
standardmäßig. Wo war denn das
drin? Wo war das drin? Standard.
FMT.
Alignment.
Print.
Bytes to Hex.
Okay, da kann man...
SIG Spoon.
SIG Spoon ist ein SIG Offering.
SIG Spoon
takes care of...
Okay.
Ja, nice. Haben wir vielleicht ein paar
Examples oder so?
Zuletzt editiert vor 3 Jahren.
Ja, okay.
Ehrlich gesagt glaube ich nicht, dass ich das
benutzen will.
Gibt ja nicht mal
Examples.
Oh, doch.
Table! 256 Colors!
SIG CLI Table.
Ich meine, ich baue
sowas nicht selbst.
Also SIG ist für den C++
Compiler für Cross Compiling.
Nee, das ist eine komplett eigene Programmiersprache.
Also ja, wir können das selbst
formatieren, aber so eine Library, die
die Tabellen und Color und
so Sachen macht, wäre schon deutlich
angenehmer. Terminal
und Low Level Libraries. ANSI Term!
Jawohl! Da gibt's doch bestimmt auch
Colors und sowas.
Escape Code Styles.
Ja, genau sowas will ich haben.
Format.
Style.
Color. Ja, das ist schon
mal besser sowas. Sowas brauchen wir.
Sowas brauchen wir. Color.
Output auf dem Terminal.
Was haben wir denn sonst noch?
Create DOS Programs. Oh ja,
unbedingt. Ganz wichtig.
Da hat die Welt
drauf gewartet.
A Port of Lin...
Was ist Linois?
Man weiß es nicht.
Parsing
Command-Lines. Moment.
Command-Line Toolkit.
Command-Line Input. Nee.
Ja, zapp.
Command-Line Toolkit vor 6 Monaten.
Bestes Logo überhaupt.
Ja, okay, lasst es noch komplizierter
machen, please.
ANSI Term. Ja, ich...
Okay, ich hätte gerne
ein
Example, wenn möglich.
Wie man das Terminal
einfärbt.
Examples gibt es nicht.
Examples sind Overrated, Outdated,
Trebated.
Style.
Color.
Ich weiß ja nicht.
So ganz ohne Examples
ist doch abfuck, oder?
Da gibt es Guides. Wo gibt es
einen Guide dafür?
Also, mein Ziel war jetzt,
ehrlich gesagt, das noch
in eine Tabelle zu packen.
Natürlich kann man eine Tabelle
selbst machen, aber ganz ehrlich,
eine ordentliche Tabelle auf dem Terminal machen,
die muss ja auch gucken nach der Breite
des Terminals. Das ist gar nicht so einfach.
Insofern, ehrlich,
gehofft, es gibt eine
Library dafür.
Nehmen wir eine C-Library.
Nee.
Das sollte dann schon...
Ich meine, da breche ich mir ja noch mehr
einen ab als hiermit.
Ja, der Vorteil gegenüber C ist, dass es anscheinend
kaum Libraries gibt.
Und dementsprechend
kann man auch nichts verkehrt machen, weil es gibt nichts.
Ja.
Also, es hat schon deutlich mehr Sachen
eingebaut als C. Ich glaube, mit C, das zu
vergleichen, ist eher nichts.
Man kann es mit C++ vergleichen und ich muss sagen,
da weiß ich es jetzt
ehrlich gesagt nicht. Also, von meinem ersten
Eindruck her, finde ich die
Syntax wirklich nicht eingängig.
Auf der anderen Seite muss man sagen,
so die Basic
C++ Syntax, die ist
nicht schwer. Das Problem
bei C++ ist,
dass die Syntax, und
wenn du manche Sachen machen willst,
unglaublich eklig komplex wird.
Zum Beispiel, wenn du einfach nur Zeiten
konvertieren willst. Ja.
Standard, Lib, Chrono,
Milliseconds, From, Wall,
Clock, gecasted
nach irgendwas. Ja.
Ich meine hier, guck mal, C++
Milliseconds,
Two Seconds und sowas.
Das geht noch irgendwie.
Aber allein schon, wenn ich sowas sehe,
da muss ich schon ein bisschen kotzen immer.
C++ ist auch nur C
mit Erweiterung. Das stimmt ja
mittlerweile gar nicht mehr.
Du hast mittlerweile Sachen,
die sind
in C erlaubt,
aber in C++ nicht.
Und du hast jede Menge Sachen, die sind
in C++ erlaubt und in C nicht.
Also C++
ist kein echtes Superset
mehr von C. Ich glaube, das beste
Beispiel dafür dürfte sein
C Enums
mit
oder
wobei C Union
Types glaube ich funktionieren halbwegs.
Nicht C Enums.
C Enums gehen
C
Instruct
Was ist das?
Das hier, genau. Das geht
in C++ nicht.
Dass du
Structs Inline
initialisieren kannst.
Also das erste, was
mir einfällt.
Vielleicht gilt das mit manchen Compilern
oder so, aber ich bilde mir
ein, dass ist im C++ Standard
nicht vorgesehen.
Ich glaube, dann lasse ich das mit dem Formatieren.
Also weil, ich habe
keine Ahnung, wie ich das hier zum
Zig Color
Output Terminal, da muss es doch irgendeine
fertige Library für geben, man.
Und anscheinend standartmäßig auch nichts dabei.
For Go, ja für
Go, für Rust gibt es da bestimmt auch
tausend Sachen.
Es ist relativ easy, das übrigens
von Hand zu machen. Das können wir auch mal
machen hier.
Ansi Color Helper
Ansi
Ansi Escape Generator
So, Foreground
Keine Ahnung, machen wir mal
hier.
Style Bold
Keine Ahnung.
Background Red, Foreground
White
Da kann man sowas machen.
Guck, da kann ich jetzt zum Beispiel sagen
Echo
Kecke und dann ist es rot.
Das Ding ist, ich müsste
eigentlich
das irgendwie closen
und ich weiß gerade nicht
wie macht man das nochmal
wie macht man das nochmal
ähm
wie closet man das nochmal
Hast du da ein Beispiel für?
Ja
Weil jetzt ist er alles
Ich glaube
so konnte man es machen, ja.
Moin Patrick
So, guck, jetzt machen wir nämlich mal hier den
Output. Mal gucken ob
das überhaupt funktioniert. Wow, was jetzt?
Muss ich das doppelt?
Escape, Run
Ne
Ähm
Das könnte am Lock liegen, oder?
Liegt das am Lock?
Standard, Debug, Print
Das könnte jetzt wirklich am Lock
liegen
Was jetzt?
Ne
Ja gut
Ähm
Ich glaube
du musst X1, was muss ich nehmen?
X1
B?
What?
Das ist übrigens das Problem, was ich meine
Man muss
das
wieder terminieren, sonst funktioniert das nicht
Ich muss
ihm sagen, ab der Stelle
ist irgendwie wieder Schluss
und ich krieg das aus dem Kopf gerade
nicht hin
Wie man, wie das genau funktioniert
hat
Bash Colors, genau, erklär mal
Ach hier, genau, das mein ich
Das muss man wieder machen zum
Damit man das resetet
Ne?
Okay
Ich hätte jetzt eigentlich gedacht
Ach, muss man das nochmal escapen?
Ja genau
Ja genau, so will ich das haben, so finde ich das gut
Excellent
Ich will das übrigens an der Stelle
Gar nicht rot, fällt mir gerade so ein
Aber
Das war jetzt Test, ob es funktioniert
Video
So
Was ist ne schöne Sache hier, guck mal hier
Bold, Text
White
Ja, das ist gut
So, das ist excellent, so will ich das haben
Oh, hier
Ist es nicht, absolute
Augenweide
Eye Tool, beste
So muss das sein
Und das gibt es auch in Magenta
Guck mal, noch viel geiler
Oder in Blue
34
Was muss ich machen?
X1B
X1B
Guck mal, jetzt werden Videostreams
Jetzt werden
Aber guck mal, Videostreams
Wait a minute
Achso, foreground color ist doch falsch
Blue und das soll auf white stehen bleiben
Oh, viel besser
Viel mehr Pog
Guck mal hier, Video ist so
Und Audio Stream ist jetzt so
Excellent, excellent
So, genug rumgespielt damit
Weil dieses Tool
Soll ja nie irgendwas sinnvolles machen
Das war nur zum Üben mit sich
Nice
Gar nicht mal so übel
Oder?
Was du
Anläufe damit
Geht doch eigentlich
Es ist zwar mehr
C als Sig
Patrick, du als
alter C-Hacker-Man
Was sagst du denn
Zu dieser Syntax hier
Ups
Was sagst du denn zu dieser
Syntax hier für
Also in C++ und C
Anstelle, willst du den Pfeil machen
Und in Sig machst du Punkt, Sternchen, Punkt
Was sagst du
Pfeil oder Punkt, Sternchen, Punkt
Was ist die bessere Syntax
Kann man Sig mit Sigbief verwenden
Chat, wir machen mal eine Umfrage
Pointer Syntax
Pfeil oder
Punkt, Sternchen, Punkt
Start
Jetzt bin ich mal gespannt
Ich würde eher sagen, es ist eine Mischung
Aus ein bisschen Go Online
Ruby
Rust
C, so alles irgendwie zusammen
Chat, ich seh genau was
passiert
Ich seh genau was da passiert gerade
Ihr gebt grad eure
Cute Points aus, äh eure
Keks Points aus für unsinnige Abstimmungen
Ich hab euch so
krass Tubated und ihr habt es nicht mitgekriegt
Ich hab nämlich gesagt
Allow additional votes
Und für jeden additional vote muss man
1000 Keks Points bezahlen
Ihr habt mir gedacht, die Leute haben eindeutig zu viele
Keks Points
Ihr habt euch einfach mal astrein gebaten lassen
von mir, weil ich wusste
dass es wieder irgendwelche Leute gibt, die
viel zu viele Keks Points haben und der Meinung sind
wir müssen jetzt irgendwie wieder 50-50
kriegen
Guckt euch mal an die Votes
Also ich muss auch sagen, die Pointer Syntax hier gefällt mir
Die Pfeil Pointer Syntax
gefällt mir besser
Wir haben 184 Zuschauer
Aber 260 Votes
Seems legit
Ups, falsches Emote
Egal
Sebasu-Chan hat abgestimmt
Chat, was sagt ihr?
Wir waren noch halbwegs erfolgreich, oder?
Wir müssen aber noch eine Sache checken
Und zwar, wie groß
ist das Binary jetzt?
SigOut wahrscheinlich
Bin? SigChamp
Wie groß ist der SigChamp?
Äh, 873k
Das ist Mini
Mini vs. Go
oder eine selfcontained.net
Anwendung
Ich linke die C-Library, ja gut, ist halt so
Das ist wirklich
klein im Vergleich zu den anderen Sachen
Bisschen schade ist es
dass es
so schwierig ist
oder nicht so schwierig ist es
bei FFmpeg, gar nicht
dass es ein bisschen komplizierter ist
Ist das Stripped?
Weiß ich nicht
Wahrscheinlich nicht, oder?
Äh, SigReleaseBuild
Vielleicht muss man da noch
irgendwas anhängen
SigBuild vs. SigBuildExcel
Äh
Wie gebe ich da
Ach hier, Modes
SetBuildMode
brauche ich noch
Ah ne, ist schon
SelectBetween
Hä?
Minus Minus Mode
Ok, Build
Minus Minus Mode
Und dann
ReleaseSmall
Small, ne
Das ist nicht Minus Minus Mode
Das ist
Mode
Oder muss das hinter
Nö
Alter, wie benutzt man den
Shit, man?
Was Minus Deoptimized
Das klingt mir jetzt eher nach
Aha
Ja, wie würde man auch darauf kommen, dass das
Mode, Mode genannt wird
Oh Gott
Gleich
SigOut
Binary, da sind wir
Oh, guck mal
14 Kilobyte
Das dumme daran ist halt nur, dass
man immer noch FFmpeg installiert braucht
Ja, gibt es nicht
Aber hier wird
Äh, ist es broken?
Es ist broken
Mein ReleaseMode hat es zerstört
Blazingly fast
Guck da, funktioniert
Und jetzt?
SigBin
Die C-Libraries sind kaputt, wenn ich
Und einfach nur ein Bild
Da geht es noch
Ok, dann machen wir Release, was war das?
ReleaseSafe oder sowas
Da geht es auch noch
Alles andere macht es kaputt
ReleaseFast
ReleaseSafe, alles gut
So
Sig
Out
Oh, Moment
Ist es noch größer geworden?
Ne, 897
Das ist ok, das ist das gleiche
Strip, deutlich kleiner
Ohne Debug-Symbols, aber jetzt
wird es wahrscheinlich nicht mehr funktionieren
Weil es dann die Einstiegspunkte
in der C-Library nicht findet
Doch, geht immer noch
Na, geht auch
Also
189k
Ich meine, FFmpeg ist nicht gebundled
Und FFmpeg zu bundlen
Ist halt
ein bisschen komplizierter
Man bräuchte eine FFmpeg-Version
Wenn man das
Na gut, eigentlich nicht
Man müsste halt ein statisch
kompiliertes FFmpeg
Da reinpacken
Und dann aufrufen, das wäre auch noch
Machbar
Die Frage ist, wenn man jetzt
Dieses Sig-FFmpeg benutzt
Was hier irgendjemand gebaut hat
Ob man sich das dann
Sparen würde, wobei ich
Ehrlich gesagt den Sinn nicht checke
Hiervon
Moment
Der hat einfach nur das Bildsystem
Ausgetauscht durch das von Sig
Oder?
Im Prinzip ist es vollkommen egal
Es kommen C-Sachen raus
Am Ende
Aber
Es wird nach wie vor durch den C-Compiler
Gejagt und braucht C-Header-Files
Aber ich finde es gut
Also
Was wir da so hingekriegt haben
Es war nicht einfach
Muss man sagen
Darauf zu kommen, wie das gerade
Im Interop mit C funktioniert
War wirklich nicht so easy
Wir haben jetzt vielleicht
Kein super
FFmpeg
FFprobe Ersatz
Aber so die Basics macht
Man kann beliebig viele Videos
Was passiert eigentlich, wenn ich eine Datei
Reinschiebe, die
Kein Video ist
Ja gut, wir haben halt wieder
Richtig gute Fehlerbehandlung
Nämlich gar keine
Guck
Wir werfen einfach alles weg
Normalerweise müsste man zumindest
Checken
AV Format Open Input
So und wenn das Result
Wobei, das können wir jetzt an der Stelle
Mal kurz machen, guck mal
Lock, keine Ahnung
Warning, Result
Run
So und jetzt gebe ich mal irgendwas an, was es nicht
Gibt
Ja, dann sagt er hier
Ja, Minus, guck
Also ich muss an der Stelle gucken
If
Result
Umgleich 0
Dann
Return
Zack und schon funktioniert es
Easy
Und jetzt haben wir das Ganze auch noch
In Blazingly Fast
Kompiliert
Zack, jetzt crasht es auch nicht mehr
Ach, ihr lest einfach nur die Header Infos
Von dem Videocontainer aus
FFmpeg
Macht das für uns, ja
Der liest die ersten paar Sachen ein
Und dann checkt es
Was da drin ist
Welche Audiospuren, welche Videospuren
Welches Videoformat
Moment
Zig hat nur einen Entwickler, das kann ich mir nicht vorstellen
Ne
Was soll denn, was wollt ihr denn sonst noch
Was soll denn sonst noch
Scala oder Erlang oder sowas
Ne, ne, ne, ne, ne
Aber es funktioniert
Chat und ich beweise euch, dass es funktioniert
Ähm
Und zwar, wir laden jetzt einfach mal
Ein Video runter
Ja
Youtube
Irgendein kurzes Video von mir brauchen wir
Ach komm
Ist wurscht, ich kann das aktuelle Video nehmen
Youtube DLP
Minus F
Oh, ups
Nicht so ganz
So, und jetzt laden wir runter
Oh, Weppen, kann der Weppen
Das müssen wir mal ausprobieren
Schön kleines, schön kleines Weppen
242
Checked
FFMpeg hat Probleme mit Weppen
Probieren wir mal aus
Zig
Battlebit
Komplett overhyped
Weppen, ein Stream, Video
VP9, Weppen
Spricht man das Weppen oder
WebM
Funktioniert
Und jetzt
Ich versuch dir mal ganz kurz zu erklären
Um was es geht
Und zwar, wir haben ein Tool programmiert
Das uns ausgibt, wenn man eben
Als Parameter eine Videodatei übergibt
Was in der Videodatei
Drin steckt
Also sprich, wie viele Videostreams, welches Format
Und mit was das Video encoded ist
Es ist Video.mp4
Videos hat 264 encoded
Audio sprich AAC encoded
Hat zwei Streams, ein Audio, ein Video
Und der Container ist mp4
Was passiert, wenn du ein
Audio-File übergibst
Dann wird dann da wahrscheinlich
WAV oder sowas stehen
Können wir ausprobieren
FFmpeg
FFmpeg-i
vid.mp4
keckel.wav
Info, Audio, PCM
S16, LE, ein Stream
WAV
Weppen ist nur Video, ja
Video Stream runtergeladen
Pass mal auf, zum Beweis
Wir machen jetzt
Das gleiche nochmal
So was anderes, wir laden jetzt
Was ist
mhtml
Was ist mhtml
Okay, keine Ahnung
Ähm, Leute
Da fehlt doch die Audiospur, ach ne, hier, hier, hier
Audio, Audio, hier
Ne
Audio, m4a
So, 22
Nehmen wir mal
22
Kann man machen, oder man lädt gleich was runter
Wo das schon so ist
So, jetzt haben wir das noch hier, mp4
Komm, wir können sogar mal ein Sternchen hier hin machen
So, beide Dateien
So, guck, es gibt einmal
VP9, Webm und einmal
H264ac
Also der kann das, der checkt das
In Webm passt doch auch Audio rein
Ja, aber war kein Audio drinnen
Ja, wir können das ganze nochmal runterladen
Was war Webm? 242?
242?
Du kannst, du kannst sagen
Ich bin mir nicht sicher, ob Webm
Plus m4a funktioniert
Also, man könnte sagen
Plus
Bin mir nicht sicher, ob das sich verträgt
Ja
Okay, er hat einen mkv draus
gemacht jetzt
Okay, geht, guckt
VP9ac
H264ac und nur VP9
Wir brauchen
keine Tests, weil das alles perfekt ist
Wunderbar
Hat funktioniert
Nice
Kann man dazu nur sagen
Nice
Chat, wenn euch das Stream gefällt
und wenn ihr was gelernt habt
Es ist ja immer noch ziemlich Anfang des Monats
Ich habe gehört, es gibt noch sehr viele Leute
die ihren Prime-Sub frei haben
Easy
Kann man sicherlich sogar als Bildungsausgabe
oder so irgendwie absetzen
Webm ist glaube ich
eine spezielle Form von mkv
Achso, Webm
Ja, das ist möglich
Ähm, VP9 aber nicht
VP9 ist ja
eigentlich der eigentliche Codec
Prime-Sub in die Steuererklärung
Ja, klar, volle Pulle
Der Chat macht keine Fehler
Ja, generell
Tests sind einfach nur
Overrated, outdated, debated
Wer muss schon testen, ne?
Sadge Leute, ich habe so eine nice
Sellout-Überleitung gemacht
und nicht einer Prime-Sub
Was passiert, wenn du ein Audio-File
übergibst? Achso, nee, das habe ich schon ausprobiert
Ist deine aktuelle
Links-Restriktion
die du empfehlen würdest
Ja, würde ich
Ich meine, ich benutze das
Setup mehr oder weniger schon seit Jahren
Wir haben es mal neu gebaut, ich habe viele Sachen
umgestellt, aber es ist relativ
lange schon ähnlich
Wenn du wissen willst, wie es funktioniert
Ich habe meine ganzen
Konfigs hier auf GitHub
Da kannst du dir angucken
Also der Prompt ist Starship
ZSH als Shell
Westterm als Terminal
Hintergründe von
meinem Twitch-Chat
Manche Sachen sieht man hier
Aber hier hast du die ganzen Config-Files
Was ist sonst noch
erwähnenswert?
ZSH
Ja, Bumblebee ist die
Statusleiste da oben, i3 ist
der Windows-Manager
Rofi ist dieses Ding
hier zum Starten von Programmen
und zum Copy-Pasten und alles
Westterm ist
das Terminal
Das Wichtigste ist, dass man
Sachen wie Transparenz hat
Du siehst ja vielleicht ein bisschen Transparenz
im Hintergrund vom Terminal
Wo hier der Hintergrund durchscheint
Für den Fall, dass ich hier wieder irgendwelche Subs übersehen habe
Der Tischbakkus hat subscribed
Ist zwar schon ein bisschen näher, aber den habe ich noch gar nicht gesehen
Ich glaube, der ist schon weg
Og
Best Practice
Ich benutze eh nur 1, 2, 3, 4, 5, 6 überall
Best Practice Passwort
Kann kein schlechtes Passwort
sein, wenn man sich anguckt, wie viele Leute das verwenden
Chatge, ich muss mal kurz
was gucken
Hast du die von scratch?
Jaja, habe ich gemacht
Wir haben das sogar zum größten Teil
im Stream
gemacht, glaube ich
Ach, Arch
Arch by the way, Package by the way
Ja, ich
Ja, ich glaube
hier haben wir das zum größten Teil gemacht
Oder?
Ne, ne, ne, ne, ne, ne
Hier haben wir das gemacht
In
In mehreren Streams
haben wir das zusammen
eingerichtet
Letztendlich ist es jetzt nicht schwer, das wieder
wieder neu herzustellen, ne
Also, ich würde einfach die Packages installieren
und meine Config wieder drüber kopieren
und alles ist gut
Um das rauszubekommen an manchen Stellen
Gerade wie man Starship konfiguriert
war gar nicht so easy
Ich habe einige unterschiedliche
Ich habe recht viele von Reolink
weil die einfach billig als Fax sind
Und man RTSP abgreifen kann
aber das sind sicherlich nicht
die
am besten gebauten Kameras
mit der besten Software
Gibt auch IT-Unternehmen, wo du als
Entwickler deine Anwendungen
wie Anwendungen werden getestet
Ich dachte, das ist komplett outdated
Sollte man
vielleicht mal DICE erzählen?
Ich glaube, die wissen das nicht
Aber DICE haben sich einfach
bei mir, würde ich sagen, Consulting geholt
und denken, sie sind so perfekt
und programmieren eh fehlerfrei, da muss man auch nichts testen
Wie man ja heute
gesehen hat, wir haben prinzipiell
nie, nie Fehler, ne
Vielleicht sollte ich mal
kurz die Sachen wieder löschen
Battle Bit
Wow
Nicht so viel Speicherplatz verschwenden
So, leider hat mein Abo-Sellout
nicht funktioniert, deswegen gehe ich jetzt off
Ne, ich will jetzt auch so off gehen, weil ich habe Hunger
Ich muss jetzt was essen
3 Stunden, nicer Brogger-Stream, Leute
Wir sehen uns, machts gut, bis denn
See you
