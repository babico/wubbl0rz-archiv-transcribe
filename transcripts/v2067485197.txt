Hallo, warum nicht früher?
Das ist die genauere Frage, wie warum nicht später.
Wahrscheinlich sind die meisten gerade auf dem Heimweg.
Ich kann dir sagen, warum nicht früher.
Weil ich früher keinen Bock hatte.
Kannst du mal mitbekommen, kannst du mal noch ins Wort gucken.
Ansonsten gibt es ja noch mehr.
Oh Mann, mir tut das Bein weh, Leute.
Was es heute zum Mittagessen gab?
Nudeln mit Lachs?
Ne, es gab keinen Nudeln mit Lachs.
Es gab, oh ja, ja, Leute, furchtbar gesund, furchtbar gesund gab es heute zum Mittagessen.
Mozzarella Sticks und Pommes Frites.
Highly, highly, äh, Bio Pommes Frites und Mozzarella Sticks.
Aber kurz die VM an- und Updater mal.
Ja, furchtbar gesund, ultra gesund, hyper gesund.
Es reicht ultra gesund, reicht nicht mehr.
Hyper gesundes Mittagessen gab es heute.
Wisst ihr, meine VMs sind so dämlich benannt, dass ich meistens auf den ersten Blick nicht weiß, welche ich benutzen muss.
Muss ich Poggers benutzen oder muss ich Stream benutzen?
Nein, ich muss Stream benutzen, weil Poggers ist die alte Stream-VM.
Warum habe ich die überhaupt noch?
Wahrscheinlich zum Zeug nachgucken, falls ich mal was brauche.
Ahem.
Spaghetti mit Lachs.
Ne, ne, ne.
Mal gucken, ob es das passende Hintergrundbild heute gibt.
Gucken, was für ein random Hintergrundbild ausgewählt wird heute.
Moment, Moment, das hat er noch nicht geupdatet.
Ich muss erstmal Package-Updates machen und dann rebooten.
Dann mal gucken, was für ein random Bild ich bekomme.
Ich schreibe am 28.
Ach, ist es mal wieder soweit, ja.
Meine erste AP1.
Ach ja, ich dachte, ich dachte, das ist...
Eher sowas wie Zwischenprüfung im Februar.
Naja.
Immer so zwei bis drei.
Ah, ne, habe in den Probe-Prüfe immer so zwei bis drei.
Und habe mich mit so einem Vorbereitungskurs und ein Vorbereitung durch...
Und ein Vorbereitung-Buch vorbereitet.
Meinst du, das reicht aus?
Ja.
Wenn du immer ganz gut durchkommst.
Ich würde dir allerdings empfehlen,
trotzdem noch ein paar Probe-Prüfungen...
zu machen, weil...
in der Probe-Prüfung ist es immer einfacher,
als wenn man dann echt vor Ort da sitzt.
Also, guck lieber, dass du bei der Probe-Prüfung
das nicht gerade so packst, sondern wirklich easy.
Und dann schaffst du es auch ganz gut vor Ort.
Weil das ist wirklich was anderes,
ob man dann da sitzt und es ist ja zu weit.
Und dann teilen die IHK-Leute das aus.
Und man versteht die Hälfte der Fragen nicht,
weil die schon so scheiße formuliert sind.
Also, es ist immer ganz gut,
wenn man im Vorfeld besser ist und nicht gerade so...
Oh, ich denke...
Ich denke, das reicht.
Das reicht aus.
Mein Vorbereitungs...
Was hast du gemacht?
Ein Vorbereitungskurs.
Du hast Probe-Prüfungen gemacht.
Also, ganz ehrlich.
Viel mehr kannst du nicht machen.
Es wird schon hinhauen.
Aber es ist schade.
Ich mache ruhig noch ein paar Probe-Prüfungen.
Bis...
Ich meine, guck mal, es ist ja noch jetzt eine Woche Zeit.
28.
Nächste Woche Montag, ja?
An die nächste Woche Mittwoch.
Ja, da kannst du schon noch mal so ein paar Prüfungen machen.
Umso mehr du dich in diesen IHK-Speak
und in diesen ganzen Blödsinn da...
reindenken kannst,
umso besser.
Ja, mach dir aber nicht zu viele Gedanken.
Im Prinzip sind die Prüfungen einfach.
Das Schwierige an den Prüfungen ist,
die IHK-Sprechweise und die IHK-Logik verstanden zu haben.
Die Prüfungen selbst sind nicht schwer.
Äh, ich kann nicht mehr richtig reden, Alter.
Die Prüfungen selbst sind nicht schwer.
Zu verstehen, was die wissen wollen
und wie die Fragen stellen,
das ist das Schwierige dran.
Die Fragen selbst, wenn man wirklich verstanden hat,
was die wollen, sind teilweise so triffig,
wie halt simpel.
So, ihr kennt ja diese typischen IHK-Prüfungen so.
Ordnen sie die Punkte zu.
Dass du links dann so...
Oder bringen sie die Punkte in die richtige Reihenfolge.
Das ist meistens so hirnverbrannt easy,
wenn man verstanden hat, was die eigentlich wollen.
Ach, AP1 ist jetzt...
Ach, das ist die Zwischenprüfung.
Heißt das jetzt AP1?
Bei mir hieß das noch Zwischenprüfung.
Aber es kann sein, ja?
Macht ja Sinn, dass das jetzt AP1 heißt.
Ja, das ist die Zwischenprüfung.
Ja, das ist die Zwischenprüfung.
Ja, das ist die Zwischenprüfung.
Ja, das ist die Zwischenprüfung.
Ja, das ist die Zwischenprüfung.
Weil die Zwischenprüfung zählt jetzt ja auch zur Abschlussprüfung irgendwie, gell?
Ich blicke da nicht durch.
Ich hab mich da ehrlich gesagt nie wieder mit beschäftigt.
Hab ich auch keinen Bock, weil warum?
Ich bin...
Warum sollte ich mich jemals wieder mit IHK-Prüfungen beschäftigen?
Warte mal, hab ich jetzt Reboot oder nicht?
Ja, hab ich.
Moment.
Alter, was ist denn das für ein Zufall, Mann?
Guck mal, Leute.
Ich hab rebooted.
Und er hat von irgendwie 20 möglichen Hintergrundbildern
exakt das gleiche wieder ausgewählt.
Moment, das muss ich jetzt checken, dass wir hier nicht jebaited werden.
Der Jebait-Test.
20% zählt die, okay.
Ja, tatsächlich.
Das war Glück.
Weil jetzt haben wir den Workout-Champ im Hintergrund.
Den Workout-Pepo im Hintergrund.
So, diesen ganzen Krempel hier mal zu.
Ja, also mach dir keine allzu vielen Gedanken.
Wie gesagt, die Prüfungen sind easy.
Und solange du das IHK...
Die IHK-Sprechweise und was die wissen wollen, verstanden hast, schaffst du das locker.
Ich würde trotzdem noch mal bis 28.02.
Also, mein Weg sein.
Mach ruhig noch die Woche noch ein paar Prüfungen.
Weil, sonst vergisst man es ja auch wieder.
Es schadet nicht, noch mal so zwei, drei Prüfungen zu machen.
Mach noch mal irgendwie die Woche zwei, drei Stück.
Nächste Woche musst du dann...
Ich meine, hier ist gut.
Bis kurz davor muss man das nicht machen.
Das schadet nicht.
Es gibt ja auch mittlerweile genug.
Ich weiß gar nicht.
Gibt es eigentlich...
Gibt es mittlerweile eine offizielle Quelle für alte IHK-Prüfungen?
Oder ist das immer noch so ein Ding?
Irgendeinen File-Hoster suchen, wo es mal einer drauf abgelegt hat?
Also, ich meine offizielle, kostenlose Quelle.
Dass man die sich kaufen kann, irgendwo weiß ich.
Soll ich euch mal sagen?
Ich finde das nach wie vor ein komplettes Unding, dass ein Azubi sich alte Prüfungen kaufen sollte.
Ich weiß gar nicht, was kosten die eigentlich?
Was kosten sowas eigentlich?
Ja, ja, später.
Fachinformatikerprüfung.
Was ist das für eine Webseite, Mann?
Was ist das für eine Webseite, Alter?
Optimiert für Microsoft Internet Explorer in 1024x768, oder was?
Exzellente Bewertung, haben die, guck mal.
Exzellent.
E-Komi, exzellente Bewertung.
Alle ablehnen.
Exzellent.
Ist das Wordpress?
Mal kurz gucken, was das ist.
Webstiles?
WSWS?
Ist das Wordpress?
Chatge?
Ihr kennt euch mit sowas besser aus.
Websale.
Websale ist das.
Was ist Websale?
Shopify für Arme, oder wie?
Webshop as a Service.
Also, seriously.
Wenn das ein Webshop as a Service ist, dann weiß ich, dann verstehe ich die Welt nicht mehr.
Das sieht aus, als hätte das mal vor 20 Jahren einer gebaut, und danach wurde das nie wieder angepasst.
Also, nach einer Service-Anwendung sieht das beim besten Willen nicht aus.
Okay.
Wie dem auch sei, Systemintegration.
Was kosten so Abschlussprüfungen?
Fachinformatiker.
Erzähl dem Erfolgspaket plus Abschlussprüfung Teil 1.
Das Erfolgspaket.
Was genau ist denn das Erfolgspaket?
Was, was ist das F?
Erfolgsgarantie, auch noch.
Da wäre ich, da wäre ich aber mal zurückhaltender.
Was ist denn da drinnen?
Ihre Vorteile, perfekt gepackt.
Ja, und was ist, was ist jetzt dabei?
Ja, und was ist denn jetzt dabei?
Erfolg.
Das Selbstcoachingbuch.
Meine Güte, machen die jetzt auf KLS, oder was?
Die Versandkostenfreilieferung schont ihr Budget.
Das Selbstcoachingbuch.
Meine Güte, machen die jetzt auf KLS, oder was?
Die Versandkostenfreilieferung schont ihr Budget.
Das Selbstcoachingbuch. Meine Güte, machen die jetzt auf KLS, oder was?
Der Shit kostet 74 Euro, Mann.
Okay, im Prinzip sind das einfach nur Abschlussinhalte.
Okay, im Prinzip sind das einfach nur Abschlussinhalte.
Prüfungstrainer-IT-Berufe, braucht keiner.
Prüfungstrainer-IT-Berufe, braucht keiner.
Lernkarten braucht auch keiner.
Prüfungs... Ja, das vielleicht schon eher.
Original IHK-Abschlussprüfung Dezember.
Moment, das ist, da ist nur eine Prüfung dabei.
Moment, das ist, da ist nur eine Prüfung dabei.
Herbst 2003, nur eine Prüfung.
Die wollen dich doch verarschen, oder?
Das ist doch Schwachsinn.
Ganz ehrlich, Leute.
Ganz ehrlich, Leute. Wir haben das damals verarscht.
Wir haben uns von Rapidshare oder so runtergeladen.
Mich würde nicht wundern,
ich möchte natürlich keinen dazu auffordern,
aber mich würde nicht wundern,
was es heute auch noch gibt.
Vielleicht nicht auf Rapidshare.
Weil ich glaube, Rapidshare selbst
gibt es nicht mehr.
Rapidshare hat auch ein bisschen die Arschkarte gehabt,
dass sie so einer der ersten, so On-Click...
Nämlich OneClick...
Wie hieß das?
Free...
So Share...
...OneClick-Hoster?
Denn davon will ich gar nichts wissen.
Wenn ich sehe, wird es gelöscht.
Kappa.
Sharehoster, ja.
Guck mal, es ist die eine Sache, was ich offiziell sagen muss und das andere, was ich mache.
Also, ich erlaube nicht, dass auf meinem Discord solche Sachen gepostet werden.
Wo kämen wir denn dahin, Mann?
Wie findest du die Programmiersprache Java?
Viel wichtiger ist die Frage, wie man das ausspricht.
Ist es Java?
Ist es Java?
Bisschen die Frage wie bei Kubernetes.
Ich mag Java nicht sonderlich.
Ich habe aber auch nichts dagegen.
Ich würde zumindest meine Projekte nicht in Java machen.
Java ist, zumindest alles, was ich bisher gesehen habe,
beziehungsweise gelesen habe,
ist ultra verbose oder verbose, wenn man das ganz richtig aussprechen muss.
Also, das sieht irgendwie so,
so, so bloated aus.
Man könnte dann sagen, dass es bei .NET und C-Sharp ähnlich ist,
aber ich finde es bei weitem nicht so krass wie in Java.
Ja, gibt es eigentlich wirklich noch Unternehmen, die Programmierer nach programmierten Zeilen bezahlen?
Das gibt es doch nicht mehr, oder?
Das macht doch 2024 niemand mehr.
Was hältst du von Go?
Go ist nice.
Viele Java-Leute schwärmen ja von Kotlin, so ein bisschen,
aber sind dann richtig sad-kill,
dass sie im Beruf nicht Kotlin verwenden dürfen,
sondern weiter mit Java rumhantieren.
Ja, dass sie weiter mit Java rumhantieren müssen.
Ja, das schadet nicht.
Es ist jetzt nicht so, als wäre Java und das Java-Ökosystem unerträglich kacke.
Ich glaube, das Schlimmste am Java-Umfeld ist tatsächlich Oracle,
wobei es ja mittlerweile mit OpenJDK und was sonst nicht noch alles,
ich bin da nicht so drinne, was das Java-Ökosystem angeht,
sicherlich ja auch vieles gibt,
wo man großen Bogen,
wo man großen Bogen um Oracle machen kann.
Ein Kollege von mir auf der Arbeit mag Oracle auch nicht.
Man muss aber wissen, der hat früher bei Sun gearbeitet
und wurde dann zwangseinverleibt von Oracle
und hatte dann nach ein paar Jahren keinen Bock mehr.
Das finde ich, das trifft echt ganz gut.
Go, wenn es schnell gehen soll und Rust, wenn man nichts von Bugs wissen will.
Das ist natürlich im Detail.
Nicht so, aber so ganz grob finde ich das gar nicht so schlecht.
In Go kann man wirklich auf die Schnelle was zusammenzimmern,
was man übrigens in C Sharp und Python und anderen Programmiersprachen auch kann.
Kommt ein bisschen drauf an, was man machen will.
Und Rust ist die einzige Programmiersprache, die ich kenne,
wo man sagen kann, dass es in der Regel,
sobald es kompiliert, das macht, was da steht oder was man zu sehen glaubt.
Dass man jetzt selbst irgendwie einen Denkfehler gemacht hat
und der Ablauf nicht richtig ist, da kann Rust auch nichts dagegen.
Aber zumindest,
in der Regel macht Rust-Code das, was da steht.
Also, ne, was da steht, sollten sie alle machen, außer C++.
C++ macht noch nicht mal das, was da steht. Das ist kein Witz.
Wir haben uns letztens, letztens habe ich euch wieder was gezeigt, wo in C++
was anderes gemacht wird, als da steht.
Aber bei Rust ist es so, das was da steht und das was du verstehst, ist in der Regel,
sobald es sich kompilieren lässt, auch das, was es macht.
Also Rust ist da schon ganz gut, ne, wenn du natürlich Blödsinn-Schränen schreibst und denkst,
dass da ein Denkfehler drin ist, da kann Rust auch nichts dagegen machen.
Ja, ich finde das, ich finde das auch ganz gut gemacht.
Rust hat ja von Anfang an gesagt, ey, Exceptions wollen wir nicht.
Wir haben nur Result-Types und Option-Types und sowas.
Die haben das halt konsequent gemacht.
In Go haben sie es nicht konsequent gemacht.
In Go hast du deinen Error-Type, kannst aber auch paniken und recovern.
So halbe-halbe ist das.
Und in C-Sharp kannst du auch beides machen.
In C-Sharp kannst du auch Error-Types verwenden.
Oder, also, ich glaube, offizielle Option- und Error-Types gibt es in der Standard-Library nicht,
aber du kannst sie ohne Probleme verwenden.
Und in Exceptions, was halt richtig nice wäre, in C-Sharp, wenn sie es mal hinkriegen,
würden, dass du, also ohne den gleichen Base-Type zu haben,
mehrere Sachen, unterschiedliche Types returnen könntest.
Irgendwelche Union-Types, aber das wollen sie irgendwie nicht.
Hast du auch?
Hast du auch studiert oder Ausbildung als Fachinformatiker?
Ich habe 2007, also das jetzt vor, ach du Scheiße, ist das schon lange her, Mann.
Das ist ernsthaft, 17 Jahre her schon.
Quick Maths, stimmt das?
Ja.
17 Jahre her habe ich eine Ausbildung als Fachinformatiker, Systemintegration gemacht.
Das gab es zu dem Zeitpunkt noch nicht so lang.
Schon ein paar Jahre, aber nur nicht so lang.
Meinungen zu Broadcom-Lizenzmodell der Zukunft?
Ich habe absolut keine Ahnung.
Was das Broadcom-Lizenzmodell der Zukunft ist.
Stellst du von C...
Nein, nein, nein, nein, da fahren wir jetzt nicht hin.
Übrigens, das ist das Einzige, was ich jetzt zu C++ sage.
Wisst ihr eigentlich, dass in C++ das hier, while, oder while true,
ich kann C++ nicht aus dem Kopf gescheit, while true hier,
print, print,
was hat er denn, was glaubt er denn jetzt eigentlich für ein...
Ach ja, was gibt Kackel?
Wisst ihr eigentlich, dass in C++ es nicht klar ist, was hier passiert?
Habe ich schon mal erzählt, ja, aber in C++ ist es tatsächlich nicht so,
dass das passiert, was man denkt.
Was würdet ihr denken über diesen Code?
Was passiert da?
Es ist jetzt übrigens keine konkrete Programmiersprache.
Nur vom Ablauf.
Wenn ihr sowas ähnliches in C++ stehen hättet,
in C++ ist es dann noch einmal...
Standard, nee, doch Standard, so irgendwie.
Allein schon, wenn ich diese Syntaxe immer sehe, kriege ich Anfälle.
Kommt auf den Compiler an, das ist korrekt.
Die Schleife ist leer und wird je nach Dings wegoptimiert.
Korrekt.
Psytech, genau so finde ich, sollte das auch sein.
Ist es aber nicht zwangsläufig.
Also ich würde auch sagen, es muss eindeutig so sein,
damit das halt passt, was da steht.
Es gibt das aus.
Und dann hängt es unendlich.
Aber nein, das ist nicht so.
Und es ist übrigens nicht so, weil die Schleife wegoptimiert wird.
Es ist so, weil...
Weil ohne Abbruchbedingungen undefined behavior ist.
Warum auch immer.
Das haben sich die Leute vom C++-Gremium sicherlich gut überlegt.
Und das ist so schlimm, dass es zwischen Compiler-Versionen
und Compiler-Upgrades sich ändert.
Also sprich, wenn du das hier, sagen wir mal, mit GCC9 kompilierst,
dann hängt es in der Endlosschleife.
Kompilierst du es mit GCC10, dann gibt es Kekkel 1 und Kekkel 2 aus.
Es ist so ein Bullshit, diese Sprache und was die Standardleute da bauen.
Ich meine, allein schon, dass eine leere...
Ich weiß gar nicht, ob das leer sein muss.
Eine Endlosschleife ohne Abbruchbedingungen undefined behavior ist.
Wer hat sich diesen dummen Schwachsinn ausgedacht?
Ja, also C++ kannst du echt klicken.
Zumindest ist C++ die einzige Sprache,
wo du wirklich vom Angucken nicht weißt,
was das ist.
Und das ist so schlimm.
Weil du nicht wissen kannst, was es macht.
Aber Rust ist schon gut in der Beziehung.
Das weiß ich nicht.
Es geht aber hauptsächlich darum...
Warte mal.
Zumindest hat der Typ das
in der Präsentation so erzählt.
Ich habe den Standard nicht gelesen.
Ich habe eine C++-Con-Präsentation geguckt,
wo es um undefined behavior geht.
Und der meinte, das Problem ist,
die Endlosschleife und Abbruchbedingungen,
das wäre nicht definiert.
Und ich glaube, das kann man nicht.
Das schaffen die doch nicht mal selbst.
C++ ist einfach komplett für den Arsch.
So, machen wir das mal zu.
Machen wir das mal zu.
Wobei, einen Browser brauchen wir schon noch.
Wir gucken uns heute das Welt 5 an.
Ich gebe zu, die Streamingzeit
ist vielleicht nicht für alle so praktisch.
Die meisten Leute sind jetzt fertig mit der Arbeit,
fahren jetzt heim.
Aber ich schwätze ja lang genug rum.
Vielleicht seid ihr ja mittlerweile schon daheim.
Und könnt gucken.
Ansonsten gibt es immer noch das Wort.
Oder wir machen ja demnächst noch ein paar mehr Streams
in der Richtung.
Zumindest, ich wollte mir heute mal das Welt 5 angucken.
Weil das ist ja irgendwann gescheduled,
released 2024 irgendwann,
wenn ich das richtig gelesen habe.
Und das Welt 5 hat
bei der Ankündigung
einen riesen Aufschrei
in der Svelte-Community verursacht,
weil sich die Syntax etwas ändert.
Und das ist ja auch ein bisschen
komisch.
Als ich das das erste Mal gesehen habe,
wir gucken es uns gleich an.
Ich habe eine coole Seite gefunden,
in einem Video auf YouTube,
wo man schön die alten und neuen Versionen vergleichen kann.
Zumindest war der Aufschrei relativ groß,
weil sich an der Syntax
ein bisschen was geändert hat.
Und ich dachte mir am Anfang auch,
ich weiß nicht,
irgendwie falte ich die alte Sache ja ganz cool.
Aber jetzt,
nachdem ich mir eine Weile überlegt habe,
glaube ich, das neue ist wirklich besser.
Und eindeutiger.
Ihr könnt das ja gleich selbst entscheiden,
wenn wir es uns angeguckt haben.
Ich bin übrigens bei weitem kein Frontend
oder Svelte-Professional.
Also es kann durchaus sein,
dass ich auch in Svelte 4 bei einigen Sachen
gar nicht so genau weiß aus dem Kopf,
wie sie funktionieren.
Kein TypeScript mehr?
Nee, wir machen hier nie TypeScript.
Oder was meinst du?
Ach, Svelte 5, kein TypeScript mehr?
Nee, du kannst das mit TypeScript verwenden,
wenn du willst.
Du kannst es auch sein lassen.
Das Einzige, wo die kein TypeScript,
das hat auch einen Riesenaufschrei verursacht.
Als die angeblich
verwendet Svelte 5 kein TypeScript mehr.
Das ist auch Blödsinn.
Die verwenden intern
in ihren,
tja,
so wie sie Svelte bauen quasi,
verwenden sie intern kein TypeScript mehr.
Aber du kannst Svelte
selbstverständlich mit TypeScript benutzen
und die offiziellen Beispiele sind auch zum größten Teil
mit TypeScript.
Ja, genau.
Das heißt nicht,
dass du Svelte nicht benutzen kannst mit TypeScript.
Sie verwenden intern in Svelte kein TypeScript mehr.
Das liegt daran,
ich habe auch ein Video gesehen mit dem Svelte-Erfinder.
Die haben gesagt, weil sie große Probleme haben,
Svelte kompiliert das ja dann zu plain JavaScript alles,
was du da an syntaktischem Zucker in Svelte machen kannst.
Die haben große Probleme,
TypeScript da zwischendrin zu parsen.
Deswegen machen sie, glaube ich,
jetzt JS-Docs intern und verzichten auf TypeScript.
Du kannst aber Svelte wunderbar,
wunderbar mit TypeScript verwenden und du wirst sogar,
glaube ich, in den offiziellen Docs dazu ermutigt.
So nach dem Motto macht's mit TypeScript.
Also das, das, was die intern machen und das,
wie du es dann am Ende verwenden kannst,
hat ja gar nichts miteinander zu tun.
So, und ich habe eine Seite gefunden in einem YouTube-Video.
Ich zeige euch das YouTube-Video mal.
Also wir gucken uns das jetzt an.
Ich habe.
Ah ja.
Ich habe ein YouTube-Video gefunden und zwar das da.
Und er hat da drin eine wirklich coole Seite gezeigt.
Und zwar guckt mal hier.
Komponent-Party.dev.
Kanntet ihr das?
Also ich kannte das vorher nicht.
Das ist aber extremly nice.
Denn man kann hier beispielsweise alle möglichen Frontend-Frameworks
vergleichen, wie ähnliche Konstrukte untereinander aussehen.
Also wir können jetzt zum Beispiel sagen,
wie sieht dann State-Handling aus in Svelte 4 versus React?
Oder wie sieht State-Handling aus in Svelte 5
versus React oder in Vue 3 oder in Vue 2 oder so.
Da sieht man die Unterschiede.
Also aber richtig nice.
Ah, so sieht es in Svelte 4 aus.
So sieht es in React aus.
So sieht es in Svelte 5 aus.
So sieht es, so sah es in Vue 2 aus.
Vue 2 fand ich super nice damals.
Das war so das erste Frontend-Framework, wo ich so, wo ich so, wo mir es so richtig gefallen hat.
Ich habe das Interesse ein bisschen verloren, weil das Upgrade zu Vue 3 sich so schleppend,
so schleppend hingezogen hat und irgendwann bin ich dann bei Svelte gelandet.
Um alle anderen mache ich ein bisschen einen Bogen.
Was ich mir irgendwann mal angucken wollte, ist tatsächlich Solid,
weil Solid ist ja, dachte ich eigentlich.
Ich dachte eigentlich, dass Solid quasi wie React ist, nur ohne JSX.
Aber anscheinend, anscheinend doch nicht.
Weil das ist doch eindeutig JSX hier unten, oder?
Es ist, es ist HTML in JavaScript.
Vielleicht haben sie das auch nur für die Einfachheit halber der Beispiele gemacht.
Egal. Zumindest, wir planten hier mal alles aus.
Wir planten Solid aus, wir planten Vue aus, wir planten React, wo ist denn React?
React aus. Da bleibt jetzt nur noch übrig Svelte 4 und Svelte 5.
Aber die Seite ist mega poggast, muss man sagen.
Und wir gucken uns mal ein paar Beispiele an.
Ich habe sogar gesehen, man kann das mittlerweile ziemlich easy auswählen.
Man muss das nicht mehr offiziell in diesem offiziellen Baukasten machen,
sondern wenn man ein neues Svelte-Kit-Projekt anlegt.
Mkdir. Das Dumme ist, ich gucke mal hier.
Meine Ordnernamen, Alter.
Wie war das? NPX?
Nee.
Alter, JavaScript-Ökosystem, wie ging das nochmal?
NPX?
Nee, keine Ahnung.
Keine Ahnung.
Moment, das Svelte-Kit 2 ist das Normale heutzutage, gell?
Create.
Ich kenne FZF, ich mag das aber für die History nicht.
Ich benutze das sogar auf der Arbeit für Host-Auto-Completion,
so nach dem Motto, ich suche die Webserver-Kiste aus dem und dem Projekt.
Ja, ich kenne das. Ich habe das, glaube ich, sogar installiert.
Ja, ich habe das sogar installiert.
Kennst du C-Oxygen?
Ja, das kenne ich.
Das ist ein CD in Rust.
Verwende ich aber auch nicht.
Aus genau dem gleichen Grund,
warum ich auch kein FZF verwende für Sachen wie Shell History und sowas.
Und das liegt daran, dass ich einen nicht unerheblichen Teil meiner Arbeitszeit
auf Remote-Systemen verbringe, per SSH.
Und dort ist dieser ganze Kram nicht drauf.
Und wenn du dich daran gewöhnst, dass du nur noch CD navigieren kannst,
mit C-Oxygen,
sei es, dass du dich nur noch daran gewöhnst, dass deine Bash-History fuzzy-searchable ist,
dann drehst du durch auf Serversystemen.
Weil es hat sehr viel damit zu tun, was man gewöhnt ist zu tippen.
Und man tippt ja oftmals schneller, als man wirklich realisiert, was passiert.
Man denkt sich im Kopf schon immer das, was dann kommt, und tippt dann weiter,
bis man irgendwie feststellt, oh fuck, das ist ja hier gar nicht drauf.
Kannst vergessen.
Also das ist der Grund, warum ich das nicht verwende.
Ist auch der Grund, warum ich bei allen Standard-Tools,
die Standard-Sachen verwende, warum ich bei LS noch LS verwende
und nicht etwa eines der 5000 LS-Rewrites in Rust.
So, wie ging das jetzt hier nochmal?
Svelte, create a latest MyApp.
Nein, nein, nicht latest, via Example.
So, angeblich Svelte-Kit-Demo-App.
Skeleton-Project.
Angeblich soll der mich jetzt fragen,
ob ich nicht...
Ob ich ein Svelte-5-Testprojekt...
Ach, hier, guck mal.
Try the Svelte-5-Preview-Unstable.
Genau, das will ich haben.
Browser-Testing.
Wer braucht Tests, wenn alles immer first try funktioniert?
Okay, npm install.
Mal schauen, wie viele Pakete gleich wieder installiert sind.
Das sparen wir uns.
Das brauchen wir gleich.
Okay.
Node-Modules.
Was ist das?
Warum sind das nur 28 MB?
Bei einem neuen Projekt.
Das ist viel zu wenig.
Also, ich glaube, unter 2-3 GB Node-Modules ist irgendwas verkehrt.
Und das funktioniert jetzt, ja?
Na gut, immerhin 48 Node-Packages am Start.
Was installiert denn der da so eigentlich?
Übrigens kann man minus R...
Du weißt nicht, minus R, dass er die Farbe macht.
Also, guck mal hier.
Was installiert der?
Acorn, was auch immer das ist.
Am Projekt.
Keine Ahnung.
Cookie-Debug.
Deep Merge.
Cleor.
Magic String.
MS.
Nano-ID.
Pico Colors.
Sirf.
Viet und Vietfu.
Zimmerframe.
Zertke.
Installiert.
Ja, guck mal.
Da installiert Zertke.
Okay, dann starten wir das mal.
Und gucken, wie es mit 12.5 aussieht.
Achso, ne Moment.
Moment.
Das war mal nett.
Das starten wir.
Das war mal nett.
Wir starten jetzt erstmal Visual Studio Code hier drinnen.
Schieben Visual Studio Code auf den zweiten Bildschirm.
Und jetzt starten wir den Camp.
So.
Und jetzt können wir es auch rüberschieben.
So, Demo-Anwendung sieht noch genauso aus wie die alte Demo-Anwendung.
Nur, dass es jetzt Svelte 5 ist.
Source.
Was fällt mir denn auf?
Als erstes.
Dass ich nicht weiß, wo meine...
Sag ich jetzt mal eine Startzeit.
Gut, da kann da noch nichts auffallen, weil das mehr oder weniger plain HTML ist.
Ohne Spirenzien.
Svelte ist feife...
Ja, Svelte ist richtig feife.
So, und jetzt können wir das mal vergleichen.
Was der Unterschied ist zwischen 4 und 5.
Zum Beispiel eine Sache, die sehr kontrovers war.
Also als Svelte 5 angekündigt wurde.
Announcing Svelte 5.
Svelte 5.
Ja.
Das war so eines der ersten Sachen, die bekannt wurde über Svelte 5.
Das haben die dann hier gezeigt.
Und da war dann auf Reddit, gingen sie alle wieder ab, dass sie das scheiße finden.
Und ein paar fanden es auch gut, aber der überwiegende Teil fand es ziemlich kacke.
Ich musste mich auch erst mal am Anfang dran gewöhnen.
Naja, zumindest ist das jetzt der Unterschied zwischen alt und neu.
Also früher hat man...
Wir nehmen das ja einfach mal als Beispiel.
Ja, wir kopieren uns das mal als Beispiel.
Ja, cute chat.
Wenn man das...
Ja.
Also früher hat man State so deklariert.
Also man hat überhaupt nicht erkannt, dass das State ist.
Das war in Svelte in gewisser Weise irgendwie magic.
Da hat man eine Variable deklariert im Skriptteil und konnte das dann hier verwenden.
Ich meine, das ist ein bisschen minimalistisch, das Beispiel.
Weil hier auch nichts geupdatet wird.
Oder irgendwas passiert.
Zumindest in Svelte 5 ist das gleiche Beispiel.
Ein Ticken länger.
Und...
Also der einzige Unterschied zwischen Svelte 4 und 5 ist, dass du hier noch State drumherum machen musst.
Also dass das hier nicht mehr automatisch passiert.
Ich fand es am Anfang doof, als ich das erste Mal das Beispiel gesehen habe.
Habe ich mir gedacht, warum muss man das noch...
Also warum muss man da noch was drumherum schreiben, wenn man das noch automatisch machen kann?
Ich glaube, den Vorteil erkennt man erst, wenn man ein bisschen mehr als 3-4 Variablen hat.
Spätestens wenn man Variablen anlegen will, die kein...
Wie soll man sagen?
Kein State sind, den du irgendwie im View verwenden willst.
Aber Svelte automatisch das versucht irgendwie zu tracken, dann bringt es wahrscheinlich was.
Mir fehlt mir ein bisschen die Erfahrung.
Auf der anderen Seite, auch als jemand, der jetzt nicht hauptberuflich als Frontendentwickler arbeitet,
eine Sache, die ich an der neuen Syntax persönlich ganz gut finde, ist,
dass man eben halt genau sieht, wann was Reactive ist und wann nicht.
Oder ist Reactive das richtige Wort?
Also das ist der Unterschied zwischen Svelte 4 und Svelte 5, wenn es um State geht.
Ich weiß nicht, ob man dazu Reactive sagen darf.
Weil ist es ja im Endeffekt auch.
Du kannst jetzt da ja auch Two-Way-Binding oder sowas machen.
Oder?
Man kann ja auch zum Beispiel an der Stelle jetzt sagen, hier, das ist, das ist, ihr Count, ja.
Count fängt an mit 1.
Ja, ja.
Fängt an mit 1 und dann machen wir irgendwie einen Button dahin und sagen hier On, Klick.
Das geht übrigens jetzt auch anders.
Ich glaube, man kann jetzt einfach sagen, direkt On, Klick.
Also, On, Klick.
Und dann sagen wir jetzt hier Count.
Count.
Und jetzt riecht hier Plus, Plus.
Und jetzt sollte...
Und jetzt sollte der hochzählen, wenn ich hier unten draufklicke.
Also sieht man, das geht Two-Way.
Das geht einmal in den View rein und einmal quasi von Interaktiv klicken, dann auch wieder.
So.
Und ich glaube, das Problem, was die versuchen damit zu lösen ist,
dass wenn ich jetzt noch mehr solcher Dinge habe, hier Count, hier was weiß ich,
wenn ich mal angenommen habe, ich habe jetzt Name.
Und das soll halt...
Das soll halt wirklich nur intern in meinem JavaScript hier oben verwendet werden.
Dann würde Svelte das trotzdem tracken, ob damit nicht was passiert.
Obwohl man eigentlich genau weiß, es passiert nichts damit.
Und in Svelte 5 passiert das nicht, weil man sagen muss, hier Dollar State.
Das sieht mir zu sehr nach PHP aus.
Das sieht legit null aus wie PHP.
Ich meine, es ist JavaScript und HTML.
Das machst du inline in PHP oftmals auch, ja.
Das Ding ist nur...
Das Ding ist nur, wie verwendet man das jetzt?
Also, machen wir da mal jetzt Svelte 5 draus, ja.
Dollar State muss da im Endeffekt bloß hin.
Dollar State.
Und es funktioniert wieder, ne?
Nice.
Ansonsten muss man da nichts ändern.
Muss man das nicht irgendwie includen oder so?
Include State?
Das scheint Standard Library zu sein.
Okay, und das in den Klammern ist der Initial Value.
Dollar State ist insofern schon mal ein bisschen verwirrend für mich,
weil Dollar war in Svelte immer Stores.
Aber das scheint jetzt kein Store zu sein.
Das ist jetzt irgendwas anderes.
Moment, das ist die TypeScript-Definition.
Das ist jetzt irgendwas anderes.
Gut.
Wie dem auch sei, das von...
Ich muss mal den Hintergrund hier ein bisschen anders machen.
Das sieht ja...
Sieht ja abartig aus.
Ach so.
Moment, wir haben ja gar keinen Tailwind.
Wie macht man mit Plain CSS Background Color?
Machen wir irgendwas?
Keine Ahnung.
Was ist eine schöne Background Color?
Monkeys.
Ah, hier ist...
Alter, sieht das kacke aus.
Kann man da nicht irgendwas...
Kann man da nicht irgendwie ein bisschen angenehmeres verwenden, so?
Ja.
Ach, das ist Alpha.
Alpha will ich nicht.
Irgendwie sowas hier oder so.
Ja, okay, schon nicht mal ganz so schlimm.
Oder kannst du Syntax aus 4 und auch in 5 verwenden?
Also, Freezei, dankeschön für den Sub 420.
Proc Subscription.
Oder kannst du Syntax aus 4 auch in 5 verwenden?
Also, soweit ich das gelesen habe, kannst du die alten Syntax weiterverwenden?
Ja.
Du musst nicht jetzt deine komplette Anwendung umschreiben, wenn du Upgradest auf Svelte 5.
Was wohl Probleme machen kann, ist, oder was schlicht und ergreifend dann gar nicht kompiliert ist,
manche Svelte 5 Konstrukte im gleichen File mit manchen Svelte 4 Konstrukten.
Also, was wohl nicht funktionieren muss, ist Dollar State und die alte...
und diese alte Schreibweise.
Da mag er nicht.
Guck, da sagt...
Dollar Doppelpunkt ist not allowed in Runes Mode.
Das ist die alte Schreibweise für mach irgendwas reaktiv und update das immer, wenn davon sich was ändert.
Das kann man nicht verwenden zusammen mit der neuen.
Aber was du machen kannst ist, wenn du jetzt eine Komponente hast, die noch mit der Svelte 4 Syntax geschrieben ist,
dann kannst du sie in ein Svelte 5 Projekt einbinden.
Beziehungsweise kannst du die auch weiterhin...
Hast du ja gesehen.
Ne, ich kann es auch weiterhin...
Ich kann es auch weiterhin...
Ich kann es auch weiterhin...
Ich kann es auch weiterhin so machen.
Und das funktioniert jetzt auch.
Also man kann bloß manche Sachen nicht zusammen im gleichen File verwenden.
Aber im besten Fall macht man diese einzelnen Komponenten, falls er eh halbwegs übersichtlich.
Class machen wir jetzt mal nicht.
Class Style.
Text.
Color?
Ne, ne, Moment.
Es ist einfach nur Color in CSS, oder?
Ja.
Excellent.
Massive Web Design.
Font.
Family.
Wow.
Huge.
Massive Web Design.
So Skills wieder am Start hier.
Magst du ans Trinken erinnern?
Ja.
Mein Wasser ist leer.
Ich hab nur noch ein bisschen hier.
So.
Also es geht weiter.
Declare State.
Wissen wir jetzt, dass das funktioniert mit Dollar State?
Ich mein, das hat vorher auch schon funktioniert.
Das war jetzt recht übersichtlich.
You have Docker installed on your system.
Ja, no shit Microsoft.
Sagt mal, sind die, sind die Icons hier nebenanders als früher?
Oder bin ich einfach nur für...
Möchte mir Microsoft irgendwas mitteilen, dass die C++ Extensions ganz oben stehen?
Ne, die sind wahrscheinlich einfach alphabetisch sortiert.
Ja, das alles ohne Konzeptzeichnung.
So, jetzt geht's weiter mit Update State.
Gut.
Das haben wir ja schon mehr oder weniger gerade ausprobiert.
In dem ich hier unten bei dem...
Bei dem Button der ganzen Sache was zugeordnet hab.
Also sprich, das müssen wir nicht ausprobieren.
Ändert sich nix.
Bleibt weiterhin, dass man Dollar State...
Computed State.
Okay.
Jetzt, jetzt wird's spannend, weil in Svelte 4, und das ist das, was viele extrem mochten an Svelte,
ist diese Syntax hier, dass man Sachen Reactive macht,
beziehungsweise automatisch sich ändern lässt,
wenn es Abhängigkeiten untereinander...
Also was man in Svelte 4 machen konnte...
Machen wir jetzt mal, machen wir jetzt mal ein Beispiel, ja?
Oder brauchen wir das gar nicht, machen wir das mal weg.
Also was man, was man in Svelte 4 machen konnte, ist...
Man kann zum Beispiel...
Das einfachste Beispiel ist wahrscheinlich mit nem, mit nem Console-Log, ja?
Also mal angenommen, ich möchte jetzt was ausführen, jedes Mal, wenn sich Count ändert.
Dann konntest du in Svelte 4 einfach sowas hier sagen, ja?
Log Count.
Und jedes Mal...
Guckt, seht ihr's hier unten?
Jedes Mal...
Jedes Mal, wenn sich Count ändert, wird das hier ausgeführt.
Das war so diese Reactivity-Syntax von Svelte 4.
Und das haben ganz viele Leute extrem gemocht an Svelte.
Das war so für viele so ein bisschen wie damals in Vue 2,
eben diese so Klassenschreibweise von den Komponenten, die viele gut fanden.
Das haben viele extrem gemocht in Svelte.
Und das gibt es in der Form jetzt nicht mehr.
Ja, und nächstes Beispiel, was man hier drinnen machen kann zum Beispiel, ist...
Ja, okay.
Ich will jetzt jedes Mal...
Jedes Mal irgendwie, wenn sich Count ändert, will ich irgendwas damit machen.
Ja, zum Beispiel könnt ihr sagen...
Let...
Let name...
Cackle oder so.
So, und jetzt geben wir nicht...
Jetzt geben wir nicht Count aus, sondern geben Name aus.
Und jedes Mal, wenn sich eben Count ändert, sage ich name gleich...
Ja, name plus...
Das ist jetzt JavaScript, dass das funktioniert.
Oh, guckt.
Das geht auch nur in JavaScript.
Einen String und eine Eins und einen Plus.
Keine Ahnung.
Fragt nicht, aber das funktioniert.
Das war so die Reactivity Syntax von Svelte 4.
So, das hat sich jetzt geändert.
Und zwar kann man...
Ach so, das war die...
Das war die Kurzschreibweise.
Das war die Kurzschreibweise von dem, was ich euch gezeigt habe.
Also, anstatt das so zu machen, könnte ich auch, solange es einzeilig bleibt...
Das war auch so ein Ding, was mich immer ein bisschen genervt hat.
Ins Svelte 4.
Dass das nur einzeilig ging.
Ja.
Ja, also sprich, anstatt so, hätte ich quasi auch schreiben können...
Dollar name gleich name...
Ich weiß gar nicht, ob das funktioniert hätte überhaupt.
Plus 1?
Könnte ich das hier wegmachen?
Keine Ahnung, ob das Funs...
Not the number?
Nee, Funs gar nicht.
Guck mal.
Ha.
Ah, nee, nicht plus 1.
Plus Count.
Ich kann...
Nee, das geht gar nicht.
Wahrscheinlich, weil das nicht belegt ist.
Ah, jetzt...
Jetzt...
Jetzt...
So, und das haben sie jetzt abgeschafft.
Das haben sie jetzt abgeschafft.
Und die neue Syntax ist jetzt explizit...
Dass man explizit definieren muss, wenn man Abhängigkeiten hat.
So genau, warum das derived heißt, habe ich ehrlich gesagt...
Nur semi-kapiert.
Hm.
Ach so, Moment.
Derived, dann muss das hier Dollar State sein, dass das funktioniert, oder?
Derived wahrscheinlich, weil das, was in derived drinne steht, hier hinten dann die Abhängigkeiten
sind.
Also, das ist jetzt nicht mal Magic, wie in Svelte 4, wo das hier im Endeffekt dafür
gesorgt hat, dass der gepasst hat, so, was ist da hinten drinne?
Ist das Reactive?
Wie hängt das von ab?
Jetzt musst du explizit sagen, ey, ich will eine Variable haben.
Und wenn sich an dieser Variable was ändert, möchte ich das hier neu ausführen.
Das geht halt mit dieser derived-Geschichte.
Übrigens, ich habe bis heute nicht gecheckt, warum sich das Runes nennt.
Brauche mir nicht ein cooles Wort für.
Ja, also, ich könnte da jetzt natürlich auch sowas hier machen.
Kekkel plus Count.
Und dann wird das auch hochzählen.
Wo ich mir nicht ganz sicher bin...
Geht sowas?
Wahrscheinlich nicht, oder?
Nee.
Das mag er nicht.
Also, man kann da nicht auf sich selbst referenzieren.
Okay.
Ich bin mir ehrlich gesagt auch nicht sicher, wie oft ich das verwenden werde, weil so einzeilige
Sachen reichen mir meistens nicht.
Die Frage ist jetzt ja auch, kann man dort, kann man dort irgendwie sowas?
Achso, ja gut.
Name.
Okay.
Warte mal, ich schreibe wieder Count rein.
Kann man, kann man da sowas machen, wie ausführen bei jedem, bei jeder State-Änderung?
Wird auch nicht funktioniert.
Wird auch nicht funktionieren, oder?
Nee, das mag der nicht.
Das ist irgendein Objekt, das ist keine Function.
Aber ich kann bestimmt sowas machen, ne?
Haben wir das nicht ausgeführt.
Okay, keine Ahnung.
Kann man andere derived Variablen in derived reinmachen?
Das ist eine gute Frage.
Das probieren wir mal aus.
Wollen wir nochmal.
Name.
So.
Name is derived from...
Okay, jetzt machen wir mal...
Name 2.
Name 2 is derived from...
Name 2 is derived from...
Name 2.
Name 2 is derived from...
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
Name 2.
keine Abbruchbedingungen hat, was ja wohl das Problem
ist. Und dass sich
das dann noch zwischen zwei Compiler-Versionen ändert
von logisch zu unlogisch,
ist ja auch nochmal bescheuert.
Aber wir machen jetzt weiter mit Svelte 5.
Also das funktioniert schon mal.
Jetzt habe ich mal eine Frage
an euch, Chat.
Welche der beiden Sachen
denkt ihr ist besser?
Nehmen wir
jetzt, nehmen wir mal das Beispiel hier
hier unten. Da hat man halt die zwei Sachen drin.
Also, das ist die Svelte 4
Variante. Das ist so quasi der Klassiker,
den ganz viele mochten.
Also sprich,
ohne dass du explizit sagen musst,
hier, tracke mir die Variable.
Ohne dass du hier explizit sagen musst,
sei reactive, wenn sich
was ändert.
Bevor ich jetzt sage, was ich denke,
frage ich mal, was ihr denkt.
Was findet ihr besser? Man könnte
auf den ersten Blick natürlich schon sagen, ey,
warum machen wir es komplizierter?
Svelte 5 ist ja doppelt
gemoppelt irgendwie hier mit den Dingen.
Also, Svelte 5 ist im Endeffekt nur länger.
Für jemanden, der die Sprache
zum ersten Mal sieht, ist das neue besser.
Okay. Also, viele mochten
ja gerade das hier und sind deswegen bei Svelte
hängen geblieben. Also, unter anderem mochten sie so was hier.
Also,
ich muss sagen, für
um Leute
zu beeindrucken, um zu sagen, boah,
ist das eine coole Sache, ist die Svelte 4
so ein Tags besser.
Aber für
Klarheit,
dass das, was du siehst, auch das
ist,
ja, also das, was du erwartest,
auch das ist, was passiert
und dass man die,
dass man es auch besser
erkennt, was Reactive ist
und was nicht. Also, im Gegensatz
zu Undefined Behavior und C++,
wo eine Endlosschleife und Abbruchbedingungen
Dinger macht, die sie nicht machen sollte,
finde ich Svelte 5 besser.
Aber gibt es denn jetzt mehrzeitige
Computed States analog zu
Sternchen, Doppelpunkt,
das habe ich mich auch gerade gefragt,
ja, das habe ich mir auch gerade gefragt,
das habe ich zumindest in dem Beispiel nicht
gefunden, deswegen habe ich ja
eben probiert,
ob man da nicht jetzt irgendwie, sagen wir mal,
zum Beispiel,
ich habe eine Idee,
Dollar Effect, ja, aber das kommt wahrscheinlich
gleich noch, weiß ich nicht, jetzt habe ich auch schon
diese, also,
was man vielleicht machen
kann, ist,
sieht das eigentlich bei sowas hier aus,
hehehe,
nicht wirklich,
das wäre jetzt fast schon React,
äh, jetzt muss ich wahrscheinlich
Klammer machen,
das funzt,
das funzt, das ist aber, glaube ich, nicht
im Sinne des Erfinders, oder?
Wenn man das so macht,
das funktioniert,
das ist aber, glaube ich,
nicht so gedacht, ehrlich gesagt,
und das sieht auch schon ein bisschen
hässlich aus, wobei man immer noch
sagen muss, man versteht tatsächlich ganz gut, was
funzt, was passiert,
ja, also, alles in allem,
das hat ja sehr viel, für sehr viele
Diskussionen und Kontroverse gesorgt,
am Anfang von 2005, von der
Ankündigung,
ich fand es auch am Anfang doof,
aber es ist schwer zu beschreiben,
kennt ihr das, ihr habt so einen,
als Programmierer, oder auch als Admin, oder
generell, als jemand, der in IT arbeitet,
hat man so einen gewissen inneren
Ordnungssinn,
man hat bei Sachen, die richtig
aussehen, ein gutes Gefühl, wisst ihr,
was ich meine?
Und ich habe, wenn ich die Svelte 5
so einen Tag sehe, das bessere
Gefühl, als bei der
Vierer, die Vierer ist so magic,
und du
erkennst vom Angucken her,
nicht genau, es sei denn, du kennst
Svelte gut, was es macht,
wohingegen du die Svelte 5
so einen Tag anguckst, und dir eigentlich
sofort klar ist, okay, hier passiert
irgendwas mit, vielleicht weißt du nicht
hundertprozentig genau was, aber du siehst schon mal, okay,
das ist keine normale Variable,
also ich muss sagen, ich
finde das Svelte 5 besser.
Findest du, dass Svelte 5 weniger intuitiv
aussieht? Ich finde, es ist viel
eindeutiger,
was es macht.
Ja, nimm Svelte, Svelte ist nice.
Es gibt schon ein Release Date,
irgendwann 2024.
Ach ja, und ein weiterer Nachteil
ist natürlich, von der
Svelte 4 Geschichte,
dass Svelte alles, was du hinschreibst,
irgendwie tracken muss.
Und hier nur das, was du
explizit markierst, als das,
was getrackt werden muss.
Also ich glaube, das hat mehrere Vorteile.
Über die, sagen wir so, was schöner ist, kann man
sich sicherlich drüber streiten, auch was intuitiver
ist, kann man sich sicher drüber streiten, ja.
Ich persönlich kann das
Svelte 5 Sache tatsächlich mehr abgewinnen,
jetzt, nachdem ich mir das ein paar Mal angeguckt hab,
als das Svelte 4 Sache.
Aber es wird auch handfeste
Vorteile haben, bei
bisschen größeren Anwendungen. Ich glaube
nicht, dass sie das einfach just for fun gemacht haben.
Ich kann euch nicht sagen, was, weil ich
keine größere Svelte-Anwendung irgendwie betreue,
aber ich gehe davon aus, dass das noch weitere
Vorteile haben wird. Und nicht nur, dass
es schneller ist, wobei das
bestimmt auch eines der Punkte sein wird.
Die Seite zeigt ja nur an, was der
Unterschied ist und nicht, was sie sich dabei gedacht haben.
Da müsste man irgendwelche Blog-Posts lesen,
ja, wie zum Beispiel hier
das da.
Okay, gucken wir mal weiter.
Also so sieht das mit
Variablen und State aus. Ich bin mal
gespannt, was sie
bei, was sie mit
Stores
jetzt machen. Weil ich habe im Vorfeld
schon gelesen, es gibt keine Svelte-Stores
mehr. Stores war,
um es kurz zu erklären,
Stores war eine Möglichkeit ins Welt
Variablen anwendungsweit
zur Verfügung zu stellen, quasi
Global-Variablen.
Also quasi sowas hier,
nur global.
Was durchaus sinnvoll ist, zum Beispiel
stellt euch vor, euer User
lockt sich ein und
ihr braucht den Username auf
mehreren Unterseiten in mehreren Unterkomponenten.
Wie wollt ihr das
hin, wie wollt ihr das
sharen?
Und da hast du beispielsweise
einen Svelte-Store gemacht, der war dann
anwendungsweit verfügbar und du konntest das in
jeder Komponente importieren und dann konntest du
auf den Username zugreifen.
Das gibt es jetzt nicht mehr, habe ich gelesen. Moin,
Sarix. Also weiter
geht's. Update-State, Computed-State
haben wir uns jetzt auch schon angeguckt.
So, Templating.
Geht's jetzt weiter.
Mindest-State.
Minimal-Template.
Da ist legit
kein Unterschied.
Styling. Da ist
auch kein Unterschied, oder?
Seht ihr da
einen Unterschied? Ne,
ich sehe keinen Unterschied. Loop.
LeLoop. Sehe ich auch keinen Unterschied.
Ach ja, und
übrigens, eines der coolen Sachen ist,
ich hab's am Anfang ja schon gesagt, weil jemand gefragt
hat, man kann Svelte 4
Syntax auch in Svelte 5 benutzen.
Man kann bloß nicht alles Mix und
Matchen, wie man will.
Loop ist das gleiche.
Event-Click.
Ah, das ist nicht das gleiche.
Also einmal hier die State-Geschichte,
aber auch
OnClick.
Jetzt bin ich
irritiert. Ist das nicht hier
der normale Vanilla
Plain JavaScript
OnClick-Händler von einem Button?
Also wenn ich Button OnClick schreibe
in Plain JavaScript, dann sieht das genauso
aus. Anscheinend
haben die ihre eigene
Event-Syntax in die Tonne
gekloppt jetzt. Das ist
in der Tat recht interessant.
Also, das müssen wir mal
ausprobieren. Also sprich,
das sollte jetzt funktionieren.
Ah, es funktioniert beides noch.
Okay. Hätte das denn
auch funktioniert
in der alten
Schreibweise?
Okay, genau so. Ja, das ist anscheinend das eine
nicht vom anderen abhängig.
Okay, es geht jetzt beides.
Man kann jetzt,
also wahrscheinlich sollte man
jetzt das neue verwenden. Man braucht
keine spezielle Event-Syntax mehr
in Svelte, sondern kann einfach die
Build-In. Das ist
gut, ganz ehrlich, da würde ich einfach
sagen, das ist grundlegend einfach mal besser.
Warum eine extra Spezial-Syntax,
wenn man auch die Build-In-Syntax benutzen kann?
Die Frage ist jetzt viel eher,
gehen damit auch solche Sachen wie
oh, was war das? Prevent?
Das weiß ich nicht mehr. Svelte
Prevent Default, gab es doch irgendwie so
einen On-Click.
Ja, Prevent Default
konnte man in Svelte machen. Geht das
jetzt hier auch? Ah,
das geht nicht. Und das geht nur noch so?
Jetzt bin ich
unschlüssig, ob
das neue jetzt so viel geiler ist, weil man
die Modifier nicht mehr verwenden kann.
Aber habe ich zu wenig
Beispiele von gesehen jetzt? Keine Ahnung.
Aber die braucht man auch
relativ selten. Braucht man eigentlich hauptsächlich
Forms und solchen Sachen.
Finde ich aber gut, dass man jetzt normale
Event-Händler-Syntax verwenden kann.
Anstatt, dass
man Doppelpunkt braucht.
Was macht Prevent Default?
Wenn ich dir sage, dass
Prevented das Default-Verhalten,
sagt dir das wahrscheinlich nichts. Stell dir mal vor,
du hast eine Form mit einem Submit-Button.
Der Submit-Button macht standardmäßig
ein Post-Request gegen den Server.
Wenn du das nicht willst, brauchst du
Prevent Default.
Wenn du sagst Type
und du klickst hier drauf.
Achso, Moment, das ist ja nicht innerhalb
von einer Form.
Wie geht das?
Form?
Okay, ich bin kein
JavaScript-Hacker, man.
Also er macht jetzt Server-Requests,
wenn du das hier ...
Ich weiß gar nicht, wie das funktioniert.
Ja, guck.
Genau.
So. Der Default-Verhalten
von so einem Button ist,
dass er einen Post macht auf den
Form-Endpunkt.
So, und wenn du jetzt sagst hier
OnClick
Prevent Default
Achso, ich brauche
einen Händler, ja.
Dann macht er nichts mehr.
Dann führt er nur noch mein Event aus
und macht kein Post-Request mehr.
Wenn ich Prevent Default weg mache,
dann schickt er das.
Dann schickt er wieder ein Post-Request.
Also, das braucht man bei so Sachen wie beispielsweise
Submit-Buttons in der Form und sowas.
Kommt nicht oft vor, dass man es braucht.
Aber wenn man es braucht, ist man froh, dass es da ist.
Gut, anscheinend
kann man in Svelte 5 jetzt die normale
Event-Syntax verwenden von Buttons.
Okay, das ist doch schon mal auch nicht verkehrt.
Ja, das heißt, wenn man OnClick
definiert, wird das Default-File immer nicht überschritten.
Ne. Ja, tatsächlich.
Ja. Ja.
So ist es.
Nur wenn du OnClick definierst, heißt
es nicht, dass er das nicht als Default macht.
Du könntest
in der Funktion selber
event
event
preventDefault.
Das würde auch funktionieren.
Guck, jetzt macht er es auch nicht.
Das ist quasi ein Shortcut
dafür, dass du es selbst
im OnClick überschreiben musst.
Finde ich eigentlich ganz nice, dass es das gibt.
Gibt es übrigens in Vue auch.
Ich gehe mal davon aus, in vielen anderen Frontend-Frameworks
wird das auch so funktionieren.
Okay, also. Ja.
Kann man jetzt verwenden. Alles gut.
Nice.
Oh, das ist eine ganze Ecke kürzer geworden.
OnMount.
Ah.
Guck mal,
es gibt keine Lifecycle-Events
mehr. Kann das sein?
Also bisher hat man in Svelte beispielsweise,
wenn man, wenn die Komponente
eingehängt wird
in dein HTML-Element,
äh, in dein HTML-Baum,
konnte man beispielsweise
bei OnMount einmalig was ausführen
lassen. Also stellt euch jetzt mal vor,
ihr habt, äh,
ein Formular und ihr wollt,
dass dort,
sobald das eingefügt wird in die Webseite,
die erste,
die erste Zeile
Input fokussiert wird.
Dann hättet ihr das früher so machen müssen.
OnMount und dann Input Element
Fokus.
Und damit man auf das Input Element referenzieren kann,
musste man das quasi hier so
binden. Das ist übrigens,
das fand ich damals schon übelst umständlich.
Ist anscheinend jetzt immer noch das gleiche.
Und jetzt gibt es wohl Effekt
oder Dollar-Effekt, was mich ein bisschen an React
erinnert, ja. Dollar,
ach, ist Dollar-Effekt sowas
wie früher Doppelpunkt?
Dollar-Doppelpunkt?
Also, boah, Dollar-Effekt,
dann kann man da
einfach, probieren wir mal,
Lock.
Und jetzt immer, wenn sich Count ändert,
wird das gelockt. Ah ja.
Okay.
Also Dollar-Effekt.
Das heißt, im Endeffekt, Doppelpunkt,
also,
Dollar-Doppelpunkt ist das
alte Effekt, beziehungsweise
Effekt ist das neue
Doppelpunkt, äh, Dollar-Doppelpunkt.
Ja, da kann man
sich jetzt drüber streiten, was da geiler ist.
Ich denke mal,
im Endeffekt ist Effekt wahrscheinlich
weniger
Magic, weil
wenn du's Welt nicht kennst,
hast du keine Ahnung, was Dollar-Doppelpunkt ist.
Auf der anderen Seite, jeder, der sich
fünf Minuten mit's Welt beschäftigt hat,
wird Dollar-Doppelpunkt kennen.
Ansonsten
ist es einfach nur ein bisschen mehr.
Aber ich bin da auch nicht tief genug drin,
um die Unterschiede jetzt so
direkt rauslesen zu können.
Zumindest ist Dollar-Effekt
anscheinend jetzt das gleiche wie Dollar-Doppelpunkt.
Okay, warum nicht?
Gewöhnt man sich auch
dran. Ich persönlich
find's gut. Ich finde,
es ist weniger Magic.
Und ich gehe ganz stark davon aus,
dass das
absichtlich gemacht wurde,
weil's auch nicht nur
die Optik
hier im Source-Code verbessert,
sondern auch anderweitig
Vorteile hat. Sei es nur Performance.
Gut, DOM-Referenz vom Element
müssen wir uns nicht angucken. Das funktioniert
noch genauso wie
in der alten Svelte-Version.
Du definierst ne Variable. Die machst du jetzt
witzigerweise mit let und nicht mit state.
Gut, weil's
kein state ist.
Weil's einmalig reingeschrieben wird
und dann war's das.
Aber dass es OnMount nicht mehr gibt, find ich
schade. Wobei ist die Frage, gibt es denn
OnMount auch gar nicht mehr?
OnMount? Doch, gibt es immer noch.
Also kann man immer noch verwenden,
wenn man will.
Der Unterschied ist jetzt halt hier,
dass...
Guck, der Unterschied ist halt hier,
dass Dollar-Effekt
jedes Mal ausgeführt
wird und Dollar-Mount
wird nur einmalig ausgeführt
beim Einhängen
der
Komponente.
Ja, das ist aber dann ein doofes Beispiel.
Es gibt ja durchaus
Sachen, die man einmalig nur machen möchte
und nicht bei jedem Mal ändern von der Variable.
Zum Beispiel
initial irgendwie was runterladen
von irgendeiner API oder so.
Aber wisst ihr, ich glaube
auch eines der Änderungsgründe,
warum die so viel geändert haben ist,
dass Server-Site-Rendering besser
funktioniert. Was ich ja bei
SvelteKit sehr, sehr selten benutze.
Ich glaube, das liegt auch mit daran.
Weil das waren
hier so Dinger, die sind nur im Browser gelaufen
und da weiß ich nicht, wie es hier
ist, ob das dazu beiträgt, dass
du die Seiten schon besser vorrendern
kannst, bevor du sie initial auslieferst.
Kein Schimmer.
Aber zumindest muss man
auch mit Effekt auch irgendwas,
dass es nur einmalig ausgeführt wird.
Es wäre doch blöd, wenn das nicht funktioniert.
DollarState.
Ja, das haben wir gerade schon ausprobiert.
Ja, Effekt.
ToRunSideEffects.
Ja, das haben wir auch schon gecheckt.
Wow!
Jetzt wird es aber advanced hier.
Aha!
So macht man jetzt
OnMount. Okay, das ist
komplizierter als früher.
So, also entweder
kann man Effekt benutzen, so als
jedes Mal ausführen,
wenn sich der Value ändert.
Oder man kann einen Callback
zurückliefern.
If a Callback is provided, it will run
immediately
before the effect reruns
be when the component is destroyed.
Hä?
Da kann man, da kann man
Hä?
Kann man
doch irgendwie aufräumen lassen oder so danach.
Okay, das wird man, wird man
Okay, das
guckt, das ist das, was ich schon vermutet habe.
Das Replaced Dollar Doppelpunkt.
Effekt only
run in browser, not during server side
rendering.
Aha.
Untrack. What?
Effekt pre?
Das wollen sie es aber wissen, ja.
Okay, da muss man, muss ich mich noch mal wissen.
Aber ich sehe jetzt noch nicht, wie sich Effekt
Die schreiben mir was von OnMount,
aber ich sehe jetzt nicht, wie sich, wie ich damit
OnMount ersetzen kann.
Gibt es hier vielleicht irgendwelche
Ne.
Ja, keine Ahnung.
Ich dachte, vielleicht gibt es irgendwelche
Effekt Arcs oder so, aber das
ist undefined.
Ja, keine Ahnung, weiß ich nicht. Also
Ich sehe, ich wüsste
jetzt nicht, wie ich damit OnMount
ersetzen soll.
Wenn die Variable untrack ist.
Ja.
Ich, aber was soll
untrack? Aha.
Oh, das ist
aber schon ziemlich Magic, oder?
Also würde ich jetzt sagen, untrack,
Count? Ne.
Hä? Das macht es schon
ein bisschen komplizierter.
Ach so, da muss der Callback dann rein.
Also im Endeffekt
Antwort,
das ist ja, äh.
Was ist denn das, Mann?
Und jetzt kann ich sagen,
Lock, Count und das ist jetzt quasi
Ersatz für OnMount.
Guck, jetzt wird es nämlich auch nicht ausgeführt.
Jetzt, jetzt wird es auch
nur einmalig.
Ich weiß ja nicht.
Ich weiß
ja nicht. Ganz ehrlich,
da ist OnMount
doch schon irgendwie die schönere Variante,
oder? Was denkt ihr?
Ich meine, OnMount ist vollkommen klar, was passiert.
Wird einmal beim Einhängen der Komponente
ausgeführt und, ja, zum Glück gibt es
OnMount noch. Aber das ist,
das ist doch echt ein bisschen durch die Brust ins Auge.
Aber,
es hat auch seinen Vorteil,
wenn ich
irgendwo mal auf, auf
einen State zugreifen möchte,
innerhalb von Effekt,
will aber nicht,
dass durch diesen State getriggert,
jedes Mal die ganze Funktion läuft,
dann ist Untrack sinnvoll.
Weil,
das war tatsächlich, das war tatsächlich
ein Problem, wenn man die alte Syntax
verwendet hat. Also, mal angenommen,
mal angenommen,
wir machen jetzt mal ein sinnloses Beispiel, ja.
Mal angenommen, ich wollte jedes Mal,
wenn sich Count ändert, Count ausgeben.
Aber zusätzlich wollte ich
auch noch Name ausgeben.
Dann wurde jetzt bei jeder Änderung von
Name und bei jeder Änderung von Count
das Ganze getriggert.
Und jetzt würde ich dann quasi sagen, Untrack
an der Stelle, ja gut,
mit dem geht es ja so, an der Stelle.
Und jetzt wird das nicht jedes Mal
ausgeführt, wenn sich Count ändert.
Das macht durchaus Sinn,
dass es das gibt.
Okay, ja, okay, leuchtet ein.
Also es gibt keinen direkten Ersatz
für Dollar-Doppelpunkt.
Weiß ich noch nicht.
Sie haben auch viele Verbesserungen für
Server-Site-Rendering drin. Ich gehe davon aus,
dass es da schon einen Ersatz für gibt.
Hallo Max, bist du am merken? Ja, ich bin gerade
in deinem Twitch-Account drin.
Eigentlich habe ich die Chat-Nachricht selbst geschrieben.
Moment, wir brauchen die richtige.
Jetzt, okay.
Wobei ich ja mittlerweile die Variante
bevorzuge.
Alter, ich bin müde, warum?
Weil es ist 17.33 Uhr, keck wait.
Okay, also lasst uns mal weiter gucken.
Event-Click.
Das hatten wir schon.
DOM-REF hatten wir auch schon. Conditional.
Okay, was ist der
Unterschied?
Const-Traffic-Lights.
Okay, das ist State.
Das hatten wir schon.
Es ist nicht mehr Dollar-Doppelpunkt,
sondern es ist Derived.
Ja.
On-Click ist anders.
Und der Rest ist gleich.
Ja, das Beispiel, keine Ahnung.
Lifecycle. Ah, ja.
Aber das Beispiel
ist doof, weil wie wir jetzt gerade
schon gelernt haben,
ist On-Mount
nicht exakt
äquivalent zu Dollar-Effekt.
Sollte sich nämlich
Page-Titel
ändern, dann wird
das hier neu ausgeführt.
Und hier nur einmalig
beim Seite laden, beziehungsweise
beim Komponente einfügen.
Also das Beispiel ist nicht richtig, was
hier steht.
On-Mount.
Ah ja, gut, guck, hier sieht man das, was wir
eben gelesen haben in der Hilfeseite von
Effekt.
Wenn auch super umständliches Beispiel, aber
okay, man kann eine Funktion
zurückliefern und die wird dann quasi so als
Cleanup ausgeführt.
Das finde ich gar nicht schlecht, aber ich meine
seriously, warum nicht einfach
On-Destroy verwenden?
Ich finde das deutlich klarer
als Effekt
für On-Mount und On-Destroy.
Aber es bleibt ja weiterhin drinnen,
man kann es ja weiterhin verwenden.
Also für solche Sachen werde ich weiterhin On-Mount
und On-Destroy verwenden. Das finde ich unnötig
kompliziert hier.
Hier versteht jeder, was passiert,
oder? Und das war ja auch mein Argument
für die andere Sache oben, dass man in der
Welt 5 das besser versteht, was
passiert. Aber hier versteht man eindeutig
die 4er-Version, wie sie es schreiben, besser.
On-Destroy, was passiert, wenn die Komponente
quasi rausgeschmissen wird aus
der DOM, dann wird Clear Interval
ausgeführt. So, und hier,
hä, what?
Werde ich weiterverwenden.
Wir gucken uns gerade Unterschiede an.
Also finde ich das hier schöner.
Ok, was geht weiter?
Component Composition.
Import User Profile, ok, importiere nochmal
das Feldkomponente.
Weiß nicht, ob du schon gesagt hast,
aber das ist 1 zu 1 UseEffect
aus React. Ne, das habe ich noch nicht
gesagt. Und ich weiß auch nicht,
ob es so ist, weil ich bin
kein React User.
Ich habe keine Ahnung von React.
Was genau ist hier
der Unterschied? Nichts, oder?
Genau das gleiche.
Was? Emit to
Parent. Ah, Event Handling, ok.
Ach stimmt, da gibt es ja noch eine 2. Datei.
Tatsächlich.
Oh, das sieht tatsächlich anders an.
Anders aus jetzt.
Was haben wir denn hier jetzt?
Export Let.
Name, Age, Favorite Color
is available.
Da unten drunter der Kram ist alles gleich.
Und jetzt,
was ist das?
Const?
Ne. Ok, das finde ich jetzt
auf den
ersten Blick
irgendwie
unintuitiver.
Das hat aber bestimmt auch seinen Sinn.
Wahrscheinlich kann man
jetzt einfacher Properties
durchreichen oder sowas. Aber das
sagt mir jetzt ehrlich gesagt nicht zu.
Lass uns das mal ausprobieren.
Irgendeinen Vorteil muss das Ganze ja haben.
Legen wir mal
eine Komponente an. Irgendwas
kleines.
Wie machen die coolen Leute das unter Lib
einen Components Ordner?
Oder? Wie machen das die coolen Svelte Leute?
Machen wir jetzt hier kekel.svelt.
Bestes Svelt Komponente überhaupt.
Die kann nur eine Sache ausgeben, nämlich kekel.
Und das binden wir jetzt in unsere
Edge ein.
Und zwar hier oben drüber
kekel.
Oh ne, Visual Studio Code hat es mal wieder nicht
gecheckt, Mann.
Warum ist Visual Studio Code so pepega
teilweise? Reicht das, wenn ich reloade?
Oder muss das groß geschrieben sein?
Das muss groß geschrieben sein, gell?
Oder nicht?
Ich bin mir jetzt gar nicht sicher, wo das hin muss.
Import
from
$lib
Hä? Muss das
groß geschrieben sein?
Oh ne, wie funktioniert das
jetzt nochmal?
Achso, ah ne, das muss man nicht.
Keine Klammern.
Dann funzt das
auch.
Warum erkennt Visual Studio
Code das nicht?
Ja, da ist es doch.
Und stylen wir das jetzt mal.
Super High IQ Styling.
Style.
Äh.
Color.
Brown.
Red.
Und jetzt machen wir da mal
eine H2 draus, das ist schön fett.
So, unsere
Kekkel-Component ist am Start.
So, und was kann die jetzt
exportieren?
Das muss ich jetzt versuchen mal zu checken.
Also früher hat man, also
früher hätte ich da jetzt gesagt, okay.
Früher hätte ich
gesagt, Script.
Script.
Und jetzt export let,
sag mal Text zum Beispiel.
Default Text ist Kekkel.
So, und hier
rendern wir jetzt den Text, den wir übergeben.
Äh, nicht der Text.
Ja, das funzt.
So, jetzt kann ich das ganze hier drinnen überschreiben.
Ich kann jetzt zum Beispiel sagen, Text ist jetzt nicht
Kekkel, sondern Lull. Und dann steht da
Lull drinnen. So, und
was ist jetzt der Vorteil von dieser
komischen Geschichte hier?
What the
fuck?
Also,
man darf das nicht mischen, okay.
Also, anstelle,
okay, also,
anstelle von export let,
sag ich jetzt Text gleich
sowas hier. So, und dann
funzt's wieder. Aber was
ist jetzt der Vorteil davon?
Außer, dass es komplizierter ausschaut.
Das check ich nicht.
Was bringt das jetzt?
Guck mal doch mal.
Okay, Props.
To declare component props, use the
props rune. Okay,
ja, haben wir gemacht.
Dass du alle Props in einem Objekt,
ja und, was interessiert mich das?
Ob ich jetzt fünf Exports untereinander
schreibe oder das hier geklammert,
macht doch für mich keinen Unterschied?
You can use familiar, aha, okay,
okay, okay.
You can use familiar destructing syntax
to rename props in case...
Ja, gut, das ist ja sehr,
sagen wir mal,
in dieser Nische jetzt,
dass man Schlüsselwörter, dass man quasi
Prop-Namen wie Schlüsselwörter braucht.
Aber okay, gut, dass er...
To get all properties, use
rest syntax.
Aaaah.
Ach so!
Okay,
das ist glaube ich ganz
nice. Da bin ich mir jetzt
und so, ich glaube das ist ganz nice.
Da kann ich jetzt zum Beispiel
sowas hier machen.
Nennen wir das mal, so.
Okay, okay.
Mal angenommen, ich übergebe jetzt hier sowas wie optional,
ja, irgendwie, ich übergebe
jetzt sowas wie, wie,
onclick.
Okay, ich glaube,
das ist tatsächlich sehr nice.
Ich übergebe jetzt onclick.
Count
plus plus.
So, und in diesem Rest
ist jetzt, so mal angenommen, ich hab
jetzt hier drinnen, wir machen das mal weg,
ich hab jetzt hier drinnen einen Button, wir kopieren uns
mal den Button.
Ich hab jetzt hier drinnen einen Button
und der kriegt jetzt, ja, wie mach ich
denn das? Dollar, Dollar,
Rest vielleicht? Nee, äh, what the
fuck?
Hops, so?
Rest? Nee.
Einfach so?
Nee. Ah, ich hab gedacht,
das funktioniert.
Das sind Runes!
Nee.
Ich dachte, so funktioniert das.
Das wär nämlich nice, wenn man das machen
könnte, aber so.
Also, man kann es destructen.
This replaces export let
export, ja, ja.
It also
replaces dollar dollar props
and rest props.
So richtig checken tue ich sein?
Also, wisst ihr,
wisst ihr, was ich jetzt eigentlich dachte ist?
Man kann so
quasi Sachen
durchreichen an
Child-Elemente innerhalb dieser
Component, ohne dass ich
jeden Mist extra
definieren muss.
Das ging vorher auch schon, war aber vorher ein bisschen
Achso, ja.
Weiß ich nicht.
Was ist mit
der Chat, als er da immer
Alter, ich kann ja immer
What the fuck?
Ah, das Fundst.
Nice! Ja, das
ist cool!
Das ist cool! Okay, das gefällt,
ja, das hat was.
Ich mach mal kurz hier unten den Kram weg.
Guckt mal.
Moment, okay, count muss ich da lassen.
Ich mach mal nur den Button weg.
Ja, das ist in der Tat jetzt wirklich nice.
Also,
nur mal zur Erklärung, guckt mal.
Ich übergebe hier,
das kennt er jetzt natürlich nicht, oder?
Weiß der, dass ich on
key
oder so, weiß der, dass das
in einem Button sitzt? Ist der so schlau?
Guckt mal, ich übergebe hier
als Property
gibt es Text. Text ist
das einzige, was ich definiert habe.
Aber ich kann auch on click zum Beispiel
übergeben und on click
hänge ich dann hier unten drunter
an den Button. Das heißt, ich kann
jetzt hier alles durchreichen an
den Button in der Component, also auch
sowas wie
on key down und solche Sachen.
Das ist
cool.
Das finde ich ganz nice.
Kann ich auch sowas durchreichen
wie class gleich?
Class gleich?
Ja,
keine Ahnung.
Hallo?
Red?
Ne, das funktioniert nicht.
Das liegt aber bestimmt daran, weil das irgendwie
reserved ist.
Das funktioniert bestimmt auch irgendwie,
wenn man es gescheit macht.
Aber nicht direkt.
Moment, das ist ja auch nicht
class. Style will ich durchreichen.
Das Funst. Ja, das ist cool,
dass das geht.
Das gefällt mir in der Tat ganz gut.
Da kann man
quasi jetzt auch
Komponenten stylen, wie man das in
View machen konnte.
Ohne Trick 17.
Das finde ich gut.
Das gefällt mir.
Ja.
Ja, das hat was.
Das ist eine gute Änderung.
Also, ich werde immer noch nicht
so ganz mit dieser Syntax da oben warm,
ehrlich gesagt.
Aber das gefällt mir, das ist cool.
Was schreiben die sonst noch so?
Oh, nix weiter, oder?
Das wird gebaut, gar nix.
Wir gucken uns die Unterschiede zwischen
Svelte 5 und Svelte 4 an.
Ups.
Ne, das gefällt mir. Das ist nice.
Das ist nice.
Dass man das so durchreichen kann.
Ohne, vor allem durchreichen kann,
ohne irgendwelche Magic Sachen.
Es gab ja vorher auch schon so komische
Dinger hier, aber das ist jetzt relativ
klar. Du siehst hier oben, okay, Reste,
restliche Sachen stecken hier drin und hier werden die dann
quasi destructed.
Sehr nice. Das ist eine gute Sache. Das gefällt mir.
Okay.
Also, proper.
Ja, und ansonsten, hat das sonst irgendwelche Vorteile?
Nö, oder? Einfach, dass es ein bisschen hübscher ist.
Wobei das hier, da kann man
sich jetzt echt drüber streiten. Also, ich muss sagen,
Export LED finde ich
optisch schon etwas schöner als
so, wie
es jetzt ist. In 5.
Aber das Destructing finde ich
tatsächlich in 5 sehr nice.
Ja, gut.
Da muss man sich dran gewöhnen.
Es ist aber nicht so eine große Umstellung wie
damals von View 2 auf View 3,
wo gefühlt alles anders aussah.
Man konnte zwar das alte noch
verwenden, aber keiner wollte es. Übrigens, vieles davon
ist ähnlich, wie sie es auch in View 3
gemacht haben. Ja, in
View 3 heißt es eigentlich dann Use Ref
und so Zeug. Okay, nice.
Ah, das gefällt mir schon mal.
Emit to Parent.
Ich sehe keinen Unterschied.
Achso, ich muss in Button gucken.
Oh, okay.
Achso!
Jetzt ergibt das mit den
Props nochmal ein bisschen mehr Sinn.
Man kann quasi
auch da drüber logischerweise dann
Events bzw. Funktionen
austauschen. Ja, das
ist cool. Wobei,
warum ging das eigentlich im Alten nicht schon?
Mir ist eigentlich fast erwartet, dass es ging
im Alten auch schon, aber anscheinend nicht.
Ja, also in
World 4, da kann ich mich noch dunkel dran erinnern,
da musste man so komische Dinger hier machen.
Also, wenn du eine Custom Komponente
hattest
und ich sollte ein Event werfen
oder auch nur
das Button
Event irgendwie durchreichen,
dann musste man das mit
Create Event Dispatcher
machen. Okay.
Ja, also sprich, das was wir hier gemacht haben,
wir haben quasi intuitiv
das gemacht, was wir in dem nächsten Beispiel
erklären. Ne, keine Ahnung.
Odolmit.
Wir haben das nächste Beispiel schon vorweg gegriffen,
ohne dass wir es gesehen haben.
Die machen nämlich genau das hier, guck mal.
Die reichen quasi Child Elemente
Events
durch
an die Parent
Komponente hier, mit OnClick in dem Fall.
Also, wir geben die Funktion da rein, aber
das OnClick Event kommt ja von dem Button
hier
in der
Child Component.
Und das ging anscheinend vorher nicht.
Vorher musste man wohl
jedes Event, was man weiterreichen
möchte, von einem
quasi nested Element
in der Child Component, musste man irgendwie explizit
nochmal exporten.
Ja, das ist nice, dass das
jetzt nicht mehr braucht, dass man das jetzt nicht mehr braucht.
Das finde ich schonmal viel besser so.
Dann nehme ich auch diese komische Prop Syntax
in Kauf.
Das finde ich cool.
Doch, das hat
tatsächlich was.
Du, du, du, du, du,
du, du, du, du, du, du,
du.
Ein Stream ist super, schön, dass ihr das gefällt.
Hog.
Oder um nicht zu sagen,
sehr, sehr
Chat wieder super
freundlich zu neuen Leuten.
Ja, ja, ich sehe es schon.
Ja, das ist gut.
Ich glaube, das werde ich ausgiebig benutzen.
Wenn dann Svelte 5.
Wenn
der Fiat Champ irgendwann
mal weiterentwickelt wird,
was er ja nicht notwendig hat, weil es sind ja
keine Probleme bekannt, wie man hier
sieht. Das ist alles
Skill Issues auf
User Seite.
Wenn er mal irgendwann weiterentwickelt wird,
dann, oh, guck mal,
ich habe die 80 Sterne, nice.
Dann kriegt das ins
Svelte 5 Frontend.
Nicht won't fix, ich brauche Hashtag Skill Issue.
Es ist ja
offensichtlich
der User Fehler, dass es keine AM64
Version gibt, oder?
Kann ich doch nichts für.
Wobei,
jetzt so blöd es klingt, ich glaube, es gibt wirklich
eine AM64 Version davon.
Moment, Moment.
Ach nee, gibt es nicht.
Okay, ich habe nichts gesagt.
Es gibt nur eine
AMD64 und eine AMV7 Version.
Auf der anderen Seite,
der kann doch ohne Probleme
die AMV7 auf
AM64 laufen lassen, oder?
Natürlich
geht das.
Also ich bin jetzt immer fest davon ausgegangen,
dass das funktioniert.
Guck mal hier, gar nicht so wenige Downloadzahlen
der Fiat Champ.
13.000 Downloads hier.
Ich habe Hunger.
Ich muss mir gleich was zu essen holen.
Aber wir sind noch nicht fertig.
Wir können auch kurze Pause machen.
Ich esse was, wir gucken irgendwas und danach machen wir weiter.
Könnten wir auch machen.
Pause Champ sozusagen.
Real Life Pause Champ.
Eating Champ.
Dinner Champ.
Okay, was ändert sich noch?
Slot ändert sich.
Svelte 4 vs Svelte 5.
Ich sehe keinen Unterschied.
Okay, ich sehe einfach,
dass es größer, dass es länger ist.
Okay, was bin ich hier sehend?
Let children props
render?
But why?
Was ist der Sinn davon?
Also Slot
ist
bei Svelte quasi ein Platzhalter,
wo
andere Komponenten
also andere Sachen eingesetzt werden.
Also
ich kann zum Beispiel, ich zeige euch das mal,
ich kann jetzt zum Beispiel hier sagen,
keine Ahnung,
div, da schreibe ich rein
Slot
und
jetzt kann ich in die
in die Komponente kann ich noch was reinschreiben,
was dann in den Slot gerendert wird.
Zum Beispiel kekw.
Guck, dann taucht das da drin auf.
Der rendert quasi das,
was ich hier reinstecke in den ersten Slot.
Vorher konnte man nicht
selektieren, wo was angezeigt wird, wenn es mehrere
sind. Doch, oder?
Du konntest doch Name Slots verwenden.
Du konntest sagen name kekw
und dann konntest du das irgendwie
frag mich nicht mehr, wie das genau
funktioniert hat.
Ich weiß jetzt nicht, wie man da
also, da bin ich jetzt
überfragt, wie man das jetzt dort
richtig rein gerendert hat.
Musste man dann hier irgendwie sagen Slot
oder so?
kekw?
Ja, so ging das.
Aber, da verstehe ich jetzt den
den Sinn davon ehrlich gesagt nicht.
Slot
Ja, if
Ja, okay, okay, das leuchtet mir alles
ein, aber Slot.
Da müssen wir uns jetzt...
Render. Ja.
Snippets?
Ist hier drinne?
Äh.
Endhändler, Functions?
Render.
Add Render.
Hier ist nichts drinne.
Ah, doch, tatsächlich.
Okay, also.
Das Ganze ist wohl ein Bestandteil
von Snippets.
Was auch immer. Okay, Beispiel.
Snippets and Render Tags
are a way to create reusable
chunks of markup inside your
Components. Also quasi kleine
Subkomponenten in der Komp...
Naja, ne, nicht Komponenten.
Ja, Snippets halt.
Wiederverwendbare
Ach
so!
Ich glaub so langsam
aber sicher check ich, worauf das
rausläuft.
Ich könnte jetzt quasi sowas hier
reinschreiben. Und das irgendwie
mehrfach verwenden.
Wie referenziert man da jetzt drauf?
Also hier, kein Slot.
Oder wie auch immer.
Wie Referenz. Das muss ich auch mal durch...
Das könnte tatsächlich was cooles sein.
If Image...
Snippet.
Ah!
Ach so!
Okay, das ist in der Tat doch ganz cool.
Ich checke noch nicht,
was es mit Slots zu tun hat, ehrlich gesagt.
Aber okay.
Das ist in der Tat ganz cool.
Also, kopieren wir
das mal.
Snippet.
Das nennen wir nicht Figure, das nennen wir...
Cackle.
Oh!
Image.
Oh!
Source.
Ja.
Ist mir alles egal, ja.
Ach so, der sagt, dass ich
kein Alt-Text hab.
So, jetzt haben wir einen
Snippet-Cackle, was
jetzt ja so nichts macht.
Und jetzt kann ich sagen,
ich will das mehrfach rendern.
An unterschiedlichen Stellen.
Und wie?
Add Render.
Okay.
Also, Add Render Cackle.
Da ist es
einmal. Und jetzt?
Aha!
Okay, das ist nicht übel.
Das ist tatsächlich
ganz cool. Ich hab jetzt
wirklich grad nicht greifbar,
weil ich das gebraucht hätte.
Aber ich geh davon aus, wenn es das gibt,
man braucht das tatsächlich öfters.
Das Beispiel ist doch gar nicht so schlecht.
Guck mal.
Die wollen beide Male
wollen sie hier Image-Sachen rendern.
Einmal
bei der Bedingung und einmal
default im Endeffekt.
Ach nee. Einmal, wenn das
gesetzt ist und einmal, wenn das...
Okay. Heißt
im Endeffekt, wenn ich
beispielsweise...
Ich hab ein gutes Beispiel.
Avatar-Bilder zum Beispiel.
Avatar-Bilder.
Avatar-Bilder braucht man mehrfach auf der Seite
mit ein paar unterschiedlichen Settings.
Vielleicht.
Und dann legt man sich einmal hier das Snippet
für Avatar-Bilder an.
Und kann das dann rendern.
Ja, irgendwie
oben links in der Komponente
und dann irgendwie nochmal in der Mitte von der Komponente.
Was auch immer.
Da ist noch kein richtig greifbares
richtig gutes Beispiel.
Aber ich glaube, das kann man gut verwenden.
Ich meine, an der Stelle
ist es natürlich bescheuert, was ich hier gemacht habe.
Das Beispiel. Weil ich könnte genauso gut
das hier alles weglassen.
Eine Schleife machen.
Fünfmal Image reinpasten.
Da brauche ich keinen Mager.
Was es natürlich in der Tat ganz interessant
macht, ist
dass man jetzt hier verschiedene
Parameter reinstecken kann.
Also ich kann beispielsweise hier Parameter
reinstellen. Name.
Gibt es Default-Parameter
bei JavaScript?
Geht else im Snippet?
Höchstwahrscheinlich, ja.
Gucken wir doch mal.
Sagen wir mal, Default-Name ist leer.
Dann machen wir jetzt mal so.
If. Moment.
If.
If.
If not name.
Dann keckel.
Okay.
Name is deprecated.
Ich glaube,
JavaScript spinnt einfach nur rum.
Aber jetzt ist es weg.
Oder alternativ will ich einfach
Name anzeigen.
Ja, das
funktioniert. Guck mal.
Wenn ich hier was reinschreibe, dann wird das gerendert.
Und wenn ich nichts reinschreibe,
also wenn ich hier
irgendwas reinschreibe, wird
das gerendert. Und ansonsten wird
das gerendert. Das ist wirklich cool.
Vor allem kann man das
jetzt mehrfach an der Seite verwenden.
Mir fehlt leider so
ein richtig gutes Beispiel
jetzt dafür. Aber
ich hab so irgendwie
das... Mir juckt so
in den Fingern zu sagen so, das ist
sehr praktisch.
Und was hat das jetzt mit Slots Replacement
zu tun?
Snippet Params can be destructed.
Snippet Params can be destructed.
Aber wieso ist Welt, wenn man auch View nutzen kann?
Warum benutzt du View und nicht React?
Oder jQuery?
Oder Solid?
Oder Knockout.js?
Oder
gar Angular?
Doch, das gefällt mir. Das hat was.
Snippet Scope.
Passing Snippets to Components.
Oh,
das ist cool.
Ja gut, Passing Snippets to Components
ist im Prinzip genau das, was
die mit Slot...
Slot ist ein Sonderfall von Passing
Snippets to Components.
Wird jQuery 2024
noch maintained?
Du wirst überrascht sein.
jQuery wird nicht nur maintained,
sondern
es kam
vor noch nicht allzu langer Zeit
sogar jQuery 4
am Start.
Es ist noch Beta,
aber guck hier.
Aber 2024,
jQuery 4.0 Beta.
Das ist nicht nur maintained,
das ist noch voll active in development.
Doch das Feature gefällt mir hier.
Snippets and Slots.
In Zwelt 4 Content can be passed
using Slots.
Snippets are more powerful and flexible.
Ja.
Man kann weiterhin Slot verwenden.
Finde ich eine gute Sache.
Ich fand es erstmal jetzt unsinnig.
Das ist so ein Ding, wisst ihr?
Man neigt ja persönlich immer dazu,
wenn man sowas hier sieht.
Zum ersten Mal sagt man,
das will ich nicht, warum nicht so,
ist doch viel einfacher.
Aber das ist mit vielen Sachen so.
Wenn man sich damit beschäftigt,
ein bisschen an der Oberfläche zu kratzen,
sich anzugucken, warum das gemacht wurde,
ergibt das durchaus Sinn.
Also oftmals durchaus Sinn.
Und hier ist es genauso.
Wenn ich mir die Sache hier mit den Snippets angucke,
finde ich das eine sehr sinnvolle Sache.
Und dementsprechend verstehe ich auch,
dass Slots deprecated sind,
im Prinzip Slots.
Zumal du weiterhin Slot verwenden kannst,
für einfache Sachen.
Interessant, gefällt mir.
Wie geht es weiter?
Context.
Jetzt kommt der Ersatz von Stores.
Das ist vielleicht zu kompliziert
jetzt für den...
User Store,
Get Context,
Create User Store.
Okay, was ist der Unterschied?
Ich will es nicht...
Was bin ich?
Okay, das ist das eigentlich Interessante.
Es gibt
keine Stores mehr.
Ah, aber es gibt
jetzt .swelt.js
Files,
um sowas ähnliches zu machen.
Oh, da wird es jetzt aber langsam abgedreht.
Also eine Kombination
aus
Export Function und
State ist quasi ein
Replacement für Stores.
Es gibt keine Stores mehr.
Das ist etwas, was ganz viele Leute
super toll ins Welt fanden,
weil das schon eingebaut ist.
Das heißt, jetzt braucht man keine Stores mehr.
Jetzt kann man...
Das mit was?
Mit Get und Set?
Erinnert mich ein bisschen an Java,
wenn ich ehrlich bin.
Das muss ich mal ausprobieren.
Nennen wir das jetzt mal einfach Store.
Ne, nicht Store.
Store ist Blödsinn.
Ja...
Warum ist es egal, wie ich es nenne?
.swelt.js
.swelt.js
.swelt.js
.swelt.js
.swelt.js
Hauen wir das jetzt mal rein.
Initial, Username, blablabla.
So.
Und jetzt importieren wir das Ganze mal.
Create.
Ah, das funktioniert nicht. Also brauchen wir jetzt hier...
Wie importiert man den Kram?
Hier.
Create. State.
Ja, ich hätte es mal anders nennen sollen.
.slip.
Okay, das hat funktioniert.
Create User State.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
.slip.
